{"version":3,"sources":["angular.min.js","angular-animate.js","angular-datepicker.js","angular-file-upload.js","angular-filter.js","angular-route.js","angular-sanitize.js","angular-slider.js","angular-textAngular-sanitize.js","angular-textAngular.js","angular-textAngularSetup.js","angular-toastr.js","angular-tooltips.js","angular-ui-select.js","angular-validation-rule.js","angular-validation.js","angular-vertilize.js","moment.js","owl.carousel.js","rangy-core.js","xfullcalendar.js","base.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1jIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxiEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7zEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChsCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACr2EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACl/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACj0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC71BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC92IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1sGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjgIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtueA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"vendor.js","sourcesContent":["/*\n AngularJS v1.6.1\n (c) 2010-2016 Google, Inc. http://angularjs.org\n License: MIT\n*/\n(function(z){'use strict';function M(a,b){b=b||Error;return function(){var d=arguments[0],c;c=\"[\"+(a?a+\":\":\"\")+d+\"] http://errors.angularjs.org/1.6.1/\"+(a?a+\"/\":\"\")+d;for(d=1;d<arguments.length;d++){c=c+(1==d?\"?\":\"&\")+\"p\"+(d-1)+\"=\";var f=encodeURIComponent,e;e=arguments[d];e=\"function\"==typeof e?e.toString().replace(/ \\{[\\s\\S]*$/,\"\"):\"undefined\"==typeof e?\"undefined\":\"string\"!=typeof e?JSON.stringify(e):e;c+=f(e)}return new b(c)}}function ta(a){if(null==a||Wa(a))return!1;if(C(a)||E(a)||D&&a instanceof\nD)return!0;var b=\"length\"in Object(a)&&a.length;return Y(b)&&(0<=b&&(b-1 in a||a instanceof Array)||\"function\"===typeof a.item)}function q(a,b,d){var c,f;if(a)if(y(a))for(c in a)\"prototype\"!==c&&\"length\"!==c&&\"name\"!==c&&a.hasOwnProperty(c)&&b.call(d,a[c],c,a);else if(C(a)||ta(a)){var e=\"object\"!==typeof a;c=0;for(f=a.length;c<f;c++)(e||c in a)&&b.call(d,a[c],c,a)}else if(a.forEach&&a.forEach!==q)a.forEach(b,d,a);else if(Dc(a))for(c in a)b.call(d,a[c],c,a);else if(\"function\"===typeof a.hasOwnProperty)for(c in a)a.hasOwnProperty(c)&&\nb.call(d,a[c],c,a);else for(c in a)va.call(a,c)&&b.call(d,a[c],c,a);return a}function Ec(a,b,d){for(var c=Object.keys(a).sort(),f=0;f<c.length;f++)b.call(d,a[c[f]],c[f]);return c}function Fc(a){return function(b,d){a(d,b)}}function ie(){return++rb}function Sb(a,b,d){for(var c=a.$$hashKey,f=0,e=b.length;f<e;++f){var g=b[f];if(F(g)||y(g))for(var h=Object.keys(g),k=0,l=h.length;k<l;k++){var m=h[k],n=g[m];d&&F(n)?fa(n)?a[m]=new Date(n.valueOf()):Xa(n)?a[m]=new RegExp(n):n.nodeName?a[m]=n.cloneNode(!0):\nTb(n)?a[m]=n.clone():(F(a[m])||(a[m]=C(n)?[]:{}),Sb(a[m],[n],!0)):a[m]=n}}c?a.$$hashKey=c:delete a.$$hashKey;return a}function R(a){return Sb(a,wa.call(arguments,1),!1)}function je(a){return Sb(a,wa.call(arguments,1),!0)}function Z(a){return parseInt(a,10)}function Ub(a,b){return R(Object.create(a),b)}function w(){}function Ya(a){return a}function ma(a){return function(){return a}}function Vb(a){return y(a.toString)&&a.toString!==na}function x(a){return\"undefined\"===typeof a}function v(a){return\"undefined\"!==\ntypeof a}function F(a){return null!==a&&\"object\"===typeof a}function Dc(a){return null!==a&&\"object\"===typeof a&&!Gc(a)}function E(a){return\"string\"===typeof a}function Y(a){return\"number\"===typeof a}function fa(a){return\"[object Date]\"===na.call(a)}function y(a){return\"function\"===typeof a}function Xa(a){return\"[object RegExp]\"===na.call(a)}function Wa(a){return a&&a.window===a}function Za(a){return a&&a.$evalAsync&&a.$watch}function Ia(a){return\"boolean\"===typeof a}function ke(a){return a&&Y(a.length)&&\nle.test(na.call(a))}function Tb(a){return!(!a||!(a.nodeName||a.prop&&a.attr&&a.find))}function me(a){var b={};a=a.split(\",\");var d;for(d=0;d<a.length;d++)b[a[d]]=!0;return b}function xa(a){return P(a.nodeName||a[0]&&a[0].nodeName)}function $a(a,b){var d=a.indexOf(b);0<=d&&a.splice(d,1);return d}function Fa(a,b){function d(a,b){var d=b.$$hashKey,e;if(C(a)){e=0;for(var f=a.length;e<f;e++)b.push(c(a[e]))}else if(Dc(a))for(e in a)b[e]=c(a[e]);else if(a&&\"function\"===typeof a.hasOwnProperty)for(e in a)a.hasOwnProperty(e)&&\n(b[e]=c(a[e]));else for(e in a)va.call(a,e)&&(b[e]=c(a[e]));d?b.$$hashKey=d:delete b.$$hashKey;return b}function c(a){if(!F(a))return a;var b=e.indexOf(a);if(-1!==b)return g[b];if(Wa(a)||Za(a))throw Ga(\"cpws\");var b=!1,c=f(a);void 0===c&&(c=C(a)?[]:Object.create(Gc(a)),b=!0);e.push(a);g.push(c);return b?d(a,c):c}function f(a){switch(na.call(a)){case \"[object Int8Array]\":case \"[object Int16Array]\":case \"[object Int32Array]\":case \"[object Float32Array]\":case \"[object Float64Array]\":case \"[object Uint8Array]\":case \"[object Uint8ClampedArray]\":case \"[object Uint16Array]\":case \"[object Uint32Array]\":return new a.constructor(c(a.buffer),\na.byteOffset,a.length);case \"[object ArrayBuffer]\":if(!a.slice){var b=new ArrayBuffer(a.byteLength);(new Uint8Array(b)).set(new Uint8Array(a));return b}return a.slice(0);case \"[object Boolean]\":case \"[object Number]\":case \"[object String]\":case \"[object Date]\":return new a.constructor(a.valueOf());case \"[object RegExp]\":return b=new RegExp(a.source,a.toString().match(/[^/]*$/)[0]),b.lastIndex=a.lastIndex,b;case \"[object Blob]\":return new a.constructor([a],{type:a.type})}if(y(a.cloneNode))return a.cloneNode(!0)}\nvar e=[],g=[];if(b){if(ke(b)||\"[object ArrayBuffer]\"===na.call(b))throw Ga(\"cpta\");if(a===b)throw Ga(\"cpi\");C(b)?b.length=0:q(b,function(a,d){\"$$hashKey\"!==d&&delete b[d]});e.push(a);g.push(b);return d(a,b)}return c(a)}function qa(a,b){if(a===b)return!0;if(null===a||null===b)return!1;if(a!==a&&b!==b)return!0;var d=typeof a,c;if(d===typeof b&&\"object\"===d)if(C(a)){if(!C(b))return!1;if((d=a.length)===b.length){for(c=0;c<d;c++)if(!qa(a[c],b[c]))return!1;return!0}}else{if(fa(a))return fa(b)?qa(a.getTime(),\nb.getTime()):!1;if(Xa(a))return Xa(b)?a.toString()===b.toString():!1;if(Za(a)||Za(b)||Wa(a)||Wa(b)||C(b)||fa(b)||Xa(b))return!1;d=W();for(c in a)if(\"$\"!==c.charAt(0)&&!y(a[c])){if(!qa(a[c],b[c]))return!1;d[c]=!0}for(c in b)if(!(c in d)&&\"$\"!==c.charAt(0)&&v(b[c])&&!y(b[c]))return!1;return!0}return!1}function ab(a,b,d){return a.concat(wa.call(b,d))}function bb(a,b){var d=2<arguments.length?wa.call(arguments,2):[];return!y(b)||b instanceof RegExp?b:d.length?function(){return arguments.length?b.apply(a,\nab(d,arguments,0)):b.apply(a,d)}:function(){return arguments.length?b.apply(a,arguments):b.call(a)}}function Hc(a,b){var d=b;\"string\"===typeof a&&\"$\"===a.charAt(0)&&\"$\"===a.charAt(1)?d=void 0:Wa(b)?d=\"$WINDOW\":b&&z.document===b?d=\"$DOCUMENT\":Za(b)&&(d=\"$SCOPE\");return d}function cb(a,b){if(!x(a))return Y(b)||(b=b?2:null),JSON.stringify(a,Hc,b)}function Ic(a){return E(a)?JSON.parse(a):a}function Jc(a,b){a=a.replace(ne,\"\");var d=Date.parse(\"Jan 01, 1970 00:00:00 \"+a)/6E4;return ga(d)?b:d}function Wb(a,\nb,d){d=d?-1:1;var c=a.getTimezoneOffset();b=Jc(b,c);d*=b-c;a=new Date(a.getTime());a.setMinutes(a.getMinutes()+d);return a}function ya(a){a=D(a).clone();try{a.empty()}catch(b){}var d=D(\"<div>\").append(a).html();try{return a[0].nodeType===Ja?P(d):d.match(/^(<[^>]+>)/)[1].replace(/^<([\\w-]+)/,function(a,b){return\"<\"+P(b)})}catch(c){return P(d)}}function Kc(a){try{return decodeURIComponent(a)}catch(b){}}function Lc(a){var b={};q((a||\"\").split(\"&\"),function(a){var c,f,e;a&&(f=a=a.replace(/\\+/g,\"%20\"),\nc=a.indexOf(\"=\"),-1!==c&&(f=a.substring(0,c),e=a.substring(c+1)),f=Kc(f),v(f)&&(e=v(e)?Kc(e):!0,va.call(b,f)?C(b[f])?b[f].push(e):b[f]=[b[f],e]:b[f]=e))});return b}function Xb(a){var b=[];q(a,function(a,c){C(a)?q(a,function(a){b.push(ka(c,!0)+(!0===a?\"\":\"=\"+ka(a,!0)))}):b.push(ka(c,!0)+(!0===a?\"\":\"=\"+ka(a,!0)))});return b.length?b.join(\"&\"):\"\"}function db(a){return ka(a,!0).replace(/%26/gi,\"&\").replace(/%3D/gi,\"=\").replace(/%2B/gi,\"+\")}function ka(a,b){return encodeURIComponent(a).replace(/%40/gi,\n\"@\").replace(/%3A/gi,\":\").replace(/%24/g,\"$\").replace(/%2C/gi,\",\").replace(/%3B/gi,\";\").replace(/%20/g,b?\"%20\":\"+\")}function oe(a,b){var d,c,f=Ka.length;for(c=0;c<f;++c)if(d=Ka[c]+b,E(d=a.getAttribute(d)))return d;return null}function pe(a,b){var d,c,f={};q(Ka,function(b){b+=\"app\";!d&&a.hasAttribute&&a.hasAttribute(b)&&(d=a,c=a.getAttribute(b))});q(Ka,function(b){b+=\"app\";var f;!d&&(f=a.querySelector(\"[\"+b.replace(\":\",\"\\\\:\")+\"]\"))&&(d=f,c=f.getAttribute(b))});d&&(qe?(f.strictDi=null!==oe(d,\"strict-di\"),\nb(d,c?[c]:[],f)):z.console.error(\"Angular: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match.\"))}function Mc(a,b,d){F(d)||(d={});d=R({strictDi:!1},d);var c=function(){a=D(a);if(a.injector()){var c=a[0]===z.document?\"document\":ya(a);throw Ga(\"btstrpd\",c.replace(/</,\"&lt;\").replace(/>/,\"&gt;\"));}b=b||[];b.unshift([\"$provide\",function(b){b.value(\"$rootElement\",a)}]);d.debugInfoEnabled&&b.push([\"$compileProvider\",function(a){a.debugInfoEnabled(!0)}]);\nb.unshift(\"ng\");c=eb(b,d.strictDi);c.invoke([\"$rootScope\",\"$rootElement\",\"$compile\",\"$injector\",function(a,b,d,c){a.$apply(function(){b.data(\"$injector\",c);d(b)(a)})}]);return c},f=/^NG_ENABLE_DEBUG_INFO!/,e=/^NG_DEFER_BOOTSTRAP!/;z&&f.test(z.name)&&(d.debugInfoEnabled=!0,z.name=z.name.replace(f,\"\"));if(z&&!e.test(z.name))return c();z.name=z.name.replace(e,\"\");$.resumeBootstrap=function(a){q(a,function(a){b.push(a)});return c()};y($.resumeDeferredBootstrap)&&$.resumeDeferredBootstrap()}function re(){z.name=\n\"NG_ENABLE_DEBUG_INFO!\"+z.name;z.location.reload()}function se(a){a=$.element(a).injector();if(!a)throw Ga(\"test\");return a.get(\"$$testability\")}function Nc(a,b){b=b||\"_\";return a.replace(te,function(a,c){return(c?b:\"\")+a.toLowerCase()})}function ue(){var a;if(!Oc){var b=sb();(oa=x(b)?z.jQuery:b?z[b]:void 0)&&oa.fn.on?(D=oa,R(oa.fn,{scope:Oa.scope,isolateScope:Oa.isolateScope,controller:Oa.controller,injector:Oa.injector,inheritedData:Oa.inheritedData}),a=oa.cleanData,oa.cleanData=function(b){for(var c,\nf=0,e;null!=(e=b[f]);f++)(c=oa._data(e,\"events\"))&&c.$destroy&&oa(e).triggerHandler(\"$destroy\");a(b)}):D=X;$.element=D;Oc=!0}}function fb(a,b,d){if(!a)throw Ga(\"areq\",b||\"?\",d||\"required\");return a}function tb(a,b,d){d&&C(a)&&(a=a[a.length-1]);fb(y(a),b,\"not a function, got \"+(a&&\"object\"===typeof a?a.constructor.name||\"Object\":typeof a));return a}function Pa(a,b){if(\"hasOwnProperty\"===a)throw Ga(\"badname\",b);}function Pc(a,b,d){if(!b)return a;b=b.split(\".\");for(var c,f=a,e=b.length,g=0;g<e;g++)c=\nb[g],a&&(a=(f=a)[c]);return!d&&y(a)?bb(f,a):a}function ub(a){for(var b=a[0],d=a[a.length-1],c,f=1;b!==d&&(b=b.nextSibling);f++)if(c||a[f]!==b)c||(c=D(wa.call(a,0,f))),c.push(b);return c||a}function W(){return Object.create(null)}function Yb(a){if(null==a)return\"\";switch(typeof a){case \"string\":break;case \"number\":a=\"\"+a;break;default:a=!Vb(a)||C(a)||fa(a)?cb(a):a.toString()}return a}function ve(a){function b(a,b,c){return a[b]||(a[b]=c())}var d=M(\"$injector\"),c=M(\"ng\");a=b(a,\"angular\",Object);a.$$minErr=\na.$$minErr||M;return b(a,\"module\",function(){var a={};return function(e,g,h){if(\"hasOwnProperty\"===e)throw c(\"badname\",\"module\");g&&a.hasOwnProperty(e)&&(a[e]=null);return b(a,e,function(){function a(b,d,e,f){f||(f=c);return function(){f[e||\"push\"]([b,d,arguments]);return J}}function b(a,d,f){f||(f=c);return function(b,c){c&&y(c)&&(c.$$moduleName=e);f.push([a,d,arguments]);return J}}if(!g)throw d(\"nomod\",e);var c=[],f=[],p=[],r=a(\"$injector\",\"invoke\",\"push\",f),J={_invokeQueue:c,_configBlocks:f,_runBlocks:p,\nrequires:g,name:e,provider:b(\"$provide\",\"provider\"),factory:b(\"$provide\",\"factory\"),service:b(\"$provide\",\"service\"),value:a(\"$provide\",\"value\"),constant:a(\"$provide\",\"constant\",\"unshift\"),decorator:b(\"$provide\",\"decorator\",f),animation:b(\"$animateProvider\",\"register\"),filter:b(\"$filterProvider\",\"register\"),controller:b(\"$controllerProvider\",\"register\"),directive:b(\"$compileProvider\",\"directive\"),component:b(\"$compileProvider\",\"component\"),config:r,run:function(a){p.push(a);return this}};h&&r(h);return J})}})}\nfunction ra(a,b){if(C(a)){b=b||[];for(var d=0,c=a.length;d<c;d++)b[d]=a[d]}else if(F(a))for(d in b=b||{},a)if(\"$\"!==d.charAt(0)||\"$\"!==d.charAt(1))b[d]=a[d];return b||a}function we(a){var b=[];return JSON.stringify(a,function(a,c){c=Hc(a,c);if(F(c)){if(0<=b.indexOf(c))return\"...\";b.push(c)}return c})}function xe(a){R(a,{bootstrap:Mc,copy:Fa,extend:R,merge:je,equals:qa,element:D,forEach:q,injector:eb,noop:w,bind:bb,toJson:cb,fromJson:Ic,identity:Ya,isUndefined:x,isDefined:v,isString:E,isFunction:y,\nisObject:F,isNumber:Y,isElement:Tb,isArray:C,version:ye,isDate:fa,lowercase:P,uppercase:vb,callbacks:{$$counter:0},getTestability:se,reloadWithDebugInfo:re,$$minErr:M,$$csp:za,$$encodeUriSegment:db,$$encodeUriQuery:ka,$$stringify:Yb});Zb=ve(z);Zb(\"ng\",[\"ngLocale\"],[\"$provide\",function(a){a.provider({$$sanitizeUri:ze});a.provider(\"$compile\",Qc).directive({a:Ae,input:Rc,textarea:Rc,form:Be,script:Ce,select:De,option:Ee,ngBind:Fe,ngBindHtml:Ge,ngBindTemplate:He,ngClass:Ie,ngClassEven:Je,ngClassOdd:Ke,\nngCloak:Le,ngController:Me,ngForm:Ne,ngHide:Oe,ngIf:Pe,ngInclude:Qe,ngInit:Re,ngNonBindable:Se,ngPluralize:Te,ngRepeat:Ue,ngShow:Ve,ngStyle:We,ngSwitch:Xe,ngSwitchWhen:Ye,ngSwitchDefault:Ze,ngOptions:$e,ngTransclude:af,ngModel:bf,ngList:cf,ngChange:df,pattern:Sc,ngPattern:Sc,required:Tc,ngRequired:Tc,minlength:Uc,ngMinlength:Uc,maxlength:Vc,ngMaxlength:Vc,ngValue:ef,ngModelOptions:ff}).directive({ngInclude:gf}).directive(wb).directive(Wc);a.provider({$anchorScroll:hf,$animate:jf,$animateCss:kf,$$animateJs:lf,\n$$animateQueue:mf,$$AnimateRunner:nf,$$animateAsyncRun:of,$browser:pf,$cacheFactory:qf,$controller:rf,$document:sf,$$isDocumentHidden:tf,$exceptionHandler:uf,$filter:Xc,$$forceReflow:vf,$interpolate:wf,$interval:xf,$http:yf,$httpParamSerializer:zf,$httpParamSerializerJQLike:Af,$httpBackend:Bf,$xhrFactory:Cf,$jsonpCallbacks:Df,$location:Ef,$log:Ff,$parse:Gf,$rootScope:Hf,$q:If,$$q:Jf,$sce:Kf,$sceDelegate:Lf,$sniffer:Mf,$templateCache:Nf,$templateRequest:Of,$$testability:Pf,$timeout:Qf,$window:Rf,$$rAF:Sf,\n$$jqLite:Tf,$$HashMap:Uf,$$cookieReader:Vf})}])}function gb(a,b){return b.toUpperCase()}function xb(a){return a.replace(Wf,gb)}function Yc(a){a=a.nodeType;return 1===a||!a||9===a}function Zc(a,b){var d,c,f=b.createDocumentFragment(),e=[];if($b.test(a)){d=f.appendChild(b.createElement(\"div\"));c=(Xf.exec(a)||[\"\",\"\"])[1].toLowerCase();c=ha[c]||ha._default;d.innerHTML=c[1]+a.replace(Yf,\"<$1></$2>\")+c[2];for(c=c[0];c--;)d=d.lastChild;e=ab(e,d.childNodes);d=f.firstChild;d.textContent=\"\"}else e.push(b.createTextNode(a));\nf.textContent=\"\";f.innerHTML=\"\";q(e,function(a){f.appendChild(a)});return f}function X(a){if(a instanceof X)return a;var b;E(a)&&(a=S(a),b=!0);if(!(this instanceof X)){if(b&&\"<\"!==a.charAt(0))throw ac(\"nosel\");return new X(a)}if(b){b=z.document;var d;a=(d=Zf.exec(a))?[b.createElement(d[1])]:(d=Zc(a,b))?d.childNodes:[];bc(this,a)}else y(a)?$c(a):bc(this,a)}function cc(a){return a.cloneNode(!0)}function yb(a,b){b||hb(a);if(a.querySelectorAll)for(var d=a.querySelectorAll(\"*\"),c=0,f=d.length;c<f;c++)hb(d[c])}\nfunction ad(a,b,d,c){if(v(c))throw ac(\"offargs\");var f=(c=zb(a))&&c.events,e=c&&c.handle;if(e)if(b){var g=function(b){var c=f[b];v(d)&&$a(c||[],d);v(d)&&c&&0<c.length||(a.removeEventListener(b,e),delete f[b])};q(b.split(\" \"),function(a){g(a);Ab[a]&&g(Ab[a])})}else for(b in f)\"$destroy\"!==b&&a.removeEventListener(b,e),delete f[b]}function hb(a,b){var d=a.ng339,c=d&&ib[d];c&&(b?delete c.data[b]:(c.handle&&(c.events.$destroy&&c.handle({},\"$destroy\"),ad(a)),delete ib[d],a.ng339=void 0))}function zb(a,\nb){var d=a.ng339,d=d&&ib[d];b&&!d&&(a.ng339=d=++$f,d=ib[d]={events:{},data:{},handle:void 0});return d}function dc(a,b,d){if(Yc(a)){var c,f=v(d),e=!f&&b&&!F(b),g=!b;a=(a=zb(a,!e))&&a.data;if(f)a[xb(b)]=d;else{if(g)return a;if(e)return a&&a[xb(b)];for(c in b)a[xb(c)]=b[c]}}}function Bb(a,b){return a.getAttribute?-1<(\" \"+(a.getAttribute(\"class\")||\"\")+\" \").replace(/[\\n\\t]/g,\" \").indexOf(\" \"+b+\" \"):!1}function Cb(a,b){b&&a.setAttribute&&q(b.split(\" \"),function(b){a.setAttribute(\"class\",S((\" \"+(a.getAttribute(\"class\")||\n\"\")+\" \").replace(/[\\n\\t]/g,\" \").replace(\" \"+S(b)+\" \",\" \")))})}function Db(a,b){if(b&&a.setAttribute){var d=(\" \"+(a.getAttribute(\"class\")||\"\")+\" \").replace(/[\\n\\t]/g,\" \");q(b.split(\" \"),function(a){a=S(a);-1===d.indexOf(\" \"+a+\" \")&&(d+=a+\" \")});a.setAttribute(\"class\",S(d))}}function bc(a,b){if(b)if(b.nodeType)a[a.length++]=b;else{var d=b.length;if(\"number\"===typeof d&&b.window!==b){if(d)for(var c=0;c<d;c++)a[a.length++]=b[c]}else a[a.length++]=b}}function bd(a,b){return Eb(a,\"$\"+(b||\"ngController\")+\n\"Controller\")}function Eb(a,b,d){9===a.nodeType&&(a=a.documentElement);for(b=C(b)?b:[b];a;){for(var c=0,f=b.length;c<f;c++)if(v(d=D.data(a,b[c])))return d;a=a.parentNode||11===a.nodeType&&a.host}}function cd(a){for(yb(a,!0);a.firstChild;)a.removeChild(a.firstChild)}function Fb(a,b){b||yb(a);var d=a.parentNode;d&&d.removeChild(a)}function ag(a,b){b=b||z;if(\"complete\"===b.document.readyState)b.setTimeout(a);else D(b).on(\"load\",a)}function $c(a){function b(){z.document.removeEventListener(\"DOMContentLoaded\",\nb);z.removeEventListener(\"load\",b);a()}\"complete\"===z.document.readyState?z.setTimeout(a):(z.document.addEventListener(\"DOMContentLoaded\",b),z.addEventListener(\"load\",b))}function dd(a,b){var d=Gb[b.toLowerCase()];return d&&ed[xa(a)]&&d}function bg(a,b){var d=function(c,d){c.isDefaultPrevented=function(){return c.defaultPrevented};var e=b[d||c.type],g=e?e.length:0;if(g){if(x(c.immediatePropagationStopped)){var h=c.stopImmediatePropagation;c.stopImmediatePropagation=function(){c.immediatePropagationStopped=\n!0;c.stopPropagation&&c.stopPropagation();h&&h.call(c)}}c.isImmediatePropagationStopped=function(){return!0===c.immediatePropagationStopped};var k=e.specialHandlerWrapper||cg;1<g&&(e=ra(e));for(var l=0;l<g;l++)c.isImmediatePropagationStopped()||k(a,c,e[l])}};d.elem=a;return d}function cg(a,b,d){d.call(a,b)}function dg(a,b,d){var c=b.relatedTarget;c&&(c===a||eg.call(a,c))||d.call(a,b)}function Tf(){this.$get=function(){return R(X,{hasClass:function(a,b){a.attr&&(a=a[0]);return Bb(a,b)},addClass:function(a,\nb){a.attr&&(a=a[0]);return Db(a,b)},removeClass:function(a,b){a.attr&&(a=a[0]);return Cb(a,b)}})}}function la(a,b){var d=a&&a.$$hashKey;if(d)return\"function\"===typeof d&&(d=a.$$hashKey()),d;d=typeof a;return d=\"function\"===d||\"object\"===d&&null!==a?a.$$hashKey=d+\":\"+(b||ie)():d+\":\"+a}function Qa(a,b){if(b){var d=0;this.nextUid=function(){return++d}}q(a,this.put,this)}function fd(a){a=(Function.prototype.toString.call(a)+\" \").replace(fg,\"\");return a.match(gg)||a.match(hg)}function ig(a){return(a=fd(a))?\n\"function(\"+(a[1]||\"\").replace(/[\\s\\r\\n]+/,\" \")+\")\":\"fn\"}function eb(a,b){function d(a){return function(b,c){if(F(b))q(b,Fc(a));else return a(b,c)}}function c(a,b){Pa(a,\"service\");if(y(b)||C(b))b=p.instantiate(b);if(!b.$get)throw da(\"pget\",a);return n[a+\"Provider\"]=b}function f(a,b){return function(){var c=O.invoke(b,this);if(x(c))throw da(\"undef\",a);return c}}function e(a,b,d){return c(a,{$get:!1!==d?f(a,b):b})}function g(a){fb(x(a)||C(a),\"modulesToLoad\",\"not an array\");var b=[],c;q(a,function(a){function d(a){var b,\nc;b=0;for(c=a.length;b<c;b++){var e=a[b],f=p.get(e[0]);f[e[1]].apply(f,e[2])}}if(!m.get(a)){m.put(a,!0);try{E(a)?(c=Zb(a),b=b.concat(g(c.requires)).concat(c._runBlocks),d(c._invokeQueue),d(c._configBlocks)):y(a)?b.push(p.invoke(a)):C(a)?b.push(p.invoke(a)):tb(a,\"module\")}catch(e){throw C(a)&&(a=a[a.length-1]),e.message&&e.stack&&-1===e.stack.indexOf(e.message)&&(e=e.message+\"\\n\"+e.stack),da(\"modulerr\",a,e.stack||e.message||e);}}});return b}function h(a,c){function d(b,e){if(a.hasOwnProperty(b)){if(a[b]===\nk)throw da(\"cdep\",b+\" <- \"+l.join(\" <- \"));return a[b]}try{return l.unshift(b),a[b]=k,a[b]=c(b,e),a[b]}catch(f){throw a[b]===k&&delete a[b],f;}finally{l.shift()}}function e(a,c,f){var g=[];a=eb.$$annotate(a,b,f);for(var h=0,k=a.length;h<k;h++){var l=a[h];if(\"string\"!==typeof l)throw da(\"itkn\",l);g.push(c&&c.hasOwnProperty(l)?c[l]:d(l,f))}return g}return{invoke:function(a,b,c,d){\"string\"===typeof c&&(d=c,c=null);c=e(a,c,d);C(a)&&(a=a[a.length-1]);d=a;if(La||\"function\"!==typeof d)d=!1;else{var f=d.$$ngIsClass;\nIa(f)||(f=d.$$ngIsClass=/^(?:class\\b|constructor\\()/.test(Function.prototype.toString.call(d)+\" \"));d=f}return d?(c.unshift(null),new (Function.prototype.bind.apply(a,c))):a.apply(b,c)},instantiate:function(a,b,c){var d=C(a)?a[a.length-1]:a;a=e(a,b,c);a.unshift(null);return new (Function.prototype.bind.apply(d,a))},get:d,annotate:eb.$$annotate,has:function(b){return n.hasOwnProperty(b+\"Provider\")||a.hasOwnProperty(b)}}}b=!0===b;var k={},l=[],m=new Qa([],!0),n={$provide:{provider:d(c),factory:d(e),\nservice:d(function(a,b){return e(a,[\"$injector\",function(a){return a.instantiate(b)}])}),value:d(function(a,b){return e(a,ma(b),!1)}),constant:d(function(a,b){Pa(a,\"constant\");n[a]=b;r[a]=b}),decorator:function(a,b){var c=p.get(a+\"Provider\"),d=c.$get;c.$get=function(){var a=O.invoke(d,c);return O.invoke(b,null,{$delegate:a})}}}},p=n.$injector=h(n,function(a,b){$.isString(b)&&l.push(b);throw da(\"unpr\",l.join(\" <- \"));}),r={},J=h(r,function(a,b){var c=p.get(a+\"Provider\",b);return O.invoke(c.$get,c,\nvoid 0,a)}),O=J;n.$injectorProvider={$get:ma(J)};var u=g(a),O=J.get(\"$injector\");O.strictDi=b;q(u,function(a){a&&O.invoke(a)});return O}function hf(){var a=!0;this.disableAutoScrolling=function(){a=!1};this.$get=[\"$window\",\"$location\",\"$rootScope\",function(b,d,c){function f(a){var b=null;Array.prototype.some.call(a,function(a){if(\"a\"===xa(a))return b=a,!0});return b}function e(a){if(a){a.scrollIntoView();var c;c=g.yOffset;y(c)?c=c():Tb(c)?(c=c[0],c=\"fixed\"!==b.getComputedStyle(c).position?0:c.getBoundingClientRect().bottom):\nY(c)||(c=0);c&&(a=a.getBoundingClientRect().top,b.scrollBy(0,a-c))}else b.scrollTo(0,0)}function g(a){a=E(a)?a:Y(a)?a.toString():d.hash();var b;a?(b=h.getElementById(a))?e(b):(b=f(h.getElementsByName(a)))?e(b):\"top\"===a&&e(null):e(null)}var h=b.document;a&&c.$watch(function(){return d.hash()},function(a,b){a===b&&\"\"===a||ag(function(){c.$evalAsync(g)})});return g}]}function jb(a,b){if(!a&&!b)return\"\";if(!a)return b;if(!b)return a;C(a)&&(a=a.join(\" \"));C(b)&&(b=b.join(\" \"));return a+\" \"+b}function jg(a){E(a)&&\n(a=a.split(\" \"));var b=W();q(a,function(a){a.length&&(b[a]=!0)});return b}function Aa(a){return F(a)?a:{}}function kg(a,b,d,c){function f(a){try{a.apply(null,wa.call(arguments,1))}finally{if(J--,0===J)for(;O.length;)try{O.pop()()}catch(b){d.error(b)}}}function e(){ia=null;g();h()}function g(){u=A();u=x(u)?null:u;qa(u,B)&&(u=B);B=u}function h(){if(U!==k.url()||H!==u)U=k.url(),H=u,q(K,function(a){a(k.url(),u)})}var k=this,l=a.location,m=a.history,n=a.setTimeout,p=a.clearTimeout,r={};k.isMock=!1;var J=\n0,O=[];k.$$completeOutstandingRequest=f;k.$$incOutstandingRequestCount=function(){J++};k.notifyWhenNoOutstandingRequests=function(a){0===J?a():O.push(a)};var u,H,U=l.href,t=b.find(\"base\"),ia=null,A=c.history?function(){try{return m.state}catch(a){}}:w;g();H=u;k.url=function(b,d,e){x(e)&&(e=null);l!==a.location&&(l=a.location);m!==a.history&&(m=a.history);if(b){var f=H===e;if(U===b&&(!c.history||f))return k;var h=U&&Ba(U)===Ba(b);U=b;H=e;!c.history||h&&f?(h||(ia=b),d?l.replace(b):h?(d=l,e=b.indexOf(\"#\"),\ne=-1===e?\"\":b.substr(e),d.hash=e):l.href=b,l.href!==b&&(ia=b)):(m[d?\"replaceState\":\"pushState\"](e,\"\",b),g(),H=u);ia&&(ia=b);return k}return ia||l.href.replace(/%27/g,\"'\")};k.state=function(){return u};var K=[],I=!1,B=null;k.onUrlChange=function(b){if(!I){if(c.history)D(a).on(\"popstate\",e);D(a).on(\"hashchange\",e);I=!0}K.push(b);return b};k.$$applicationDestroyed=function(){D(a).off(\"hashchange popstate\",e)};k.$$checkUrlChange=h;k.baseHref=function(){var a=t.attr(\"href\");return a?a.replace(/^(https?:)?\\/\\/[^/]*/,\n\"\"):\"\"};k.defer=function(a,b){var c;J++;c=n(function(){delete r[c];f(a)},b||0);r[c]=!0;return c};k.defer.cancel=function(a){return r[a]?(delete r[a],p(a),f(w),!0):!1}}function pf(){this.$get=[\"$window\",\"$log\",\"$sniffer\",\"$document\",function(a,b,d,c){return new kg(a,c,b,d)}]}function qf(){this.$get=function(){function a(a,c){function f(a){a!==n&&(p?p===a&&(p=a.n):p=a,e(a.n,a.p),e(a,n),n=a,n.n=null)}function e(a,b){a!==b&&(a&&(a.p=b),b&&(b.n=a))}if(a in b)throw M(\"$cacheFactory\")(\"iid\",a);var g=0,h=\nR({},c,{id:a}),k=W(),l=c&&c.capacity||Number.MAX_VALUE,m=W(),n=null,p=null;return b[a]={put:function(a,b){if(!x(b)){if(l<Number.MAX_VALUE){var c=m[a]||(m[a]={key:a});f(c)}a in k||g++;k[a]=b;g>l&&this.remove(p.key);return b}},get:function(a){if(l<Number.MAX_VALUE){var b=m[a];if(!b)return;f(b)}return k[a]},remove:function(a){if(l<Number.MAX_VALUE){var b=m[a];if(!b)return;b===n&&(n=b.p);b===p&&(p=b.n);e(b.n,b.p);delete m[a]}a in k&&(delete k[a],g--)},removeAll:function(){k=W();g=0;m=W();n=p=null},destroy:function(){m=\nh=k=null;delete b[a]},info:function(){return R({},h,{size:g})}}}var b={};a.info=function(){var a={};q(b,function(b,f){a[f]=b.info()});return a};a.get=function(a){return b[a]};return a}}function Nf(){this.$get=[\"$cacheFactory\",function(a){return a(\"templates\")}]}function Qc(a,b){function d(a,b,c){var d=/^\\s*([@&<]|=(\\*?))(\\??)\\s*(\\w*)\\s*$/,e=W();q(a,function(a,f){if(a in n)e[f]=n[a];else{var g=a.match(d);if(!g)throw ea(\"iscp\",b,f,a,c?\"controller bindings definition\":\"isolate scope definition\");e[f]=\n{mode:g[1][0],collection:\"*\"===g[2],optional:\"?\"===g[3],attrName:g[4]||f};g[4]&&(n[a]=e[f])}});return e}function c(a){var b=a.charAt(0);if(!b||b!==P(b))throw ea(\"baddir\",a);if(a!==a.trim())throw ea(\"baddir\",a);}function f(a){var b=a.require||a.controller&&a.name;!C(b)&&F(b)&&q(b,function(a,c){var d=a.match(l);a.substring(d[0].length)||(b[c]=d[0]+c)});return b}var e={},g=/^\\s*directive:\\s*([\\w-]+)\\s+(.*)$/,h=/(([\\w-]+)(?::([^;]+))?;?)/,k=me(\"ngSrc,ngSrcset,src,srcset\"),l=/^(?:(\\^\\^?)?(\\?)?(\\^\\^?)?)?/,\nm=/^(on[a-z]+|formaction)$/,n=W();this.directive=function U(b,d){fb(b,\"name\");Pa(b,\"directive\");E(b)?(c(b),fb(d,\"directiveFactory\"),e.hasOwnProperty(b)||(e[b]=[],a.factory(b+\"Directive\",[\"$injector\",\"$exceptionHandler\",function(a,c){var d=[];q(e[b],function(e,g){try{var h=a.invoke(e);y(h)?h={compile:ma(h)}:!h.compile&&h.link&&(h.compile=ma(h.link));h.priority=h.priority||0;h.index=g;h.name=h.name||b;h.require=f(h);var k=h,l=h.restrict;if(l&&(!E(l)||!/[EACM]/.test(l)))throw ea(\"badrestrict\",l,b);k.restrict=\nl||\"EA\";h.$$moduleName=e.$$moduleName;d.push(h)}catch(m){c(m)}});return d}])),e[b].push(d)):q(b,Fc(U));return this};this.component=function(a,b){function c(a){function e(b){return y(b)||C(b)?function(c,d){return a.invoke(b,this,{$element:c,$attrs:d})}:b}var f=b.template||b.templateUrl?b.template:\"\",g={controller:d,controllerAs:lg(b.controller)||b.controllerAs||\"$ctrl\",template:e(f),templateUrl:e(b.templateUrl),transclude:b.transclude,scope:{},bindToController:b.bindings||{},restrict:\"E\",require:b.require};\nq(b,function(a,b){\"$\"===b.charAt(0)&&(g[b]=a)});return g}var d=b.controller||function(){};q(b,function(a,b){\"$\"===b.charAt(0)&&(c[b]=a,y(d)&&(d[b]=a))});c.$inject=[\"$injector\"];return this.directive(a,c)};this.aHrefSanitizationWhitelist=function(a){return v(a)?(b.aHrefSanitizationWhitelist(a),this):b.aHrefSanitizationWhitelist()};this.imgSrcSanitizationWhitelist=function(a){return v(a)?(b.imgSrcSanitizationWhitelist(a),this):b.imgSrcSanitizationWhitelist()};var p=!0;this.debugInfoEnabled=function(a){return v(a)?\n(p=a,this):p};var r=!1;this.preAssignBindingsEnabled=function(a){return v(a)?(r=a,this):r};var J=10;this.onChangesTtl=function(a){return arguments.length?(J=a,this):J};var O=!0;this.commentDirectivesEnabled=function(a){return arguments.length?(O=a,this):O};var u=!0;this.cssClassDirectivesEnabled=function(a){return arguments.length?(u=a,this):u};this.$get=[\"$injector\",\"$interpolate\",\"$exceptionHandler\",\"$templateRequest\",\"$parse\",\"$controller\",\"$rootScope\",\"$sce\",\"$animate\",\"$$sanitizeUri\",function(a,\nb,c,f,n,I,B,L,N,G){function T(){try{if(!--za)throw da=void 0,ea(\"infchng\",J);B.$apply(function(){for(var a=[],b=0,c=da.length;b<c;++b)try{da[b]()}catch(d){a.push(d)}da=void 0;if(a.length)throw a;})}finally{za++}}function s(a,b){if(b){var c=Object.keys(b),d,e,f;d=0;for(e=c.length;d<e;d++)f=c[d],this[f]=b[f]}else this.$attr={};this.$$element=a}function Q(a,b,c){ua.innerHTML=\"<span \"+b+\">\";b=ua.firstChild.attributes;var d=b[0];b.removeNamedItem(d.name);d.value=c;a.attributes.setNamedItem(d)}function Ma(a,\nb){try{a.addClass(b)}catch(c){}}function ba(a,b,c,d,e){a instanceof D||(a=D(a));var f=Na(a,b,a,c,d,e);ba.$$addScopeClass(a);var g=null;return function(b,c,d){if(!a)throw ea(\"multilink\");fb(b,\"scope\");e&&e.needsNewScope&&(b=b.$parent.$new());d=d||{};var h=d.parentBoundTranscludeFn,k=d.transcludeControllers;d=d.futureParentElement;h&&h.$$boundTransclude&&(h=h.$$boundTransclude);g||(g=(d=d&&d[0])?\"foreignobject\"!==xa(d)&&na.call(d).match(/SVG/)?\"svg\":\"html\":\"html\");d=\"html\"!==g?D(ha(g,D(\"<div>\").append(a).html())):\nc?Oa.clone.call(a):a;if(k)for(var l in k)d.data(\"$\"+l+\"Controller\",k[l].instance);ba.$$addScopeInfo(d,b);c&&c(d,b);f&&f(b,d,d,h);c||(a=f=null);return d}}function Na(a,b,c,d,e,f){function g(a,c,d,e){var f,k,l,m,n,p,r;if(K)for(r=Array(c.length),m=0;m<h.length;m+=3)f=h[m],r[f]=c[f];else r=c;m=0;for(n=h.length;m<n;)k=r[h[m++]],c=h[m++],f=h[m++],c?(c.scope?(l=a.$new(),ba.$$addScopeInfo(D(k),l)):l=a,p=c.transcludeOnThisElement?ja(a,c.transclude,e):!c.templateOnThisElement&&e?e:!e&&b?ja(a,b):null,c(f,l,\nk,d,p)):f&&f(a,k.childNodes,void 0,e)}for(var h=[],k=C(a)||a instanceof D,l,m,n,p,K,r=0;r<a.length;r++){l=new s;11===La&&M(a,r,k);m=fc(a[r],[],l,0===r?d:void 0,e);(f=m.length?X(m,a[r],l,b,c,null,[],[],f):null)&&f.scope&&ba.$$addScopeClass(l.$$element);l=f&&f.terminal||!(n=a[r].childNodes)||!n.length?null:Na(n,f?(f.transcludeOnThisElement||!f.templateOnThisElement)&&f.transclude:b);if(f||l)h.push(r,f,l),p=!0,K=K||f;f=null}return p?g:null}function M(a,b,c){var d=a[b],e=d.parentNode,f;if(d.nodeType===\nJa)for(;;){f=e?d.nextSibling:a[b+1];if(!f||f.nodeType!==Ja)break;d.nodeValue+=f.nodeValue;f.parentNode&&f.parentNode.removeChild(f);c&&f===a[b+1]&&a.splice(b+1,1)}}function ja(a,b,c){function d(e,f,g,h,k){e||(e=a.$new(!1,k),e.$$transcluded=!0);return b(e,f,{parentBoundTranscludeFn:c,transcludeControllers:g,futureParentElement:h})}var e=d.$$slots=W(),f;for(f in b.$$slots)e[f]=b.$$slots[f]?ja(a,b.$$slots[f],c):null;return d}function fc(a,b,c,d,e){var f=c.$attr,g;switch(a.nodeType){case 1:g=xa(a);Y(b,\nCa(g),\"E\",d,e);for(var k,l,m,n,p=a.attributes,K=0,r=p&&p.length;K<r;K++){var A=!1,B=!1;k=p[K];l=k.name;m=k.value;k=Ca(l);(n=Ha.test(k))&&(l=l.replace(gd,\"\").substr(8).replace(/_(.)/g,function(a,b){return b.toUpperCase()}));(k=k.match(Ka))&&Z(k[1])&&(A=l,B=l.substr(0,l.length-5)+\"end\",l=l.substr(0,l.length-6));k=Ca(l.toLowerCase());f[k]=l;if(n||!c.hasOwnProperty(k))c[k]=m,dd(a,k)&&(c[k]=!0);ra(a,b,m,k,n);Y(b,k,\"A\",d,e,A,B)}\"input\"===g&&\"hidden\"===a.getAttribute(\"type\")&&a.setAttribute(\"autocomplete\",\n\"off\");if(!Ga)break;f=a.className;F(f)&&(f=f.animVal);if(E(f)&&\"\"!==f)for(;a=h.exec(f);)k=Ca(a[2]),Y(b,k,\"C\",d,e)&&(c[k]=S(a[3])),f=f.substr(a.index+a[0].length);break;case Ja:ma(b,a.nodeValue);break;case 8:if(!Fa)break;kb(a,b,c,d,e)}b.sort(ka);return b}function kb(a,b,c,d,e){try{var f=g.exec(a.nodeValue);if(f){var h=Ca(f[1]);Y(b,h,\"M\",d,e)&&(c[h]=S(f[2]))}}catch(k){}}function hd(a,b,c){var d=[],e=0;if(b&&a.hasAttribute&&a.hasAttribute(b)){do{if(!a)throw ea(\"uterdir\",b,c);1===a.nodeType&&(a.hasAttribute(b)&&\ne++,a.hasAttribute(c)&&e--);d.push(a);a=a.nextSibling}while(0<e)}else d.push(a);return D(d)}function id(a,b,c){return function(d,e,f,g,h){e=hd(e[0],b,c);return a(d,e,f,g,h)}}function gc(a,b,c,d,e,f){var g;return a?ba(b,c,d,e,f):function(){g||(g=ba(b,c,d,e,f),b=c=f=null);return g.apply(this,arguments)}}function X(a,b,d,e,f,g,h,k,l){function m(a,b,c,d){if(a){c&&(a=id(a,c,d));a.require=t.require;a.directiveName=L;if(B===t||t.$$isolateScope)a=sa(a,{isolateScope:!0});h.push(a)}if(b){c&&(b=id(b,c,d));b.require=\nt.require;b.directiveName=L;if(B===t||t.$$isolateScope)b=sa(b,{isolateScope:!0});k.push(b)}}function n(a,e,f,g,l){function m(a,b,c,d){var e;Za(a)||(d=c,c=b,b=a,a=void 0);U&&(e=N);c||(c=U?L.parent():L);if(d){var f=l.$$slots[d];if(f)return f(a,b,e,c,Q);if(x(f))throw ea(\"noslot\",d,ya(L));}else return l(a,b,e,c,Q)}var p,t,u,G,J,N,T,L;b===f?(g=d,L=d.$$element):(L=D(f),g=new s(L,d));J=e;B?G=e.$new(!0):K&&(J=e.$parent);l&&(T=m,T.$$boundTransclude=l,T.isSlotFilled=function(a){return!!l.$$slots[a]});A&&(N=\nca(L,g,T,A,G,e,B));B&&(ba.$$addScopeInfo(L,G,!0,!(I&&(I===B||I===B.$$originalDirective))),ba.$$addScopeClass(L,!0),G.$$isolateBindings=B.$$isolateBindings,t=oa(e,g,G,G.$$isolateBindings,B),t.removeWatches&&G.$on(\"$destroy\",t.removeWatches));for(p in N){t=A[p];u=N[p];var Hb=t.$$bindings.bindToController;if(r){u.bindingInfo=Hb?oa(J,g,u.instance,Hb,t):{};var O=u();O!==u.instance&&(u.instance=O,L.data(\"$\"+t.name+\"Controller\",O),u.bindingInfo.removeWatches&&u.bindingInfo.removeWatches(),u.bindingInfo=\noa(J,g,u.instance,Hb,t))}else u.instance=u(),L.data(\"$\"+t.name+\"Controller\",u.instance),u.bindingInfo=oa(J,g,u.instance,Hb,t)}q(A,function(a,b){var c=a.require;a.bindToController&&!C(c)&&F(c)&&R(N[b].instance,V(b,c,L,N))});q(N,function(a){var b=a.instance;if(y(b.$onChanges))try{b.$onChanges(a.bindingInfo.initialChanges)}catch(d){c(d)}if(y(b.$onInit))try{b.$onInit()}catch(e){c(e)}y(b.$doCheck)&&(J.$watch(function(){b.$doCheck()}),b.$doCheck());y(b.$onDestroy)&&J.$on(\"$destroy\",function(){b.$onDestroy()})});\np=0;for(t=h.length;p<t;p++)u=h[p],ta(u,u.isolateScope?G:e,L,g,u.require&&V(u.directiveName,u.require,L,N),T);var Q=e;B&&(B.template||null===B.templateUrl)&&(Q=G);a&&a(Q,f.childNodes,void 0,l);for(p=k.length-1;0<=p;p--)u=k[p],ta(u,u.isolateScope?G:e,L,g,u.require&&V(u.directiveName,u.require,L,N),T);q(N,function(a){a=a.instance;y(a.$postLink)&&a.$postLink()})}l=l||{};for(var p=-Number.MAX_VALUE,K=l.newScopeDirective,A=l.controllerDirectives,B=l.newIsolateScopeDirective,I=l.templateDirective,u=l.nonTlbTranscludeDirective,\nJ=!1,N=!1,U=l.hasElementTranscludeDirective,G=d.$$element=D(b),t,L,T,O=e,Q,v=!1,Ma=!1,w,z=0,E=a.length;z<E;z++){t=a[z];var Na=t.$$start,M=t.$$end;Na&&(G=hd(b,Na,M));T=void 0;if(p>t.priority)break;if(w=t.scope)t.templateUrl||(F(w)?($(\"new/isolated scope\",B||K,t,G),B=t):$(\"new/isolated scope\",B,t,G)),K=K||t;L=t.name;if(!v&&(t.replace&&(t.templateUrl||t.template)||t.transclude&&!t.$$tlb)){for(w=z+1;v=a[w++];)if(v.transclude&&!v.$$tlb||v.replace&&(v.templateUrl||v.template)){Ma=!0;break}v=!0}!t.templateUrl&&\nt.controller&&(A=A||W(),$(\"'\"+L+\"' controller\",A[L],t,G),A[L]=t);if(w=t.transclude)if(J=!0,t.$$tlb||($(\"transclusion\",u,t,G),u=t),\"element\"===w)U=!0,p=t.priority,T=G,G=d.$$element=D(ba.$$createComment(L,d[L])),b=G[0],la(f,wa.call(T,0),b),T[0].$$parentNode=T[0].parentNode,O=gc(Ma,T,e,p,g&&g.name,{nonTlbTranscludeDirective:u});else{var ja=W();if(F(w)){T=[];var P=W(),kb=W();q(w,function(a,b){var c=\"?\"===a.charAt(0);a=c?a.substring(1):a;P[a]=b;ja[b]=null;kb[b]=c});q(G.contents(),function(a){var b=P[Ca(xa(a))];\nb?(kb[b]=!0,ja[b]=ja[b]||[],ja[b].push(a)):T.push(a)});q(kb,function(a,b){if(!a)throw ea(\"reqslot\",b);});for(var ec in ja)ja[ec]&&(ja[ec]=gc(Ma,ja[ec],e))}else T=D(cc(b)).contents();G.empty();O=gc(Ma,T,e,void 0,void 0,{needsNewScope:t.$$isolateScope||t.$$newScope});O.$$slots=ja}if(t.template)if(N=!0,$(\"template\",I,t,G),I=t,w=y(t.template)?t.template(G,d):t.template,w=Ea(w),t.replace){g=t;T=$b.test(w)?jd(ha(t.templateNamespace,S(w))):[];b=T[0];if(1!==T.length||1!==b.nodeType)throw ea(\"tplrt\",L,\"\");\nla(f,G,b);E={$attr:{}};w=fc(b,[],E);var Y=a.splice(z+1,a.length-(z+1));(B||K)&&aa(w,B,K);a=a.concat(w).concat(Y);fa(d,E);E=a.length}else G.html(w);if(t.templateUrl)N=!0,$(\"template\",I,t,G),I=t,t.replace&&(g=t),n=ga(a.splice(z,a.length-z),G,d,f,J&&O,h,k,{controllerDirectives:A,newScopeDirective:K!==t&&K,newIsolateScopeDirective:B,templateDirective:I,nonTlbTranscludeDirective:u}),E=a.length;else if(t.compile)try{Q=t.compile(G,d,O);var Z=t.$$originalDirective||t;y(Q)?m(null,bb(Z,Q),Na,M):Q&&m(bb(Z,Q.pre),\nbb(Z,Q.post),Na,M)}catch(da){c(da,ya(G))}t.terminal&&(n.terminal=!0,p=Math.max(p,t.priority))}n.scope=K&&!0===K.scope;n.transcludeOnThisElement=J;n.templateOnThisElement=N;n.transclude=O;l.hasElementTranscludeDirective=U;return n}function V(a,b,c,d){var e;if(E(b)){var f=b.match(l);b=b.substring(f[0].length);var g=f[1]||f[3],f=\"?\"===f[2];\"^^\"===g?c=c.parent():e=(e=d&&d[b])&&e.instance;if(!e){var h=\"$\"+b+\"Controller\";e=g?c.inheritedData(h):c.data(h)}if(!e&&!f)throw ea(\"ctreq\",b,a);}else if(C(b))for(e=\n[],g=0,f=b.length;g<f;g++)e[g]=V(a,b[g],c,d);else F(b)&&(e={},q(b,function(b,f){e[f]=V(a,b,c,d)}));return e||null}function ca(a,b,c,d,e,f,g){var h=W(),k;for(k in d){var l=d[k],m={$scope:l===g||l.$$isolateScope?e:f,$element:a,$attrs:b,$transclude:c},n=l.controller;\"@\"===n&&(n=b[l.name]);m=I(n,m,!0,l.controllerAs);h[l.name]=m;a.data(\"$\"+l.name+\"Controller\",m.instance)}return h}function aa(a,b,c){for(var d=0,e=a.length;d<e;d++)a[d]=Ub(a[d],{$$isolateScope:b,$$newScope:c})}function Y(b,c,f,g,h,k,l){if(c===\nh)return null;var m=null;if(e.hasOwnProperty(c)){h=a.get(c+\"Directive\");for(var n=0,p=h.length;n<p;n++)if(c=h[n],(x(g)||g>c.priority)&&-1!==c.restrict.indexOf(f)){k&&(c=Ub(c,{$$start:k,$$end:l}));if(!c.$$bindings){var K=m=c,r=c.name,A={isolateScope:null,bindToController:null};F(K.scope)&&(!0===K.bindToController?(A.bindToController=d(K.scope,r,!0),A.isolateScope={}):A.isolateScope=d(K.scope,r,!1));F(K.bindToController)&&(A.bindToController=d(K.bindToController,r,!0));if(A.bindToController&&!K.controller)throw ea(\"noctrl\",\nr);m=m.$$bindings=A;F(m.isolateScope)&&(c.$$isolateBindings=m.isolateScope)}b.push(c);m=c}}return m}function Z(b){if(e.hasOwnProperty(b))for(var c=a.get(b+\"Directive\"),d=0,f=c.length;d<f;d++)if(b=c[d],b.multiElement)return!0;return!1}function fa(a,b){var c=b.$attr,d=a.$attr;q(a,function(d,e){\"$\"!==e.charAt(0)&&(b[e]&&b[e]!==d&&(d=d.length?d+((\"style\"===e?\";\":\" \")+b[e]):b[e]),a.$set(e,d,!0,c[e]))});q(b,function(b,e){a.hasOwnProperty(e)||\"$\"===e.charAt(0)||(a[e]=b,\"class\"!==e&&\"style\"!==e&&(d[e]=c[e]))})}\nfunction ga(a,b,d,e,g,h,k,l){var m=[],n,p,K=b[0],r=a.shift(),u=Ub(r,{templateUrl:null,transclude:null,replace:null,$$originalDirective:r}),t=y(r.templateUrl)?r.templateUrl(b,d):r.templateUrl,B=r.templateNamespace;b.empty();f(t).then(function(c){var f,A;c=Ea(c);if(r.replace){c=$b.test(c)?jd(ha(B,S(c))):[];f=c[0];if(1!==c.length||1!==f.nodeType)throw ea(\"tplrt\",r.name,t);c={$attr:{}};la(e,b,f);var I=fc(f,[],c);F(r.scope)&&aa(I,!0);a=I.concat(a);fa(d,c)}else f=K,b.html(c);a.unshift(u);n=X(a,f,d,g,b,\nr,h,k,l);q(e,function(a,c){a===f&&(e[c]=b[0])});for(p=Na(b[0].childNodes,g);m.length;){c=m.shift();A=m.shift();var G=m.shift(),J=m.shift(),I=b[0];if(!c.$$destroyed){if(A!==K){var N=A.className;l.hasElementTranscludeDirective&&r.replace||(I=cc(f));la(G,D(A),I);Ma(D(I),N)}A=n.transcludeOnThisElement?ja(c,n.transclude,J):J;n(p,c,I,e,A)}}m=null}).catch(function(a){a instanceof Error&&c(a)}).catch(w);return function(a,b,c,d,e){a=e;b.$$destroyed||(m?m.push(b,c,d,a):(n.transcludeOnThisElement&&(a=ja(b,n.transclude,\ne)),n(p,b,c,d,a)))}}function ka(a,b){var c=b.priority-a.priority;return 0!==c?c:a.name!==b.name?a.name<b.name?-1:1:a.index-b.index}function $(a,b,c,d){function e(a){return a?\" (module: \"+a+\")\":\"\"}if(b)throw ea(\"multidir\",b.name,e(b.$$moduleName),c.name,e(c.$$moduleName),a,ya(d));}function ma(a,c){var d=b(c,!0);d&&a.push({priority:0,compile:function(a){a=a.parent();var b=!!a.length;b&&ba.$$addBindingClass(a);return function(a,c){var e=c.parent();b||ba.$$addBindingClass(e);ba.$$addBindingInfo(e,d.expressions);\na.$watch(d,function(a){c[0].nodeValue=a})}}})}function ha(a,b){a=P(a||\"html\");switch(a){case \"svg\":case \"math\":var c=z.document.createElement(\"div\");c.innerHTML=\"<\"+a+\">\"+b+\"</\"+a+\">\";return c.childNodes[0].childNodes;default:return b}}function pa(a,b){if(\"srcdoc\"===b)return L.HTML;var c=xa(a);if(\"src\"===b||\"ngSrc\"===b){if(-1===[\"img\",\"video\",\"audio\",\"source\",\"track\"].indexOf(c))return L.RESOURCE_URL}else if(\"xlinkHref\"===b||\"form\"===c&&\"action\"===b||\"link\"===c&&\"href\"===b)return L.RESOURCE_URL}function ra(a,\nc,d,e,f){var g=pa(a,e),h=k[e]||f,l=b(d,!f,g,h);if(l){if(\"multiple\"===e&&\"select\"===xa(a))throw ea(\"selmulti\",ya(a));if(m.test(e))throw ea(\"nodomevents\");c.push({priority:100,compile:function(){return{pre:function(a,c,f){c=f.$$observers||(f.$$observers=W());var k=f[e];k!==d&&(l=k&&b(k,!0,g,h),d=k);l&&(f[e]=l(a),(c[e]||(c[e]=[])).$$inter=!0,(f.$$observers&&f.$$observers[e].$$scope||a).$watch(l,function(a,b){\"class\"===e&&a!==b?f.$updateClass(a,b):f.$set(e,a)}))}}}})}}function la(a,b,c){var d=b[0],e=\nb.length,f=d.parentNode,g,h;if(a)for(g=0,h=a.length;g<h;g++)if(a[g]===d){a[g++]=c;h=g+e-1;for(var k=a.length;g<k;g++,h++)h<k?a[g]=a[h]:delete a[g];a.length-=e-1;a.context===d&&(a.context=c);break}f&&f.replaceChild(c,d);a=z.document.createDocumentFragment();for(g=0;g<e;g++)a.appendChild(b[g]);D.hasData(d)&&(D.data(c,D.data(d)),D(d).off(\"$destroy\"));D.cleanData(a.querySelectorAll(\"*\"));for(g=1;g<e;g++)delete b[g];b[0]=c;b.length=1}function sa(a,b){return R(function(){return a.apply(null,arguments)},\na,b)}function ta(a,b,d,e,f,g){try{a(b,d,e,f,g)}catch(h){c(h,ya(d))}}function oa(a,c,d,e,f){function g(b,c,e){!y(d.$onChanges)||c===e||c!==c&&e!==e||(da||(a.$$postDigest(T),da=[]),m||(m={},da.push(h)),m[b]&&(e=m[b].previousValue),m[b]=new Ib(e,c))}function h(){d.$onChanges(m);m=void 0}var k=[],l={},m;q(e,function(e,h){var m=e.attrName,p=e.optional,r,A,u,B;switch(e.mode){case \"@\":p||va.call(c,m)||(d[h]=c[m]=void 0);p=c.$observe(m,function(a){if(E(a)||Ia(a))g(h,a,d[h]),d[h]=a});c.$$observers[m].$$scope=\na;r=c[m];E(r)?d[h]=b(r)(a):Ia(r)&&(d[h]=r);l[h]=new Ib(hc,d[h]);k.push(p);break;case \"=\":if(!va.call(c,m)){if(p)break;c[m]=void 0}if(p&&!c[m])break;A=n(c[m]);B=A.literal?qa:function(a,b){return a===b||a!==a&&b!==b};u=A.assign||function(){r=d[h]=A(a);throw ea(\"nonassign\",c[m],m,f.name);};r=d[h]=A(a);p=function(b){B(b,d[h])||(B(b,r)?u(a,b=d[h]):d[h]=b);return r=b};p.$stateful=!0;p=e.collection?a.$watchCollection(c[m],p):a.$watch(n(c[m],p),null,A.literal);k.push(p);break;case \"<\":if(!va.call(c,m)){if(p)break;\nc[m]=void 0}if(p&&!c[m])break;A=n(c[m]);var I=A.literal,G=d[h]=A(a);l[h]=new Ib(hc,d[h]);p=a.$watch(A,function(a,b){if(b===a){if(b===G||I&&qa(b,G))return;b=G}g(h,a,b);d[h]=a},I);k.push(p);break;case \"&\":A=c.hasOwnProperty(m)?n(c[m]):w;if(A===w&&p)break;d[h]=function(b){return A(a,b)}}});return{initialChanges:l,removeWatches:k.length&&function(){for(var a=0,b=k.length;a<b;++a)k[a]()}}}var Da=/^\\w/,ua=z.document.createElement(\"div\"),Fa=O,Ga=u,za=J,da;s.prototype={$normalize:Ca,$addClass:function(a){a&&\n0<a.length&&N.addClass(this.$$element,a)},$removeClass:function(a){a&&0<a.length&&N.removeClass(this.$$element,a)},$updateClass:function(a,b){var c=kd(a,b);c&&c.length&&N.addClass(this.$$element,c);(c=kd(b,a))&&c.length&&N.removeClass(this.$$element,c)},$set:function(a,b,d,e){var f=dd(this.$$element[0],a),g=ld[a],h=a;f?(this.$$element.prop(a,b),e=f):g&&(this[g]=b,h=g);this[a]=b;e?this.$attr[a]=e:(e=this.$attr[a])||(this.$attr[a]=e=Nc(a,\"-\"));f=xa(this.$$element);if(\"a\"===f&&(\"href\"===a||\"xlinkHref\"===\na)||\"img\"===f&&\"src\"===a)this[a]=b=G(b,\"src\"===a);else if(\"img\"===f&&\"srcset\"===a&&v(b)){for(var f=\"\",g=S(b),k=/(\\s+\\d+x\\s*,|\\s+\\d+w\\s*,|\\s+,|,\\s+)/,k=/\\s/.test(g)?k:/(,)/,g=g.split(k),k=Math.floor(g.length/2),l=0;l<k;l++)var m=2*l,f=f+G(S(g[m]),!0),f=f+(\" \"+S(g[m+1]));g=S(g[2*l]).split(/\\s/);f+=G(S(g[0]),!0);2===g.length&&(f+=\" \"+S(g[1]));this[a]=b=f}!1!==d&&(null===b||x(b)?this.$$element.removeAttr(e):Da.test(e)?this.$$element.attr(e,b):Q(this.$$element[0],e,b));(a=this.$$observers)&&q(a[h],function(a){try{a(b)}catch(d){c(d)}})},\n$observe:function(a,b){var c=this,d=c.$$observers||(c.$$observers=W()),e=d[a]||(d[a]=[]);e.push(b);B.$evalAsync(function(){e.$$inter||!c.hasOwnProperty(a)||x(c[a])||b(c[a])});return function(){$a(e,b)}}};var Aa=b.startSymbol(),Ba=b.endSymbol(),Ea=\"{{\"===Aa&&\"}}\"===Ba?Ya:function(a){return a.replace(/\\{\\{/g,Aa).replace(/}}/g,Ba)},Ha=/^ngAttr[A-Z]/,Ka=/^(.+)Start$/;ba.$$addBindingInfo=p?function(a,b){var c=a.data(\"$binding\")||[];C(b)?c=c.concat(b):c.push(b);a.data(\"$binding\",c)}:w;ba.$$addBindingClass=\np?function(a){Ma(a,\"ng-binding\")}:w;ba.$$addScopeInfo=p?function(a,b,c,d){a.data(c?d?\"$isolateScopeNoTemplate\":\"$isolateScope\":\"$scope\",b)}:w;ba.$$addScopeClass=p?function(a,b){Ma(a,b?\"ng-isolate-scope\":\"ng-scope\")}:w;ba.$$createComment=function(a,b){var c=\"\";p&&(c=\" \"+(a||\"\")+\": \",b&&(c+=b+\" \"));return z.document.createComment(c)};return ba}]}function Ib(a,b){this.previousValue=a;this.currentValue=b}function Ca(a){return a.replace(gd,\"\").replace(mg,gb)}function kd(a,b){var d=\"\",c=a.split(/\\s+/),\nf=b.split(/\\s+/),e=0;a:for(;e<c.length;e++){for(var g=c[e],h=0;h<f.length;h++)if(g===f[h])continue a;d+=(0<d.length?\" \":\"\")+g}return d}function jd(a){a=D(a);var b=a.length;if(1>=b)return a;for(;b--;){var d=a[b];(8===d.nodeType||d.nodeType===Ja&&\"\"===d.nodeValue.trim())&&ng.call(a,b,1)}return a}function lg(a,b){if(b&&E(b))return b;if(E(a)){var d=md.exec(a);if(d)return d[3]}}function rf(){var a={},b=!1;this.has=function(b){return a.hasOwnProperty(b)};this.register=function(b,c){Pa(b,\"controller\");F(b)?\nR(a,b):a[b]=c};this.allowGlobals=function(){b=!0};this.$get=[\"$injector\",\"$window\",function(d,c){function f(a,b,c,d){if(!a||!F(a.$scope))throw M(\"$controller\")(\"noscp\",d,b);a.$scope[b]=c}return function(e,g,h,k){var l,m,n;h=!0===h;k&&E(k)&&(n=k);if(E(e)){k=e.match(md);if(!k)throw nd(\"ctrlfmt\",e);m=k[1];n=n||k[3];e=a.hasOwnProperty(m)?a[m]:Pc(g.$scope,m,!0)||(b?Pc(c,m,!0):void 0);if(!e)throw nd(\"ctrlreg\",m);tb(e,m,!0)}if(h)return h=(C(e)?e[e.length-1]:e).prototype,l=Object.create(h||null),n&&f(g,n,\nl,m||e.name),R(function(){var a=d.invoke(e,l,g,m);a!==l&&(F(a)||y(a))&&(l=a,n&&f(g,n,l,m||e.name));return l},{instance:l,identifier:n});l=d.instantiate(e,g,m);n&&f(g,n,l,m||e.name);return l}}]}function sf(){this.$get=[\"$window\",function(a){return D(a.document)}]}function tf(){this.$get=[\"$document\",\"$rootScope\",function(a,b){function d(){f=c.hidden}var c=a[0],f=c&&c.hidden;a.on(\"visibilitychange\",d);b.$on(\"$destroy\",function(){a.off(\"visibilitychange\",d)});return function(){return f}}]}function uf(){this.$get=\n[\"$log\",function(a){return function(b,d){a.error.apply(a,arguments)}}]}function ic(a){return F(a)?fa(a)?a.toISOString():cb(a):a}function zf(){this.$get=function(){return function(a){if(!a)return\"\";var b=[];Ec(a,function(a,c){null===a||x(a)||(C(a)?q(a,function(a){b.push(ka(c)+\"=\"+ka(ic(a)))}):b.push(ka(c)+\"=\"+ka(ic(a))))});return b.join(\"&\")}}}function Af(){this.$get=function(){return function(a){function b(a,f,e){null===a||x(a)||(C(a)?q(a,function(a,c){b(a,f+\"[\"+(F(a)?c:\"\")+\"]\")}):F(a)&&!fa(a)?Ec(a,\nfunction(a,c){b(a,f+(e?\"\":\"[\")+c+(e?\"\":\"]\"))}):d.push(ka(f)+\"=\"+ka(ic(a))))}if(!a)return\"\";var d=[];b(a,\"\",!0);return d.join(\"&\")}}}function jc(a,b){if(E(a)){var d=a.replace(og,\"\").trim();if(d){var c=b(\"Content-Type\");(c=c&&0===c.indexOf(od))||(c=(c=d.match(pg))&&qg[c[0]].test(d));c&&(a=Ic(d))}}return a}function pd(a){var b=W(),d;E(a)?q(a.split(\"\\n\"),function(a){d=a.indexOf(\":\");var f=P(S(a.substr(0,d)));a=S(a.substr(d+1));f&&(b[f]=b[f]?b[f]+\", \"+a:a)}):F(a)&&q(a,function(a,d){var e=P(d),g=S(a);e&&\n(b[e]=b[e]?b[e]+\", \"+g:g)});return b}function qd(a){var b;return function(d){b||(b=pd(a));return d?(d=b[P(d)],void 0===d&&(d=null),d):b}}function rd(a,b,d,c){if(y(c))return c(a,b,d);q(c,function(c){a=c(a,b,d)});return a}function yf(){var a=this.defaults={transformResponse:[jc],transformRequest:[function(a){return F(a)&&\"[object File]\"!==na.call(a)&&\"[object Blob]\"!==na.call(a)&&\"[object FormData]\"!==na.call(a)?cb(a):a}],headers:{common:{Accept:\"application/json, text/plain, */*\"},post:ra(kc),put:ra(kc),\npatch:ra(kc)},xsrfCookieName:\"XSRF-TOKEN\",xsrfHeaderName:\"X-XSRF-TOKEN\",paramSerializer:\"$httpParamSerializer\",jsonpCallbackParam:\"callback\"},b=!1;this.useApplyAsync=function(a){return v(a)?(b=!!a,this):b};var d=this.interceptors=[];this.$get=[\"$browser\",\"$httpBackend\",\"$$cookieReader\",\"$cacheFactory\",\"$rootScope\",\"$q\",\"$injector\",\"$sce\",function(c,f,e,g,h,k,l,m){function n(b){function d(a,b){for(var c=0,e=b.length;c<e;){var f=b[c++],g=b[c++];a=a.then(f,g)}b.length=0;return a}function e(a,b){var c,\nd={};q(a,function(a,e){y(a)?(c=a(b),null!=c&&(d[e]=c)):d[e]=a});return d}function f(a){var b=R({},a);b.data=rd(a.data,a.headers,a.status,g.transformResponse);a=a.status;return 200<=a&&300>a?b:k.reject(b)}if(!F(b))throw M(\"$http\")(\"badreq\",b);if(!E(m.valueOf(b.url)))throw M(\"$http\")(\"badreq\",b.url);var g=R({method:\"get\",transformRequest:a.transformRequest,transformResponse:a.transformResponse,paramSerializer:a.paramSerializer,jsonpCallbackParam:a.jsonpCallbackParam},b);g.headers=function(b){var c=\na.headers,d=R({},b.headers),f,g,h,c=R({},c.common,c[P(b.method)]);a:for(f in c){g=P(f);for(h in d)if(P(h)===g)continue a;d[f]=c[f]}return e(d,ra(b))}(b);g.method=vb(g.method);g.paramSerializer=E(g.paramSerializer)?l.get(g.paramSerializer):g.paramSerializer;c.$$incOutstandingRequestCount();var h=[],n=[];b=k.resolve(g);q(u,function(a){(a.request||a.requestError)&&h.unshift(a.request,a.requestError);(a.response||a.responseError)&&n.push(a.response,a.responseError)});b=d(b,h);b=b.then(function(b){var c=\nb.headers,d=rd(b.data,qd(c),void 0,b.transformRequest);x(d)&&q(c,function(a,b){\"content-type\"===P(b)&&delete c[b]});x(b.withCredentials)&&!x(a.withCredentials)&&(b.withCredentials=a.withCredentials);return p(b,d).then(f,f)});b=d(b,n);return b=b.finally(function(){c.$$completeOutstandingRequest(w)})}function p(c,d){function g(a){if(a){var c={};q(a,function(a,d){c[d]=function(c){function d(){a(c)}b?h.$applyAsync(d):h.$$phase?d():h.$apply(d)}});return c}}function l(a,c,d,e){function f(){p(c,a,d,e)}N&&\n(200<=a&&300>a?N.put(Q,[a,c,pd(d),e]):N.remove(Q));b?h.$applyAsync(f):(f(),h.$$phase||h.$apply())}function p(a,b,d,e){b=-1<=b?b:0;(200<=b&&300>b?B.resolve:B.reject)({data:a,status:b,headers:qd(d),config:c,statusText:e})}function K(a){p(a.data,a.status,ra(a.headers()),a.statusText)}function u(){var a=n.pendingRequests.indexOf(c);-1!==a&&n.pendingRequests.splice(a,1)}var B=k.defer(),L=B.promise,N,G,T=c.headers,s=\"jsonp\"===P(c.method),Q=c.url;s?Q=m.getTrustedResourceUrl(Q):E(Q)||(Q=m.valueOf(Q));Q=r(Q,\nc.paramSerializer(c.params));s&&(Q=J(Q,c.jsonpCallbackParam));n.pendingRequests.push(c);L.then(u,u);!c.cache&&!a.cache||!1===c.cache||\"GET\"!==c.method&&\"JSONP\"!==c.method||(N=F(c.cache)?c.cache:F(a.cache)?a.cache:O);N&&(G=N.get(Q),v(G)?G&&y(G.then)?G.then(K,K):C(G)?p(G[1],G[0],ra(G[2]),G[3]):p(G,200,{},\"OK\"):N.put(Q,L));x(G)&&((G=sd(c.url)?e()[c.xsrfCookieName||a.xsrfCookieName]:void 0)&&(T[c.xsrfHeaderName||a.xsrfHeaderName]=G),f(c.method,Q,d,l,T,c.timeout,c.withCredentials,c.responseType,g(c.eventHandlers),\ng(c.uploadEventHandlers)));return L}function r(a,b){0<b.length&&(a+=(-1===a.indexOf(\"?\")?\"?\":\"&\")+b);return a}function J(a,b){if(/[&?][^=]+=JSON_CALLBACK/.test(a))throw td(\"badjsonp\",a);if((new RegExp(\"[&?]\"+b+\"=\")).test(a))throw td(\"badjsonp\",b,a);return a+=(-1===a.indexOf(\"?\")?\"?\":\"&\")+b+\"=JSON_CALLBACK\"}var O=g(\"$http\");a.paramSerializer=E(a.paramSerializer)?l.get(a.paramSerializer):a.paramSerializer;var u=[];q(d,function(a){u.unshift(E(a)?l.get(a):l.invoke(a))});n.pendingRequests=[];(function(a){q(arguments,\nfunction(a){n[a]=function(b,c){return n(R({},c||{},{method:a,url:b}))}})})(\"get\",\"delete\",\"head\",\"jsonp\");(function(a){q(arguments,function(a){n[a]=function(b,c,d){return n(R({},d||{},{method:a,url:b,data:c}))}})})(\"post\",\"put\",\"patch\");n.defaults=a;return n}]}function Cf(){this.$get=function(){return function(){return new z.XMLHttpRequest}}}function Bf(){this.$get=[\"$browser\",\"$jsonpCallbacks\",\"$document\",\"$xhrFactory\",function(a,b,d,c){return rg(a,c,a.defer,b,d[0])}]}function rg(a,b,d,c,f){function e(a,\nb,d){a=a.replace(\"JSON_CALLBACK\",b);var e=f.createElement(\"script\"),m=null;e.type=\"text/javascript\";e.src=a;e.async=!0;m=function(a){e.removeEventListener(\"load\",m);e.removeEventListener(\"error\",m);f.body.removeChild(e);e=null;var g=-1,r=\"unknown\";a&&(\"load\"!==a.type||c.wasCalled(b)||(a={type:\"error\"}),r=a.type,g=\"error\"===a.type?404:200);d&&d(g,r)};e.addEventListener(\"load\",m);e.addEventListener(\"error\",m);f.body.appendChild(e);return m}return function(f,h,k,l,m,n,p,r,J,O){function u(){U&&U();t&&\nt.abort()}h=h||a.url();if(\"jsonp\"===P(f))var H=c.createCallback(h),U=e(h,H,function(a,b){var e=200===a&&c.getResponse(H);v(A)&&d.cancel(A);U=t=null;l(a,e,\"\",b);c.removeCallback(H)});else{var t=b(f,h);t.open(f,h,!0);q(m,function(a,b){v(a)&&t.setRequestHeader(b,a)});t.onload=function(){var a=t.statusText||\"\",b=\"response\"in t?t.response:t.responseText,c=1223===t.status?204:t.status;0===c&&(c=b?200:\"file\"===Da(h).protocol?404:0);var e=t.getAllResponseHeaders();v(A)&&d.cancel(A);U=t=null;l(c,b,e,a)};f=\nfunction(){v(A)&&d.cancel(A);U=t=null;l(-1,null,null,\"\")};t.onerror=f;t.onabort=f;t.ontimeout=f;q(J,function(a,b){t.addEventListener(b,a)});q(O,function(a,b){t.upload.addEventListener(b,a)});p&&(t.withCredentials=!0);if(r)try{t.responseType=r}catch(s){if(\"json\"!==r)throw s;}t.send(x(k)?null:k)}if(0<n)var A=d(u,n);else n&&y(n.then)&&n.then(u)}}function wf(){var a=\"{{\",b=\"}}\";this.startSymbol=function(b){return b?(a=b,this):a};this.endSymbol=function(a){return a?(b=a,this):b};this.$get=[\"$parse\",\"$exceptionHandler\",\n\"$sce\",function(d,c,f){function e(a){return\"\\\\\\\\\\\\\"+a}function g(c){return c.replace(n,a).replace(p,b)}function h(a,b,c,d){var e=a.$watch(function(a){e();return d(a)},b,c);return e}function k(e,k,n,p){function H(a){try{var b=a;a=n?f.getTrusted(n,b):f.valueOf(b);return p&&!v(a)?a:Yb(a)}catch(d){c(Ea.interr(e,d))}}if(!e.length||-1===e.indexOf(a)){var q;k||(k=g(e),q=ma(k),q.exp=e,q.expressions=[],q.$$watchDelegate=h);return q}p=!!p;var t,s,A=0,K=[],I=[];q=e.length;for(var B=[],L=[];A<q;)if(-1!==(t=e.indexOf(a,\nA))&&-1!==(s=e.indexOf(b,t+l)))A!==t&&B.push(g(e.substring(A,t))),A=e.substring(t+l,s),K.push(A),I.push(d(A,H)),A=s+m,L.push(B.length),B.push(\"\");else{A!==q&&B.push(g(e.substring(A)));break}n&&1<B.length&&Ea.throwNoconcat(e);if(!k||K.length){var N=function(a){for(var b=0,c=K.length;b<c;b++){if(p&&x(a[b]))return;B[L[b]]=a[b]}return B.join(\"\")};return R(function(a){var b=0,d=K.length,f=Array(d);try{for(;b<d;b++)f[b]=I[b](a);return N(f)}catch(g){c(Ea.interr(e,g))}},{exp:e,expressions:K,$$watchDelegate:function(a,\nb){var c;return a.$watchGroup(I,function(d,e){var f=N(d);y(b)&&b.call(this,f,d!==e?c:f,a);c=f})}})}}var l=a.length,m=b.length,n=new RegExp(a.replace(/./g,e),\"g\"),p=new RegExp(b.replace(/./g,e),\"g\");k.startSymbol=function(){return a};k.endSymbol=function(){return b};return k}]}function xf(){this.$get=[\"$rootScope\",\"$window\",\"$q\",\"$$q\",\"$browser\",function(a,b,d,c,f){function e(e,k,l,m){function n(){p?e.apply(null,r):e(u)}var p=4<arguments.length,r=p?wa.call(arguments,4):[],J=b.setInterval,q=b.clearInterval,\nu=0,H=v(m)&&!m,U=(H?c:d).defer(),t=U.promise;l=v(l)?l:0;t.$$intervalId=J(function(){H?f.defer(n):a.$evalAsync(n);U.notify(u++);0<l&&u>=l&&(U.resolve(u),q(t.$$intervalId),delete g[t.$$intervalId]);H||a.$apply()},k);g[t.$$intervalId]=U;return t}var g={};e.cancel=function(a){return a&&a.$$intervalId in g?(g[a.$$intervalId].promise.catch(w),g[a.$$intervalId].reject(\"canceled\"),b.clearInterval(a.$$intervalId),delete g[a.$$intervalId],!0):!1};return e}]}function lc(a){a=a.split(\"/\");for(var b=a.length;b--;)a[b]=\ndb(a[b]);return a.join(\"/\")}function ud(a,b){var d=Da(a);b.$$protocol=d.protocol;b.$$host=d.hostname;b.$$port=Z(d.port)||sg[d.protocol]||null}function vd(a,b){if(tg.test(a))throw lb(\"badpath\",a);var d=\"/\"!==a.charAt(0);d&&(a=\"/\"+a);var c=Da(a);b.$$path=decodeURIComponent(d&&\"/\"===c.pathname.charAt(0)?c.pathname.substring(1):c.pathname);b.$$search=Lc(c.search);b.$$hash=decodeURIComponent(c.hash);b.$$path&&\"/\"!==b.$$path.charAt(0)&&(b.$$path=\"/\"+b.$$path)}function mc(a,b){return a.slice(0,b.length)===\nb}function sa(a,b){if(mc(b,a))return b.substr(a.length)}function Ba(a){var b=a.indexOf(\"#\");return-1===b?a:a.substr(0,b)}function mb(a){return a.replace(/(#.+)|#$/,\"$1\")}function nc(a,b,d){this.$$html5=!0;d=d||\"\";ud(a,this);this.$$parse=function(a){var d=sa(b,a);if(!E(d))throw lb(\"ipthprfx\",a,b);vd(d,this);this.$$path||(this.$$path=\"/\");this.$$compose()};this.$$compose=function(){var a=Xb(this.$$search),d=this.$$hash?\"#\"+db(this.$$hash):\"\";this.$$url=lc(this.$$path)+(a?\"?\"+a:\"\")+d;this.$$absUrl=b+\nthis.$$url.substr(1)};this.$$parseLinkUrl=function(c,f){if(f&&\"#\"===f[0])return this.hash(f.slice(1)),!0;var e,g;v(e=sa(a,c))?(g=e,g=d&&v(e=sa(d,e))?b+(sa(\"/\",e)||e):a+g):v(e=sa(b,c))?g=b+e:b===c+\"/\"&&(g=b);g&&this.$$parse(g);return!!g}}function oc(a,b,d){ud(a,this);this.$$parse=function(c){var f=sa(a,c)||sa(b,c),e;x(f)||\"#\"!==f.charAt(0)?this.$$html5?e=f:(e=\"\",x(f)&&(a=c,this.replace())):(e=sa(d,f),x(e)&&(e=f));vd(e,this);c=this.$$path;var f=a,g=/^\\/[A-Z]:(\\/.*)/;mc(e,f)&&(e=e.replace(f,\"\"));g.exec(e)||\n(c=(e=g.exec(c))?e[1]:c);this.$$path=c;this.$$compose()};this.$$compose=function(){var b=Xb(this.$$search),f=this.$$hash?\"#\"+db(this.$$hash):\"\";this.$$url=lc(this.$$path)+(b?\"?\"+b:\"\")+f;this.$$absUrl=a+(this.$$url?d+this.$$url:\"\")};this.$$parseLinkUrl=function(b,d){return Ba(a)===Ba(b)?(this.$$parse(b),!0):!1}}function wd(a,b,d){this.$$html5=!0;oc.apply(this,arguments);this.$$parseLinkUrl=function(c,f){if(f&&\"#\"===f[0])return this.hash(f.slice(1)),!0;var e,g;a===Ba(c)?e=c:(g=sa(b,c))?e=a+d+g:b===\nc+\"/\"&&(e=b);e&&this.$$parse(e);return!!e};this.$$compose=function(){var b=Xb(this.$$search),f=this.$$hash?\"#\"+db(this.$$hash):\"\";this.$$url=lc(this.$$path)+(b?\"?\"+b:\"\")+f;this.$$absUrl=a+d+this.$$url}}function Jb(a){return function(){return this[a]}}function xd(a,b){return function(d){if(x(d))return this[a];this[a]=b(d);this.$$compose();return this}}function Ef(){var a=\"!\",b={enabled:!1,requireBase:!0,rewriteLinks:!0};this.hashPrefix=function(b){return v(b)?(a=b,this):a};this.html5Mode=function(a){if(Ia(a))return b.enabled=\na,this;if(F(a)){Ia(a.enabled)&&(b.enabled=a.enabled);Ia(a.requireBase)&&(b.requireBase=a.requireBase);if(Ia(a.rewriteLinks)||E(a.rewriteLinks))b.rewriteLinks=a.rewriteLinks;return this}return b};this.$get=[\"$rootScope\",\"$browser\",\"$sniffer\",\"$rootElement\",\"$window\",function(d,c,f,e,g){function h(a,b,d){var e=l.url(),f=l.$$state;try{c.url(a,b,d),l.$$state=c.state()}catch(g){throw l.url(e),l.$$state=f,g;}}function k(a,b){d.$broadcast(\"$locationChangeSuccess\",l.absUrl(),a,l.$$state,b)}var l,m;m=c.baseHref();\nvar n=c.url(),p;if(b.enabled){if(!m&&b.requireBase)throw lb(\"nobase\");p=n.substring(0,n.indexOf(\"/\",n.indexOf(\"//\")+2))+(m||\"/\");m=f.history?nc:wd}else p=Ba(n),m=oc;var r=p.substr(0,Ba(p).lastIndexOf(\"/\")+1);l=new m(p,r,\"#\"+a);l.$$parseLinkUrl(n,n);l.$$state=c.state();var J=/^\\s*(javascript|mailto):/i;e.on(\"click\",function(a){var f=b.rewriteLinks;if(f&&!a.ctrlKey&&!a.metaKey&&!a.shiftKey&&2!==a.which&&2!==a.button){for(var h=D(a.target);\"a\"!==xa(h[0]);)if(h[0]===e[0]||!(h=h.parent())[0])return;if(!E(f)||\n!x(h.attr(f))){var f=h.prop(\"href\"),k=h.attr(\"href\")||h.attr(\"xlink:href\");F(f)&&\"[object SVGAnimatedString]\"===f.toString()&&(f=Da(f.animVal).href);J.test(f)||!f||h.attr(\"target\")||a.isDefaultPrevented()||!l.$$parseLinkUrl(f,k)||(a.preventDefault(),l.absUrl()!==c.url()&&(d.$apply(),g.angular[\"ff-684208-preventDefault\"]=!0))}}});mb(l.absUrl())!==mb(n)&&c.url(l.absUrl(),!0);var q=!0;c.onUrlChange(function(a,b){mc(a,r)?(d.$evalAsync(function(){var c=l.absUrl(),e=l.$$state,f;a=mb(a);l.$$parse(a);l.$$state=\nb;f=d.$broadcast(\"$locationChangeStart\",a,c,b,e).defaultPrevented;l.absUrl()===a&&(f?(l.$$parse(c),l.$$state=e,h(c,!1,e)):(q=!1,k(c,e)))}),d.$$phase||d.$digest()):g.location.href=a});d.$watch(function(){var a=mb(c.url()),b=mb(l.absUrl()),e=c.state(),g=l.$$replace,m=a!==b||l.$$html5&&f.history&&e!==l.$$state;if(q||m)q=!1,d.$evalAsync(function(){var b=l.absUrl(),c=d.$broadcast(\"$locationChangeStart\",b,a,l.$$state,e).defaultPrevented;l.absUrl()===b&&(c?(l.$$parse(a),l.$$state=e):(m&&h(b,g,e===l.$$state?\nnull:l.$$state),k(a,e)))});l.$$replace=!1});return l}]}function Ff(){var a=!0,b=this;this.debugEnabled=function(b){return v(b)?(a=b,this):a};this.$get=[\"$window\",function(d){function c(a){a instanceof Error&&(a.stack?a=a.message&&-1===a.stack.indexOf(a.message)?\"Error: \"+a.message+\"\\n\"+a.stack:a.stack:a.sourceURL&&(a=a.message+\"\\n\"+a.sourceURL+\":\"+a.line));return a}function f(a){var b=d.console||{},f=b[a]||b.log||w;a=!1;try{a=!!f.apply}catch(k){}return a?function(){var a=[];q(arguments,function(b){a.push(c(b))});\nreturn f.apply(b,a)}:function(a,b){f(a,null==b?\"\":b)}}return{log:f(\"log\"),info:f(\"info\"),warn:f(\"warn\"),error:f(\"error\"),debug:function(){var c=f(\"debug\");return function(){a&&c.apply(b,arguments)}}()}}]}function ug(a){return a+\"\"}function vg(a,b){return\"undefined\"!==typeof a?a:b}function yd(a,b){return\"undefined\"===typeof a?b:\"undefined\"===typeof b?a:a+b}function V(a,b){var d,c,f;switch(a.type){case s.Program:d=!0;q(a.body,function(a){V(a.expression,b);d=d&&a.expression.constant});a.constant=d;break;\ncase s.Literal:a.constant=!0;a.toWatch=[];break;case s.UnaryExpression:V(a.argument,b);a.constant=a.argument.constant;a.toWatch=a.argument.toWatch;break;case s.BinaryExpression:V(a.left,b);V(a.right,b);a.constant=a.left.constant&&a.right.constant;a.toWatch=a.left.toWatch.concat(a.right.toWatch);break;case s.LogicalExpression:V(a.left,b);V(a.right,b);a.constant=a.left.constant&&a.right.constant;a.toWatch=a.constant?[]:[a];break;case s.ConditionalExpression:V(a.test,b);V(a.alternate,b);V(a.consequent,\nb);a.constant=a.test.constant&&a.alternate.constant&&a.consequent.constant;a.toWatch=a.constant?[]:[a];break;case s.Identifier:a.constant=!1;a.toWatch=[a];break;case s.MemberExpression:V(a.object,b);a.computed&&V(a.property,b);a.constant=a.object.constant&&(!a.computed||a.property.constant);a.toWatch=[a];break;case s.CallExpression:d=f=a.filter?!b(a.callee.name).$stateful:!1;c=[];q(a.arguments,function(a){V(a,b);d=d&&a.constant;a.constant||c.push.apply(c,a.toWatch)});a.constant=d;a.toWatch=f?c:[a];\nbreak;case s.AssignmentExpression:V(a.left,b);V(a.right,b);a.constant=a.left.constant&&a.right.constant;a.toWatch=[a];break;case s.ArrayExpression:d=!0;c=[];q(a.elements,function(a){V(a,b);d=d&&a.constant;a.constant||c.push.apply(c,a.toWatch)});a.constant=d;a.toWatch=c;break;case s.ObjectExpression:d=!0;c=[];q(a.properties,function(a){V(a.value,b);d=d&&a.value.constant&&!a.computed;a.value.constant||c.push.apply(c,a.value.toWatch)});a.constant=d;a.toWatch=c;break;case s.ThisExpression:a.constant=\n!1;a.toWatch=[];break;case s.LocalsExpression:a.constant=!1,a.toWatch=[]}}function zd(a){if(1===a.length){a=a[0].expression;var b=a.toWatch;return 1!==b.length?b:b[0]!==a?b:void 0}}function Ad(a){return a.type===s.Identifier||a.type===s.MemberExpression}function Bd(a){if(1===a.body.length&&Ad(a.body[0].expression))return{type:s.AssignmentExpression,left:a.body[0].expression,right:{type:s.NGValueParameter},operator:\"=\"}}function Cd(a){return 0===a.body.length||1===a.body.length&&(a.body[0].expression.type===\ns.Literal||a.body[0].expression.type===s.ArrayExpression||a.body[0].expression.type===s.ObjectExpression)}function Dd(a,b){this.astBuilder=a;this.$filter=b}function Ed(a,b){this.astBuilder=a;this.$filter=b}function pc(a){return y(a.valueOf)?a.valueOf():wg.call(a)}function Gf(){var a=W(),b={\"true\":!0,\"false\":!1,\"null\":null,undefined:void 0},d,c;this.addLiteral=function(a,c){b[a]=c};this.setIdentifierFns=function(a,b){d=a;c=b;return this};this.$get=[\"$filter\",function(f){function e(a,b){return null==\na||null==b?a===b:\"object\"===typeof a&&(a=pc(a),\"object\"===typeof a)?!1:a===b||a!==a&&b!==b}function g(a,b,c,d,f){var g=d.inputs,h;if(1===g.length){var k=e,g=g[0];return a.$watch(function(a){var b=g(a);e(b,k)||(h=d(a,void 0,void 0,[b]),k=b&&pc(b));return h},b,c,f)}for(var l=[],m=[],n=0,I=g.length;n<I;n++)l[n]=e,m[n]=null;return a.$watch(function(a){for(var b=!1,c=0,f=g.length;c<f;c++){var k=g[c](a);if(b||(b=!e(k,l[c])))m[c]=k,l[c]=k&&pc(k)}b&&(h=d(a,void 0,void 0,m));return h},b,c,f)}function h(a,\nb,c,d,e){function f(a){return d(a)}function h(a,c,d){l=a;y(b)&&b(a,c,d);v(a)&&d.$$postDigest(function(){v(l)&&k()})}var k,l;return k=d.inputs?g(a,h,c,d,e):a.$watch(f,h,c)}function k(a,b,c,d){function e(a){var b=!0;q(a,function(a){v(a)||(b=!1)});return b}var f,g;return f=a.$watch(function(a){return d(a)},function(a,c,d){g=a;y(b)&&b(a,c,d);e(a)&&d.$$postDigest(function(){e(g)&&f()})},c)}function l(a,b,c,d){var e=a.$watch(function(a){e();return d(a)},b,c);return e}function m(a,b){if(!b)return a;var c=\na.$$watchDelegate,d=!1,c=c!==k&&c!==h?function(c,e,f,g){f=d&&g?g[0]:a(c,e,f,g);return b(f,c,e)}:function(c,d,e,f){e=a(c,d,e,f);c=b(e,c,d);return v(e)?c:e},d=!a.inputs;a.$$watchDelegate&&a.$$watchDelegate!==g?(c.$$watchDelegate=a.$$watchDelegate,c.inputs=a.inputs):b.$stateful||(c.$$watchDelegate=g,c.inputs=a.inputs?a.inputs:[a]);return c}var n={csp:za().noUnsafeEval,literals:Fa(b),isIdentifierStart:y(d)&&d,isIdentifierContinue:y(c)&&c};return function(b,c){var d,e,u;switch(typeof b){case \"string\":return u=\nb=b.trim(),d=a[u],d||(\":\"===b.charAt(0)&&\":\"===b.charAt(1)&&(e=!0,b=b.substring(2)),d=new qc(n),d=(new rc(d,f,n)).parse(b),d.constant?d.$$watchDelegate=l:e?d.$$watchDelegate=d.literal?k:h:d.inputs&&(d.$$watchDelegate=g),a[u]=d),m(d,c);case \"function\":return m(b,c);default:return m(w,c)}}}]}function If(){var a=!0;this.$get=[\"$rootScope\",\"$exceptionHandler\",function(b,d){return Fd(function(a){b.$evalAsync(a)},d,a)}];this.errorOnUnhandledRejections=function(b){return v(b)?(a=b,this):a}}function Jf(){var a=\n!0;this.$get=[\"$browser\",\"$exceptionHandler\",function(b,d){return Fd(function(a){b.defer(a)},d,a)}];this.errorOnUnhandledRejections=function(b){return v(b)?(a=b,this):a}}function Fd(a,b,d){function c(){return new f}function f(){var a=this.promise=new e;this.resolve=function(b){k(a,b)};this.reject=function(b){m(a,b)};this.notify=function(b){p(a,b)}}function e(){this.$$state={status:0}}function g(){for(;!v&&t.length;){var a=t.shift();if(!a.pur){a.pur=!0;var c=a.value,c=\"Possibly unhandled rejection: \"+\n(\"function\"===typeof c?c.toString().replace(/ \\{[\\s\\S]*$/,\"\"):x(c)?\"undefined\":\"string\"!==typeof c?we(c):c);a.value instanceof Error?b(a.value,c):b(c)}}}function h(b){!d||b.pending||2!==b.status||b.pur||(0===v&&0===t.length&&a(g),t.push(b));!b.processScheduled&&b.pending&&(b.processScheduled=!0,++v,a(function(){var c,e,f;f=b.pending;b.processScheduled=!1;b.pending=void 0;try{for(var h=0,l=f.length;h<l;++h){b.pur=!0;e=f[h][0];c=f[h][b.status];try{y(c)?k(e,c(b.value)):1===b.status?k(e,b.value):m(e,\nb.value)}catch(n){m(e,n)}}}finally{--v,d&&0===v&&a(g)}}))}function k(a,b){a.$$state.status||(b===a?n(a,H(\"qcycle\",b)):l(a,b))}function l(a,b){function c(b){g||(g=!0,l(a,b))}function d(b){g||(g=!0,n(a,b))}function e(b){p(a,b)}var f,g=!1;try{if(F(b)||y(b))f=b.then;y(f)?(a.$$state.status=-1,f.call(b,c,d,e)):(a.$$state.value=b,a.$$state.status=1,h(a.$$state))}catch(k){d(k)}}function m(a,b){a.$$state.status||n(a,b)}function n(a,b){a.$$state.value=b;a.$$state.status=2;h(a.$$state)}function p(c,d){var e=\nc.$$state.pending;0>=c.$$state.status&&e&&e.length&&a(function(){for(var a,c,f=0,g=e.length;f<g;f++){c=e[f][0];a=e[f][3];try{p(c,y(a)?a(d):d)}catch(h){b(h)}}})}function r(a){var b=new e;m(b,a);return b}function J(a,b,c){var d=null;try{y(c)&&(d=c())}catch(e){return r(e)}return d&&y(d.then)?d.then(function(){return b(a)},r):b(a)}function s(a,b,c,d){var f=new e;k(f,a);return f.then(b,c,d)}function u(a){if(!y(a))throw H(\"norslvr\",a);var b=new e;a(function(a){k(b,a)},function(a){m(b,a)});return b}var H=\nM(\"$q\",TypeError),v=0,t=[];R(e.prototype,{then:function(a,b,c){if(x(a)&&x(b)&&x(c))return this;var d=new e;this.$$state.pending=this.$$state.pending||[];this.$$state.pending.push([d,a,b,c]);0<this.$$state.status&&h(this.$$state);return d},\"catch\":function(a){return this.then(null,a)},\"finally\":function(a,b){return this.then(function(b){return J(b,w,a)},function(b){return J(b,r,a)},b)}});var w=s;u.prototype=e.prototype;u.defer=c;u.reject=r;u.when=s;u.resolve=w;u.all=function(a){var b=new e,c=0,d=C(a)?\n[]:{};q(a,function(a,e){c++;s(a).then(function(a){d[e]=a;--c||k(b,d)},function(a){m(b,a)})});0===c&&k(b,d);return b};u.race=function(a){var b=c();q(a,function(a){s(a).then(b.resolve,b.reject)});return b.promise};return u}function Sf(){this.$get=[\"$window\",\"$timeout\",function(a,b){var d=a.requestAnimationFrame||a.webkitRequestAnimationFrame,c=a.cancelAnimationFrame||a.webkitCancelAnimationFrame||a.webkitCancelRequestAnimationFrame,f=!!d,e=f?function(a){var b=d(a);return function(){c(b)}}:function(a){var c=\nb(a,16.66,!1);return function(){b.cancel(c)}};e.supported=f;return e}]}function Hf(){function a(a){function b(){this.$$watchers=this.$$nextSibling=this.$$childHead=this.$$childTail=null;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$id=++rb;this.$$ChildScope=null}b.prototype=a;return b}var b=10,d=M(\"$rootScope\"),c=null,f=null;this.digestTtl=function(a){arguments.length&&(b=a);return b};this.$get=[\"$exceptionHandler\",\"$parse\",\"$browser\",function(e,g,h){function k(a){a.currentScope.$$destroyed=\n!0}function l(a){9===La&&(a.$$childHead&&l(a.$$childHead),a.$$nextSibling&&l(a.$$nextSibling));a.$parent=a.$$nextSibling=a.$$prevSibling=a.$$childHead=a.$$childTail=a.$root=a.$$watchers=null}function m(){this.$id=++rb;this.$$phase=this.$parent=this.$$watchers=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=null;this.$root=this;this.$$destroyed=!1;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$$isolateBindings=null}function n(a){if(H.$$phase)throw d(\"inprog\",\nH.$$phase);H.$$phase=a}function p(a,b){do a.$$watchersCount+=b;while(a=a.$parent)}function r(a,b,c){do a.$$listenerCount[c]-=b,0===a.$$listenerCount[c]&&delete a.$$listenerCount[c];while(a=a.$parent)}function J(){}function s(){for(;ia.length;)try{ia.shift()()}catch(a){e(a)}f=null}function u(){null===f&&(f=h.defer(function(){H.$apply(s)}))}m.prototype={constructor:m,$new:function(b,c){var d;c=c||this;b?(d=new m,d.$root=this.$root):(this.$$ChildScope||(this.$$ChildScope=a(this)),d=new this.$$ChildScope);\nd.$parent=c;d.$$prevSibling=c.$$childTail;c.$$childHead?(c.$$childTail.$$nextSibling=d,c.$$childTail=d):c.$$childHead=c.$$childTail=d;(b||c!==this)&&d.$on(\"$destroy\",k);return d},$watch:function(a,b,d,e){var f=g(a);if(f.$$watchDelegate)return f.$$watchDelegate(this,b,d,f,a);var h=this,k=h.$$watchers,l={fn:b,last:J,get:f,exp:e||a,eq:!!d};c=null;y(b)||(l.fn=w);k||(k=h.$$watchers=[],k.$$digestWatchIndex=-1);k.unshift(l);k.$$digestWatchIndex++;p(this,1);return function(){var a=$a(k,l);0<=a&&(p(h,-1),\na<k.$$digestWatchIndex&&k.$$digestWatchIndex--);c=null}},$watchGroup:function(a,b){function c(){h=!1;k?(k=!1,b(e,e,g)):b(e,d,g)}var d=Array(a.length),e=Array(a.length),f=[],g=this,h=!1,k=!0;if(!a.length){var l=!0;g.$evalAsync(function(){l&&b(e,e,g)});return function(){l=!1}}if(1===a.length)return this.$watch(a[0],function(a,c,f){e[0]=a;d[0]=c;b(e,a===c?e:d,f)});q(a,function(a,b){var k=g.$watch(a,function(a,f){e[b]=a;d[b]=f;h||(h=!0,g.$evalAsync(c))});f.push(k)});return function(){for(;f.length;)f.shift()()}},\n$watchCollection:function(a,b){function c(a){e=a;var b,d,g,h;if(!x(e)){if(F(e))if(ta(e))for(f!==n&&(f=n,u=f.length=0,l++),a=e.length,u!==a&&(l++,f.length=u=a),b=0;b<a;b++)h=f[b],g=e[b],d=h!==h&&g!==g,d||h===g||(l++,f[b]=g);else{f!==p&&(f=p={},u=0,l++);a=0;for(b in e)va.call(e,b)&&(a++,g=e[b],h=f[b],b in f?(d=h!==h&&g!==g,d||h===g||(l++,f[b]=g)):(u++,f[b]=g,l++));if(u>a)for(b in l++,f)va.call(e,b)||(u--,delete f[b])}else f!==e&&(f=e,l++);return l}}c.$stateful=!0;var d=this,e,f,h,k=1<b.length,l=0,m=\ng(a,c),n=[],p={},r=!0,u=0;return this.$watch(m,function(){r?(r=!1,b(e,e,d)):b(e,h,d);if(k)if(F(e))if(ta(e)){h=Array(e.length);for(var a=0;a<e.length;a++)h[a]=e[a]}else for(a in h={},e)va.call(e,a)&&(h[a]=e[a]);else h=e})},$digest:function(){var a,g,k,l,m,p,r,u=b,q,w=[],x,ia;n(\"$digest\");h.$$checkUrlChange();this===H&&null!==f&&(h.defer.cancel(f),s());c=null;do{r=!1;q=this;for(p=0;p<v.length;p++){try{ia=v[p],ia.scope.$eval(ia.expression,ia.locals)}catch(z){e(z)}c=null}v.length=0;a:do{if(p=q.$$watchers)for(p.$$digestWatchIndex=\np.length;p.$$digestWatchIndex--;)try{if(a=p[p.$$digestWatchIndex])if(m=a.get,(g=m(q))!==(k=a.last)&&!(a.eq?qa(g,k):ga(g)&&ga(k)))r=!0,c=a,a.last=a.eq?Fa(g,null):g,l=a.fn,l(g,k===J?g:k,q),5>u&&(x=4-u,w[x]||(w[x]=[]),w[x].push({msg:y(a.exp)?\"fn: \"+(a.exp.name||a.exp.toString()):a.exp,newVal:g,oldVal:k}));else if(a===c){r=!1;break a}}catch(D){e(D)}if(!(p=q.$$watchersCount&&q.$$childHead||q!==this&&q.$$nextSibling))for(;q!==this&&!(p=q.$$nextSibling);)q=q.$parent}while(q=p);if((r||v.length)&&!u--)throw H.$$phase=\nnull,d(\"infdig\",b,w);}while(r||v.length);for(H.$$phase=null;A<t.length;)try{t[A++]()}catch(E){e(E)}t.length=A=0},$destroy:function(){if(!this.$$destroyed){var a=this.$parent;this.$broadcast(\"$destroy\");this.$$destroyed=!0;this===H&&h.$$applicationDestroyed();p(this,-this.$$watchersCount);for(var b in this.$$listenerCount)r(this,this.$$listenerCount[b],b);a&&a.$$childHead===this&&(a.$$childHead=this.$$nextSibling);a&&a.$$childTail===this&&(a.$$childTail=this.$$prevSibling);this.$$prevSibling&&(this.$$prevSibling.$$nextSibling=\nthis.$$nextSibling);this.$$nextSibling&&(this.$$nextSibling.$$prevSibling=this.$$prevSibling);this.$destroy=this.$digest=this.$apply=this.$evalAsync=this.$applyAsync=w;this.$on=this.$watch=this.$watchGroup=function(){return w};this.$$listeners={};this.$$nextSibling=null;l(this)}},$eval:function(a,b){return g(a)(this,b)},$evalAsync:function(a,b){H.$$phase||v.length||h.defer(function(){v.length&&H.$digest()});v.push({scope:this,expression:g(a),locals:b})},$$postDigest:function(a){t.push(a)},$apply:function(a){try{n(\"$apply\");\ntry{return this.$eval(a)}finally{H.$$phase=null}}catch(b){e(b)}finally{try{H.$digest()}catch(c){throw e(c),c;}}},$applyAsync:function(a){function b(){c.$eval(a)}var c=this;a&&ia.push(b);a=g(a);u()},$on:function(a,b){var c=this.$$listeners[a];c||(this.$$listeners[a]=c=[]);c.push(b);var d=this;do d.$$listenerCount[a]||(d.$$listenerCount[a]=0),d.$$listenerCount[a]++;while(d=d.$parent);var e=this;return function(){var d=c.indexOf(b);-1!==d&&(c[d]=null,r(e,1,a))}},$emit:function(a,b){var c=[],d,f=this,\ng=!1,h={name:a,targetScope:f,stopPropagation:function(){g=!0},preventDefault:function(){h.defaultPrevented=!0},defaultPrevented:!1},k=ab([h],arguments,1),l,m;do{d=f.$$listeners[a]||c;h.currentScope=f;l=0;for(m=d.length;l<m;l++)if(d[l])try{d[l].apply(null,k)}catch(n){e(n)}else d.splice(l,1),l--,m--;if(g)return h.currentScope=null,h;f=f.$parent}while(f);h.currentScope=null;return h},$broadcast:function(a,b){var c=this,d=this,f={name:a,targetScope:this,preventDefault:function(){f.defaultPrevented=!0},\ndefaultPrevented:!1};if(!this.$$listenerCount[a])return f;for(var g=ab([f],arguments,1),h,k;c=d;){f.currentScope=c;d=c.$$listeners[a]||[];h=0;for(k=d.length;h<k;h++)if(d[h])try{d[h].apply(null,g)}catch(l){e(l)}else d.splice(h,1),h--,k--;if(!(d=c.$$listenerCount[a]&&c.$$childHead||c!==this&&c.$$nextSibling))for(;c!==this&&!(d=c.$$nextSibling);)c=c.$parent}f.currentScope=null;return f}};var H=new m,v=H.$$asyncQueue=[],t=H.$$postDigestQueue=[],ia=H.$$applyAsyncQueue=[],A=0;return H}]}function ze(){var a=\n/^\\s*(https?|ftp|mailto|tel|file):/,b=/^\\s*((https?|ftp|file|blob):|data:image\\/)/;this.aHrefSanitizationWhitelist=function(b){return v(b)?(a=b,this):a};this.imgSrcSanitizationWhitelist=function(a){return v(a)?(b=a,this):b};this.$get=function(){return function(d,c){var f=c?b:a,e;e=Da(d).href;return\"\"===e||e.match(f)?d:\"unsafe:\"+e}}}function xg(a){if(\"self\"===a)return a;if(E(a)){if(-1<a.indexOf(\"***\"))throw ua(\"iwcard\",a);a=Gd(a).replace(/\\\\\\*\\\\\\*/g,\".*\").replace(/\\\\\\*/g,\"[^:/.?&;]*\");return new RegExp(\"^\"+\na+\"$\")}if(Xa(a))return new RegExp(\"^\"+a.source+\"$\");throw ua(\"imatcher\");}function Hd(a){var b=[];v(a)&&q(a,function(a){b.push(xg(a))});return b}function Lf(){this.SCE_CONTEXTS=pa;var a=[\"self\"],b=[];this.resourceUrlWhitelist=function(b){arguments.length&&(a=Hd(b));return a};this.resourceUrlBlacklist=function(a){arguments.length&&(b=Hd(a));return b};this.$get=[\"$injector\",function(d){function c(a,b){return\"self\"===a?sd(b):!!a.exec(b.href)}function f(a){var b=function(a){this.$$unwrapTrustedValue=\nfunction(){return a}};a&&(b.prototype=new a);b.prototype.valueOf=function(){return this.$$unwrapTrustedValue()};b.prototype.toString=function(){return this.$$unwrapTrustedValue().toString()};return b}var e=function(a){throw ua(\"unsafe\");};d.has(\"$sanitize\")&&(e=d.get(\"$sanitize\"));var g=f(),h={};h[pa.HTML]=f(g);h[pa.CSS]=f(g);h[pa.URL]=f(g);h[pa.JS]=f(g);h[pa.RESOURCE_URL]=f(h[pa.URL]);return{trustAs:function(a,b){var c=h.hasOwnProperty(a)?h[a]:null;if(!c)throw ua(\"icontext\",a,b);if(null===b||x(b)||\n\"\"===b)return b;if(\"string\"!==typeof b)throw ua(\"itype\",a);return new c(b)},getTrusted:function(d,f){if(null===f||x(f)||\"\"===f)return f;var g=h.hasOwnProperty(d)?h[d]:null;if(g&&f instanceof g)return f.$$unwrapTrustedValue();if(d===pa.RESOURCE_URL){var g=Da(f.toString()),n,p,r=!1;n=0;for(p=a.length;n<p;n++)if(c(a[n],g)){r=!0;break}if(r)for(n=0,p=b.length;n<p;n++)if(c(b[n],g)){r=!1;break}if(r)return f;throw ua(\"insecurl\",f.toString());}if(d===pa.HTML)return e(f);throw ua(\"unsafe\");},valueOf:function(a){return a instanceof\ng?a.$$unwrapTrustedValue():a}}}]}function Kf(){var a=!0;this.enabled=function(b){arguments.length&&(a=!!b);return a};this.$get=[\"$parse\",\"$sceDelegate\",function(b,d){if(a&&8>La)throw ua(\"iequirks\");var c=ra(pa);c.isEnabled=function(){return a};c.trustAs=d.trustAs;c.getTrusted=d.getTrusted;c.valueOf=d.valueOf;a||(c.trustAs=c.getTrusted=function(a,b){return b},c.valueOf=Ya);c.parseAs=function(a,d){var e=b(d);return e.literal&&e.constant?e:b(d,function(b){return c.getTrusted(a,b)})};var f=c.parseAs,\ne=c.getTrusted,g=c.trustAs;q(pa,function(a,b){var d=P(b);c[(\"parse_as_\"+d).replace(sc,gb)]=function(b){return f(a,b)};c[(\"get_trusted_\"+d).replace(sc,gb)]=function(b){return e(a,b)};c[(\"trust_as_\"+d).replace(sc,gb)]=function(b){return g(a,b)}});return c}]}function Mf(){this.$get=[\"$window\",\"$document\",function(a,b){var d={},c=!(a.chrome&&(a.chrome.app&&a.chrome.app.runtime||!a.chrome.app&&a.chrome.runtime&&a.chrome.runtime.id))&&a.history&&a.history.pushState,f=Z((/android (\\d+)/.exec(P((a.navigator||\n{}).userAgent))||[])[1]),e=/Boxee/i.test((a.navigator||{}).userAgent),g=b[0]||{},h=g.body&&g.body.style,k=!1,l=!1;h&&(k=!!(\"transition\"in h||\"webkitTransition\"in h),l=!!(\"animation\"in h||\"webkitAnimation\"in h));return{history:!(!c||4>f||e),hasEvent:function(a){if(\"input\"===a&&La)return!1;if(x(d[a])){var b=g.createElement(\"div\");d[a]=\"on\"+a in b}return d[a]},csp:za(),transitions:k,animations:l,android:f}}]}function Of(){var a;this.httpOptions=function(b){return b?(a=b,this):a};this.$get=[\"$exceptionHandler\",\n\"$templateCache\",\"$http\",\"$q\",\"$sce\",function(b,d,c,f,e){function g(h,k){g.totalPendingRequests++;if(!E(h)||x(d.get(h)))h=e.getTrustedResourceUrl(h);var l=c.defaults&&c.defaults.transformResponse;C(l)?l=l.filter(function(a){return a!==jc}):l===jc&&(l=null);return c.get(h,R({cache:d,transformResponse:l},a)).finally(function(){g.totalPendingRequests--}).then(function(a){d.put(h,a.data);return a.data},function(a){k||(a=yg(\"tpload\",h,a.status,a.statusText),b(a));return f.reject(a)})}g.totalPendingRequests=\n0;return g}]}function Pf(){this.$get=[\"$rootScope\",\"$browser\",\"$location\",function(a,b,d){return{findBindings:function(a,b,d){a=a.getElementsByClassName(\"ng-binding\");var g=[];q(a,function(a){var c=$.element(a).data(\"$binding\");c&&q(c,function(c){d?(new RegExp(\"(^|\\\\s)\"+Gd(b)+\"(\\\\s|\\\\||$)\")).test(c)&&g.push(a):-1!==c.indexOf(b)&&g.push(a)})});return g},findModels:function(a,b,d){for(var g=[\"ng-\",\"data-ng-\",\"ng\\\\:\"],h=0;h<g.length;++h){var k=a.querySelectorAll(\"[\"+g[h]+\"model\"+(d?\"=\":\"*=\")+'\"'+b+'\"]');\nif(k.length)return k}},getLocation:function(){return d.url()},setLocation:function(b){b!==d.url()&&(d.url(b),a.$digest())},whenStable:function(a){b.notifyWhenNoOutstandingRequests(a)}}}]}function Qf(){this.$get=[\"$rootScope\",\"$browser\",\"$q\",\"$$q\",\"$exceptionHandler\",function(a,b,d,c,f){function e(e,k,l){y(e)||(l=k,k=e,e=w);var m=wa.call(arguments,3),n=v(l)&&!l,p=(n?c:d).defer(),r=p.promise,q;q=b.defer(function(){try{p.resolve(e.apply(null,m))}catch(b){p.reject(b),f(b)}finally{delete g[r.$$timeoutId]}n||\na.$apply()},k);r.$$timeoutId=q;g[q]=p;return r}var g={};e.cancel=function(a){return a&&a.$$timeoutId in g?(g[a.$$timeoutId].promise.catch(w),g[a.$$timeoutId].reject(\"canceled\"),delete g[a.$$timeoutId],b.defer.cancel(a.$$timeoutId)):!1};return e}]}function Da(a){La&&(ca.setAttribute(\"href\",a),a=ca.href);ca.setAttribute(\"href\",a);return{href:ca.href,protocol:ca.protocol?ca.protocol.replace(/:$/,\"\"):\"\",host:ca.host,search:ca.search?ca.search.replace(/^\\?/,\"\"):\"\",hash:ca.hash?ca.hash.replace(/^#/,\"\"):\n\"\",hostname:ca.hostname,port:ca.port,pathname:\"/\"===ca.pathname.charAt(0)?ca.pathname:\"/\"+ca.pathname}}function sd(a){a=E(a)?Da(a):a;return a.protocol===Id.protocol&&a.host===Id.host}function Rf(){this.$get=ma(z)}function Jd(a){function b(a){try{return decodeURIComponent(a)}catch(b){return a}}var d=a[0]||{},c={},f=\"\";return function(){var a,g,h,k,l;try{a=d.cookie||\"\"}catch(m){a=\"\"}if(a!==f)for(f=a,a=f.split(\"; \"),c={},h=0;h<a.length;h++)g=a[h],k=g.indexOf(\"=\"),0<k&&(l=b(g.substring(0,k)),x(c[l])&&\n(c[l]=b(g.substring(k+1))));return c}}function Vf(){this.$get=Jd}function Xc(a){function b(d,c){if(F(d)){var f={};q(d,function(a,c){f[c]=b(c,a)});return f}return a.factory(d+\"Filter\",c)}this.register=b;this.$get=[\"$injector\",function(a){return function(b){return a.get(b+\"Filter\")}}];b(\"currency\",Kd);b(\"date\",Ld);b(\"filter\",zg);b(\"json\",Ag);b(\"limitTo\",Bg);b(\"lowercase\",Cg);b(\"number\",Md);b(\"orderBy\",Nd);b(\"uppercase\",Dg)}function zg(){return function(a,b,d,c){if(!ta(a)){if(null==a)return a;throw M(\"filter\")(\"notarray\",\na);}c=c||\"$\";var f;switch(tc(b)){case \"function\":break;case \"boolean\":case \"null\":case \"number\":case \"string\":f=!0;case \"object\":b=Eg(b,d,c,f);break;default:return a}return Array.prototype.filter.call(a,b)}}function Eg(a,b,d,c){var f=F(a)&&d in a;!0===b?b=qa:y(b)||(b=function(a,b){if(x(a))return!1;if(null===a||null===b)return a===b;if(F(b)||F(a)&&!Vb(a))return!1;a=P(\"\"+a);b=P(\"\"+b);return-1!==a.indexOf(b)});return function(e){return f&&!F(e)?Ha(e,a[d],b,d,!1):Ha(e,a,b,d,c)}}function Ha(a,b,d,c,f,\ne){var g=tc(a),h=tc(b);if(\"string\"===h&&\"!\"===b.charAt(0))return!Ha(a,b.substring(1),d,c,f);if(C(a))return a.some(function(a){return Ha(a,b,d,c,f)});switch(g){case \"object\":var k;if(f){for(k in a)if(\"$\"!==k.charAt(0)&&Ha(a[k],b,d,c,!0))return!0;return e?!1:Ha(a,b,d,c,!1)}if(\"object\"===h){for(k in b)if(e=b[k],!y(e)&&!x(e)&&(g=k===c,!Ha(g?a:a[k],e,d,c,g,g)))return!1;return!0}return d(a,b);case \"function\":return!1;default:return d(a,b)}}function tc(a){return null===a?\"null\":typeof a}function Kd(a){var b=\na.NUMBER_FORMATS;return function(a,c,f){x(c)&&(c=b.CURRENCY_SYM);x(f)&&(f=b.PATTERNS[1].maxFrac);return null==a?a:Od(a,b.PATTERNS[1],b.GROUP_SEP,b.DECIMAL_SEP,f).replace(/\\u00A4/g,c)}}function Md(a){var b=a.NUMBER_FORMATS;return function(a,c){return null==a?a:Od(a,b.PATTERNS[0],b.GROUP_SEP,b.DECIMAL_SEP,c)}}function Fg(a){var b=0,d,c,f,e,g;-1<(c=a.indexOf(Pd))&&(a=a.replace(Pd,\"\"));0<(f=a.search(/e/i))?(0>c&&(c=f),c+=+a.slice(f+1),a=a.substring(0,f)):0>c&&(c=a.length);for(f=0;a.charAt(f)===uc;f++);\nif(f===(g=a.length))d=[0],c=1;else{for(g--;a.charAt(g)===uc;)g--;c-=f;d=[];for(e=0;f<=g;f++,e++)d[e]=+a.charAt(f)}c>Qd&&(d=d.splice(0,Qd-1),b=c-1,c=1);return{d:d,e:b,i:c}}function Gg(a,b,d,c){var f=a.d,e=f.length-a.i;b=x(b)?Math.min(Math.max(d,e),c):+b;d=b+a.i;c=f[d];if(0<d){f.splice(Math.max(a.i,d));for(var g=d;g<f.length;g++)f[g]=0}else for(e=Math.max(0,e),a.i=1,f.length=Math.max(1,d=b+1),f[0]=0,g=1;g<d;g++)f[g]=0;if(5<=c)if(0>d-1){for(c=0;c>d;c--)f.unshift(0),a.i++;f.unshift(1);a.i++}else f[d-\n1]++;for(;e<Math.max(0,b);e++)f.push(0);if(b=f.reduceRight(function(a,b,c,d){b+=a;d[c]=b%10;return Math.floor(b/10)},0))f.unshift(b),a.i++}function Od(a,b,d,c,f){if(!E(a)&&!Y(a)||isNaN(a))return\"\";var e=!isFinite(a),g=!1,h=Math.abs(a)+\"\",k=\"\";if(e)k=\"\\u221e\";else{g=Fg(h);Gg(g,f,b.minFrac,b.maxFrac);k=g.d;h=g.i;f=g.e;e=[];for(g=k.reduce(function(a,b){return a&&!b},!0);0>h;)k.unshift(0),h++;0<h?e=k.splice(h,k.length):(e=k,k=[0]);h=[];for(k.length>=b.lgSize&&h.unshift(k.splice(-b.lgSize,k.length).join(\"\"));k.length>\nb.gSize;)h.unshift(k.splice(-b.gSize,k.length).join(\"\"));k.length&&h.unshift(k.join(\"\"));k=h.join(d);e.length&&(k+=c+e.join(\"\"));f&&(k+=\"e+\"+f)}return 0>a&&!g?b.negPre+k+b.negSuf:b.posPre+k+b.posSuf}function Kb(a,b,d,c){var f=\"\";if(0>a||c&&0>=a)c?a=-a+1:(a=-a,f=\"-\");for(a=\"\"+a;a.length<b;)a=uc+a;d&&(a=a.substr(a.length-b));return f+a}function aa(a,b,d,c,f){d=d||0;return function(e){e=e[\"get\"+a]();if(0<d||e>-d)e+=d;0===e&&-12===d&&(e=12);return Kb(e,b,c,f)}}function nb(a,b,d){return function(c,f){var e=\nc[\"get\"+a](),g=vb((d?\"STANDALONE\":\"\")+(b?\"SHORT\":\"\")+a);return f[g][e]}}function Rd(a){var b=(new Date(a,0,1)).getDay();return new Date(a,0,(4>=b?5:12)-b)}function Sd(a){return function(b){var d=Rd(b.getFullYear());b=+new Date(b.getFullYear(),b.getMonth(),b.getDate()+(4-b.getDay()))-+d;b=1+Math.round(b/6048E5);return Kb(b,a)}}function vc(a,b){return 0>=a.getFullYear()?b.ERAS[0]:b.ERAS[1]}function Ld(a){function b(a){var b;if(b=a.match(d)){a=new Date(0);var e=0,g=0,h=b[8]?a.setUTCFullYear:a.setFullYear,\nk=b[8]?a.setUTCHours:a.setHours;b[9]&&(e=Z(b[9]+b[10]),g=Z(b[9]+b[11]));h.call(a,Z(b[1]),Z(b[2])-1,Z(b[3]));e=Z(b[4]||0)-e;g=Z(b[5]||0)-g;h=Z(b[6]||0);b=Math.round(1E3*parseFloat(\"0.\"+(b[7]||0)));k.call(a,e,g,h,b)}return a}var d=/^(\\d{4})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d+))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d))?)?$/;return function(c,d,e){var g=\"\",h=[],k,l;d=d||\"mediumDate\";d=a.DATETIME_FORMATS[d]||d;E(c)&&(c=Hg.test(c)?Z(c):b(c));Y(c)&&(c=new Date(c));if(!fa(c)||!isFinite(c.getTime()))return c;\nfor(;d;)(l=Ig.exec(d))?(h=ab(h,l,1),d=h.pop()):(h.push(d),d=null);var m=c.getTimezoneOffset();e&&(m=Jc(e,m),c=Wb(c,e,!0));q(h,function(b){k=Jg[b];g+=k?k(c,a.DATETIME_FORMATS,m):\"''\"===b?\"'\":b.replace(/(^'|'$)/g,\"\").replace(/''/g,\"'\")});return g}}function Ag(){return function(a,b){x(b)&&(b=2);return cb(a,b)}}function Bg(){return function(a,b,d){b=Infinity===Math.abs(Number(b))?Number(b):Z(b);if(ga(b))return a;Y(a)&&(a=a.toString());if(!ta(a))return a;d=!d||isNaN(d)?0:Z(d);d=0>d?Math.max(0,a.length+\nd):d;return 0<=b?wc(a,d,d+b):0===d?wc(a,b,a.length):wc(a,Math.max(0,d+b),d)}}function wc(a,b,d){return E(a)?a.slice(b,d):wa.call(a,b,d)}function Nd(a){function b(b){return b.map(function(b){var c=1,d=Ya;if(y(b))d=b;else if(E(b)){if(\"+\"===b.charAt(0)||\"-\"===b.charAt(0))c=\"-\"===b.charAt(0)?-1:1,b=b.substring(1);if(\"\"!==b&&(d=a(b),d.constant))var f=d(),d=function(a){return a[f]}}return{get:d,descending:c}})}function d(a){switch(typeof a){case \"number\":case \"boolean\":case \"string\":return!0;default:return!1}}\nfunction c(a,b){var c=0,d=a.type,k=b.type;if(d===k){var k=a.value,l=b.value;\"string\"===d?(k=k.toLowerCase(),l=l.toLowerCase()):\"object\"===d&&(F(k)&&(k=a.index),F(l)&&(l=b.index));k!==l&&(c=k<l?-1:1)}else c=d<k?-1:1;return c}return function(a,e,g,h){if(null==a)return a;if(!ta(a))throw M(\"orderBy\")(\"notarray\",a);C(e)||(e=[e]);0===e.length&&(e=[\"+\"]);var k=b(e),l=g?-1:1,m=y(h)?h:c;a=Array.prototype.map.call(a,function(a,b){return{value:a,tieBreaker:{value:b,type:\"number\",index:b},predicateValues:k.map(function(c){var e=\nc.get(a);c=typeof e;if(null===e)c=\"string\",e=\"null\";else if(\"object\"===c)a:{if(y(e.valueOf)&&(e=e.valueOf(),d(e)))break a;Vb(e)&&(e=e.toString(),d(e))}return{value:e,type:c,index:b}})}});a.sort(function(a,b){for(var c=0,d=k.length;c<d;c++){var e=m(a.predicateValues[c],b.predicateValues[c]);if(e)return e*k[c].descending*l}return m(a.tieBreaker,b.tieBreaker)*l});return a=a.map(function(a){return a.value})}}function Ra(a){y(a)&&(a={link:a});a.restrict=a.restrict||\"AC\";return ma(a)}function Lb(a,b,d,\nc,f){this.$$controls=[];this.$error={};this.$$success={};this.$pending=void 0;this.$name=f(b.name||b.ngForm||\"\")(d);this.$dirty=!1;this.$valid=this.$pristine=!0;this.$submitted=this.$invalid=!1;this.$$parentForm=Mb;this.$$element=a;this.$$animate=c;Td(this)}function Td(a){a.$$classCache={};a.$$classCache[Ud]=!(a.$$classCache[ob]=a.$$element.hasClass(ob))}function Vd(a){function b(a,b,c){c&&!a.$$classCache[b]?(a.$$animate.addClass(a.$$element,b),a.$$classCache[b]=!0):!c&&a.$$classCache[b]&&(a.$$animate.removeClass(a.$$element,\nb),a.$$classCache[b]=!1)}function d(a,c,d){c=c?\"-\"+Nc(c,\"-\"):\"\";b(a,ob+c,!0===d);b(a,Ud+c,!1===d)}var c=a.set,f=a.unset;a.clazz.prototype.$setValidity=function(a,g,h){x(g)?(this.$pending||(this.$pending={}),c(this.$pending,a,h)):(this.$pending&&f(this.$pending,a,h),Wd(this.$pending)&&(this.$pending=void 0));Ia(g)?g?(f(this.$error,a,h),c(this.$$success,a,h)):(c(this.$error,a,h),f(this.$$success,a,h)):(f(this.$error,a,h),f(this.$$success,a,h));this.$pending?(b(this,\"ng-pending\",!0),this.$valid=this.$invalid=\nvoid 0,d(this,\"\",null)):(b(this,\"ng-pending\",!1),this.$valid=Wd(this.$error),this.$invalid=!this.$valid,d(this,\"\",this.$valid));g=this.$pending&&this.$pending[a]?void 0:this.$error[a]?!1:this.$$success[a]?!0:null;d(this,a,g);this.$$parentForm.$setValidity(a,g,this)}}function Wd(a){if(a)for(var b in a)if(a.hasOwnProperty(b))return!1;return!0}function xc(a){a.$formatters.push(function(b){return a.$isEmpty(b)?b:b.toString()})}function Sa(a,b,d,c,f,e){var g=P(b[0].type);if(!f.android){var h=!1;b.on(\"compositionstart\",\nfunction(){h=!0});b.on(\"compositionend\",function(){h=!1;l()})}var k,l=function(a){k&&(e.defer.cancel(k),k=null);if(!h){var f=b.val();a=a&&a.type;\"password\"===g||d.ngTrim&&\"false\"===d.ngTrim||(f=S(f));(c.$viewValue!==f||\"\"===f&&c.$$hasNativeValidators)&&c.$setViewValue(f,a)}};if(f.hasEvent(\"input\"))b.on(\"input\",l);else{var m=function(a,b,c){k||(k=e.defer(function(){k=null;b&&b.value===c||l(a)}))};b.on(\"keydown\",function(a){var b=a.keyCode;91===b||15<b&&19>b||37<=b&&40>=b||m(a,this,this.value)});if(f.hasEvent(\"paste\"))b.on(\"paste cut\",\nm)}b.on(\"change\",l);if(Xd[g]&&c.$$hasNativeValidators&&g===d.type)b.on(\"keydown wheel mousedown\",function(a){if(!k){var b=this.validity,c=b.badInput,d=b.typeMismatch;k=e.defer(function(){k=null;b.badInput===c&&b.typeMismatch===d||l(a)})}});c.$render=function(){var a=c.$isEmpty(c.$viewValue)?\"\":c.$viewValue;b.val()!==a&&b.val(a)}}function Nb(a,b){return function(d,c){var f,e;if(fa(d))return d;if(E(d)){'\"'===d.charAt(0)&&'\"'===d.charAt(d.length-1)&&(d=d.substring(1,d.length-1));if(Kg.test(d))return new Date(d);\na.lastIndex=0;if(f=a.exec(d))return f.shift(),e=c?{yyyy:c.getFullYear(),MM:c.getMonth()+1,dd:c.getDate(),HH:c.getHours(),mm:c.getMinutes(),ss:c.getSeconds(),sss:c.getMilliseconds()/1E3}:{yyyy:1970,MM:1,dd:1,HH:0,mm:0,ss:0,sss:0},q(f,function(a,c){c<b.length&&(e[b[c]]=+a)}),new Date(e.yyyy,e.MM-1,e.dd,e.HH,e.mm,e.ss||0,1E3*e.sss||0)}return NaN}}function pb(a,b,d,c){return function(f,e,g,h,k,l,m){function n(a){return a&&!(a.getTime&&a.getTime()!==a.getTime())}function p(a){return v(a)&&!fa(a)?d(a)||\nvoid 0:a}yc(f,e,g,h);Sa(f,e,g,h,k,l);var r=h&&h.$options.getOption(\"timezone\"),q;h.$$parserName=a;h.$parsers.push(function(a){if(h.$isEmpty(a))return null;if(b.test(a))return a=d(a,q),r&&(a=Wb(a,r)),a});h.$formatters.push(function(a){if(a&&!fa(a))throw qb(\"datefmt\",a);if(n(a))return(q=a)&&r&&(q=Wb(q,r,!0)),m(\"date\")(a,c,r);q=null;return\"\"});if(v(g.min)||g.ngMin){var s;h.$validators.min=function(a){return!n(a)||x(s)||d(a)>=s};g.$observe(\"min\",function(a){s=p(a);h.$validate()})}if(v(g.max)||g.ngMax){var u;\nh.$validators.max=function(a){return!n(a)||x(u)||d(a)<=u};g.$observe(\"max\",function(a){u=p(a);h.$validate()})}}}function yc(a,b,d,c){(c.$$hasNativeValidators=F(b[0].validity))&&c.$parsers.push(function(a){var c=b.prop(\"validity\")||{};return c.badInput||c.typeMismatch?void 0:a})}function Yd(a){a.$$parserName=\"number\";a.$parsers.push(function(b){if(a.$isEmpty(b))return null;if(Lg.test(b))return parseFloat(b)});a.$formatters.push(function(b){if(!a.$isEmpty(b)){if(!Y(b))throw qb(\"numfmt\",b);b=b.toString()}return b})}\nfunction Ta(a){v(a)&&!Y(a)&&(a=parseFloat(a));return ga(a)?void 0:a}function zc(a){var b=a.toString(),d=b.indexOf(\".\");return-1===d?-1<a&&1>a&&(a=/e-(\\d+)$/.exec(b))?Number(a[1]):0:b.length-d-1}function Zd(a,b,d){a=Number(a);if((a|0)!==a||(b|0)!==b||(d|0)!==d){var c=Math.max(zc(a),zc(b),zc(d)),c=Math.pow(10,c);a*=c;b*=c;d*=c}return 0===(a-b)%d}function $d(a,b,d,c,f){if(v(c)){a=a(c);if(!a.constant)throw qb(\"constexpr\",d,c);return a(b)}return f}function Ac(a,b){function d(a,b){if(!a||!a.length)return[];\nif(!b||!b.length)return a;var c=[],d=0;a:for(;d<a.length;d++){for(var e=a[d],f=0;f<b.length;f++)if(e===b[f])continue a;c.push(e)}return c}function c(a){var b=a;C(a)?b=a.map(c).join(\" \"):F(a)&&(b=Object.keys(a).filter(function(b){return a[b]}).join(\" \"));return b}function f(a){var b=a;if(C(a))b=a.map(f);else if(F(a)){var c=!1,b=Object.keys(a).filter(function(b){b=a[b];!c&&x(b)&&(c=!0);return b});c&&b.push(void 0)}return b}a=\"ngClass\"+a;var e;return[\"$parse\",function(g){return{restrict:\"AC\",link:function(h,\nk,l){function m(a,b){var c=[];q(a,function(a){if(0<b||H[a])H[a]=(H[a]||0)+b,H[a]===+(0<b)&&c.push(a)});return c.join(\" \")}function n(a){if(a===b){var c=t,c=m(c&&c.split(\" \"),1);l.$addClass(c)}else c=t,c=m(c&&c.split(\" \"),-1),l.$removeClass(c);w=a}function p(a){a=c(a);a!==t&&r(a)}function r(a){if(w===b){var c=t&&t.split(\" \"),e=a&&a.split(\" \"),f=d(c,e),c=d(e,c),f=m(f,-1),c=m(c,1);l.$addClass(c);l.$removeClass(f)}t=a}var s=l[a].trim(),v=\":\"===s.charAt(0)&&\":\"===s.charAt(1),s=g(s,v?f:c),u=v?p:r,H=k.data(\"$classCounts\"),\nw=!0,t;H||(H=W(),k.data(\"$classCounts\",H));\"ngClass\"!==a&&(e||(e=g(\"$index\",function(a){return a&1})),h.$watch(e,n));h.$watch(s,u,v)}}}]}function Ob(a,b,d,c,f,e,g,h,k){this.$modelValue=this.$viewValue=Number.NaN;this.$$rawModelValue=void 0;this.$validators={};this.$asyncValidators={};this.$parsers=[];this.$formatters=[];this.$viewChangeListeners=[];this.$untouched=!0;this.$touched=!1;this.$pristine=!0;this.$dirty=!1;this.$valid=!0;this.$invalid=!1;this.$error={};this.$$success={};this.$pending=void 0;\nthis.$name=k(d.name||\"\",!1)(a);this.$$parentForm=Mb;this.$options=Pb;this.$$parsedNgModel=f(d.ngModel);this.$$parsedNgModelAssign=this.$$parsedNgModel.assign;this.$$ngModelGet=this.$$parsedNgModel;this.$$ngModelSet=this.$$parsedNgModelAssign;this.$$pendingDebounce=null;this.$$parserValid=void 0;this.$$currentValidationRunId=0;this.$$scope=a;this.$$attr=d;this.$$element=c;this.$$animate=e;this.$$timeout=g;this.$$parse=f;this.$$q=h;this.$$exceptionHandler=b;Td(this);Mg(this)}function Mg(a){a.$$scope.$watch(function(){var b=\na.$$ngModelGet(a.$$scope);if(b!==a.$modelValue&&(a.$modelValue===a.$modelValue||b===b)){a.$modelValue=a.$$rawModelValue=b;a.$$parserValid=void 0;for(var d=a.$formatters,c=d.length,f=b;c--;)f=d[c](f);a.$viewValue!==f&&(a.$$updateEmptyClasses(f),a.$viewValue=a.$$lastCommittedViewValue=f,a.$render(),a.$$runValidators(a.$modelValue,a.$viewValue,w))}return b})}function Bc(a){this.$$options=a}function ae(a,b){q(b,function(b,c){v(a[c])||(a[c]=b)})}var Ng=/^\\/(.+)\\/([a-z]*)$/,va=Object.prototype.hasOwnProperty,\nP=function(a){return E(a)?a.toLowerCase():a},vb=function(a){return E(a)?a.toUpperCase():a},La,D,oa,wa=[].slice,ng=[].splice,Og=[].push,na=Object.prototype.toString,Gc=Object.getPrototypeOf,Ga=M(\"ng\"),$=z.angular||(z.angular={}),Zb,rb=0;La=z.document.documentMode;var ga=Number.isNaN||function(a){return a!==a};w.$inject=[];Ya.$inject=[];var C=Array.isArray,le=/^\\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/,S=function(a){return E(a)?a.trim():a},Gd=function(a){return a.replace(/([-()[\\]{}+?*.$^|,:#<!\\\\])/g,\n\"\\\\$1\").replace(/\\x08/g,\"\\\\x08\")},za=function(){if(!v(za.rules)){var a=z.document.querySelector(\"[ng-csp]\")||z.document.querySelector(\"[data-ng-csp]\");if(a){var b=a.getAttribute(\"ng-csp\")||a.getAttribute(\"data-ng-csp\");za.rules={noUnsafeEval:!b||-1!==b.indexOf(\"no-unsafe-eval\"),noInlineStyle:!b||-1!==b.indexOf(\"no-inline-style\")}}else{a=za;try{new Function(\"\"),b=!1}catch(d){b=!0}a.rules={noUnsafeEval:b,noInlineStyle:!1}}}return za.rules},sb=function(){if(v(sb.name_))return sb.name_;var a,b,d=Ka.length,\nc,f;for(b=0;b<d;++b)if(c=Ka[b],a=z.document.querySelector(\"[\"+c.replace(\":\",\"\\\\:\")+\"jq]\")){f=a.getAttribute(c+\"jq\");break}return sb.name_=f},ne=/:/g,Ka=[\"ng-\",\"data-ng-\",\"ng:\",\"x-ng-\"],qe=function(a){if(!a.currentScript)return!0;var b=a.currentScript.getAttribute(\"src\"),d=a.createElement(\"a\");d.href=b;if(a.location.origin===d.origin)return!0;switch(d.protocol){case \"http:\":case \"https:\":case \"ftp:\":case \"blob:\":case \"file:\":case \"data:\":return!0;default:return!1}}(z.document),te=/[A-Z]/g,Oc=!1,Ja=\n3,ye={full:\"1.6.1\",major:1,minor:6,dot:1,codeName:\"promise-rectification\"};X.expando=\"ng339\";var ib=X.cache={},$f=1;X._data=function(a){return this.cache[a[this.expando]]||{}};var Wf=/-([a-z])/g,Pg=/^-ms-/,Ab={mouseleave:\"mouseout\",mouseenter:\"mouseover\"},ac=M(\"jqLite\"),Zf=/^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/,$b=/<|&#?\\w+;/,Xf=/<([\\w:-]+)/,Yf=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,ha={option:[1,'<select multiple=\"multiple\">',\"</select>\"],thead:[1,\"<table>\",\"</table>\"],\ncol:[2,\"<table><colgroup>\",\"</colgroup></table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],_default:[0,\"\",\"\"]};ha.optgroup=ha.option;ha.tbody=ha.tfoot=ha.colgroup=ha.caption=ha.thead;ha.th=ha.td;var eg=z.Node.prototype.contains||function(a){return!!(this.compareDocumentPosition(a)&16)},Oa=X.prototype={ready:$c,toString:function(){var a=[];q(this,function(b){a.push(\"\"+b)});return\"[\"+a.join(\", \")+\"]\"},eq:function(a){return 0<=a?D(this[a]):D(this[this.length+\na])},length:0,push:Og,sort:[].sort,splice:[].splice},Gb={};q(\"multiple selected checked disabled readOnly required open\".split(\" \"),function(a){Gb[P(a)]=a});var ed={};q(\"input select option textarea button form details\".split(\" \"),function(a){ed[a]=!0});var ld={ngMinlength:\"minlength\",ngMaxlength:\"maxlength\",ngMin:\"min\",ngMax:\"max\",ngPattern:\"pattern\",ngStep:\"step\"};q({data:dc,removeData:hb,hasData:function(a){for(var b in ib[a.ng339])return!0;return!1},cleanData:function(a){for(var b=0,d=a.length;b<\nd;b++)hb(a[b])}},function(a,b){X[b]=a});q({data:dc,inheritedData:Eb,scope:function(a){return D.data(a,\"$scope\")||Eb(a.parentNode||a,[\"$isolateScope\",\"$scope\"])},isolateScope:function(a){return D.data(a,\"$isolateScope\")||D.data(a,\"$isolateScopeNoTemplate\")},controller:bd,injector:function(a){return Eb(a,\"$injector\")},removeAttr:function(a,b){a.removeAttribute(b)},hasClass:Bb,css:function(a,b,d){b=xb(b.replace(Pg,\"ms-\"));if(v(d))a.style[b]=d;else return a.style[b]},attr:function(a,b,d){var c=a.nodeType;\nif(c!==Ja&&2!==c&&8!==c&&a.getAttribute){var c=P(b),f=Gb[c];if(v(d))null===d||!1===d&&f?a.removeAttribute(b):a.setAttribute(b,f?c:d);else return a=a.getAttribute(b),f&&null!==a&&(a=c),null===a?void 0:a}},prop:function(a,b,d){if(v(d))a[b]=d;else return a[b]},text:function(){function a(a,d){if(x(d)){var c=a.nodeType;return 1===c||c===Ja?a.textContent:\"\"}a.textContent=d}a.$dv=\"\";return a}(),val:function(a,b){if(x(b)){if(a.multiple&&\"select\"===xa(a)){var d=[];q(a.options,function(a){a.selected&&d.push(a.value||\na.text)});return d}return a.value}a.value=b},html:function(a,b){if(x(b))return a.innerHTML;yb(a,!0);a.innerHTML=b},empty:cd},function(a,b){X.prototype[b]=function(b,c){var f,e,g=this.length;if(a!==cd&&x(2===a.length&&a!==Bb&&a!==bd?b:c)){if(F(b)){for(f=0;f<g;f++)if(a===dc)a(this[f],b);else for(e in b)a(this[f],e,b[e]);return this}f=a.$dv;g=x(f)?Math.min(g,1):g;for(e=0;e<g;e++){var h=a(this[e],b,c);f=f?f+h:h}return f}for(f=0;f<g;f++)a(this[f],b,c);return this}});q({removeData:hb,on:function(a,b,d,\nc){if(v(c))throw ac(\"onargs\");if(Yc(a)){c=zb(a,!0);var f=c.events,e=c.handle;e||(e=c.handle=bg(a,f));c=0<=b.indexOf(\" \")?b.split(\" \"):[b];for(var g=c.length,h=function(b,c,g){var h=f[b];h||(h=f[b]=[],h.specialHandlerWrapper=c,\"$destroy\"===b||g||a.addEventListener(b,e));h.push(d)};g--;)b=c[g],Ab[b]?(h(Ab[b],dg),h(b,void 0,!0)):h(b)}},off:ad,one:function(a,b,d){a=D(a);a.on(b,function f(){a.off(b,d);a.off(b,f)});a.on(b,d)},replaceWith:function(a,b){var d,c=a.parentNode;yb(a);q(new X(b),function(b){d?\nc.insertBefore(b,d.nextSibling):c.replaceChild(b,a);d=b})},children:function(a){var b=[];q(a.childNodes,function(a){1===a.nodeType&&b.push(a)});return b},contents:function(a){return a.contentDocument||a.childNodes||[]},append:function(a,b){var d=a.nodeType;if(1===d||11===d){b=new X(b);for(var d=0,c=b.length;d<c;d++)a.appendChild(b[d])}},prepend:function(a,b){if(1===a.nodeType){var d=a.firstChild;q(new X(b),function(b){a.insertBefore(b,d)})}},wrap:function(a,b){var d=D(b).eq(0).clone()[0],c=a.parentNode;\nc&&c.replaceChild(d,a);d.appendChild(a)},remove:Fb,detach:function(a){Fb(a,!0)},after:function(a,b){var d=a,c=a.parentNode;if(c){b=new X(b);for(var f=0,e=b.length;f<e;f++){var g=b[f];c.insertBefore(g,d.nextSibling);d=g}}},addClass:Db,removeClass:Cb,toggleClass:function(a,b,d){b&&q(b.split(\" \"),function(b){var f=d;x(f)&&(f=!Bb(a,b));(f?Db:Cb)(a,b)})},parent:function(a){return(a=a.parentNode)&&11!==a.nodeType?a:null},next:function(a){return a.nextElementSibling},find:function(a,b){return a.getElementsByTagName?\na.getElementsByTagName(b):[]},clone:cc,triggerHandler:function(a,b,d){var c,f,e=b.type||b,g=zb(a);if(g=(g=g&&g.events)&&g[e])c={preventDefault:function(){this.defaultPrevented=!0},isDefaultPrevented:function(){return!0===this.defaultPrevented},stopImmediatePropagation:function(){this.immediatePropagationStopped=!0},isImmediatePropagationStopped:function(){return!0===this.immediatePropagationStopped},stopPropagation:w,type:e,target:a},b.type&&(c=R(c,b)),b=ra(g),f=d?[c].concat(d):[c],q(b,function(b){c.isImmediatePropagationStopped()||\nb.apply(a,f)})}},function(a,b){X.prototype[b]=function(b,c,f){for(var e,g=0,h=this.length;g<h;g++)x(e)?(e=a(this[g],b,c,f),v(e)&&(e=D(e))):bc(e,a(this[g],b,c,f));return v(e)?e:this}});X.prototype.bind=X.prototype.on;X.prototype.unbind=X.prototype.off;Qa.prototype={put:function(a,b){this[la(a,this.nextUid)]=b},get:function(a){return this[la(a,this.nextUid)]},remove:function(a){var b=this[a=la(a,this.nextUid)];delete this[a];return b}};var Uf=[function(){this.$get=[function(){return Qa}]}],gg=/^([^(]+?)=>/,\nhg=/^[^(]*\\(\\s*([^)]*)\\)/m,Qg=/,/,Rg=/^\\s*(_?)(\\S+?)\\1\\s*$/,fg=/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg,da=M(\"$injector\");eb.$$annotate=function(a,b,d){var c;if(\"function\"===typeof a){if(!(c=a.$inject)){c=[];if(a.length){if(b)throw E(d)&&d||(d=a.name||ig(a)),da(\"strictdi\",d);b=fd(a);q(b[1].split(Qg),function(a){a.replace(Rg,function(a,b,d){c.push(d)})})}a.$inject=c}}else C(a)?(b=a.length-1,tb(a[b],\"fn\"),c=a.slice(0,b)):tb(a,\"fn\",!0);return c};var be=M(\"$animate\"),lf=function(){this.$get=w},mf=function(){var a=\nnew Qa,b=[];this.$get=[\"$$AnimateRunner\",\"$rootScope\",function(d,c){function f(a,b,c){var d=!1;b&&(b=E(b)?b.split(\" \"):C(b)?b:[],q(b,function(b){b&&(d=!0,a[b]=c)}));return d}function e(){q(b,function(b){var c=a.get(b);if(c){var d=jg(b.attr(\"class\")),e=\"\",f=\"\";q(c,function(a,b){a!==!!d[b]&&(a?e+=(e.length?\" \":\"\")+b:f+=(f.length?\" \":\"\")+b)});q(b,function(a){e&&Db(a,e);f&&Cb(a,f)});a.remove(b)}});b.length=0}return{enabled:w,on:w,off:w,pin:w,push:function(g,h,k,l){l&&l();k=k||{};k.from&&g.css(k.from);\nk.to&&g.css(k.to);if(k.addClass||k.removeClass)if(h=k.addClass,l=k.removeClass,k=a.get(g)||{},h=f(k,h,!0),l=f(k,l,!1),h||l)a.put(g,k),b.push(g),1===b.length&&c.$$postDigest(e);g=new d;g.complete();return g}}}]},jf=[\"$provide\",function(a){var b=this;this.$$registeredAnimations=Object.create(null);this.register=function(d,c){if(d&&\".\"!==d.charAt(0))throw be(\"notcsel\",d);var f=d+\"-animation\";b.$$registeredAnimations[d.substr(1)]=f;a.factory(f,c)};this.classNameFilter=function(a){if(1===arguments.length&&\n(this.$$classNameFilter=a instanceof RegExp?a:null)&&/(\\s+|\\/)ng-animate(\\s+|\\/)/.test(this.$$classNameFilter.toString()))throw be(\"nongcls\",\"ng-animate\");return this.$$classNameFilter};this.$get=[\"$$animateQueue\",function(a){function b(a,c,d){if(d){var h;a:{for(h=0;h<d.length;h++){var k=d[h];if(1===k.nodeType){h=k;break a}}h=void 0}!h||h.parentNode||h.previousElementSibling||(d=null)}d?d.after(a):c.prepend(a)}return{on:a.on,off:a.off,pin:a.pin,enabled:a.enabled,cancel:function(a){a.end&&a.end()},\nenter:function(f,e,g,h){e=e&&D(e);g=g&&D(g);e=e||g.parent();b(f,e,g);return a.push(f,\"enter\",Aa(h))},move:function(f,e,g,h){e=e&&D(e);g=g&&D(g);e=e||g.parent();b(f,e,g);return a.push(f,\"move\",Aa(h))},leave:function(b,c){return a.push(b,\"leave\",Aa(c),function(){b.remove()})},addClass:function(b,c,g){g=Aa(g);g.addClass=jb(g.addclass,c);return a.push(b,\"addClass\",g)},removeClass:function(b,c,g){g=Aa(g);g.removeClass=jb(g.removeClass,c);return a.push(b,\"removeClass\",g)},setClass:function(b,c,g,h){h=Aa(h);\nh.addClass=jb(h.addClass,c);h.removeClass=jb(h.removeClass,g);return a.push(b,\"setClass\",h)},animate:function(b,c,g,h,k){k=Aa(k);k.from=k.from?R(k.from,c):c;k.to=k.to?R(k.to,g):g;k.tempClasses=jb(k.tempClasses,h||\"ng-inline-animate\");return a.push(b,\"animate\",k)}}}]}],of=function(){this.$get=[\"$$rAF\",function(a){function b(b){d.push(b);1<d.length||a(function(){for(var a=0;a<d.length;a++)d[a]();d=[]})}var d=[];return function(){var a=!1;b(function(){a=!0});return function(d){a?d():b(d)}}}]},nf=function(){this.$get=\n[\"$q\",\"$sniffer\",\"$$animateAsyncRun\",\"$$isDocumentHidden\",\"$timeout\",function(a,b,d,c,f){function e(a){this.setHost(a);var b=d();this._doneCallbacks=[];this._tick=function(a){c()?f(a,0,!1):b(a)};this._state=0}e.chain=function(a,b){function c(){if(d===a.length)b(!0);else a[d](function(a){!1===a?b(!1):(d++,c())})}var d=0;c()};e.all=function(a,b){function c(f){e=e&&f;++d===a.length&&b(e)}var d=0,e=!0;q(a,function(a){a.done(c)})};e.prototype={setHost:function(a){this.host=a||{}},done:function(a){2===\nthis._state?a():this._doneCallbacks.push(a)},progress:w,getPromise:function(){if(!this.promise){var b=this;this.promise=a(function(a,c){b.done(function(b){!1===b?c():a()})})}return this.promise},then:function(a,b){return this.getPromise().then(a,b)},\"catch\":function(a){return this.getPromise()[\"catch\"](a)},\"finally\":function(a){return this.getPromise()[\"finally\"](a)},pause:function(){this.host.pause&&this.host.pause()},resume:function(){this.host.resume&&this.host.resume()},end:function(){this.host.end&&\nthis.host.end();this._resolve(!0)},cancel:function(){this.host.cancel&&this.host.cancel();this._resolve(!1)},complete:function(a){var b=this;0===b._state&&(b._state=1,b._tick(function(){b._resolve(a)}))},_resolve:function(a){2!==this._state&&(q(this._doneCallbacks,function(b){b(a)}),this._doneCallbacks.length=0,this._state=2)}};return e}]},kf=function(){this.$get=[\"$$rAF\",\"$q\",\"$$AnimateRunner\",function(a,b,d){return function(b,f){function e(){a(function(){g.addClass&&(b.addClass(g.addClass),g.addClass=\nnull);g.removeClass&&(b.removeClass(g.removeClass),g.removeClass=null);g.to&&(b.css(g.to),g.to=null);h||k.complete();h=!0});return k}var g=f||{};g.$$prepared||(g=Fa(g));g.cleanupStyles&&(g.from=g.to=null);g.from&&(b.css(g.from),g.from=null);var h,k=new d;return{start:e,end:e}}}]},ea=M(\"$compile\"),hc=new function(){};Qc.$inject=[\"$provide\",\"$$sanitizeUriProvider\"];Ib.prototype.isFirstChange=function(){return this.previousValue===hc};var gd=/^((?:x|data)[:\\-_])/i,mg=/[:\\-_]+(.)/g,nd=M(\"$controller\"),\nmd=/^(\\S+)(\\s+as\\s+([\\w$]+))?$/,vf=function(){this.$get=[\"$document\",function(a){return function(b){b?!b.nodeType&&b instanceof D&&(b=b[0]):b=a[0].body;return b.offsetWidth+1}}]},od=\"application/json\",kc={\"Content-Type\":od+\";charset=utf-8\"},pg=/^\\[|^\\{(?!\\{)/,qg={\"[\":/]$/,\"{\":/}$/},og=/^\\)]\\}',?\\n/,td=M(\"$http\"),Ea=$.$interpolateMinErr=M(\"$interpolate\");Ea.throwNoconcat=function(a){throw Ea(\"noconcat\",a);};Ea.interr=function(a,b){return Ea(\"interr\",a,b.toString())};var Df=function(){this.$get=[\"$window\",\nfunction(a){function b(a){var b=function(a){b.data=a;b.called=!0};b.id=a;return b}var d=a.angular.callbacks,c={};return{createCallback:function(a){a=\"_\"+(d.$$counter++).toString(36);var e=\"angular.callbacks.\"+a,g=b(a);c[e]=d[a]=g;return e},wasCalled:function(a){return c[a].called},getResponse:function(a){return c[a].data},removeCallback:function(a){delete d[c[a].id];delete c[a]}}}]},Sg=/^([^?#]*)(\\?([^#]*))?(#(.*))?$/,sg={http:80,https:443,ftp:21},lb=M(\"$location\"),tg=/^\\s*[\\\\/]{2,}/,Tg={$$absUrl:\"\",\n$$html5:!1,$$replace:!1,absUrl:Jb(\"$$absUrl\"),url:function(a){if(x(a))return this.$$url;var b=Sg.exec(a);(b[1]||\"\"===a)&&this.path(decodeURIComponent(b[1]));(b[2]||b[1]||\"\"===a)&&this.search(b[3]||\"\");this.hash(b[5]||\"\");return this},protocol:Jb(\"$$protocol\"),host:Jb(\"$$host\"),port:Jb(\"$$port\"),path:xd(\"$$path\",function(a){a=null!==a?a.toString():\"\";return\"/\"===a.charAt(0)?a:\"/\"+a}),search:function(a,b){switch(arguments.length){case 0:return this.$$search;case 1:if(E(a)||Y(a))a=a.toString(),this.$$search=\nLc(a);else if(F(a))a=Fa(a,{}),q(a,function(b,c){null==b&&delete a[c]}),this.$$search=a;else throw lb(\"isrcharg\");break;default:x(b)||null===b?delete this.$$search[a]:this.$$search[a]=b}this.$$compose();return this},hash:xd(\"$$hash\",function(a){return null!==a?a.toString():\"\"}),replace:function(){this.$$replace=!0;return this}};q([wd,oc,nc],function(a){a.prototype=Object.create(Tg);a.prototype.state=function(b){if(!arguments.length)return this.$$state;if(a!==nc||!this.$$html5)throw lb(\"nostate\");this.$$state=\nx(b)?null:b;return this}});var Ua=M(\"$parse\"),wg={}.constructor.prototype.valueOf,Qb=W();q(\"+ - * / % === !== == != < > <= >= && || ! = |\".split(\" \"),function(a){Qb[a]=!0});var Ug={n:\"\\n\",f:\"\\f\",r:\"\\r\",t:\"\\t\",v:\"\\v\",\"'\":\"'\",'\"':'\"'},qc=function(a){this.options=a};qc.prototype={constructor:qc,lex:function(a){this.text=a;this.index=0;for(this.tokens=[];this.index<this.text.length;)if(a=this.text.charAt(this.index),'\"'===a||\"'\"===a)this.readString(a);else if(this.isNumber(a)||\".\"===a&&this.isNumber(this.peek()))this.readNumber();\nelse if(this.isIdentifierStart(this.peekMultichar()))this.readIdent();else if(this.is(a,\"(){}[].,;:?\"))this.tokens.push({index:this.index,text:a}),this.index++;else if(this.isWhitespace(a))this.index++;else{var b=a+this.peek(),d=b+this.peek(2),c=Qb[b],f=Qb[d];Qb[a]||c||f?(a=f?d:c?b:a,this.tokens.push({index:this.index,text:a,operator:!0}),this.index+=a.length):this.throwError(\"Unexpected next character \",this.index,this.index+1)}return this.tokens},is:function(a,b){return-1!==b.indexOf(a)},peek:function(a){a=\na||1;return this.index+a<this.text.length?this.text.charAt(this.index+a):!1},isNumber:function(a){return\"0\"<=a&&\"9\">=a&&\"string\"===typeof a},isWhitespace:function(a){return\" \"===a||\"\\r\"===a||\"\\t\"===a||\"\\n\"===a||\"\\v\"===a||\"\\u00a0\"===a},isIdentifierStart:function(a){return this.options.isIdentifierStart?this.options.isIdentifierStart(a,this.codePointAt(a)):this.isValidIdentifierStart(a)},isValidIdentifierStart:function(a){return\"a\"<=a&&\"z\">=a||\"A\"<=a&&\"Z\">=a||\"_\"===a||\"$\"===a},isIdentifierContinue:function(a){return this.options.isIdentifierContinue?\nthis.options.isIdentifierContinue(a,this.codePointAt(a)):this.isValidIdentifierContinue(a)},isValidIdentifierContinue:function(a,b){return this.isValidIdentifierStart(a,b)||this.isNumber(a)},codePointAt:function(a){return 1===a.length?a.charCodeAt(0):(a.charCodeAt(0)<<10)+a.charCodeAt(1)-56613888},peekMultichar:function(){var a=this.text.charAt(this.index),b=this.peek();if(!b)return a;var d=a.charCodeAt(0),c=b.charCodeAt(0);return 55296<=d&&56319>=d&&56320<=c&&57343>=c?a+b:a},isExpOperator:function(a){return\"-\"===\na||\"+\"===a||this.isNumber(a)},throwError:function(a,b,d){d=d||this.index;b=v(b)?\"s \"+b+\"-\"+this.index+\" [\"+this.text.substring(b,d)+\"]\":\" \"+d;throw Ua(\"lexerr\",a,b,this.text);},readNumber:function(){for(var a=\"\",b=this.index;this.index<this.text.length;){var d=P(this.text.charAt(this.index));if(\".\"===d||this.isNumber(d))a+=d;else{var c=this.peek();if(\"e\"===d&&this.isExpOperator(c))a+=d;else if(this.isExpOperator(d)&&c&&this.isNumber(c)&&\"e\"===a.charAt(a.length-1))a+=d;else if(!this.isExpOperator(d)||\nc&&this.isNumber(c)||\"e\"!==a.charAt(a.length-1))break;else this.throwError(\"Invalid exponent\")}this.index++}this.tokens.push({index:b,text:a,constant:!0,value:Number(a)})},readIdent:function(){var a=this.index;for(this.index+=this.peekMultichar().length;this.index<this.text.length;){var b=this.peekMultichar();if(!this.isIdentifierContinue(b))break;this.index+=b.length}this.tokens.push({index:a,text:this.text.slice(a,this.index),identifier:!0})},readString:function(a){var b=this.index;this.index++;\nfor(var d=\"\",c=a,f=!1;this.index<this.text.length;){var e=this.text.charAt(this.index),c=c+e;if(f)\"u\"===e?(f=this.text.substring(this.index+1,this.index+5),f.match(/[\\da-f]{4}/i)||this.throwError(\"Invalid unicode escape [\\\\u\"+f+\"]\"),this.index+=4,d+=String.fromCharCode(parseInt(f,16))):d+=Ug[e]||e,f=!1;else if(\"\\\\\"===e)f=!0;else{if(e===a){this.index++;this.tokens.push({index:b,text:c,constant:!0,value:d});return}d+=e}this.index++}this.throwError(\"Unterminated quote\",b)}};var s=function(a,b){this.lexer=\na;this.options=b};s.Program=\"Program\";s.ExpressionStatement=\"ExpressionStatement\";s.AssignmentExpression=\"AssignmentExpression\";s.ConditionalExpression=\"ConditionalExpression\";s.LogicalExpression=\"LogicalExpression\";s.BinaryExpression=\"BinaryExpression\";s.UnaryExpression=\"UnaryExpression\";s.CallExpression=\"CallExpression\";s.MemberExpression=\"MemberExpression\";s.Identifier=\"Identifier\";s.Literal=\"Literal\";s.ArrayExpression=\"ArrayExpression\";s.Property=\"Property\";s.ObjectExpression=\"ObjectExpression\";\ns.ThisExpression=\"ThisExpression\";s.LocalsExpression=\"LocalsExpression\";s.NGValueParameter=\"NGValueParameter\";s.prototype={ast:function(a){this.text=a;this.tokens=this.lexer.lex(a);a=this.program();0!==this.tokens.length&&this.throwError(\"is an unexpected token\",this.tokens[0]);return a},program:function(){for(var a=[];;)if(0<this.tokens.length&&!this.peek(\"}\",\")\",\";\",\"]\")&&a.push(this.expressionStatement()),!this.expect(\";\"))return{type:s.Program,body:a}},expressionStatement:function(){return{type:s.ExpressionStatement,\nexpression:this.filterChain()}},filterChain:function(){for(var a=this.expression();this.expect(\"|\");)a=this.filter(a);return a},expression:function(){return this.assignment()},assignment:function(){var a=this.ternary();if(this.expect(\"=\")){if(!Ad(a))throw Ua(\"lval\");a={type:s.AssignmentExpression,left:a,right:this.assignment(),operator:\"=\"}}return a},ternary:function(){var a=this.logicalOR(),b,d;return this.expect(\"?\")&&(b=this.expression(),this.consume(\":\"))?(d=this.expression(),{type:s.ConditionalExpression,\ntest:a,alternate:b,consequent:d}):a},logicalOR:function(){for(var a=this.logicalAND();this.expect(\"||\");)a={type:s.LogicalExpression,operator:\"||\",left:a,right:this.logicalAND()};return a},logicalAND:function(){for(var a=this.equality();this.expect(\"&&\");)a={type:s.LogicalExpression,operator:\"&&\",left:a,right:this.equality()};return a},equality:function(){for(var a=this.relational(),b;b=this.expect(\"==\",\"!=\",\"===\",\"!==\");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.relational()};\nreturn a},relational:function(){for(var a=this.additive(),b;b=this.expect(\"<\",\">\",\"<=\",\">=\");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.additive()};return a},additive:function(){for(var a=this.multiplicative(),b;b=this.expect(\"+\",\"-\");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.multiplicative()};return a},multiplicative:function(){for(var a=this.unary(),b;b=this.expect(\"*\",\"/\",\"%\");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.unary()};return a},\nunary:function(){var a;return(a=this.expect(\"+\",\"-\",\"!\"))?{type:s.UnaryExpression,operator:a.text,prefix:!0,argument:this.unary()}:this.primary()},primary:function(){var a;this.expect(\"(\")?(a=this.filterChain(),this.consume(\")\")):this.expect(\"[\")?a=this.arrayDeclaration():this.expect(\"{\")?a=this.object():this.selfReferential.hasOwnProperty(this.peek().text)?a=Fa(this.selfReferential[this.consume().text]):this.options.literals.hasOwnProperty(this.peek().text)?a={type:s.Literal,value:this.options.literals[this.consume().text]}:\nthis.peek().identifier?a=this.identifier():this.peek().constant?a=this.constant():this.throwError(\"not a primary expression\",this.peek());for(var b;b=this.expect(\"(\",\"[\",\".\");)\"(\"===b.text?(a={type:s.CallExpression,callee:a,arguments:this.parseArguments()},this.consume(\")\")):\"[\"===b.text?(a={type:s.MemberExpression,object:a,property:this.expression(),computed:!0},this.consume(\"]\")):\".\"===b.text?a={type:s.MemberExpression,object:a,property:this.identifier(),computed:!1}:this.throwError(\"IMPOSSIBLE\");\nreturn a},filter:function(a){a=[a];for(var b={type:s.CallExpression,callee:this.identifier(),arguments:a,filter:!0};this.expect(\":\");)a.push(this.expression());return b},parseArguments:function(){var a=[];if(\")\"!==this.peekToken().text){do a.push(this.filterChain());while(this.expect(\",\"))}return a},identifier:function(){var a=this.consume();a.identifier||this.throwError(\"is not a valid identifier\",a);return{type:s.Identifier,name:a.text}},constant:function(){return{type:s.Literal,value:this.consume().value}},\narrayDeclaration:function(){var a=[];if(\"]\"!==this.peekToken().text){do{if(this.peek(\"]\"))break;a.push(this.expression())}while(this.expect(\",\"))}this.consume(\"]\");return{type:s.ArrayExpression,elements:a}},object:function(){var a=[],b;if(\"}\"!==this.peekToken().text){do{if(this.peek(\"}\"))break;b={type:s.Property,kind:\"init\"};this.peek().constant?(b.key=this.constant(),b.computed=!1,this.consume(\":\"),b.value=this.expression()):this.peek().identifier?(b.key=this.identifier(),b.computed=!1,this.peek(\":\")?\n(this.consume(\":\"),b.value=this.expression()):b.value=b.key):this.peek(\"[\")?(this.consume(\"[\"),b.key=this.expression(),this.consume(\"]\"),b.computed=!0,this.consume(\":\"),b.value=this.expression()):this.throwError(\"invalid key\",this.peek());a.push(b)}while(this.expect(\",\"))}this.consume(\"}\");return{type:s.ObjectExpression,properties:a}},throwError:function(a,b){throw Ua(\"syntax\",b.text,a,b.index+1,this.text,this.text.substring(b.index));},consume:function(a){if(0===this.tokens.length)throw Ua(\"ueoe\",\nthis.text);var b=this.expect(a);b||this.throwError(\"is unexpected, expecting [\"+a+\"]\",this.peek());return b},peekToken:function(){if(0===this.tokens.length)throw Ua(\"ueoe\",this.text);return this.tokens[0]},peek:function(a,b,d,c){return this.peekAhead(0,a,b,d,c)},peekAhead:function(a,b,d,c,f){if(this.tokens.length>a){a=this.tokens[a];var e=a.text;if(e===b||e===d||e===c||e===f||!(b||d||c||f))return a}return!1},expect:function(a,b,d,c){return(a=this.peek(a,b,d,c))?(this.tokens.shift(),a):!1},selfReferential:{\"this\":{type:s.ThisExpression},\n$locals:{type:s.LocalsExpression}}};Dd.prototype={compile:function(a){var b=this;a=this.astBuilder.ast(a);this.state={nextId:0,filters:{},fn:{vars:[],body:[],own:{}},assign:{vars:[],body:[],own:{}},inputs:[]};V(a,b.$filter);var d=\"\",c;this.stage=\"assign\";if(c=Bd(a))this.state.computing=\"assign\",d=this.nextId(),this.recurse(c,d),this.return_(d),d=\"fn.assign=\"+this.generateFunction(\"assign\",\"s,v,l\");c=zd(a.body);b.stage=\"inputs\";q(c,function(a,c){var d=\"fn\"+c;b.state[d]={vars:[],body:[],own:{}};b.state.computing=\nd;var h=b.nextId();b.recurse(a,h);b.return_(h);b.state.inputs.push(d);a.watchId=c});this.state.computing=\"fn\";this.stage=\"main\";this.recurse(a);d='\"'+this.USE+\" \"+this.STRICT+'\";\\n'+this.filterPrefix()+\"var fn=\"+this.generateFunction(\"fn\",\"s,l,a,i\")+d+this.watchFns()+\"return fn;\";d=(new Function(\"$filter\",\"getStringValue\",\"ifDefined\",\"plus\",d))(this.$filter,ug,vg,yd);this.state=this.stage=void 0;d.literal=Cd(a);d.constant=a.constant;return d},USE:\"use\",STRICT:\"strict\",watchFns:function(){var a=[],\nb=this.state.inputs,d=this;q(b,function(b){a.push(\"var \"+b+\"=\"+d.generateFunction(b,\"s\"))});b.length&&a.push(\"fn.inputs=[\"+b.join(\",\")+\"];\");return a.join(\"\")},generateFunction:function(a,b){return\"function(\"+b+\"){\"+this.varsPrefix(a)+this.body(a)+\"};\"},filterPrefix:function(){var a=[],b=this;q(this.state.filters,function(d,c){a.push(d+\"=$filter(\"+b.escape(c)+\")\")});return a.length?\"var \"+a.join(\",\")+\";\":\"\"},varsPrefix:function(a){return this.state[a].vars.length?\"var \"+this.state[a].vars.join(\",\")+\n\";\":\"\"},body:function(a){return this.state[a].body.join(\"\")},recurse:function(a,b,d,c,f,e){var g,h,k=this,l,m,n;c=c||w;if(!e&&v(a.watchId))b=b||this.nextId(),this.if_(\"i\",this.lazyAssign(b,this.computedMember(\"i\",a.watchId)),this.lazyRecurse(a,b,d,c,f,!0));else switch(a.type){case s.Program:q(a.body,function(b,c){k.recurse(b.expression,void 0,void 0,function(a){h=a});c!==a.body.length-1?k.current().body.push(h,\";\"):k.return_(h)});break;case s.Literal:m=this.escape(a.value);this.assign(b,m);c(b||m);\nbreak;case s.UnaryExpression:this.recurse(a.argument,void 0,void 0,function(a){h=a});m=a.operator+\"(\"+this.ifDefined(h,0)+\")\";this.assign(b,m);c(m);break;case s.BinaryExpression:this.recurse(a.left,void 0,void 0,function(a){g=a});this.recurse(a.right,void 0,void 0,function(a){h=a});m=\"+\"===a.operator?this.plus(g,h):\"-\"===a.operator?this.ifDefined(g,0)+a.operator+this.ifDefined(h,0):\"(\"+g+\")\"+a.operator+\"(\"+h+\")\";this.assign(b,m);c(m);break;case s.LogicalExpression:b=b||this.nextId();k.recurse(a.left,\nb);k.if_(\"&&\"===a.operator?b:k.not(b),k.lazyRecurse(a.right,b));c(b);break;case s.ConditionalExpression:b=b||this.nextId();k.recurse(a.test,b);k.if_(b,k.lazyRecurse(a.alternate,b),k.lazyRecurse(a.consequent,b));c(b);break;case s.Identifier:b=b||this.nextId();d&&(d.context=\"inputs\"===k.stage?\"s\":this.assign(this.nextId(),this.getHasOwnProperty(\"l\",a.name)+\"?l:s\"),d.computed=!1,d.name=a.name);k.if_(\"inputs\"===k.stage||k.not(k.getHasOwnProperty(\"l\",a.name)),function(){k.if_(\"inputs\"===k.stage||\"s\",function(){f&&\n1!==f&&k.if_(k.isNull(k.nonComputedMember(\"s\",a.name)),k.lazyAssign(k.nonComputedMember(\"s\",a.name),\"{}\"));k.assign(b,k.nonComputedMember(\"s\",a.name))})},b&&k.lazyAssign(b,k.nonComputedMember(\"l\",a.name)));c(b);break;case s.MemberExpression:g=d&&(d.context=this.nextId())||this.nextId();b=b||this.nextId();k.recurse(a.object,g,void 0,function(){k.if_(k.notNull(g),function(){a.computed?(h=k.nextId(),k.recurse(a.property,h),k.getStringValue(h),f&&1!==f&&k.if_(k.not(k.computedMember(g,h)),k.lazyAssign(k.computedMember(g,\nh),\"{}\")),m=k.computedMember(g,h),k.assign(b,m),d&&(d.computed=!0,d.name=h)):(f&&1!==f&&k.if_(k.isNull(k.nonComputedMember(g,a.property.name)),k.lazyAssign(k.nonComputedMember(g,a.property.name),\"{}\")),m=k.nonComputedMember(g,a.property.name),k.assign(b,m),d&&(d.computed=!1,d.name=a.property.name))},function(){k.assign(b,\"undefined\")});c(b)},!!f);break;case s.CallExpression:b=b||this.nextId();a.filter?(h=k.filter(a.callee.name),l=[],q(a.arguments,function(a){var b=k.nextId();k.recurse(a,b);l.push(b)}),\nm=h+\"(\"+l.join(\",\")+\")\",k.assign(b,m),c(b)):(h=k.nextId(),g={},l=[],k.recurse(a.callee,h,g,function(){k.if_(k.notNull(h),function(){q(a.arguments,function(b){k.recurse(b,a.constant?void 0:k.nextId(),void 0,function(a){l.push(a)})});m=g.name?k.member(g.context,g.name,g.computed)+\"(\"+l.join(\",\")+\")\":h+\"(\"+l.join(\",\")+\")\";k.assign(b,m)},function(){k.assign(b,\"undefined\")});c(b)}));break;case s.AssignmentExpression:h=this.nextId();g={};this.recurse(a.left,void 0,g,function(){k.if_(k.notNull(g.context),\nfunction(){k.recurse(a.right,h);m=k.member(g.context,g.name,g.computed)+a.operator+h;k.assign(b,m);c(b||m)})},1);break;case s.ArrayExpression:l=[];q(a.elements,function(b){k.recurse(b,a.constant?void 0:k.nextId(),void 0,function(a){l.push(a)})});m=\"[\"+l.join(\",\")+\"]\";this.assign(b,m);c(b||m);break;case s.ObjectExpression:l=[];n=!1;q(a.properties,function(a){a.computed&&(n=!0)});n?(b=b||this.nextId(),this.assign(b,\"{}\"),q(a.properties,function(a){a.computed?(g=k.nextId(),k.recurse(a.key,g)):g=a.key.type===\ns.Identifier?a.key.name:\"\"+a.key.value;h=k.nextId();k.recurse(a.value,h);k.assign(k.member(b,g,a.computed),h)})):(q(a.properties,function(b){k.recurse(b.value,a.constant?void 0:k.nextId(),void 0,function(a){l.push(k.escape(b.key.type===s.Identifier?b.key.name:\"\"+b.key.value)+\":\"+a)})}),m=\"{\"+l.join(\",\")+\"}\",this.assign(b,m));c(b||m);break;case s.ThisExpression:this.assign(b,\"s\");c(b||\"s\");break;case s.LocalsExpression:this.assign(b,\"l\");c(b||\"l\");break;case s.NGValueParameter:this.assign(b,\"v\"),c(b||\n\"v\")}},getHasOwnProperty:function(a,b){var d=a+\".\"+b,c=this.current().own;c.hasOwnProperty(d)||(c[d]=this.nextId(!1,a+\"&&(\"+this.escape(b)+\" in \"+a+\")\"));return c[d]},assign:function(a,b){if(a)return this.current().body.push(a,\"=\",b,\";\"),a},filter:function(a){this.state.filters.hasOwnProperty(a)||(this.state.filters[a]=this.nextId(!0));return this.state.filters[a]},ifDefined:function(a,b){return\"ifDefined(\"+a+\",\"+this.escape(b)+\")\"},plus:function(a,b){return\"plus(\"+a+\",\"+b+\")\"},return_:function(a){this.current().body.push(\"return \",\na,\";\")},if_:function(a,b,d){if(!0===a)b();else{var c=this.current().body;c.push(\"if(\",a,\"){\");b();c.push(\"}\");d&&(c.push(\"else{\"),d(),c.push(\"}\"))}},not:function(a){return\"!(\"+a+\")\"},isNull:function(a){return a+\"==null\"},notNull:function(a){return a+\"!=null\"},nonComputedMember:function(a,b){var d=/[^$_a-zA-Z0-9]/g;return/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(b)?a+\".\"+b:a+'[\"'+b.replace(d,this.stringEscapeFn)+'\"]'},computedMember:function(a,b){return a+\"[\"+b+\"]\"},member:function(a,b,d){return d?this.computedMember(a,\nb):this.nonComputedMember(a,b)},getStringValue:function(a){this.assign(a,\"getStringValue(\"+a+\")\")},lazyRecurse:function(a,b,d,c,f,e){var g=this;return function(){g.recurse(a,b,d,c,f,e)}},lazyAssign:function(a,b){var d=this;return function(){d.assign(a,b)}},stringEscapeRegex:/[^ a-zA-Z0-9]/g,stringEscapeFn:function(a){return\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)},escape:function(a){if(E(a))return\"'\"+a.replace(this.stringEscapeRegex,this.stringEscapeFn)+\"'\";if(Y(a))return a.toString();\nif(!0===a)return\"true\";if(!1===a)return\"false\";if(null===a)return\"null\";if(\"undefined\"===typeof a)return\"undefined\";throw Ua(\"esc\");},nextId:function(a,b){var d=\"v\"+this.state.nextId++;a||this.current().vars.push(d+(b?\"=\"+b:\"\"));return d},current:function(){return this.state[this.state.computing]}};Ed.prototype={compile:function(a){var b=this;a=this.astBuilder.ast(a);V(a,b.$filter);var d,c;if(d=Bd(a))c=this.recurse(d);d=zd(a.body);var f;d&&(f=[],q(d,function(a,c){var d=b.recurse(a);a.input=d;f.push(d);\na.watchId=c}));var e=[];q(a.body,function(a){e.push(b.recurse(a.expression))});d=0===a.body.length?w:1===a.body.length?e[0]:function(a,b){var c;q(e,function(d){c=d(a,b)});return c};c&&(d.assign=function(a,b,d){return c(a,d,b)});f&&(d.inputs=f);d.literal=Cd(a);d.constant=a.constant;return d},recurse:function(a,b,d){var c,f,e=this,g;if(a.input)return this.inputs(a.input,a.watchId);switch(a.type){case s.Literal:return this.value(a.value,b);case s.UnaryExpression:return f=this.recurse(a.argument),this[\"unary\"+\na.operator](f,b);case s.BinaryExpression:return c=this.recurse(a.left),f=this.recurse(a.right),this[\"binary\"+a.operator](c,f,b);case s.LogicalExpression:return c=this.recurse(a.left),f=this.recurse(a.right),this[\"binary\"+a.operator](c,f,b);case s.ConditionalExpression:return this[\"ternary?:\"](this.recurse(a.test),this.recurse(a.alternate),this.recurse(a.consequent),b);case s.Identifier:return e.identifier(a.name,b,d);case s.MemberExpression:return c=this.recurse(a.object,!1,!!d),a.computed||(f=a.property.name),\na.computed&&(f=this.recurse(a.property)),a.computed?this.computedMember(c,f,b,d):this.nonComputedMember(c,f,b,d);case s.CallExpression:return g=[],q(a.arguments,function(a){g.push(e.recurse(a))}),a.filter&&(f=this.$filter(a.callee.name)),a.filter||(f=this.recurse(a.callee,!0)),a.filter?function(a,c,d,e){for(var n=[],p=0;p<g.length;++p)n.push(g[p](a,c,d,e));a=f.apply(void 0,n,e);return b?{context:void 0,name:void 0,value:a}:a}:function(a,c,d,e){var n=f(a,c,d,e),p;if(null!=n.value){p=[];for(var r=0;r<\ng.length;++r)p.push(g[r](a,c,d,e));p=n.value.apply(n.context,p)}return b?{value:p}:p};case s.AssignmentExpression:return c=this.recurse(a.left,!0,1),f=this.recurse(a.right),function(a,d,e,g){var n=c(a,d,e,g);a=f(a,d,e,g);n.context[n.name]=a;return b?{value:a}:a};case s.ArrayExpression:return g=[],q(a.elements,function(a){g.push(e.recurse(a))}),function(a,c,d,e){for(var f=[],p=0;p<g.length;++p)f.push(g[p](a,c,d,e));return b?{value:f}:f};case s.ObjectExpression:return g=[],q(a.properties,function(a){a.computed?\ng.push({key:e.recurse(a.key),computed:!0,value:e.recurse(a.value)}):g.push({key:a.key.type===s.Identifier?a.key.name:\"\"+a.key.value,computed:!1,value:e.recurse(a.value)})}),function(a,c,d,e){for(var f={},p=0;p<g.length;++p)g[p].computed?f[g[p].key(a,c,d,e)]=g[p].value(a,c,d,e):f[g[p].key]=g[p].value(a,c,d,e);return b?{value:f}:f};case s.ThisExpression:return function(a){return b?{value:a}:a};case s.LocalsExpression:return function(a,c){return b?{value:c}:c};case s.NGValueParameter:return function(a,\nc,d){return b?{value:d}:d}}},\"unary+\":function(a,b){return function(d,c,f,e){d=a(d,c,f,e);d=v(d)?+d:0;return b?{value:d}:d}},\"unary-\":function(a,b){return function(d,c,f,e){d=a(d,c,f,e);d=v(d)?-d:-0;return b?{value:d}:d}},\"unary!\":function(a,b){return function(d,c,f,e){d=!a(d,c,f,e);return b?{value:d}:d}},\"binary+\":function(a,b,d){return function(c,f,e,g){var h=a(c,f,e,g);c=b(c,f,e,g);h=yd(h,c);return d?{value:h}:h}},\"binary-\":function(a,b,d){return function(c,f,e,g){var h=a(c,f,e,g);c=b(c,f,e,g);\nh=(v(h)?h:0)-(v(c)?c:0);return d?{value:h}:h}},\"binary*\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)*b(c,f,e,g);return d?{value:c}:c}},\"binary/\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)/b(c,f,e,g);return d?{value:c}:c}},\"binary%\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)%b(c,f,e,g);return d?{value:c}:c}},\"binary===\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)===b(c,f,e,g);return d?{value:c}:c}},\"binary!==\":function(a,b,d){return function(c,f,e,g){c=a(c,\nf,e,g)!==b(c,f,e,g);return d?{value:c}:c}},\"binary==\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)==b(c,f,e,g);return d?{value:c}:c}},\"binary!=\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)!=b(c,f,e,g);return d?{value:c}:c}},\"binary<\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)<b(c,f,e,g);return d?{value:c}:c}},\"binary>\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)>b(c,f,e,g);return d?{value:c}:c}},\"binary<=\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,\ng)<=b(c,f,e,g);return d?{value:c}:c}},\"binary>=\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)>=b(c,f,e,g);return d?{value:c}:c}},\"binary&&\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)&&b(c,f,e,g);return d?{value:c}:c}},\"binary||\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)||b(c,f,e,g);return d?{value:c}:c}},\"ternary?:\":function(a,b,d,c){return function(f,e,g,h){f=a(f,e,g,h)?b(f,e,g,h):d(f,e,g,h);return c?{value:f}:f}},value:function(a,b){return function(){return b?{context:void 0,\nname:void 0,value:a}:a}},identifier:function(a,b,d){return function(c,f,e,g){c=f&&a in f?f:c;d&&1!==d&&c&&null==c[a]&&(c[a]={});f=c?c[a]:void 0;return b?{context:c,name:a,value:f}:f}},computedMember:function(a,b,d,c){return function(f,e,g,h){var k=a(f,e,g,h),l,m;null!=k&&(l=b(f,e,g,h),l+=\"\",c&&1!==c&&k&&!k[l]&&(k[l]={}),m=k[l]);return d?{context:k,name:l,value:m}:m}},nonComputedMember:function(a,b,d,c){return function(f,e,g,h){f=a(f,e,g,h);c&&1!==c&&f&&null==f[b]&&(f[b]={});e=null!=f?f[b]:void 0;\nreturn d?{context:f,name:b,value:e}:e}},inputs:function(a,b){return function(d,c,f,e){return e?e[b]:a(d,c,f)}}};var rc=function(a,b,d){this.lexer=a;this.$filter=b;this.options=d;this.ast=new s(a,d);this.astCompiler=d.csp?new Ed(this.ast,b):new Dd(this.ast,b)};rc.prototype={constructor:rc,parse:function(a){return this.astCompiler.compile(a)}};var ua=M(\"$sce\"),pa={HTML:\"html\",CSS:\"css\",URL:\"url\",RESOURCE_URL:\"resourceUrl\",JS:\"js\"},sc=/_([a-z])/g,yg=M(\"$compile\"),ca=z.document.createElement(\"a\"),Id=\nDa(z.location.href);Jd.$inject=[\"$document\"];Xc.$inject=[\"$provide\"];var Qd=22,Pd=\".\",uc=\"0\";Kd.$inject=[\"$locale\"];Md.$inject=[\"$locale\"];var Jg={yyyy:aa(\"FullYear\",4,0,!1,!0),yy:aa(\"FullYear\",2,0,!0,!0),y:aa(\"FullYear\",1,0,!1,!0),MMMM:nb(\"Month\"),MMM:nb(\"Month\",!0),MM:aa(\"Month\",2,1),M:aa(\"Month\",1,1),LLLL:nb(\"Month\",!1,!0),dd:aa(\"Date\",2),d:aa(\"Date\",1),HH:aa(\"Hours\",2),H:aa(\"Hours\",1),hh:aa(\"Hours\",2,-12),h:aa(\"Hours\",1,-12),mm:aa(\"Minutes\",2),m:aa(\"Minutes\",1),ss:aa(\"Seconds\",2),s:aa(\"Seconds\",\n1),sss:aa(\"Milliseconds\",3),EEEE:nb(\"Day\"),EEE:nb(\"Day\",!0),a:function(a,b){return 12>a.getHours()?b.AMPMS[0]:b.AMPMS[1]},Z:function(a,b,d){a=-1*d;return a=(0<=a?\"+\":\"\")+(Kb(Math[0<a?\"floor\":\"ceil\"](a/60),2)+Kb(Math.abs(a%60),2))},ww:Sd(2),w:Sd(1),G:vc,GG:vc,GGG:vc,GGGG:function(a,b){return 0>=a.getFullYear()?b.ERANAMES[0]:b.ERANAMES[1]}},Ig=/((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,Hg=/^-?\\d+$/;Ld.$inject=[\"$locale\"];var Cg=ma(P),Dg=ma(vb);Nd.$inject=\n[\"$parse\"];var Ae=ma({restrict:\"E\",compile:function(a,b){if(!b.href&&!b.xlinkHref)return function(a,b){if(\"a\"===b[0].nodeName.toLowerCase()){var f=\"[object SVGAnimatedString]\"===na.call(b.prop(\"href\"))?\"xlink:href\":\"href\";b.on(\"click\",function(a){b.attr(f)||a.preventDefault()})}}}}),wb={};q(Gb,function(a,b){function d(a,d,f){a.$watch(f[c],function(a){f.$set(b,!!a)})}if(\"multiple\"!==a){var c=Ca(\"ng-\"+b),f=d;\"checked\"===a&&(f=function(a,b,f){f.ngModel!==f[c]&&d(a,b,f)});wb[c]=function(){return{restrict:\"A\",\npriority:100,link:f}}}});q(ld,function(a,b){wb[b]=function(){return{priority:100,link:function(a,c,f){if(\"ngPattern\"===b&&\"/\"===f.ngPattern.charAt(0)&&(c=f.ngPattern.match(Ng))){f.$set(\"ngPattern\",new RegExp(c[1],c[2]));return}a.$watch(f[b],function(a){f.$set(b,a)})}}}});q([\"src\",\"srcset\",\"href\"],function(a){var b=Ca(\"ng-\"+a);wb[b]=function(){return{priority:99,link:function(d,c,f){var e=a,g=a;\"href\"===a&&\"[object SVGAnimatedString]\"===na.call(c.prop(\"href\"))&&(g=\"xlinkHref\",f.$attr[g]=\"xlink:href\",\ne=null);f.$observe(b,function(b){b?(f.$set(g,b),La&&e&&c.prop(e,f[g])):\"href\"===a&&f.$set(g,null)})}}}});var Mb={$addControl:w,$$renameControl:function(a,b){a.$name=b},$removeControl:w,$setValidity:w,$setDirty:w,$setPristine:w,$setSubmitted:w};Lb.$inject=[\"$element\",\"$attrs\",\"$scope\",\"$animate\",\"$interpolate\"];Lb.prototype={$rollbackViewValue:function(){q(this.$$controls,function(a){a.$rollbackViewValue()})},$commitViewValue:function(){q(this.$$controls,function(a){a.$commitViewValue()})},$addControl:function(a){Pa(a.$name,\n\"input\");this.$$controls.push(a);a.$name&&(this[a.$name]=a);a.$$parentForm=this},$$renameControl:function(a,b){var d=a.$name;this[d]===a&&delete this[d];this[b]=a;a.$name=b},$removeControl:function(a){a.$name&&this[a.$name]===a&&delete this[a.$name];q(this.$pending,function(b,d){this.$setValidity(d,null,a)},this);q(this.$error,function(b,d){this.$setValidity(d,null,a)},this);q(this.$$success,function(b,d){this.$setValidity(d,null,a)},this);$a(this.$$controls,a);a.$$parentForm=Mb},$setDirty:function(){this.$$animate.removeClass(this.$$element,\nVa);this.$$animate.addClass(this.$$element,Rb);this.$dirty=!0;this.$pristine=!1;this.$$parentForm.$setDirty()},$setPristine:function(){this.$$animate.setClass(this.$$element,Va,Rb+\" ng-submitted\");this.$dirty=!1;this.$pristine=!0;this.$submitted=!1;q(this.$$controls,function(a){a.$setPristine()})},$setUntouched:function(){q(this.$$controls,function(a){a.$setUntouched()})},$setSubmitted:function(){this.$$animate.addClass(this.$$element,\"ng-submitted\");this.$submitted=!0;this.$$parentForm.$setSubmitted()}};\nVd({clazz:Lb,set:function(a,b,d){var c=a[b];c?-1===c.indexOf(d)&&c.push(d):a[b]=[d]},unset:function(a,b,d){var c=a[b];c&&($a(c,d),0===c.length&&delete a[b])}});var ce=function(a){return[\"$timeout\",\"$parse\",function(b,d){function c(a){return\"\"===a?d('this[\"\"]').assign:d(a).assign||w}return{name:\"form\",restrict:a?\"EAC\":\"E\",require:[\"form\",\"^^?form\"],controller:Lb,compile:function(d,e){d.addClass(Va).addClass(ob);var g=e.name?\"name\":a&&e.ngForm?\"ngForm\":!1;return{pre:function(a,d,e,f){var n=f[0];if(!(\"action\"in\ne)){var p=function(b){a.$apply(function(){n.$commitViewValue();n.$setSubmitted()});b.preventDefault()};d[0].addEventListener(\"submit\",p);d.on(\"$destroy\",function(){b(function(){d[0].removeEventListener(\"submit\",p)},0,!1)})}(f[1]||n.$$parentForm).$addControl(n);var r=g?c(n.$name):w;g&&(r(a,n),e.$observe(g,function(b){n.$name!==b&&(r(a,void 0),n.$$parentForm.$$renameControl(n,b),r=c(n.$name),r(a,n))}));d.on(\"$destroy\",function(){n.$$parentForm.$removeControl(n);r(a,void 0);R(n,Mb)})}}}}}]},Be=ce(),\nNe=ce(!0),Kg=/^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/,Vg=/^[a-z][a-z\\d.+-]*:\\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\\s:/?#]+|\\[[a-f\\d:]+])(?::\\d+)?(?:\\/[^?#]*)?(?:\\?[^#]*)?(?:#.*)?$/i,Wg=/^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/,Lg=/^\\s*(-|\\+)?(\\d+|(\\d*(\\.\\d*)))([eE][+-]?\\d+)?\\s*$/,de=/^(\\d{4,})-(\\d{2})-(\\d{2})$/,ee=/^(\\d{4,})-(\\d\\d)-(\\d\\d)T(\\d\\d):(\\d\\d)(?::(\\d\\d)(\\.\\d{1,3})?)?$/,\nCc=/^(\\d{4,})-W(\\d\\d)$/,fe=/^(\\d{4,})-(\\d\\d)$/,ge=/^(\\d\\d):(\\d\\d)(?::(\\d\\d)(\\.\\d{1,3})?)?$/,Xd=W();q([\"date\",\"datetime-local\",\"month\",\"time\",\"week\"],function(a){Xd[a]=!0});var he={text:function(a,b,d,c,f,e){Sa(a,b,d,c,f,e);xc(c)},date:pb(\"date\",de,Nb(de,[\"yyyy\",\"MM\",\"dd\"]),\"yyyy-MM-dd\"),\"datetime-local\":pb(\"datetimelocal\",ee,Nb(ee,\"yyyy MM dd HH mm ss sss\".split(\" \")),\"yyyy-MM-ddTHH:mm:ss.sss\"),time:pb(\"time\",ge,Nb(ge,[\"HH\",\"mm\",\"ss\",\"sss\"]),\"HH:mm:ss.sss\"),week:pb(\"week\",Cc,function(a,b){if(fa(a))return a;\nif(E(a)){Cc.lastIndex=0;var d=Cc.exec(a);if(d){var c=+d[1],f=+d[2],e=d=0,g=0,h=0,k=Rd(c),f=7*(f-1);b&&(d=b.getHours(),e=b.getMinutes(),g=b.getSeconds(),h=b.getMilliseconds());return new Date(c,0,k.getDate()+f,d,e,g,h)}}return NaN},\"yyyy-Www\"),month:pb(\"month\",fe,Nb(fe,[\"yyyy\",\"MM\"]),\"yyyy-MM\"),number:function(a,b,d,c,f,e){yc(a,b,d,c);Yd(c);Sa(a,b,d,c,f,e);var g,h;if(v(d.min)||d.ngMin)c.$validators.min=function(a){return c.$isEmpty(a)||x(g)||a>=g},d.$observe(\"min\",function(a){g=Ta(a);c.$validate()});\nif(v(d.max)||d.ngMax)c.$validators.max=function(a){return c.$isEmpty(a)||x(h)||a<=h},d.$observe(\"max\",function(a){h=Ta(a);c.$validate()});if(v(d.step)||d.ngStep){var k;c.$validators.step=function(a,b){return c.$isEmpty(b)||x(k)||Zd(b,g||0,k)};d.$observe(\"step\",function(a){k=Ta(a);c.$validate()})}},url:function(a,b,d,c,f,e){Sa(a,b,d,c,f,e);xc(c);c.$$parserName=\"url\";c.$validators.url=function(a,b){var d=a||b;return c.$isEmpty(d)||Vg.test(d)}},email:function(a,b,d,c,f,e){Sa(a,b,d,c,f,e);xc(c);c.$$parserName=\n\"email\";c.$validators.email=function(a,b){var d=a||b;return c.$isEmpty(d)||Wg.test(d)}},radio:function(a,b,d,c){var f=!d.ngTrim||\"false\"!==S(d.ngTrim);x(d.name)&&b.attr(\"name\",++rb);b.on(\"click\",function(a){var g;b[0].checked&&(g=d.value,f&&(g=S(g)),c.$setViewValue(g,a&&a.type))});c.$render=function(){var a=d.value;f&&(a=S(a));b[0].checked=a===c.$viewValue};d.$observe(\"value\",c.$render)},range:function(a,b,d,c,f,e){function g(a,c){b.attr(a,d[a]);d.$observe(a,c)}function h(a){n=Ta(a);ga(c.$modelValue)||\n(m?(a=b.val(),n>a&&(a=n,b.val(a)),c.$setViewValue(a)):c.$validate())}function k(a){p=Ta(a);ga(c.$modelValue)||(m?(a=b.val(),p<a&&(b.val(p),a=p<n?n:p),c.$setViewValue(a)):c.$validate())}function l(a){r=Ta(a);ga(c.$modelValue)||(m&&c.$viewValue!==b.val()?c.$setViewValue(b.val()):c.$validate())}yc(a,b,d,c);Yd(c);Sa(a,b,d,c,f,e);var m=c.$$hasNativeValidators&&\"range\"===b[0].type,n=m?0:void 0,p=m?100:void 0,r=m?1:void 0,q=b[0].validity;a=v(d.min);f=v(d.max);e=v(d.step);var s=c.$render;c.$render=m&&v(q.rangeUnderflow)&&\nv(q.rangeOverflow)?function(){s();c.$setViewValue(b.val())}:s;a&&(c.$validators.min=m?function(){return!0}:function(a,b){return c.$isEmpty(b)||x(n)||b>=n},g(\"min\",h));f&&(c.$validators.max=m?function(){return!0}:function(a,b){return c.$isEmpty(b)||x(p)||b<=p},g(\"max\",k));e&&(c.$validators.step=m?function(){return!q.stepMismatch}:function(a,b){return c.$isEmpty(b)||x(r)||Zd(b,n||0,r)},g(\"step\",l))},checkbox:function(a,b,d,c,f,e,g,h){var k=$d(h,a,\"ngTrueValue\",d.ngTrueValue,!0),l=$d(h,a,\"ngFalseValue\",\nd.ngFalseValue,!1);b.on(\"click\",function(a){c.$setViewValue(b[0].checked,a&&a.type)});c.$render=function(){b[0].checked=c.$viewValue};c.$isEmpty=function(a){return!1===a};c.$formatters.push(function(a){return qa(a,k)});c.$parsers.push(function(a){return a?k:l})},hidden:w,button:w,submit:w,reset:w,file:w},Rc=[\"$browser\",\"$sniffer\",\"$filter\",\"$parse\",function(a,b,d,c){return{restrict:\"E\",require:[\"?ngModel\"],link:{pre:function(f,e,g,h){h[0]&&(he[P(g.type)]||he.text)(f,e,g,h[0],b,a,d,c)}}}}],Xg=/^(true|false|\\d+)$/,\nef=function(){return{restrict:\"A\",priority:100,compile:function(a,b){return Xg.test(b.ngValue)?function(a,b,f){a=a.$eval(f.ngValue);b.prop(\"value\",a);f.$set(\"value\",a)}:function(a,b,f){a.$watch(f.ngValue,function(a){b.prop(\"value\",a);f.$set(\"value\",a)})}}}},Fe=[\"$compile\",function(a){return{restrict:\"AC\",compile:function(b){a.$$addBindingClass(b);return function(b,c,f){a.$$addBindingInfo(c,f.ngBind);c=c[0];b.$watch(f.ngBind,function(a){c.textContent=Yb(a)})}}}}],He=[\"$interpolate\",\"$compile\",function(a,\nb){return{compile:function(d){b.$$addBindingClass(d);return function(c,d,e){c=a(d.attr(e.$attr.ngBindTemplate));b.$$addBindingInfo(d,c.expressions);d=d[0];e.$observe(\"ngBindTemplate\",function(a){d.textContent=x(a)?\"\":a})}}}}],Ge=[\"$sce\",\"$parse\",\"$compile\",function(a,b,d){return{restrict:\"A\",compile:function(c,f){var e=b(f.ngBindHtml),g=b(f.ngBindHtml,function(b){return a.valueOf(b)});d.$$addBindingClass(c);return function(b,c,f){d.$$addBindingInfo(c,f.ngBindHtml);b.$watch(g,function(){var d=e(b);\nc.html(a.getTrustedHtml(d)||\"\")})}}}}],df=ma({restrict:\"A\",require:\"ngModel\",link:function(a,b,d,c){c.$viewChangeListeners.push(function(){a.$eval(d.ngChange)})}}),Ie=Ac(\"\",!0),Ke=Ac(\"Odd\",0),Je=Ac(\"Even\",1),Le=Ra({compile:function(a,b){b.$set(\"ngCloak\",void 0);a.removeClass(\"ng-cloak\")}}),Me=[function(){return{restrict:\"A\",scope:!0,controller:\"@\",priority:500}}],Wc={},Yg={blur:!0,focus:!0};q(\"click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste\".split(\" \"),\nfunction(a){var b=Ca(\"ng-\"+a);Wc[b]=[\"$parse\",\"$rootScope\",function(d,c){return{restrict:\"A\",compile:function(f,e){var g=d(e[b],null,!0);return function(b,d){d.on(a,function(d){var e=function(){g(b,{$event:d})};Yg[a]&&c.$$phase?b.$evalAsync(e):b.$apply(e)})}}}}]});var Pe=[\"$animate\",\"$compile\",function(a,b){return{multiElement:!0,transclude:\"element\",priority:600,terminal:!0,restrict:\"A\",$$tlb:!0,link:function(d,c,f,e,g){var h,k,l;d.$watch(f.ngIf,function(d){d?k||g(function(d,e){k=e;d[d.length++]=\nb.$$createComment(\"end ngIf\",f.ngIf);h={clone:d};a.enter(d,c.parent(),c)}):(l&&(l.remove(),l=null),k&&(k.$destroy(),k=null),h&&(l=ub(h.clone),a.leave(l).done(function(a){!1!==a&&(l=null)}),h=null))})}}}],Qe=[\"$templateRequest\",\"$anchorScroll\",\"$animate\",function(a,b,d){return{restrict:\"ECA\",priority:400,terminal:!0,transclude:\"element\",controller:$.noop,compile:function(c,f){var e=f.ngInclude||f.src,g=f.onload||\"\",h=f.autoscroll;return function(c,f,m,n,p){var q=0,s,w,u,H=function(){w&&(w.remove(),\nw=null);s&&(s.$destroy(),s=null);u&&(d.leave(u).done(function(a){!1!==a&&(w=null)}),w=u,u=null)};c.$watch(e,function(e){var m=function(a){!1===a||!v(h)||h&&!c.$eval(h)||b()},w=++q;e?(a(e,!0).then(function(a){if(!c.$$destroyed&&w===q){var b=c.$new();n.template=a;a=p(b,function(a){H();d.enter(a,null,f).done(m)});s=b;u=a;s.$emit(\"$includeContentLoaded\",e);c.$eval(g)}},function(){c.$$destroyed||w!==q||(H(),c.$emit(\"$includeContentError\",e))}),c.$emit(\"$includeContentRequested\",e)):(H(),n.template=null)})}}}}],\ngf=[\"$compile\",function(a){return{restrict:\"ECA\",priority:-400,require:\"ngInclude\",link:function(b,d,c,f){na.call(d[0]).match(/SVG/)?(d.empty(),a(Zc(f.template,z.document).childNodes)(b,function(a){d.append(a)},{futureParentElement:d})):(d.html(f.template),a(d.contents())(b))}}}],Re=Ra({priority:450,compile:function(){return{pre:function(a,b,d){a.$eval(d.ngInit)}}}}),cf=function(){return{restrict:\"A\",priority:100,require:\"ngModel\",link:function(a,b,d,c){var f=d.ngList||\", \",e=\"false\"!==d.ngTrim,g=\ne?S(f):f;c.$parsers.push(function(a){if(!x(a)){var b=[];a&&q(a.split(g),function(a){a&&b.push(e?S(a):a)});return b}});c.$formatters.push(function(a){if(C(a))return a.join(f)});c.$isEmpty=function(a){return!a||!a.length}}}},ob=\"ng-valid\",Ud=\"ng-invalid\",Va=\"ng-pristine\",Rb=\"ng-dirty\",qb=M(\"ngModel\");Ob.$inject=\"$scope $exceptionHandler $attrs $element $parse $animate $timeout $q $interpolate\".split(\" \");Ob.prototype={$$initGetterSetters:function(){if(this.$options.getOption(\"getterSetter\")){var a=\nthis.$$parse(this.$$attr.ngModel+\"()\"),b=this.$$parse(this.$$attr.ngModel+\"($$$p)\");this.$$ngModelGet=function(b){var c=this.$$parsedNgModel(b);y(c)&&(c=a(b));return c};this.$$ngModelSet=function(a,c){y(this.$$parsedNgModel(a))?b(a,{$$$p:c}):this.$$parsedNgModelAssign(a,c)}}else if(!this.$$parsedNgModel.assign)throw qb(\"nonassign\",this.$$attr.ngModel,ya(this.$$element));},$render:w,$isEmpty:function(a){return x(a)||\"\"===a||null===a||a!==a},$$updateEmptyClasses:function(a){this.$isEmpty(a)?(this.$$animate.removeClass(this.$$element,\n\"ng-not-empty\"),this.$$animate.addClass(this.$$element,\"ng-empty\")):(this.$$animate.removeClass(this.$$element,\"ng-empty\"),this.$$animate.addClass(this.$$element,\"ng-not-empty\"))},$setPristine:function(){this.$dirty=!1;this.$pristine=!0;this.$$animate.removeClass(this.$$element,Rb);this.$$animate.addClass(this.$$element,Va)},$setDirty:function(){this.$dirty=!0;this.$pristine=!1;this.$$animate.removeClass(this.$$element,Va);this.$$animate.addClass(this.$$element,Rb);this.$$parentForm.$setDirty()},\n$setUntouched:function(){this.$touched=!1;this.$untouched=!0;this.$$animate.setClass(this.$$element,\"ng-untouched\",\"ng-touched\")},$setTouched:function(){this.$touched=!0;this.$untouched=!1;this.$$animate.setClass(this.$$element,\"ng-touched\",\"ng-untouched\")},$rollbackViewValue:function(){this.$$timeout.cancel(this.$$pendingDebounce);this.$viewValue=this.$$lastCommittedViewValue;this.$render()},$validate:function(){if(!ga(this.$modelValue)){var a=this.$$lastCommittedViewValue,b=this.$$rawModelValue,\nd=this.$valid,c=this.$modelValue,f=this.$options.getOption(\"allowInvalid\"),e=this;this.$$runValidators(b,a,function(a){f||d===a||(e.$modelValue=a?b:void 0,e.$modelValue!==c&&e.$$writeModelToScope())})}},$$runValidators:function(a,b,d){function c(){var c=!0;q(k.$validators,function(d,f){var g=Boolean(d(a,b));c=c&&g;e(f,g)});return c?!0:(q(k.$asyncValidators,function(a,b){e(b,null)}),!1)}function f(){var c=[],d=!0;q(k.$asyncValidators,function(f,g){var h=f(a,b);if(!h||!y(h.then))throw qb(\"nopromise\",\nh);e(g,void 0);c.push(h.then(function(){e(g,!0)},function(){d=!1;e(g,!1)}))});c.length?k.$$q.all(c).then(function(){g(d)},w):g(!0)}function e(a,b){h===k.$$currentValidationRunId&&k.$setValidity(a,b)}function g(a){h===k.$$currentValidationRunId&&d(a)}this.$$currentValidationRunId++;var h=this.$$currentValidationRunId,k=this;(function(){var a=k.$$parserName||\"parse\";if(x(k.$$parserValid))e(a,null);else return k.$$parserValid||(q(k.$validators,function(a,b){e(b,null)}),q(k.$asyncValidators,function(a,\nb){e(b,null)})),e(a,k.$$parserValid),k.$$parserValid;return!0})()?c()?f():g(!1):g(!1)},$commitViewValue:function(){var a=this.$viewValue;this.$$timeout.cancel(this.$$pendingDebounce);if(this.$$lastCommittedViewValue!==a||\"\"===a&&this.$$hasNativeValidators)this.$$updateEmptyClasses(a),this.$$lastCommittedViewValue=a,this.$pristine&&this.$setDirty(),this.$$parseAndValidate()},$$parseAndValidate:function(){var a=this.$$lastCommittedViewValue,b=this;if(this.$$parserValid=x(a)?void 0:!0)for(var d=0;d<\nthis.$parsers.length;d++)if(a=this.$parsers[d](a),x(a)){this.$$parserValid=!1;break}ga(this.$modelValue)&&(this.$modelValue=this.$$ngModelGet(this.$$scope));var c=this.$modelValue,f=this.$options.getOption(\"allowInvalid\");this.$$rawModelValue=a;f&&(this.$modelValue=a,b.$modelValue!==c&&b.$$writeModelToScope());this.$$runValidators(a,this.$$lastCommittedViewValue,function(d){f||(b.$modelValue=d?a:void 0,b.$modelValue!==c&&b.$$writeModelToScope())})},$$writeModelToScope:function(){this.$$ngModelSet(this.$$scope,\nthis.$modelValue);q(this.$viewChangeListeners,function(a){try{a()}catch(b){this.$$exceptionHandler(b)}},this)},$setViewValue:function(a,b){this.$viewValue=a;this.$options.getOption(\"updateOnDefault\")&&this.$$debounceViewValueCommit(b)},$$debounceViewValueCommit:function(a){var b=this.$options.getOption(\"debounce\");Y(b[a])?b=b[a]:Y(b[\"default\"])&&(b=b[\"default\"]);this.$$timeout.cancel(this.$$pendingDebounce);var d=this;0<b?this.$$pendingDebounce=this.$$timeout(function(){d.$commitViewValue()},b):this.$$scope.$root.$$phase?\nthis.$commitViewValue():this.$$scope.$apply(function(){d.$commitViewValue()})}};Vd({clazz:Ob,set:function(a,b){a[b]=!0},unset:function(a,b){delete a[b]}});var bf=[\"$rootScope\",function(a){return{restrict:\"A\",require:[\"ngModel\",\"^?form\",\"^?ngModelOptions\"],controller:Ob,priority:1,compile:function(b){b.addClass(Va).addClass(\"ng-untouched\").addClass(ob);return{pre:function(a,b,f,e){var g=e[0];b=e[1]||g.$$parentForm;if(e=e[2])g.$options=e.$options;g.$$initGetterSetters();b.$addControl(g);f.$observe(\"name\",\nfunction(a){g.$name!==a&&g.$$parentForm.$$renameControl(g,a)});a.$on(\"$destroy\",function(){g.$$parentForm.$removeControl(g)})},post:function(b,c,f,e){function g(){h.$setTouched()}var h=e[0];if(h.$options.getOption(\"updateOn\"))c.on(h.$options.getOption(\"updateOn\"),function(a){h.$$debounceViewValueCommit(a&&a.type)});c.on(\"blur\",function(){h.$touched||(a.$$phase?b.$evalAsync(g):b.$apply(g))})}}}}}],Pb,Zg=/(\\s+|^)default(\\s+|$)/;Bc.prototype={getOption:function(a){return this.$$options[a]},createChild:function(a){var b=\n!1;a=R({},a);q(a,function(d,c){\"$inherit\"===d?\"*\"===c?b=!0:(a[c]=this.$$options[c],\"updateOn\"===c&&(a.updateOnDefault=this.$$options.updateOnDefault)):\"updateOn\"===c&&(a.updateOnDefault=!1,a[c]=S(d.replace(Zg,function(){a.updateOnDefault=!0;return\" \"})))},this);b&&(delete a[\"*\"],ae(a,this.$$options));ae(a,Pb.$$options);return new Bc(a)}};Pb=new Bc({updateOn:\"\",updateOnDefault:!0,debounce:0,getterSetter:!1,allowInvalid:!1,timezone:null});var ff=function(){function a(a,d){this.$$attrs=a;this.$$scope=\nd}a.$inject=[\"$attrs\",\"$scope\"];a.prototype={$onInit:function(){var a=this.parentCtrl?this.parentCtrl.$options:Pb,d=this.$$scope.$eval(this.$$attrs.ngModelOptions);this.$options=a.createChild(d)}};return{restrict:\"A\",priority:10,require:{parentCtrl:\"?^^ngModelOptions\"},bindToController:!0,controller:a}},Se=Ra({terminal:!0,priority:1E3}),$g=M(\"ngOptions\"),ah=/^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+group\\s+by\\s+([\\s\\S]+?))?(?:\\s+disable\\s+when\\s+([\\s\\S]+?))?\\s+for\\s+(?:([$\\w][$\\w]*)|(?:\\(\\s*([$\\w][$\\w]*)\\s*,\\s*([$\\w][$\\w]*)\\s*\\)))\\s+in\\s+([\\s\\S]+?)(?:\\s+track\\s+by\\s+([\\s\\S]+?))?$/,\n$e=[\"$compile\",\"$document\",\"$parse\",function(a,b,d){function c(a,b,c){function e(a,b,c,d,f){this.selectValue=a;this.viewValue=b;this.label=c;this.group=d;this.disabled=f}function f(a){var b;if(!q&&ta(a))b=a;else{b=[];for(var c in a)a.hasOwnProperty(c)&&\"$\"!==c.charAt(0)&&b.push(c)}return b}var n=a.match(ah);if(!n)throw $g(\"iexp\",a,ya(b));var p=n[5]||n[7],q=n[6];a=/ as /.test(n[0])&&n[1];var s=n[9];b=d(n[2]?n[1]:p);var v=a&&d(a)||b,u=s&&d(s),w=s?function(a,b){return u(c,b)}:function(a){return la(a)},\nx=function(a,b){return w(a,B(a,b))},t=d(n[2]||n[1]),z=d(n[3]||\"\"),A=d(n[4]||\"\"),K=d(n[8]),I={},B=q?function(a,b){I[q]=b;I[p]=a;return I}:function(a){I[p]=a;return I};return{trackBy:s,getTrackByValue:x,getWatchables:d(K,function(a){var b=[];a=a||[];for(var d=f(a),e=d.length,g=0;g<e;g++){var h=a===d?g:d[g],l=a[h],h=B(l,h),l=w(l,h);b.push(l);if(n[2]||n[1])l=t(c,h),b.push(l);n[4]&&(h=A(c,h),b.push(h))}return b}),getOptions:function(){for(var a=[],b={},d=K(c)||[],g=f(d),h=g.length,n=0;n<h;n++){var p=d===\ng?n:g[n],q=B(d[p],p),r=v(c,q),p=w(r,q),u=t(c,q),I=z(c,q),q=A(c,q),r=new e(p,r,u,I,q);a.push(r);b[p]=r}return{items:a,selectValueMap:b,getOptionFromViewValue:function(a){return b[x(a)]},getViewValueFromOption:function(a){return s?Fa(a.viewValue):a.viewValue}}}}}var f=z.document.createElement(\"option\"),e=z.document.createElement(\"optgroup\");return{restrict:\"A\",terminal:!0,require:[\"select\",\"ngModel\"],link:{pre:function(a,b,c,d){d[0].registerOption=w},post:function(d,h,k,l){function m(a){var b=(a=t.getOptionFromViewValue(a))&&\na.element;b&&!b.selected&&(b.selected=!0);return a}function n(a,b){a.element=b;b.disabled=a.disabled;a.label!==b.label&&(b.label=a.label,b.textContent=a.label);b.value=a.selectValue}function p(){var a=t&&r.readValue();if(t)for(var b=t.items.length-1;0<=b;b--){var c=t.items[b];v(c.group)?Fb(c.element.parentNode):Fb(c.element)}t=y.getOptions();var d={};z&&h.prepend(r.emptyOption);t.items.forEach(function(a){var b;if(v(a.group)){b=d[a.group];b||(b=e.cloneNode(!1),A.appendChild(b),b.label=null===a.group?\n\"null\":a.group,d[a.group]=b);var c=f.cloneNode(!1)}else b=A,c=f.cloneNode(!1);b.appendChild(c);n(a,c)});h[0].appendChild(A);s.$render();s.$isEmpty(a)||(b=r.readValue(),(y.trackBy||w?qa(a,b):a===b)||(s.$setViewValue(b),s.$render()))}var r=l[0],s=l[1],w=k.multiple;l=0;for(var u=h.children(),x=u.length;l<x;l++)if(\"\"===u[l].value){r.hasEmptyOption=!0;r.emptyOption=u.eq(l);break}var z=!!r.emptyOption;D(f.cloneNode(!1)).val(\"?\");var t,y=c(k.ngOptions,h,d),A=b[0].createDocumentFragment();r.generateUnknownOptionValue=\nfunction(a){return\"?\"};w?(r.writeValue=function(a){var b=a&&a.map(m)||[];t.items.forEach(function(a){a.element.selected&&-1===Array.prototype.indexOf.call(b,a)&&(a.element.selected=!1)})},r.readValue=function(){var a=h.val()||[],b=[];q(a,function(a){(a=t.selectValueMap[a])&&!a.disabled&&b.push(t.getViewValueFromOption(a))});return b},y.trackBy&&d.$watchCollection(function(){if(C(s.$viewValue))return s.$viewValue.map(function(a){return y.getTrackByValue(a)})},function(){s.$render()})):(r.writeValue=\nfunction(a){var b=t.selectValueMap[h.val()],c=t.getOptionFromViewValue(a);b&&b.element.removeAttribute(\"selected\");c?(h[0].value!==c.selectValue&&(r.removeUnknownOption(),r.unselectEmptyOption(),h[0].value=c.selectValue,c.element.selected=!0),c.element.setAttribute(\"selected\",\"selected\")):z?r.selectEmptyOption():r.unknownOption.parent().length?r.updateUnknownOption(a):r.renderUnknownOption(a)},r.readValue=function(){var a=t.selectValueMap[h.val()];return a&&!a.disabled?(r.unselectEmptyOption(),r.removeUnknownOption(),\nt.getViewValueFromOption(a)):null},y.trackBy&&d.$watch(function(){return y.getTrackByValue(s.$viewValue)},function(){s.$render()}));z&&(r.emptyOption.remove(),a(r.emptyOption)(d),8===r.emptyOption[0].nodeType?(r.hasEmptyOption=!1,r.registerOption=function(a,b){\"\"===b.val()&&(r.hasEmptyOption=!0,r.emptyOption=b,r.emptyOption.removeClass(\"ng-scope\"),s.$render(),b.on(\"$destroy\",function(){r.hasEmptyOption=!1;r.emptyOption=void 0}))}):r.emptyOption.removeClass(\"ng-scope\"));h.empty();p();d.$watchCollection(y.getWatchables,\np)}}}}],Te=[\"$locale\",\"$interpolate\",\"$log\",function(a,b,d){var c=/{}/g,f=/^when(Minus)?(.+)$/;return{link:function(e,g,h){function k(a){g.text(a||\"\")}var l=h.count,m=h.$attr.when&&g.attr(h.$attr.when),n=h.offset||0,p=e.$eval(m)||{},r={},s=b.startSymbol(),v=b.endSymbol(),u=s+l+\"-\"+n+v,H=$.noop,y;q(h,function(a,b){var c=f.exec(b);c&&(c=(c[1]?\"-\":\"\")+P(c[2]),p[c]=g.attr(h.$attr[b]))});q(p,function(a,d){r[d]=b(a.replace(c,u))});e.$watch(l,function(b){var c=parseFloat(b),f=ga(c);f||c in p||(c=a.pluralCat(c-\nn));c===y||f&&ga(y)||(H(),f=r[c],x(f)?(null!=b&&d.debug(\"ngPluralize: no rule defined for '\"+c+\"' in \"+m),H=w,k()):H=e.$watch(f,k),y=c)})}}}],Ue=[\"$parse\",\"$animate\",\"$compile\",function(a,b,d){var c=M(\"ngRepeat\"),f=function(a,b,c,d,f,m,n){a[c]=d;f&&(a[f]=m);a.$index=b;a.$first=0===b;a.$last=b===n-1;a.$middle=!(a.$first||a.$last);a.$odd=!(a.$even=0===(b&1))};return{restrict:\"A\",multiElement:!0,transclude:\"element\",priority:1E3,terminal:!0,$$tlb:!0,compile:function(e,g){var h=g.ngRepeat,k=d.$$createComment(\"end ngRepeat\",\nh),l=h.match(/^\\s*([\\s\\S]+?)\\s+in\\s+([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+track\\s+by\\s+([\\s\\S]+?))?\\s*$/);if(!l)throw c(\"iexp\",h);var m=l[1],n=l[2],p=l[3],r=l[4],l=m.match(/^(?:(\\s*[$\\w]+)|\\(\\s*([$\\w]+)\\s*,\\s*([$\\w]+)\\s*\\))$/);if(!l)throw c(\"iidexp\",m);var s=l[3]||l[1],v=l[2];if(p&&(!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(p)||/^(null|undefined|this|\\$index|\\$first|\\$middle|\\$last|\\$even|\\$odd|\\$parent|\\$root|\\$id)$/.test(p)))throw c(\"badident\",p);var u,w,x,t,y={$id:la};r?u=a(r):(x=function(a,b){return la(b)},\nt=function(a){return a});return function(a,d,e,g,l){u&&(w=function(b,c,d){v&&(y[v]=b);y[s]=c;y.$index=d;return u(a,y)});var m=W();a.$watchCollection(n,function(e){var g,n,r=d[0],u,y=W(),z,D,E,B,F,C,I;p&&(a[p]=e);if(ta(e))F=e,n=w||x;else for(I in n=w||t,F=[],e)va.call(e,I)&&\"$\"!==I.charAt(0)&&F.push(I);z=F.length;I=Array(z);for(g=0;g<z;g++)if(D=e===F?g:F[g],E=e[D],B=n(D,E,g),m[B])C=m[B],delete m[B],y[B]=C,I[g]=C;else{if(y[B])throw q(I,function(a){a&&a.scope&&(m[a.id]=a)}),c(\"dupes\",h,B,E);I[g]={id:B,\nscope:void 0,clone:void 0};y[B]=!0}for(u in m){C=m[u];B=ub(C.clone);b.leave(B);if(B[0].parentNode)for(g=0,n=B.length;g<n;g++)B[g].$$NG_REMOVED=!0;C.scope.$destroy()}for(g=0;g<z;g++)if(D=e===F?g:F[g],E=e[D],C=I[g],C.scope){u=r;do u=u.nextSibling;while(u&&u.$$NG_REMOVED);C.clone[0]!==u&&b.move(ub(C.clone),null,r);r=C.clone[C.clone.length-1];f(C.scope,g,s,E,v,D,z)}else l(function(a,c){C.scope=c;var d=k.cloneNode(!1);a[a.length++]=d;b.enter(a,null,r);r=d;C.clone=a;y[C.id]=C;f(C.scope,g,s,E,v,D,z)});m=\ny})}}}}],Ve=[\"$animate\",function(a){return{restrict:\"A\",multiElement:!0,link:function(b,d,c){b.$watch(c.ngShow,function(b){a[b?\"removeClass\":\"addClass\"](d,\"ng-hide\",{tempClasses:\"ng-hide-animate\"})})}}}],Oe=[\"$animate\",function(a){return{restrict:\"A\",multiElement:!0,link:function(b,d,c){b.$watch(c.ngHide,function(b){a[b?\"addClass\":\"removeClass\"](d,\"ng-hide\",{tempClasses:\"ng-hide-animate\"})})}}}],We=Ra(function(a,b,d){a.$watch(d.ngStyle,function(a,d){d&&a!==d&&q(d,function(a,c){b.css(c,\"\")});a&&b.css(a)},\n!0)}),Xe=[\"$animate\",\"$compile\",function(a,b){return{require:\"ngSwitch\",controller:[\"$scope\",function(){this.cases={}}],link:function(d,c,f,e){var g=[],h=[],k=[],l=[],m=function(a,b){return function(c){!1!==c&&a.splice(b,1)}};d.$watch(f.ngSwitch||f.on,function(c){for(var d,f;k.length;)a.cancel(k.pop());d=0;for(f=l.length;d<f;++d){var s=ub(h[d].clone);l[d].$destroy();(k[d]=a.leave(s)).done(m(k,d))}h.length=0;l.length=0;(g=e.cases[\"!\"+c]||e.cases[\"?\"])&&q(g,function(c){c.transclude(function(d,e){l.push(e);\nvar f=c.element;d[d.length++]=b.$$createComment(\"end ngSwitchWhen\");h.push({clone:d});a.enter(d,f.parent(),f)})})})}}}],Ye=Ra({transclude:\"element\",priority:1200,require:\"^ngSwitch\",multiElement:!0,link:function(a,b,d,c,f){a=d.ngSwitchWhen.split(d.ngSwitchWhenSeparator).sort().filter(function(a,b,c){return c[b-1]!==a});q(a,function(a){c.cases[\"!\"+a]=c.cases[\"!\"+a]||[];c.cases[\"!\"+a].push({transclude:f,element:b})})}}),Ze=Ra({transclude:\"element\",priority:1200,require:\"^ngSwitch\",multiElement:!0,link:function(a,\nb,d,c,f){c.cases[\"?\"]=c.cases[\"?\"]||[];c.cases[\"?\"].push({transclude:f,element:b})}}),bh=M(\"ngTransclude\"),af=[\"$compile\",function(a){return{restrict:\"EAC\",terminal:!0,compile:function(b){var d=a(b.contents());b.empty();return function(a,b,e,g,h){function k(){d(a,function(a){b.append(a)})}if(!h)throw bh(\"orphan\",ya(b));e.ngTransclude===e.$attr.ngTransclude&&(e.ngTransclude=\"\");e=e.ngTransclude||e.ngTranscludeSlot;h(function(a,c){var d;if(d=a.length)a:{d=0;for(var e=a.length;d<e;d++){var g=a[d];if(g.nodeType!==\nJa||g.nodeValue.trim()){d=!0;break a}}d=void 0}d?b.append(a):(k(),c.$destroy())},null,e);e&&!h.isSlotFilled(e)&&k()}}}}],Ce=[\"$templateCache\",function(a){return{restrict:\"E\",terminal:!0,compile:function(b,d){\"text/ng-template\"===d.type&&a.put(d.id,b[0].text)}}}],ch={$setViewValue:w,$render:w},dh=[\"$element\",\"$scope\",function(a,b){function d(){h||(h=!0,b.$$postDigest(function(){h=!1;e.ngModelCtrl.$render()}))}function c(a){k||(k=!0,b.$$postDigest(function(){b.$$destroyed||(k=!1,e.ngModelCtrl.$setViewValue(e.readValue()),\na&&e.ngModelCtrl.$render())}))}function f(a){a.prop(\"selected\",!0);a.attr(\"selected\",!0)}var e=this,g=new Qa;e.selectValueMap={};e.ngModelCtrl=ch;e.multiple=!1;e.unknownOption=D(z.document.createElement(\"option\"));e.hasEmptyOption=!1;e.emptyOption=void 0;e.renderUnknownOption=function(b){b=e.generateUnknownOptionValue(b);e.unknownOption.val(b);a.prepend(e.unknownOption);f(e.unknownOption);a.val(b)};e.updateUnknownOption=function(b){b=e.generateUnknownOptionValue(b);e.unknownOption.val(b);f(e.unknownOption);\na.val(b)};e.generateUnknownOptionValue=function(a){return\"? \"+la(a)+\" ?\"};e.removeUnknownOption=function(){e.unknownOption.parent()&&e.unknownOption.remove()};e.selectEmptyOption=function(){e.emptyOption&&(a.val(\"\"),f(e.emptyOption))};e.unselectEmptyOption=function(){e.hasEmptyOption&&e.emptyOption.removeAttr(\"selected\")};b.$on(\"$destroy\",function(){e.renderUnknownOption=w});e.readValue=function(){var b=a.val(),b=b in e.selectValueMap?e.selectValueMap[b]:b;return e.hasOption(b)?b:null};e.writeValue=\nfunction(b){var c=a[0].options[a[0].selectedIndex];c&&c.removeAttribute(\"selected\");e.hasOption(b)?(e.removeUnknownOption(),c=la(b),a.val(c in e.selectValueMap?c:b),f(D(a[0].options[a[0].selectedIndex]))):null==b&&e.emptyOption?(e.removeUnknownOption(),e.selectEmptyOption()):e.unknownOption.parent().length?e.updateUnknownOption(b):e.renderUnknownOption(b)};e.addOption=function(a,b){if(8!==b[0].nodeType){Pa(a,'\"option value\"');\"\"===a&&(e.hasEmptyOption=!0,e.emptyOption=b);var c=g.get(a)||0;g.put(a,\nc+1);d()}};e.removeOption=function(a){var b=g.get(a);b&&(1===b?(g.remove(a),\"\"===a&&(e.hasEmptyOption=!1,e.emptyOption=void 0)):g.put(a,b-1))};e.hasOption=function(a){return!!g.get(a)};var h=!1,k=!1;e.registerOption=function(a,b,d,f,g){if(d.$attr.ngValue){var h,k=NaN;d.$observe(\"value\",function(a){var d,f=b.prop(\"selected\");v(k)&&(e.removeOption(h),delete e.selectValueMap[k],d=!0);k=la(a);h=a;e.selectValueMap[k]=a;e.addOption(a,b);b.attr(\"value\",k);d&&f&&c()})}else f?d.$observe(\"value\",function(a){e.readValue();\nvar d,f=b.prop(\"selected\");v(h)&&(e.removeOption(h),d=!0);h=a;e.addOption(a,b);d&&f&&c()}):g?a.$watch(g,function(a,f){d.$set(\"value\",a);var g=b.prop(\"selected\");f!==a&&e.removeOption(f);e.addOption(a,b);f&&g&&c()}):e.addOption(d.value,b);d.$observe(\"disabled\",function(a){if(\"true\"===a||a&&b.prop(\"selected\"))e.multiple?c(!0):(e.ngModelCtrl.$setViewValue(null),e.ngModelCtrl.$render())});b.on(\"$destroy\",function(){var a=e.readValue(),b=d.value;e.removeOption(b);e.ngModelCtrl.$render();(e.multiple&&a&&\n-1!==a.indexOf(b)||a===b)&&c(!0)})}}],De=function(){return{restrict:\"E\",require:[\"select\",\"?ngModel\"],controller:dh,priority:1,link:{pre:function(a,b,d,c){var f=c[0],e=c[1];if(e){if(f.ngModelCtrl=e,b.on(\"change\",function(){f.removeUnknownOption();a.$apply(function(){e.$setViewValue(f.readValue())})}),d.multiple){f.multiple=!0;f.readValue=function(){var a=[];q(b.find(\"option\"),function(b){b.selected&&!b.disabled&&(b=b.value,a.push(b in f.selectValueMap?f.selectValueMap[b]:b))});return a};f.writeValue=\nfunction(a){var c=new Qa(a);q(b.find(\"option\"),function(a){a.selected=v(c.get(a.value))||v(c.get(f.selectValueMap[a.value]))})};var g,h=NaN;a.$watch(function(){h!==e.$viewValue||qa(g,e.$viewValue)||(g=ra(e.$viewValue),e.$render());h=e.$viewValue});e.$isEmpty=function(a){return!a||0===a.length}}}else f.registerOption=w},post:function(a,b,d,c){var f=c[1];if(f){var e=c[0];f.$render=function(){e.writeValue(f.$viewValue)}}}}}},Ee=[\"$interpolate\",function(a){return{restrict:\"E\",priority:100,compile:function(b,\nd){var c,f;v(d.ngValue)||(v(d.value)?c=a(d.value,!0):(f=a(b.text(),!0))||d.$set(\"value\",b.text()));return function(a,b,d){var k=b.parent();(k=k.data(\"$selectController\")||k.parent().data(\"$selectController\"))&&k.registerOption(a,b,d,c,f)}}}}],Tc=function(){return{restrict:\"A\",require:\"?ngModel\",link:function(a,b,d,c){c&&(d.required=!0,c.$validators.required=function(a,b){return!d.required||!c.$isEmpty(b)},d.$observe(\"required\",function(){c.$validate()}))}}},Sc=function(){return{restrict:\"A\",require:\"?ngModel\",\nlink:function(a,b,d,c){if(c){var f,e=d.ngPattern||d.pattern;d.$observe(\"pattern\",function(a){E(a)&&0<a.length&&(a=new RegExp(\"^\"+a+\"$\"));if(a&&!a.test)throw M(\"ngPattern\")(\"noregexp\",e,a,ya(b));f=a||void 0;c.$validate()});c.$validators.pattern=function(a,b){return c.$isEmpty(b)||x(f)||f.test(b)}}}}},Vc=function(){return{restrict:\"A\",require:\"?ngModel\",link:function(a,b,d,c){if(c){var f=-1;d.$observe(\"maxlength\",function(a){a=Z(a);f=ga(a)?-1:a;c.$validate()});c.$validators.maxlength=function(a,b){return 0>\nf||c.$isEmpty(b)||b.length<=f}}}}},Uc=function(){return{restrict:\"A\",require:\"?ngModel\",link:function(a,b,d,c){if(c){var f=0;d.$observe(\"minlength\",function(a){f=Z(a)||0;c.$validate()});c.$validators.minlength=function(a,b){return c.$isEmpty(b)||b.length>=f}}}}};z.angular.bootstrap?z.console&&console.log(\"WARNING: Tried to load angular more than once.\"):(ue(),xe($),$.module(\"ngLocale\",[],[\"$provide\",function(a){function b(a){a+=\"\";var b=a.indexOf(\".\");return-1==b?0:a.length-b-1}a.value(\"$locale\",\n{DATETIME_FORMATS:{AMPMS:[\"AM\",\"PM\"],DAY:\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),ERANAMES:[\"Before Christ\",\"Anno Domini\"],ERAS:[\"BC\",\"AD\"],FIRSTDAYOFWEEK:6,MONTH:\"January February March April May June July August September October November December\".split(\" \"),SHORTDAY:\"Sun Mon Tue Wed Thu Fri Sat\".split(\" \"),SHORTMONTH:\"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),STANDALONEMONTH:\"January February March April May June July August September October November December\".split(\" \"),\nWEEKENDRANGE:[5,6],fullDate:\"EEEE, MMMM d, y\",longDate:\"MMMM d, y\",medium:\"MMM d, y h:mm:ss a\",mediumDate:\"MMM d, y\",mediumTime:\"h:mm:ss a\",\"short\":\"M/d/yy h:mm a\",shortDate:\"M/d/yy\",shortTime:\"h:mm a\"},NUMBER_FORMATS:{CURRENCY_SYM:\"$\",DECIMAL_SEP:\".\",GROUP_SEP:\",\",PATTERNS:[{gSize:3,lgSize:3,maxFrac:3,minFrac:0,minInt:1,negPre:\"-\",negSuf:\"\",posPre:\"\",posSuf:\"\"},{gSize:3,lgSize:3,maxFrac:2,minFrac:2,minInt:1,negPre:\"-\\u00a4\",negSuf:\"\",posPre:\"\\u00a4\",posSuf:\"\"}]},id:\"en-us\",localeID:\"en_US\",pluralCat:function(a,\nc){var f=a|0,e=c;void 0===e&&(e=Math.min(b(a),3));Math.pow(10,e);return 1==f&&0==e?\"one\":\"other\"}})}]),D(function(){pe(z.document,Mc)}))})(window);!window.angular.$$csp().noInlineStyle&&window.angular.element(document.head).prepend('<style type=\"text/css\">@charset \"UTF-8\";[ng\\\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');\n//# sourceMappingURL=angular.min.js.map\n","/**\n * @license AngularJS v1.6.1\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar ADD_CLASS_SUFFIX = '-add';\nvar REMOVE_CLASS_SUFFIX = '-remove';\nvar EVENT_CLASS_PREFIX = 'ng-';\nvar ACTIVE_CLASS_SUFFIX = '-active';\nvar PREPARE_CLASS_SUFFIX = '-prepare';\n\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif ((window.ontransitionend === undefined) && (window.onwebkittransitionend !== undefined)) {\n  CSS_PREFIX = '-webkit-';\n  TRANSITION_PROP = 'WebkitTransition';\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n  TRANSITION_PROP = 'transition';\n  TRANSITIONEND_EVENT = 'transitionend';\n}\n\nif ((window.onanimationend === undefined) && (window.onwebkitanimationend !== undefined)) {\n  CSS_PREFIX = '-webkit-';\n  ANIMATION_PROP = 'WebkitAnimation';\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n  ANIMATION_PROP = 'animation';\n  ANIMATIONEND_EVENT = 'animationend';\n}\n\nvar DURATION_KEY = 'Duration';\nvar PROPERTY_KEY = 'Property';\nvar DELAY_KEY = 'Delay';\nvar TIMING_KEY = 'TimingFunction';\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar ngMinErr = angular.$$minErr('ng');\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', 'Argument \\'{0}\\' is {1}', (name || '?'), (reason || 'required'));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return '';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(' ');\n  if (isArray(b)) b = b.join(' ');\n  return a + ' ' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = '';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? ' ' : '';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return element;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it's important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType === ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  };\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationDetails(element, oldAnimation, newAnimation) {\n  var target = oldAnimation.options || {};\n  var newOptions = newAnimation.options || {};\n\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\n  if (newOptions.preparationClasses) {\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n    delete newOptions.preparationClasses;\n  }\n\n  // noop is basically when there is no callback; otherwise something has been set\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\n  extend(target, newOptions);\n\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {\n    target.domOperation = realDomOperation;\n  }\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  oldAnimation.addClass = target.addClass;\n  oldAnimation.removeClass = target.removeClass;\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: '',\n    removeClass: ''\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = 'addClass';\n      allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];\n    } else if (val === REMOVE_CLASS) {\n      prop = 'removeClass';\n      allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += ' ';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(' ');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof jqLite) ? element[0] : element;\n}\n\nfunction applyGeneratedPreparationClasses(element, event, options) {\n  var classes = '';\n  if (event) {\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n  }\n  if (options.addClass) {\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n  }\n  if (options.removeClass) {\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n  }\n  if (classes.length) {\n    options.preparationClasses = classes;\n    element.addClass(classes);\n  }\n}\n\nfunction clearGeneratedClasses(element, options) {\n  if (options.preparationClasses) {\n    element.removeClass(options.preparationClasses);\n    options.preparationClasses = null;\n  }\n  if (options.activeClasses) {\n    element.removeClass(options.activeClasses);\n    options.activeClasses = null;\n  }\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? '-' + duration + 's' : '';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? 'paused' : '';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction concatWithSpace(a,b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a + ' ' + b;\n}\n\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n  var queue, cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    queue = queue.concat(tasks);\n    nextTick();\n  }\n\n  queue = scheduler.queue = [];\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!queue.length) return;\n\n    var items = queue.shift();\n    for (var i = 0; i < items.length; i++) {\n      items[i]();\n    }\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n}];\n\n/**\n * @ngdoc directive\n * @name ngAnimateChildren\n * @restrict AE\n * @element ANY\n *\n * @description\n *\n * ngAnimateChildren allows you to specify that children of this element should animate even if any\n * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`\n * (structural) animation, child elements that also have an active structural animation are not animated.\n *\n * Note that even if `ngAnimateChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).\n *\n *\n * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,\n *     then child animations are allowed. If the value is `false`, child animations are not allowed.\n *\n * @example\n * <example module=\"ngAnimateChildren\" name=\"ngAnimateChildren\" deps=\"angular-animate.js\" animations=\"true\">\n     <file name=\"index.html\">\n       <div ng-controller=\"MainController as main\">\n         <label>Show container? <input type=\"checkbox\" ng-model=\"main.enterElement\" /></label>\n         <label>Animate children? <input type=\"checkbox\" ng-model=\"main.animateChildren\" /></label>\n         <hr>\n         <div ng-animate-children=\"{{main.animateChildren}}\">\n           <div ng-if=\"main.enterElement\" class=\"container\">\n             List of items:\n             <div ng-repeat=\"item in [0, 1, 2, 3]\" class=\"item\">Item {{item}}</div>\n           </div>\n         </div>\n       </div>\n     </file>\n     <file name=\"animations.css\">\n\n      .container.ng-enter,\n      .container.ng-leave {\n        transition: all ease 1.5s;\n      }\n\n      .container.ng-enter,\n      .container.ng-leave-active {\n        opacity: 0;\n      }\n\n      .container.ng-leave,\n      .container.ng-enter-active {\n        opacity: 1;\n      }\n\n      .item {\n        background: firebrick;\n        color: #FFF;\n        margin-bottom: 10px;\n      }\n\n      .item.ng-enter,\n      .item.ng-leave {\n        transition: transform 1.5s ease;\n      }\n\n      .item.ng-enter {\n        transform: translateX(50px);\n      }\n\n      .item.ng-enter-active {\n        transform: translateX(0);\n      }\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngAnimateChildren', ['ngAnimate'])\n        .controller('MainController', function MainController() {\n          this.animateChildren = false;\n          this.enterElement = false;\n        });\n    </file>\n  </example>\n */\nvar $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {\n  return {\n    link: function(scope, element, attrs) {\n      var val = attrs.ngAnimateChildren;\n      if (isString(val) && val.length === 0) { //empty attribute\n        element.data(NG_ANIMATE_CHILDREN_DATA, true);\n      } else {\n        // Interpolate and set the value, so that it is available to\n        // animations that run right after compilation\n        setData($interpolate(val)(scope));\n        attrs.$observe('ngAnimateChildren', setData);\n      }\n\n      function setData(value) {\n        value = value === 'on' || value === 'true';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      }\n    }\n  };\n}];\n\n/* exported $AnimateCssProvider */\n\nvar ANIMATE_TIMER_KEY = '$$animateCss';\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and\n * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n *    the animation is closed. This is useful for when the styles are used purely for the sake of\n *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).\n *    By default this value is set to `false`.\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\nvar ONE_SECOND = 1000;\n\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + 's'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + 's'];\n}\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === '-' || c === '+' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for negative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it's always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) === 's') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + 's';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += ' linear all';\n  }\n  return [style, value];\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\n// we do not reassign an already present style value since\n// if we detect the style property value again we may be\n// detecting styles that were added via the `from` styles.\n// We make use of `isDefined` here since an empty string\n// or null value (which is what getPropertyValue will return\n// for a non-existing style) will still be marked as a valid\n// value for the style (a falsy value implies that the style\n// is to be removed at the end of the animation). If we had a simple\n// \"OR\" statement then it would not be enough to catch that.\nfunction registerRestorableStyles(backup, node, properties) {\n  forEach(properties, function(prop) {\n    backup[prop] = isDefined(backup[prop])\n        ? backup[prop]\n        : node.style.getPropertyValue(prop);\n  });\n}\n\nvar $AnimateCssProvider = ['$animateProvider', /** @this */ function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = '$$ngAnimateParentKey';\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === 'infinite') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we're keeping an internal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, '-stagger');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n        var pageWidth = $$forceReflow();\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](pageWidth);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    return function init(element, initialOptions) {\n      // all of the animation functions should create\n      // a copy of the options data, however, if a\n      // parent service has already created a copy then\n      // we should stick to using that\n      var options = initialOptions || {};\n      if (!options.$$prepared) {\n        options = prepareAnimationOptions(copy(options));\n      }\n\n      var restoreStyles = {};\n      var node = getDomNode(element);\n      if (!node\n          || !node.parentNode\n          || !$$animateQueue.enabled()) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var temporaryStyles = [];\n      var classes = element.attr('class');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n      var startTime;\n      var events = [];\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(' ')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = '';\n      var addRemoveClassName = '';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += ' ';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n      }\n\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n      var fullClassName = classes + ' ' + preparationClasses;\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !preparationClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      if (!options.$$skipPreparationClasses) {\n        $$jqLite.addClass(element, preparationClasses);\n      }\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst && !options.skipBlocking) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty === 'all';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      if (options.delay != null) {\n        var delayStyle;\n        if (typeof options.delay !== 'boolean') {\n          delayStyle = parseFloat(options.delay);\n          // number in options.delay means we have to recalculate the delay for the closing timeout\n          maxDelay = Math.max(delayStyle, 0);\n        }\n\n        if (flags.applyTransitionDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle));\n        }\n\n        if (flags.applyAnimationDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n        }\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      if (options.from) {\n        if (options.cleanupStyles) {\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n        }\n        applyAnimationFromStyles(element, options);\n      }\n\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n        applyBlocking(maxDuration);\n      } else if (!options.skipBlocking) {\n        blockTransitions(node, false);\n      }\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don't have access to pause/resume the animation\n          // since it hasn't run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) {\n        // if the promise has been called already then we shouldn't close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        if (!options.$$skipPreparationClasses) {\n          $$jqLite.removeClass(element, preparationClasses);\n        }\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = '';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        if (Object.keys(restoreStyles).length) {\n          forEach(restoreStyles, function(value, prop) {\n            if (value) {\n              node.style.setProperty(prop, value);\n            } else {\n              node.style.removeProperty(prop);\n            }\n          });\n        }\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        if (events && events.length) {\n          // Remove the transitionend / animationend listener(s)\n          element.off(events.join(' '), onAnimationProgress);\n        }\n\n        //Cancel the fallback closing timeout and remove the timer data\n        var animationTimerData = element.data(ANIMATE_TIMER_KEY);\n        if (animationTimerData) {\n          $timeout.cancel(animationTimerData[0].timer);\n          element.removeData(ANIMATE_TIMER_KEY);\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        // should flush the cache animation\n        waitUntilQuiet(noop);\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function onAnimationProgress(event) {\n        event.stopPropagation();\n        var ev = event.originalEvent || event;\n\n        // we now always use `Date.now()` due to the recent changes with\n        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)\n        var timeStamp = ev.$manualTimeStamp || Date.now();\n\n        /* Firefox (or possibly just Gecko) likes to not round values up\n         * when a ms measurement is used for the animation */\n        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n        /* $manualTimeStamp is a mocked timeStamp value which is set\n         * within browserTrigger(). This is only here so that tests can\n         * mock animations properly. Real events fallback to event.timeStamp,\n         * or, if they don't, then a timeStamp is automatically created for them.\n         * We're checking to see if the timeStamp surpasses the expected delay,\n         * but we're using elapsedTime instead of the timeStamp on the 2nd\n         * pre-condition since animationPauseds sometimes close off early */\n        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n          // we set this flag to ensure that if the transition is paused then, when resumed,\n          // the animation will automatically close itself since transitions cannot be paused.\n          animationCompleted = true;\n          close();\n        }\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              if (animationPaused) {\n                temporaryStyles.push(value);\n              } else {\n                removeFromArray(temporaryStyles, value);\n              }\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidentally cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intentional stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.getAttribute('class') + ' ' + preparationClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== 'boolean' && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n            timings.animationDelay = relativeDelay;\n            delayStyle = getCssDelayStyle(relativeDelay, true);\n            temporaryStyles.push(delayStyle);\n            node.style[delayStyle[0]] = delayStyle[1];\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n          var endTime = startTime + timerTime;\n\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n          var setupFallbackTimer = true;\n          if (animationsData.length) {\n            var currentTimerData = animationsData[0];\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n            if (setupFallbackTimer) {\n              $timeout.cancel(currentTimerData.timer);\n            } else {\n              animationsData.push(close);\n            }\n          }\n\n          if (setupFallbackTimer) {\n            var timer = $timeout(onAnimationExpired, timerTime, false);\n            animationsData[0] = {\n              timer: timer,\n              expectedEndTime: endTime\n            };\n            animationsData.push(close);\n            element.data(ANIMATE_TIMER_KEY, animationsData);\n          }\n\n          if (events.length) {\n            element.on(events.join(' '), onAnimationProgress);\n          }\n\n          if (options.to) {\n            if (options.cleanupStyles) {\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n            }\n            applyAnimationToStyles(element, options);\n          }\n        }\n\n        function onAnimationExpired() {\n          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\n          // this will be false in the event that the element was\n          // removed from the DOM (via a leave animation or something\n          // similar)\n          if (animationsData) {\n            for (var i = 1; i < animationsData.length; i++) {\n              animationsData[i]();\n            }\n            element.removeData(ANIMATE_TIMER_KEY);\n          }\n        }\n      }\n    };\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = ['$$animationProvider', /** @this */ function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateCssDriver');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\n  function isDocumentFragment(node) {\n    return node.parentNode && node.parentNode.nodeType === 11;\n  }\n\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = $document[0].body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(\n      // this is to avoid using something that exists outside of the body\n      // we also special case the doc fragment case because our unit test code\n      // appends the $rootElement to the body after the app has been bootstrapped\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n    );\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, '');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(' ');\n      if (isString(b)) b = b.split(' ');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(' ');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn't return\n        // all the keys for the coords object when iterated\n        forEach(['width','height','top','left'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case 'top':\n              value += bodyNode.scrollTop;\n              break;\n            case 'left':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + 'px';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr('class') || '';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from, noop);\n      var toAnimation = prepareRegularAnimation(to, noop);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor['out'];\n        var inElement = anchor['in'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        options.event = animationDetails.event;\n        options.structural = true;\n        options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        if (animationDetails.event === 'leave') {\n          options.onDone = options.domOperation;\n        }\n      }\n\n      // We assign the preparationClasses as the actual animation event since\n      // the internals of $animateCss will just suffix the event token values\n      // with `-active` to trigger the animation.\n      if (options.preparationClasses) {\n        options.event = concatWithSpace(options.event, options.preparationClasses);\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = ['$animateProvider', /** @this */ function($animateProvider) {\n  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n       function($injector,   $$AnimateRunner,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, 'enter');\n    return function(element, event, classes, options) {\n      var animationClosed = false;\n\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element's className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr('class') || '';\n        if (options.addClass) {\n          classes += ' ' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += ' ' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don't return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event === 'leave') {\n          beforeFn = 'leave';\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== 'enter' && event !== 'move') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      function close() {\n        animationClosed = true;\n        applyOptions();\n        applyAnimationStyles(element, options);\n      }\n\n      var runner;\n\n      return {\n        $$willAnimate: true,\n        end: function() {\n          if (runner) {\n            runner.end();\n          } else {\n            close();\n            runner = new $$AnimateRunner();\n            runner.complete(true);\n          }\n          return runner;\n        },\n        start: function() {\n          if (runner) {\n            return runner;\n          }\n\n          runner = new $$AnimateRunner();\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          runner.setHost({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            close(success);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case 'animate':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case 'setClass':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case 'addClass':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case 'removeClass':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a, b;\n          if (fnName === 'beforeSetClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n          } else if (fnName === 'setClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          if (runners.length) {\n            $$AnimateRunner.all(runners, callback);\n          }  else {\n            callback();\n          }\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              if (reject) {\n                runner.cancel();\n              } else {\n                runner.end();\n              }\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(' ');\n      var matches = [], flagMap = {};\n      for (var i = 0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = ['$$animationProvider', /** @this */ function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateJsDriver');\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\nvar $$AnimateQueueProvider = ['$animateProvider', /** @this */ function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n  var ONE_SPACE = ' ';\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function makeTruthyCssClassMap(classString) {\n    if (!classString) {\n      return null;\n    }\n\n    var keys = classString.split(ONE_SPACE);\n    var map = Object.create(null);\n\n    forEach(keys, function(key) {\n      map[key] = true;\n    });\n    return map;\n  }\n\n  function hasMatchingClasses(newClassString, currentClassString) {\n    if (newClassString && currentClassString) {\n      var currentClassMap = makeTruthyCssClassMap(currentClassString);\n      return newClassString.split(ONE_SPACE).some(function(className) {\n        return currentClassMap[className];\n      });\n    }\n  }\n\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(element, currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(animation, and) {\n    var a = (animation.addClass || '').length > 0;\n    var b = (animation.removeClass || '').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(element, newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event === 'leave' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // if there is an ongoing current animation then don't even bother running the class-based animation\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // cancel the animation if classes added / removed in both animation cancel each other out,\n    // but only if the current animation isn't structural\n\n    if (currentAnimation.structural) return false;\n\n    var nA = newAnimation.addClass;\n    var nR = newAnimation.removeClass;\n    var cA = currentAnimation.addClass;\n    var cR = currentAnimation.removeClass;\n\n    // early detection to save the global CPU shortage :)\n    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {\n      return false;\n    }\n\n    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);\n  });\n\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n               '$$isDocumentHidden',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow,\n                $$isDocumentHidden) {\n\n    var activeAnimationsLookup = new $$HashMap();\n    var disabledElementsLookup = new $$HashMap();\n    var animationsEnabled = null;\n\n    function postDigestTaskFactory() {\n      var postDigestCalled = false;\n      return function(fn) {\n        // we only issue a call to postDigest before\n        // it has first passed. This prevents any callbacks\n        // from not firing once the animation has completed\n        // since it will be out of the digest cycle.\n        if (postDigestCalled) {\n          fn();\n        } else {\n          $rootScope.$$postDigest(function() {\n            postDigestCalled = true;\n            fn();\n          });\n        }\n      };\n    }\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it's important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var callbackRegistry = Object.create(null);\n\n    // remember that the classNameFilter is set during the provider/config\n    // stage therefore we can optimize here and setup a helper function\n    var classNameFilter = $animateProvider.classNameFilter();\n    var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationDetails(element, animation) {\n      return mergeAnimationDetails(element, animation, {});\n    }\n\n    // IE9-11 has no method \"contains\" in SVG element and in Node.prototype. Bug #10259.\n    var contains = window.Node.prototype.contains || /** @this */ function(arg) {\n      // eslint-disable-next-line no-bitwise\n      return this === arg || !!(this.compareDocumentPosition(arg) & 16);\n    };\n\n    function findCallbacks(parent, element, event) {\n      var targetNode = getDomNode(element);\n      var targetParentNode = getDomNode(parent);\n\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (contains.call(entry.node, targetNode)) {\n            matches.push(entry.callback);\n          } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    function filterFromRegistry(list, matchContainer, matchCallback) {\n      var containerNode = extractElementNode(matchContainer);\n      return list.filter(function(entry) {\n        var isMatch = entry.node === containerNode &&\n                        (!matchCallback || entry.callback === matchCallback);\n        return !isMatch;\n      });\n    }\n\n    function cleanupEventListeners(phase, element) {\n      if (phase === 'close' && !element[0].parentNode) {\n        // If the element is not attached to a parentNode, it has been removed by\n        // the domOperation, and we can safely remove the event callbacks\n        $animate.off(element);\n      }\n    }\n\n    var $animate = {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n\n        // Remove the callback when the element is removed from the DOM\n        jqLite(container).on('$destroy', function() {\n          var animationDetails = activeAnimationsLookup.get(node);\n\n          if (!animationDetails) {\n            // If there's an animation ongoing, the callback calling code will remove\n            // the event listeners. If we'd remove here, the callbacks would be removed\n            // before the animation ends\n            $animate.off(event, container, callback);\n          }\n        });\n      },\n\n      off: function(event, container, callback) {\n        if (arguments.length === 1 && !isString(arguments[0])) {\n          container = arguments[0];\n          for (var eventType in callbackRegistry) {\n            callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);\n          }\n\n          return;\n        }\n\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), 'element', 'not an element');\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !disabledElementsLookup.get(node);\n            } else {\n              // (element, bool) - Element setter\n              disabledElementsLookup.put(node, !bool);\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    return $animate;\n\n    function queueAnimation(element, event, initialOptions) {\n      // we always make a copy of the options since\n      // there should never be any side effects on\n      // the input data when running `$animateCss`.\n      var options = copy(initialOptions);\n\n      var node, parent;\n      element = stripCommentsFromElement(element);\n      if (element) {\n        node = getDomNode(element);\n        parent = element.parent();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // this is used to trigger callbacks in postDigest mode\n      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(' ');\n      }\n\n      if (options.addClass && !isString(options.addClass)) {\n        options.addClass = null;\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(' ');\n      }\n\n      if (options.removeClass && !isString(options.removeClass)) {\n        options.removeClass = null;\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      // there are situations where a directive issues an animation for\n      // a jqLite wrapper that contains only comment nodes... If this\n      // happens then there is no way we can perform an animation\n      if (!node) {\n        close();\n        return runner;\n      }\n\n      var className = [node.getAttribute('class'), options.addClass, options.removeClass].join(' ');\n      if (!isAnimatableClassName(className)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      var documentHidden = $$isDocumentHidden();\n\n      // this is a hard disable of all animations for the application or on\n      // the element itself, therefore  there is no need to continue further\n      // past this point if not enabled\n      // Animations are also disabled if the document is currently hidden (page is not visible\n      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame\n      var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state !== PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(element, parent, event);\n      }\n\n      if (skipAnimations) {\n        // Callbacks should fire even if the document is hidden (regression fix for issue #14120)\n        if (documentHidden) notifyProgress(runner, event, 'start');\n        close();\n        if (documentHidden) notifyProgress(runner, event, 'close');\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(element);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        addClass: options.addClass,\n        removeClass: options.removeClass,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationDetails(element, existingAnimation, newAnimation);\n            return existingAnimation.runner;\n          }\n        }\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn't started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the new animation options into existing animation options\n            mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n            return existingAnimation.runner;\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationDetails(element, newAnimation);\n            } else {\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n              //we return the same runner since only the option values of this animation will\n              //be fed into the `existingAnimation`.\n              return existingAnimation.runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationDetails(element, newAnimation);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(element);\n        return runner;\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === 'animate'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it's the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn't allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won't read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(element);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)\n            ? 'setClass'\n            : animationDetails.event;\n\n        markElementAnimationState(element, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n\n        // this will update the runner's flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, 'start', {});\n\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(getDomNode(element));\n          }\n          notifyProgress(runner, event, 'close', {});\n        });\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        runInNextPostDigestOrNow(function() {\n          var callbacks = findCallbacks(parent, element, event);\n          if (callbacks.length) {\n            // do not optimize this call here to RAF because\n            // we don't know how heavy the callback code here will\n            // be and if this code is buffered then this can\n            // lead to a performance regression.\n            $$rAF(function() {\n              forEach(callbacks, function(callback) {\n                callback(element, phase, data);\n              });\n              cleanupEventListeners(phase, element);\n            });\n          } else {\n            cleanupEventListeners(phase, element);\n          }\n        });\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) {\n        clearGeneratedClasses(element, options);\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(element) {\n      var node = getDomNode(element);\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10);\n        var animationDetails = activeAnimationsLookup.get(child);\n        if (animationDetails) {\n          switch (state) {\n            case RUNNING_STATE:\n              animationDetails.runner.end();\n              /* falls through */\n            case PRE_DIGEST_STATE:\n              activeAnimationsLookup.remove(child);\n              break;\n          }\n        }\n      });\n    }\n\n    function clearElementAnimationState(element) {\n      var node = getDomNode(element);\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.remove(node);\n    }\n\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n    }\n\n    /**\n     * This fn returns false if any of the following is true:\n     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed\n     * b) a parent element has an ongoing structural animation, and animateChildren is false\n     * c) the element is not a child of the body\n     * d) the element is not a child of the $rootElement\n     */\n    function areAnimationsAllowed(element, parentElement, event) {\n      var bodyElement = jqLite($document[0].body);\n      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';\n      var rootElementDetected = isMatchingElement(element, $rootElement);\n      var parentAnimationDetected = false;\n      var animateChildren;\n      var elementDisabled = disabledElementsLookup.get(getDomNode(element));\n\n      var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentElement = parentHost;\n      }\n\n      parentElement = getDomNode(parentElement);\n\n      while (parentElement) {\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n        }\n\n        if (parentElement.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentElement) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can't allow any animations to take place\n        // but if a parent animation is class-based then that's ok\n        if (!parentAnimationDetected) {\n          var parentElementDisabled = disabledElementsLookup.get(parentElement);\n\n          if (parentElementDisabled === true && elementDisabled !== false) {\n            // disable animations if the user hasn't explicitly enabled animations on the\n            // current element\n            elementDisabled = true;\n            // element is disabled via parent element, no need to check anything else\n            break;\n          } else if (parentElementDisabled === false) {\n            elementDisabled = false;\n          }\n          parentAnimationDetected = details.structural;\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!bodyElementDetected) {\n          // we also need to ensure that the element is or will be a part of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n        }\n\n        if (bodyElementDetected && rootElementDetected) {\n          // If both body and root have been found, any other checks are pointless,\n          // as no animation data should live outside the application\n          break;\n        }\n\n        if (!rootElementDetected) {\n          // If no rootElement is detected, check if the parentElement is pinned to another element\n          parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);\n          if (parentHost) {\n            // The pin target element becomes the next parent element\n            parentElement = getDomNode(parentHost);\n            continue;\n          }\n        }\n\n        parentElement = parentElement.parentNode;\n      }\n\n      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;\n      return allowAnimation && rootElementDetected && bodyElementDetected;\n    }\n\n    function markElementAnimationState(element, state, details) {\n      details = details || {};\n      details.state = state;\n\n      var node = getDomNode(element);\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.put(node, newValue);\n    }\n  }];\n}];\n\n/* exported $$AnimationProvider */\n\nvar $$AnimationProvider = ['$animateProvider', /** @this */ function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function sortAnimations(animations) {\n      var tree = { children: [] };\n      var i, lookup = new $$HashMap();\n\n      // this is done first beforehand so that the hashmap\n      // is filled with a list of the elements that will be animated\n      for (i = 0; i < animations.length; i++) {\n        var animation = animations[i];\n        lookup.put(animation.domNode, animations[i] = {\n          domNode: animation.domNode,\n          fn: animation.fn,\n          children: []\n        });\n      }\n\n      for (i = 0; i < animations.length; i++) {\n        processNode(animations[i]);\n      }\n\n      return flatten(tree);\n\n      function processNode(entry) {\n        if (entry.processed) return entry;\n        entry.processed = true;\n\n        var elementNode = entry.domNode;\n        var parentNode = elementNode.parentNode;\n        lookup.put(elementNode, entry);\n\n        var parentEntry;\n        while (parentNode) {\n          parentEntry = lookup.get(parentNode);\n          if (parentEntry) {\n            if (!parentEntry.processed) {\n              parentEntry = processNode(parentEntry);\n            }\n            break;\n          }\n          parentNode = parentNode.parentNode;\n        }\n\n        (parentEntry || tree).children.push(entry);\n        return entry;\n      }\n\n      function flatten(tree) {\n        var result = [];\n        var queue = [];\n        var i;\n\n        for (i = 0; i < tree.children.length; i++) {\n          queue.push(tree.children[i]);\n        }\n\n        var remainingLevelEntries = queue.length;\n        var nextLevelEntries = 0;\n        var row = [];\n\n        for (i = 0; i < queue.length; i++) {\n          var entry = queue[i];\n          if (remainingLevelEntries <= 0) {\n            remainingLevelEntries = nextLevelEntries;\n            nextLevelEntries = 0;\n            result.push(row);\n            row = [];\n          }\n          row.push(entry.fn);\n          entry.children.forEach(function(childEntry) {\n            nextLevelEntries++;\n            queue.push(childEntry);\n          });\n          remainingLevelEntries--;\n        }\n\n        if (row.length) {\n          result.push(row);\n        }\n\n        return result;\n      }\n    }\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver's end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += ' ' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      var prepareClassName;\n      if (isStructural) {\n        prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;\n        $$jqLite.addClass(element, prepareClassName);\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on('$destroy', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can't animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          } else {\n            entry.close();\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        var groupedAnimations = groupAnimations(animations);\n        var toBeSortedAnimations = [];\n\n        forEach(groupedAnimations, function(animationEntry) {\n          toBeSortedAnimations.push({\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n            fn: function triggerAnimationStart() {\n              // it's important that we apply the `ng-animate` CSS class and the\n              // temporary classes before we do any driver invoking since these\n              // CSS classes may be required for proper CSS detection.\n              animationEntry.beforeStart();\n\n              var startAnimationFn, closeFn = animationEntry.close;\n\n              // in the event that the element was removed before the digest runs or\n              // during the RAF sequencing then we should not trigger the animation.\n              var targetElement = animationEntry.anchors\n                  ? (animationEntry.from.element || animationEntry.to.element)\n                  : animationEntry.element;\n\n              if (getRunner(targetElement)) {\n                var operation = invokeFirstDriver(animationEntry);\n                if (operation) {\n                  startAnimationFn = operation.start;\n                }\n              }\n\n              if (!startAnimationFn) {\n                closeFn();\n              } else {\n                var animationRunner = startAnimationFn();\n                animationRunner.done(function(status) {\n                  closeFn(!status);\n                });\n                updateAnimationRunners(animationEntry, animationRunner);\n              }\n            }\n          });\n        });\n\n        // we need to sort each of the animations in order of parent to child\n        // relationships. This ensures that the child classes are applied at the\n        // right time.\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? 'to' : 'from';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can't have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effectively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            'out': from.element, 'in': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(' ');\n        b = b.split(' ');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === 'ng-') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(' ');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n        if (prepareClassName) {\n          $$jqLite.removeClass(element, prepareClassName);\n          prepareClassName = null;\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          var runner = getRunner(element);\n          if (runner) runner.setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) {\n        element.off('$destroy', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/**\n * @ngdoc directive\n * @name ngAnimateSwap\n * @restrict A\n * @scope\n *\n * @description\n *\n * ngAnimateSwap is a animation-oriented directive that allows for the container to\n * be removed and entered in whenever the associated expression changes. A\n * common usecase for this directive is a rotating banner or slider component which\n * contains one image being present at a time. When the active image changes\n * then the old image will perform a `leave` animation and the new element\n * will be inserted via an `enter` animation.\n *\n * @animations\n * | Animation                        | Occurs                               |\n * |----------------------------------|--------------------------------------|\n * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |\n * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |\n *\n * @example\n * <example name=\"ngAnimateSwap-directive\" module=\"ngAnimateSwapExample\"\n *          deps=\"angular-animate.js\"\n *          animations=\"true\" fixBase=\"true\">\n *   <file name=\"index.html\">\n *     <div class=\"container\" ng-controller=\"AppCtrl\">\n *       <div ng-animate-swap=\"number\" class=\"cell swap-animation\" ng-class=\"colorClass(number)\">\n *         {{ number }}\n *       </div>\n *     </div>\n *   </file>\n *   <file name=\"script.js\">\n *     angular.module('ngAnimateSwapExample', ['ngAnimate'])\n *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {\n *         $scope.number = 0;\n *         $interval(function() {\n *           $scope.number++;\n *         }, 1000);\n *\n *         var colors = ['red','blue','green','yellow','orange'];\n *         $scope.colorClass = function(number) {\n *           return colors[number % colors.length];\n *         };\n *       }]);\n *   </file>\n *  <file name=\"animations.css\">\n *  .container {\n *    height:250px;\n *    width:250px;\n *    position:relative;\n *    overflow:hidden;\n *    border:2px solid black;\n *  }\n *  .container .cell {\n *    font-size:150px;\n *    text-align:center;\n *    line-height:250px;\n *    position:absolute;\n *    top:0;\n *    left:0;\n *    right:0;\n *    border-bottom:2px solid black;\n *  }\n *  .swap-animation.ng-enter, .swap-animation.ng-leave {\n *    transition:0.5s linear all;\n *  }\n *  .swap-animation.ng-enter {\n *    top:-250px;\n *  }\n *  .swap-animation.ng-enter-active {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave-active {\n *    top:250px;\n *  }\n *  .red { background:red; }\n *  .green { background:green; }\n *  .blue { background:blue; }\n *  .yellow { background:yellow; }\n *  .orange { background:orange; }\n *  </file>\n * </example>\n */\nvar ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {\n  return {\n    restrict: 'A',\n    transclude: 'element',\n    terminal: true,\n    priority: 600, // we use 600 here to ensure that the directive is caught before others\n    link: function(scope, $element, attrs, ctrl, $transclude) {\n      var previousElement, previousScope;\n      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {\n        if (previousElement) {\n          $animate.leave(previousElement);\n        }\n        if (previousScope) {\n          previousScope.$destroy();\n          previousScope = null;\n        }\n        if (value || value === 0) {\n          previousScope = scope.$new();\n          $transclude(previousScope, function(element) {\n            previousElement = element;\n            $animate.enter(element, null, $element);\n          });\n        }\n      });\n    }\n  };\n}];\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=!bool\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n *     to not accidentally inherit a delay property from another CSS class &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ### The `ng-[event]-prepare` class\n *\n * This is a special class that can be used to prevent unwanted flickering / flash of content before\n * the actual animation starts. The class is added as soon as an animation is initialized, but removed\n * before the actual animation starts (after waiting for a $digest).\n * It is also only added for *structural* animations (`enter`, `move`, and `leave`).\n *\n * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`\n * into elements that have class-based animations such as `ngClass`.\n *\n * ```html\n * <div ng-class=\"{red: myProp}\">\n *   <div ng-class=\"{blue: myProp}\">\n *     <div class=\"message\" ng-if=\"myProp\"></div>\n *   </div>\n * </div>\n * ```\n *\n * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.\n * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:\n *\n * ```css\n * .message.ng-enter-prepare {\n *   opacity: 0;\n * }\n *\n * ```\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the animation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]);\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true,\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#!/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id: 1, title: 'Miss Beulah Roob' },\n            { id: 2, title: 'Trent Morissette' },\n            { id: 3, title: 'Miss Ava Pouros' },\n            { id: 4, title: 'Rod Pouros' },\n            { id: 5, title: 'Abdul Rice' },\n            { id: 6, title: 'Laurie Rutherford Sr.' },\n            { id: 7, title: 'Nakia McLaughlin' },\n            { id: 8, title: 'Jordon Blanda DVM' },\n            { id: 9, title: 'Rhoda Hand' },\n            { id: 10, title: 'Alexandrea Sauer' }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams',\n            function ProfileController($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#!/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\nvar copy;\nvar extend;\nvar forEach;\nvar isArray;\nvar isDefined;\nvar isElement;\nvar isFunction;\nvar isObject;\nvar isString;\nvar isUndefined;\nvar jqLite;\nvar noop;\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n */\nangular.module('ngAnimate', [], function initAngularHelpers() {\n  // Access helpers from angular core.\n  // Do it inside a `config` block to ensure `window.angular` is available.\n  noop        = angular.noop;\n  copy        = angular.copy;\n  extend      = angular.extend;\n  jqLite      = angular.element;\n  forEach     = angular.forEach;\n  isArray     = angular.isArray;\n  isString    = angular.isString;\n  isObject    = angular.isObject;\n  isUndefined = angular.isUndefined;\n  isDefined   = angular.isDefined;\n  isFunction  = angular.isFunction;\n  isElement   = angular.isElement;\n})\n  .directive('ngAnimateSwap', ngAnimateSwapDirective)\n\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\n  .provider('$$animateQueue', $$AnimateQueueProvider)\n  .provider('$$animation', $$AnimationProvider)\n\n  .provider('$animateCss', $AnimateCssProvider)\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\n  .provider('$$animateJs', $$AnimateJsProvider)\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n","/*global angular document navigator*/\n(function withAngular(angular, navigator) {\n\n    'use strict';\n\n    var A_DAY_IN_MILLISECONDS = 86400000\n        , isMobile = (function isMobile() {\n\n        if (navigator.userAgent &&\n            (navigator.userAgent.match(/Android/i) ||\n            navigator.userAgent.match(/webOS/i) ||\n            navigator.userAgent.match(/iPhone/i) ||\n            navigator.userAgent.match(/iPad/i) ||\n            navigator.userAgent.match(/iPod/i) ||\n            navigator.userAgent.match(/BlackBerry/i) ||\n            navigator.userAgent.match(/Windows Phone/i))) {\n\n            return true;\n        }\n    }())\n        , generateMonthAndYearHeader = function generateMonthAndYearHeader(prevButton, nextButton, preventMobile) {\n\n        if (preventMobile) {\n\n            isMobile = false;\n        }\n\n        if (isMobile) {\n\n            return [\n                '<div class=\"_720kb-datepicker-calendar-header\">',\n                '<div class=\"_720kb-datepicker-calendar-header-middle _720kb-datepicker-mobile-item _720kb-datepicker-calendar-month\">',\n                '<select ng-model=\"month\" title=\"{{ dateMonthTitle }}\" ng-change=\"selectedMonthHandle(month)\">',\n                '<option ng-repeat=\"item in months\" ng-selected=\"item === month\" ng-disabled=\\'!isSelectableMaxDate(item + \" \" + day + \", \" + year) || !isSelectableMinDate(item + \" \" + day + \", \" + year)\\' ng-value=\"$index + 1\" value=\"$index + 1\">',\n                '{{ item }}',\n                '</option>',\n                '</select>',\n                '</div>',\n                '</div>',\n                '<div class=\"_720kb-datepicker-calendar-header\">',\n                '<div class=\"_720kb-datepicker-calendar-header-middle _720kb-datepicker-mobile-item _720kb-datepicker-calendar-month\">',\n                '<select ng-model=\"mobileYear\" title=\"{{ dateYearTitle }}\" ng-change=\"setNewYear(mobileYear)\">',\n                '<option ng-repeat=\"item in paginationYears track by $index\" ng-selected=\"year === item\" ng-disabled=\"!isSelectableMinYear(item) || !isSelectableMaxYear(item)\" ng-value=\"item\" value=\"item\">',\n                '{{ item }}',\n                '</option>',\n                '</select>',\n                '</div>',\n                '</div>'\n            ];\n        }\n\n        return [\n            '<div class=\"_720kb-datepicker-calendar-header\">',\n            '<div class=\"_720kb-datepicker-calendar-header-left\">',\n            '<a class=\"_720kb-datepicker-calendar-month-button\" href=\"javascript:void(0)\" ng-class=\"{\\'_720kb-datepicker-item-hidden\\': !willPrevMonthBeSelectable()}\" ng-click=\"prevMonth()\" title=\"{{ buttonPrevTitle }}\">',\n            prevButton,\n            '</a>',\n            '</div>',\n            '<div class=\"_720kb-datepicker-calendar-header-middle _720kb-datepicker-calendar-month\">',\n            '{{month}}&nbsp;',\n            '<a href=\"javascript:void(0)\" ng-click=\"paginateYears(year); showYearsPagination = !showYearsPagination;\">',\n            '<span>',\n            '{{year}}',\n            '<i ng-class=\"{\\'_720kb-datepicker-calendar-header-closed-pagination\\': !showYearsPagination, \\'_720kb-datepicker-calendar-header-opened-pagination\\': showYearsPagination}\"></i>',\n            '</span>',\n            '</a>',\n            '</div>',\n            '<div class=\"_720kb-datepicker-calendar-header-right\">',\n            '<a class=\"_720kb-datepicker-calendar-month-button\" ng-class=\"{\\'_720kb-datepicker-item-hidden\\': !willNextMonthBeSelectable()}\" href=\"javascript:void(0)\" ng-click=\"nextMonth()\" title=\"{{ buttonNextTitle }}\">',\n            nextButton,\n            '</a>',\n            '</div>',\n            '</div>'\n        ];\n    }\n        , generateYearsPaginationHeader = function generateYearsPaginationHeader(prevButton, nextButton) {\n\n        return [\n            '<div class=\"_720kb-datepicker-calendar-header\" ng-show=\"showYearsPagination\">',\n            '<div class=\"_720kb-datepicker-calendar-years-pagination\">',\n            '<a ng-class=\"{\\'_720kb-datepicker-active\\': y === year, \\'_720kb-datepicker-disabled\\': !isSelectableMaxYear(y) || !isSelectableMinYear(y)}\" href=\"javascript:void(0)\" ng-click=\"setNewYear(y)\" ng-repeat=\"y in paginationYears track by $index\">',\n            '{{y}}',\n            '</a>',\n            '</div>',\n            '<div class=\"_720kb-datepicker-calendar-years-pagination-pages\">',\n            '<a href=\"javascript:void(0)\" ng-click=\"paginateYears(paginationYears[0])\" ng-class=\"{\\'_720kb-datepicker-item-hidden\\': paginationYearsPrevDisabled}\">',\n            prevButton,\n            '</a>',\n            '<a href=\"javascript:void(0)\" ng-click=\"paginateYears(paginationYears[paginationYears.length -1 ])\" ng-class=\"{\\'_720kb-datepicker-item-hidden\\': paginationYearsNextDisabled}\">',\n            nextButton,\n            '</a>',\n            '</div>',\n            '</div>'\n        ];\n    }\n        , generateDaysColumns = function generateDaysColumns() {\n\n        return [\n            '<div class=\"_720kb-datepicker-calendar-days-header\">',\n            '<div ng-repeat=\"d in daysInString\">',\n            '{{d}}',\n            '</div>',\n            '</div>'\n        ];\n    }\n        , generateDays = function generateDays() {\n\n        return [\n            '<div class=\"_720kb-datepicker-calendar-body\">',\n            '<a href=\"javascript:void(0)\" ng-repeat=\"px in prevMonthDays\" class=\"_720kb-datepicker-calendar-day _720kb-datepicker-disabled\">',\n            '{{px}}',\n            '</a>',\n            '<a href=\"javascript:void(0)\" ng-repeat=\"item in days\" ng-click=\"setDatepickerDay(item)\" ng-class=\"{\\'_720kb-datepicker-active\\': selectedDay === item && selectedMonth === monthNumber && selectedYear === year, \\'_720kb-datepicker-disabled\\': !isSelectableMinDate(year + \\'/\\' + monthNumber + \\'/\\' + item ) || !isSelectableMaxDate(year + \\'/\\' + monthNumber + \\'/\\' + item) || !isSelectableDate(monthNumber, year, item) || !isSelectableDay(monthNumber, year, item),\\'_720kb-datepicker-today\\': item === today.getDate() && monthNumber === (today.getMonth() + 1) && year === today.getFullYear() && !selectedDay}\" class=\"_720kb-datepicker-calendar-day\">',\n            '{{item}}',\n            '</a>',\n            '<a href=\"javascript:void(0)\" ng-repeat=\"nx in nextMonthDays\" class=\"_720kb-datepicker-calendar-day _720kb-datepicker-disabled\">',\n            '{{nx}}',\n            '</a>',\n            '</div>'\n        ];\n    }\n        , generateHtmlTemplate = function generateHtmlTemplate(prevButton, nextButton, preventMobile) {\n\n        var toReturn = [\n            '<div class=\"_720kb-datepicker-calendar {{datepickerClass}} {{datepickerID}}\" ng-class=\"{\\'_720kb-datepicker-forced-to-open\\': checkVisibility()}\" ng-blur=\"hideCalendar()\">',\n            '</div>'\n        ]\n            , monthAndYearHeader = generateMonthAndYearHeader(prevButton, nextButton, preventMobile)\n            , yearsPaginationHeader = generateYearsPaginationHeader(prevButton, nextButton)\n            , daysColumns = generateDaysColumns()\n            , days = generateDays()\n            , iterator = function iterator(aRow) {\n\n            toReturn.splice(toReturn.length - 1, 0, aRow);\n        };\n\n        monthAndYearHeader.forEach(iterator);\n        yearsPaginationHeader.forEach(iterator);\n        daysColumns.forEach(iterator);\n        days.forEach(iterator);\n\n        return toReturn.join('');\n    }\n        , datepickerDirective = function datepickerDirective($window, $compile, $locale, $filter, $interpolate, $timeout) {\n\n        var linkingFunction = function linkingFunction($scope, element, attr) {\n\n            //get child input\n            var selector = attr.selector\n                , thisInput = angular.element(selector ? element[0].querySelector('.' + selector) : element[0].children[0])\n                , theCalendar\n                , defaultPrevButton = '<b class=\"_720kb-datepicker-default-button\">&lang;</b>'\n                , defaultNextButton = '<b class=\"_720kb-datepicker-default-button\">&rang;</b>'\n                , prevButton = attr.buttonPrev || defaultPrevButton\n                , nextButton = attr.buttonNext || defaultNextButton\n                , dateFormat = attr.dateFormat\n                //, dateMinLimit\n                //, dateMaxLimit\n                , dateDisabledDates = $scope.$eval($scope.dateDisabledDates)\n                , dateDisabledWeekdays = $scope.$eval($scope.dateDisabledWeekdays)\n                , date = new Date()\n                , isMouseOn = false\n                , isMouseOnInput = false\n                , preventMobile = typeof attr.datepickerMobile !== 'undefined' && attr.datepickerMobile !== 'false'\n                , datetime = $locale.DATETIME_FORMATS\n                , pageDatepickers\n                , hours24h = 86400000\n                , htmlTemplate = generateHtmlTemplate(prevButton, nextButton, preventMobile)\n                , n\n                , onClickOnWindow = function onClickOnWindow() {\n\n                    if (!isMouseOn &&\n                        !isMouseOnInput && theCalendar) {\n\n                        $scope.hideCalendar();\n                    }\n                }\n                , setDaysInMonth = function setDaysInMonth(month, year) {\n\n                    var i\n                        , limitDate = new Date(year, month, 0).getDate()\n                        , firstDayMonthNumber = new Date(year + '/' + month + '/' + 1).getDay()\n                        , lastDayMonthNumber = new Date(year + '/' + month + '/' + limitDate).getDay()\n                        , prevMonthDays = []\n                        , nextMonthDays = []\n                        , howManyNextDays\n                        , howManyPreviousDays\n                        , monthAlias\n                        , dateWeekEndDay;\n\n                    $scope.days = [];\n                    $scope.dateWeekStartDay = $scope.validateWeekDay($scope.dateWeekStartDay);\n                    dateWeekEndDay = ($scope.dateWeekStartDay + 6) % 7;\n\n                    for (i = 1; i <= limitDate; i += 1) {\n\n                        $scope.days.push(i);\n                    }\n\n                    //get previous month days if first day in month is not first day in week\n                    if (firstDayMonthNumber === $scope.dateWeekStartDay) {\n\n                        //no need for it\n                        $scope.prevMonthDays = [];\n                    } else {\n\n                        howManyPreviousDays = firstDayMonthNumber - $scope.dateWeekStartDay;\n\n                        if (firstDayMonthNumber < $scope.dateWeekStartDay) {\n\n                            howManyPreviousDays += 7;\n                        }\n\n                        //get previous month\n                        if (Number(month) === 1) {\n\n                            monthAlias = 12;\n                        } else {\n\n                            monthAlias = month - 1;\n                        }\n                        //return previous month days\n                        for (i = 1; i <= new Date(year, monthAlias, 0).getDate(); i += 1) {\n\n                            prevMonthDays.push(i);\n                        }\n                        //attach previous month days\n                        $scope.prevMonthDays = prevMonthDays.slice(-howManyPreviousDays);\n                    }\n\n                    //get next month days if last day in month is not last day in week\n                    if (lastDayMonthNumber === dateWeekEndDay) {\n                        //no need for it\n                        $scope.nextMonthDays = [];\n                    } else {\n                        howManyNextDays = 6 - lastDayMonthNumber + $scope.dateWeekStartDay;\n\n                        if (lastDayMonthNumber < $scope.dateWeekStartDay) {\n\n                            howManyNextDays -= 7;\n                        }\n                        //get previous month\n\n                        //return next month days\n                        for (i = 1; i <= howManyNextDays; i += 1) {\n\n                            nextMonthDays.push(i);\n                        }\n                        //attach previous month days\n                        $scope.nextMonthDays = nextMonthDays;\n                    }\n                }\n                , resetToMinDate = function resetToMinDate() {\n\n                    $scope.month = $filter('date')(new Date($scope.dateMinLimit), 'MMMM');\n                    $scope.monthNumber = Number($filter('date')(new Date($scope.dateMinLimit), 'MM'));\n                    $scope.day = Number($filter('date')(new Date($scope.dateMinLimit), 'dd'));\n                    $scope.year = Number($filter('date')(new Date($scope.dateMinLimit), 'yyyy'));\n\n                    setDaysInMonth($scope.monthNumber, $scope.year);\n                }\n                , resetToMaxDate = function resetToMaxDate() {\n\n                    $scope.month = $filter('date')(new Date($scope.dateMaxLimit), 'MMMM');\n                    $scope.monthNumber = Number($filter('date')(new Date($scope.dateMaxLimit), 'MM'));\n                    $scope.day = Number($filter('date')(new Date($scope.dateMaxLimit), 'dd'));\n                    $scope.year = Number($filter('date')(new Date($scope.dateMaxLimit), 'yyyy'));\n\n                    setDaysInMonth($scope.monthNumber, $scope.year);\n                }\n                , prevYear = function prevYear() {\n\n                    $scope.year = Number($scope.year) - 1;\n                }\n                , nextYear = function nextYear() {\n\n                    $scope.year = Number($scope.year) + 1;\n                }\n                , localDateTimestamp = function localDateTimestamp(rawDate, dateFormatDefinition) {\n\n                    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|MMMM|MMM|MM|M|dd?d?|yy?yy?y?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g\n                        ,formatDate,dateSplit, m, d, y, index, el, longName, shortName;\n\n                    for (index = 0; index < datetime.MONTH.length; index += 1) {\n                        longName = datetime.MONTH[index];\n                        shortName = datetime.SHORTMONTH[index];\n\n                        if (rawDate.indexOf(longName) !== -1) {\n                            rawDate = rawDate.replace(longName, index + 1);\n                            break;\n                        }\n\n                        if (rawDate.indexOf(shortName) !== -1) {\n                            rawDate = rawDate.replace(shortName, index + 1);\n                            break;\n                        }\n                    }\n\n                    dateSplit = rawDate\n                        .split(/\\D/)\n                        .filter(function dateSplitFilter(item) {\n                            return item.length > 0;\n                        });\n\n                    formatDate = dateFormatDefinition\n                        .match(formattingTokens)\n                        .filter(function fromatDateFilter(item) {\n                            return item.match(/^[a-zA-Z]+$/i) !== null;\n                        });\n\n                    for (index = 0; index < formatDate.length; index += 1) {\n                        el = formatDate[index];\n\n                        switch (true) {\n                            case el.indexOf('d') !== -1: {\n                                d = dateSplit[index];\n                                break;\n                            }\n                            case el.indexOf('M') !== -1: {\n                                m = dateSplit[index];\n                                break;\n                            }\n                            case el.indexOf('y') !== -1: {\n                                y = dateSplit[index];\n                                break;\n                            }\n                            default: {\n                                break;\n                            }\n                        }\n                    }\n\n                    return new Date(y + '/' + m + '/' + d);\n                }\n                , setInputValue = function setInputValue() {\n\n                    if ($scope.isSelectableMinDate($scope.year + '/' + $scope.monthNumber + '/' + $scope.day) &&\n                        $scope.isSelectableMaxDate($scope.year + '/' + $scope.monthNumber + '/' + $scope.day)) {\n\n                        var modelDate = new Date($scope.year + '/' + $scope.monthNumber + '/' + $scope.day);\n\n                        if (attr.dateFormat) {\n\n                            thisInput.val($filter('date')(modelDate, dateFormat));\n                        } else {\n\n                            thisInput.val(modelDate);\n                        }\n\n                        thisInput.triggerHandler('input');\n                        thisInput.triggerHandler('change');//just to be sure;\n                    } else {\n\n                        return false;\n                    }\n                }\n                , classHelper = {\n                    'add': function add(ele, klass) {\n                        var classes;\n\n                        if (ele.className.indexOf(klass) > -1) {\n\n                            return;\n                        }\n\n                        classes = ele.className.split(' ');\n                        classes.push(klass);\n                        ele.className = classes.join(' ');\n                    },\n                    'remove': function remove(ele, klass) {\n                        var i\n                            , classes;\n\n                        if (ele.className.indexOf(klass) === -1) {\n\n                            return;\n                        }\n\n                        classes = ele.className.split(' ');\n                        for (i = 0; i < classes.length; i += 1) {\n\n                            if (classes[i] === klass) {\n\n                                classes = classes.slice(0, i).concat(classes.slice(i + 1));\n                                break;\n                            }\n                        }\n                        ele.className = classes.join(' ');\n                    }\n                }\n                , showCalendar = function showCalendar() {\n                    //lets hide all the latest instances of datepicker\n                    pageDatepickers = $window.document.getElementsByClassName('_720kb-datepicker-calendar');\n\n                    angular.forEach(pageDatepickers, function forEachDatepickerPages(value, key) {\n                        if (pageDatepickers[key].classList) {\n\n                            pageDatepickers[key].classList.remove('_720kb-datepicker-open');\n                        } else {\n\n                            classHelper.remove(pageDatepickers[key], '_720kb-datepicker-open');\n                        }\n                    });\n\n                    if (theCalendar.classList) {\n\n                        theCalendar.classList.add('_720kb-datepicker-open');\n                        if (dateFormat) {\n                            date = localDateTimestamp(thisInput[0].value.toString(), dateFormat);\n                        } else {\n                            date = new Date(thisInput[0].value.toString());\n                        }\n                        $scope.selectedMonth = Number($filter('date')(date, 'MM'));\n                        $scope.selectedDay = Number($filter('date')(date, 'dd'));\n                        $scope.selectedYear = Number($filter('date')(date, 'yyyy'));\n                    } else {\n\n                        classHelper.add(theCalendar, '_720kb-datepicker-open');\n                    }\n                    $scope.today = new Date();\n                    $timeout(function timeoutForYears() {\n                        if ($scope.selectedDay) {\n                            $scope.year = $scope.selectedYear;\n                            $scope.monthNumber = $scope.selectedMonth;\n                        } else {\n                            $scope.year = $scope.today.getFullYear();\n                            $scope.monthNumber = $scope.today.getMonth() + 1;\n                        }\n                        $scope.month = $filter('date')(new Date($scope.year, $scope.monthNumber - 1), 'MMMM');\n                        setDaysInMonth($scope.monthNumber, $scope.year);\n                    }, 0);\n                }\n                , checkToggle = function checkToggle() {\n                    if (!$scope.datepickerToggle) {\n\n                        return true;\n                    }\n\n                    return $scope.$eval($scope.datepickerToggle);\n                }\n                , checkVisibility = function checkVisibility() {\n                    if (!$scope.datepickerShow) {\n\n                        return false;\n                    }\n                    return $scope.$eval($scope.datepickerShow);\n                }\n                , unregisterDataSetWatcher = $scope.$watch('dateSet', function dateSetWatcher(newValue) {\n\n                    if (newValue && !isNaN(Date.parse(newValue))) {\n\n                        date = new Date(newValue);\n\n                        $scope.month = $filter('date')(date, 'MMMM');//december-November like\n                        $scope.monthNumber = Number($filter('date')(date, 'MM')); // 01-12 like\n                        $scope.day = Number($filter('date')(date, 'dd')); //01-31 like\n                        $scope.year = Number($filter('date')(date, 'yyyy'));//2014 like\n\n                        setDaysInMonth($scope.monthNumber, $scope.year);\n\n                        if ($scope.dateSetHidden !== 'true') {\n\n                            setInputValue();\n                        }\n                    }\n                })\n                , unregisterDateMinLimitWatcher = $scope.$watch('dateMinLimit', function dateMinLimitWatcher(newValue) {\n                    if (newValue) {\n                        resetToMinDate();\n                    }\n                })\n                , unregisterDateMaxLimitWatcher = $scope.$watch('dateMaxLimit', function dateMaxLimitWatcher(newValue) {\n                    if (newValue) {\n                        resetToMaxDate();\n                    }\n                })\n                , unregisterDateFormatWatcher = $scope.$watch('dateFormat', function dateFormatWatcher(newValue) {\n                    if (newValue) {\n                        setInputValue();\n                    }\n                })\n                , unregisterDateDisabledDatesWatcher = $scope.$watch('dateDisabledDates', function dateDisabledDatesWatcher(newValue) {\n                    if (newValue) {\n                        dateDisabledDates = $scope.$eval(newValue);\n\n                        if (!$scope.isSelectableDate($scope.monthNumber, $scope.year, $scope.day)) {\n                            thisInput.val('');\n                            thisInput.triggerHandler('input');\n                            thisInput.triggerHandler('change');//just to be sure;\n                        }\n                    }\n                });\n\n            $scope.nextMonth = function nextMonth() {\n\n                if ($scope.monthNumber === 12) {\n\n                    $scope.monthNumber = 1;\n                    //its happy new year\n                    nextYear();\n                } else {\n\n                    $scope.monthNumber += 1;\n                }\n\n                //check if max date is ok\n                if ($scope.dateMaxLimit) {\n\n                    if (!$scope.isSelectableMaxDate($scope.year + '/' + $scope.monthNumber + '/' + $scope.days[0])) {\n\n                        resetToMaxDate();\n                    }\n                }\n\n                //set next month\n                $scope.month = $filter('date')(new Date($scope.year, $scope.monthNumber - 1), 'MMMM');\n                //reinit days\n                setDaysInMonth($scope.monthNumber, $scope.year);\n                //deactivate selected day\n                $scope.day = undefined;\n            };\n\n            $scope.willPrevMonthBeSelectable = function willPrevMonthBeSelectable() {\n                var monthNumber = $scope.monthNumber\n                    , year = $scope.year\n                    , prevDay = $filter('date')(new Date(new Date(year + '/' + monthNumber + '/01').getTime() - hours24h), 'dd'); //get last day in previous month\n\n                if (monthNumber === 1) {\n\n                    monthNumber = 12;\n                    year = year - 1;\n                } else {\n\n                    monthNumber -= 1;\n                }\n\n                if ($scope.dateMinLimit) {\n                    if (!$scope.isSelectableMinDate(year + '/' + monthNumber + '/' + prevDay)) {\n\n                        return false;\n                    }\n                }\n\n                return true;\n            };\n\n            $scope.willNextMonthBeSelectable = function willNextMonthBeSelectable() {\n                var monthNumber = $scope.monthNumber\n                    , year = $scope.year;\n\n                if (monthNumber === 12) {\n\n                    monthNumber = 1;\n                    year += 1;\n                } else {\n\n                    monthNumber += 1;\n                }\n\n                if ($scope.dateMaxLimit) {\n                    if (!$scope.isSelectableMaxDate(year + '/' + monthNumber + '/01')) {\n\n                        return false;\n                    }\n                }\n\n                return true;\n            };\n\n            $scope.prevMonth = function managePrevMonth() {\n\n                if ($scope.monthNumber === 1) {\n\n                    $scope.monthNumber = 12;\n                    //its happy new year\n                    prevYear();\n                } else {\n\n                    $scope.monthNumber -= 1;\n                }\n                //check if min date is ok\n                if ($scope.dateMinLimit) {\n\n                    if (!$scope.isSelectableMinDate($scope.year + '/' + $scope.monthNumber + '/' + $scope.days[$scope.days.length - 1])) {\n\n                        resetToMinDate();\n                    }\n                }\n                //set next month\n                $scope.month = $filter('date')(new Date($scope.year, $scope.monthNumber - 1), 'MMMM');\n                //reinit days\n                setDaysInMonth($scope.monthNumber, $scope.year);\n                //deactivate selected day\n                $scope.day = undefined;\n            };\n\n            $scope.selectedMonthHandle = function manageSelectedMonthHandle(selectedMonthNumber) {\n\n                $scope.monthNumber = Number($filter('date')(new Date(selectedMonthNumber + '/01/2000'), 'MM'));\n                setDaysInMonth($scope.monthNumber, $scope.year);\n                setInputValue();\n            };\n\n            $scope.setNewYear = function setNewYear(year) {\n\n                //deactivate selected day\n                if (!isMobile) {\n                    $scope.day = undefined;\n                }\n\n                if ($scope.dateMaxLimit &&\n                    $scope.year < Number(year)) {\n\n                    if (!$scope.isSelectableMaxYear(year)) {\n\n                        return;\n                    }\n                } else if ($scope.dateMinLimit &&\n                    $scope.year > Number(year)) {\n\n                    if (!$scope.isSelectableMinYear(year)) {\n\n                        return;\n                    }\n                }\n\n                $scope.paginateYears(year);\n                $scope.showYearsPagination = false;\n                $timeout(function timeoutForYears() {\n                    $scope.year = Number(year);\n                    setDaysInMonth($scope.monthNumber, $scope.year);\n                }, 0);\n            };\n\n            $scope.hideCalendar = function hideCalendar() {\n                if (theCalendar.classList) {\n                    theCalendar.classList.remove('_720kb-datepicker-open');\n                } else {\n\n                    classHelper.remove(theCalendar, '_720kb-datepicker-open');\n                }\n            };\n\n            $scope.setDatepickerDay = function setDatepickerDay(day) {\n\n                if ($scope.isSelectableDay($scope.monthNumber, $scope.year, day) &&\n                    $scope.isSelectableDate($scope.monthNumber, $scope.year, day) &&\n                    $scope.isSelectableMaxDate($scope.year + '/' + $scope.monthNumber + '/' + day) &&\n                    $scope.isSelectableMinDate($scope.year + '/' + $scope.monthNumber + '/' + day)) {\n\n                    $scope.day = Number(day);\n                    $scope.selectedDay = $scope.day;\n                    $scope.selectedMonth = $scope.monthNumber;\n                    $scope.selectedYear = $scope.year;\n\n                    setInputValue();\n\n                    if (attr.hasOwnProperty('dateRefocus')) {\n                        thisInput[0].focus();\n                    }\n\n                    $scope.hideCalendar();\n                }\n            };\n\n            $scope.paginateYears = function paginateYears(startingYear) {\n                var i\n                    , theNewYears = []\n                    , daysToPrepend = 10\n                    , daysToAppend = 10;\n\n                $scope.paginationYears = [];\n                if (isMobile) {\n\n                    daysToPrepend = 50;\n                    daysToAppend = 50;\n                    if ( $scope.dateMinLimit && $scope.dateMaxLimit) {\n\n                        startingYear = new Date($scope.dateMaxLimit).getFullYear();\n                        daysToPrepend = startingYear - new Date($scope.dateMinLimit).getFullYear();\n                        daysToAppend = 1;\n                    }\n                }\n\n                for (i = daysToPrepend; i > 0; i -= 1) {\n\n                    theNewYears.push(Number(startingYear) - i);\n                }\n\n                for (i = 0; i < daysToAppend; i += 1) {\n\n                    theNewYears.push(Number(startingYear) + i);\n                }\n                //date typing in input date-typer\n                if ($scope.dateTyper === 'true') {\n\n                    thisInput.on('keyup blur', function onTyping() {\n\n                        if (thisInput[0].value &&\n                            thisInput[0].value.length &&\n                            thisInput[0].value.length > 0) {\n\n                            try {\n                                if (dateFormat) {\n                                    date = localDateTimestamp(thisInput[0].value.toString(), dateFormat);\n                                } else {\n                                    date = new Date(thisInput[0].value.toString());\n                                }\n\n                                if (date.getFullYear() &&\n                                    !isNaN(date.getDay()) &&\n                                    !isNaN(date.getMonth()) &&\n                                    $scope.isSelectableDay(date.getMonth(), date.getFullYear(), date.getDay()) &&\n                                    $scope.isSelectableDate(date.getMonth(), date.getFullYear(), date.getDay()) &&\n                                    $scope.isSelectableMaxDate(date) &&\n                                    $scope.isSelectableMinDate(date)) {\n\n                                    $scope.$apply(function applyTyping() {\n\n                                        $scope.month = $filter('date')(date, 'MMMM');//december-November like\n                                        $scope.monthNumber = Number($filter('date')(date, 'MM')); // 01-12 like\n                                        $scope.day = Number($filter('date')(date, 'dd')); //01-31 like\n\n                                        if (date.getFullYear().toString().length === 4) {\n                                            $scope.year = Number($filter('date')(date, 'yyyy'));//2014 like\n                                        }\n                                        setDaysInMonth($scope.monthNumber, $scope.year);\n                                    });\n                                }\n                            } catch (e) {\n\n                                return e;\n                            }\n                        }\n                    });\n                }\n                //check range dates\n                if ($scope.dateMaxLimit &&\n                    theNewYears &&\n                    theNewYears.length &&\n                    !$scope.isSelectableMaxYear(Number(theNewYears[theNewYears.length - 1]) + 1)) {\n\n                    $scope.paginationYearsNextDisabled = true;\n                } else {\n\n                    $scope.paginationYearsNextDisabled = false;\n                }\n\n                if ($scope.dateMinLimit &&\n                    theNewYears &&\n                    theNewYears.length &&\n                    !$scope.isSelectableMinYear(Number(theNewYears[0]) - 1)) {\n\n                    $scope.paginationYearsPrevDisabled = true;\n                } else {\n\n                    $scope.paginationYearsPrevDisabled = false;\n                }\n\n                $scope.paginationYears = theNewYears;\n            };\n\n            $scope.isSelectableDay = function isSelectableDay(monthNumber, year, day) {\n                var i = 0;\n\n                if (dateDisabledWeekdays && dateDisabledWeekdays.length > 0) {\n                    for (i; i <= dateDisabledWeekdays.length; i += 1) {\n                        if (dateDisabledWeekdays[i] === new Date(monthNumber + '/' + day + '/' + year).getDay()) {\n                            return false;\n                        }\n                    }\n                }\n\n                return true;\n            };\n\n            $scope.isSelectableDate = function isSelectableDate(monthNumber, year, day) {\n                var i = 0;\n\n                if (dateDisabledDates &&\n                    dateDisabledDates.length > 0) {\n\n                    for (i; i <= dateDisabledDates.length; i += 1) {\n\n                        if (new Date(dateDisabledDates[i]).getTime() === new Date(monthNumber + '/' + day + '/' + year).getTime()) {\n\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            };\n\n            $scope.isSelectableMinDate = function isSelectableMinDate(aDate) {\n                //if current date\n                if (!!$scope.dateMinLimit &&\n                    !!new Date($scope.dateMinLimit) &&\n                    new Date(aDate).getTime() < new Date($scope.dateMinLimit).getTime()) {\n\n                    return false;\n                }\n\n                return true;\n            };\n\n            $scope.isSelectableMaxDate = function isSelectableMaxDate(aDate) {\n                //if current date\n                if (!!$scope.dateMaxLimit &&\n                    !!new Date($scope.dateMaxLimit) &&\n                    new Date(aDate).getTime() > new Date($scope.dateMaxLimit).getTime()) {\n\n                    return false;\n                }\n\n                return true;\n            };\n\n            $scope.isSelectableMaxYear = function isSelectableMaxYear(year) {\n                if (!!$scope.dateMaxLimit &&\n                    year > new Date($scope.dateMaxLimit).getFullYear()) {\n\n                    return false;\n                }\n\n                return true;\n            };\n\n            $scope.isSelectableMinYear = function isSelectableMinYear(year) {\n                if (!!$scope.dateMinLimit &&\n                    year < new Date($scope.dateMinLimit).getFullYear()) {\n\n                    return false;\n                }\n\n                return true;\n            };\n\n            $scope.validateWeekDay = function isValidWeekDay(weekDay) {\n                var validWeekDay = Number(weekDay, 10);\n                // making sure that the given option is valid\n                if (!validWeekDay || validWeekDay < 0 || validWeekDay > 6) {\n\n                    validWeekDay = 0;\n                }\n                return validWeekDay;\n            };\n\n            // respect previously configured interpolation symbols.\n            htmlTemplate = htmlTemplate.replace(/{{/g, $interpolate.startSymbol()).replace(/}}/g, $interpolate.endSymbol());\n            $scope.dateMonthTitle = $scope.dateMonthTitle || 'Select month';\n            $scope.dateYearTitle = $scope.dateYearTitle || 'Select year';\n            $scope.buttonNextTitle = $scope.buttonNextTitle || 'Next';\n            $scope.buttonPrevTitle = $scope.buttonPrevTitle || 'Prev';\n            $scope.month = $filter('date')(date, 'MMMM');//december-November like\n            $scope.monthNumber = Number($filter('date')(date, 'MM')); // 01-12 like\n            $scope.day = Number($filter('date')(date, 'dd')); //01-31 like\n            $scope.dateWeekStartDay = $scope.validateWeekDay($scope.dateWeekStartDay);\n\n            if ($scope.dateMaxLimit) {\n\n                $scope.year = Number($filter('date')(new Date($scope.dateMaxLimit), 'yyyy'));//2014 like\n            } else {\n\n                $scope.year = Number($filter('date')(date, 'yyyy'));//2014 like\n            }\n            $scope.months = datetime.MONTH;\n\n            $scope.daysInString = [];\n            for (n = $scope.dateWeekStartDay; n <= $scope.dateWeekStartDay + 6; n += 1) {\n\n                $scope.daysInString.push(n % 7);\n            }\n            $scope.daysInString = $scope.daysInString.map(function mappingFunc(el) {\n\n                return $filter('date')(new Date(new Date('06/08/2014').valueOf() + A_DAY_IN_MILLISECONDS * el), 'EEE');\n            });\n\n            //create the calendar holder and append where needed\n            if ($scope.datepickerAppendTo &&\n                $scope.datepickerAppendTo.indexOf('.') !== -1) {\n\n                $scope.datepickerID = 'datepicker-id-' + new Date().getTime() + (Math.floor(Math.random() * 6) + 8);\n                angular.element(document.getElementsByClassName($scope.datepickerAppendTo.replace('.', ''))[0]).append($compile(angular.element(htmlTemplate))($scope, function afterCompile(el) {\n\n                    theCalendar = angular.element(el)[0];\n                }));\n            } else if ($scope.datepickerAppendTo &&\n                $scope.datepickerAppendTo.indexOf('#') !== -1) {\n\n                $scope.datepickerID = 'datepicker-id-' + new Date().getTime() + (Math.floor(Math.random() * 6) + 8);\n                angular.element(document.getElementById($scope.datepickerAppendTo.replace('#', ''))).append($compile(angular.element(htmlTemplate))($scope, function afterCompile(el) {\n\n                    theCalendar = angular.element(el)[0];\n                }));\n            } else if ($scope.datepickerAppendTo &&\n                $scope.datepickerAppendTo === 'body') {\n                $scope.datepickerID = 'datepicker-id-' + (new Date().getTime() + (Math.floor(Math.random() * 6) + 8));\n                angular.element(document).find('body').append($compile(angular.element(htmlTemplate))($scope, function afterCompile(el) {\n\n                    theCalendar = angular.element(el)[0];\n                }));\n            } else {\n\n                thisInput.after($compile(angular.element(htmlTemplate))($scope));\n                //get the calendar as element\n                theCalendar = element[0].querySelector('._720kb-datepicker-calendar');\n            }\n            //if datepicker-toggle=\"\" is not present or true by default\n            if (checkToggle()) {\n\n                thisInput.on('focus click focusin', function onFocusAndClick() {\n\n                    isMouseOnInput = true;\n\n                    if (!isMouseOn &&\n                        !isMouseOnInput && theCalendar) {\n\n                        $scope.hideCalendar();\n                    } else {\n\n                        showCalendar();\n                    }\n                });\n            }\n\n            thisInput.on('focusout blur', function onBlurAndFocusOut() {\n\n                isMouseOnInput = false;\n            });\n            //some tricky dirty events to fire if click is outside of the calendar and show/hide calendar when needed\n            angular.element(theCalendar).on('mouseenter', function onMouseEnter() {\n\n                isMouseOn = true;\n            });\n\n            angular.element(theCalendar).on('mouseleave', function onMouseLeave() {\n\n                isMouseOn = false;\n            });\n\n            angular.element(theCalendar).on('focusin', function onCalendarFocus() {\n\n                isMouseOn = true;\n            });\n\n            angular.element($window).on('click focus focusin', onClickOnWindow);\n\n            //check always if given range of dates is ok\n            if ($scope.dateMinLimit &&\n                !$scope.isSelectableMinYear($scope.year) ||\n                !$scope.isSelectableMinDate($scope.year + '/' + $scope.monthNumber + '/' + $scope.day)) {\n\n                resetToMinDate();\n            }\n\n            if ($scope.dateMaxLimit &&\n                !$scope.isSelectableMaxYear($scope.year) ||\n                !$scope.isSelectableMaxDate($scope.year + '/' + $scope.monthNumber + '/' + $scope.day)) {\n\n                resetToMaxDate();\n            }\n\n            //datepicker boot start\n            $scope.paginateYears($scope.year);\n\n            setDaysInMonth($scope.monthNumber, $scope.year);\n            $scope.checkVisibility = checkVisibility;\n\n            $scope.$on('$destroy', function unregisterListener() {\n\n                unregisterDataSetWatcher();\n                unregisterDateMinLimitWatcher();\n                unregisterDateMaxLimitWatcher();\n                unregisterDateFormatWatcher();\n                unregisterDateDisabledDatesWatcher();\n                thisInput.off('focus click focusout blur');\n                angular.element(theCalendar).off('mouseenter mouseleave focusin');\n                angular.element($window).off('click focus focusin', onClickOnWindow);\n            });\n        };\n\n        return {\n            'restrict': 'AEC',\n            'scope': {\n                'dateSet': '@',\n                'dateMinLimit': '@',\n                'dateMaxLimit': '@',\n                'dateMonthTitle': '@',\n                'dateYearTitle': '@',\n                'buttonNextTitle': '@',\n                'buttonPrevTitle': '@',\n                'dateDisabledDates': '@',\n                'dateDisabledWeekdays': '@',\n                'dateSetHidden': '@',\n                'dateTyper': '@',\n                'dateWeekStartDay': '@',\n                'datepickerAppendTo': '@',\n                'datepickerToggle': '@',\n                'datepickerClass': '@',\n                'datepickerShow': '@'\n            },\n            'link': linkingFunction\n        };\n    };\n\n    angular.module('720kb.datepicker', [])\n        .directive('datepicker', ['$window', '$compile', '$locale', '$filter', '$interpolate', '$timeout', datepickerDirective]);\n}(angular, navigator));","/*\n angular-file-upload v2.5.0\n https://github.com/nervgh/angular-file-upload\n*/\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angular-file-upload\"] = factory();\n\telse\n\t\troot[\"angular-file-upload\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tvar _options = __webpack_require__(2);\n\t\n\tvar _options2 = _interopRequireDefault(_options);\n\t\n\tvar _FileUploader = __webpack_require__(3);\n\t\n\tvar _FileUploader2 = _interopRequireDefault(_FileUploader);\n\t\n\tvar _FileLikeObject = __webpack_require__(4);\n\t\n\tvar _FileLikeObject2 = _interopRequireDefault(_FileLikeObject);\n\t\n\tvar _FileItem = __webpack_require__(5);\n\t\n\tvar _FileItem2 = _interopRequireDefault(_FileItem);\n\t\n\tvar _FileDirective = __webpack_require__(6);\n\t\n\tvar _FileDirective2 = _interopRequireDefault(_FileDirective);\n\t\n\tvar _FileSelect = __webpack_require__(7);\n\t\n\tvar _FileSelect2 = _interopRequireDefault(_FileSelect);\n\t\n\tvar _Pipeline = __webpack_require__(8);\n\t\n\tvar _Pipeline2 = _interopRequireDefault(_Pipeline);\n\t\n\tvar _FileDrop = __webpack_require__(9);\n\t\n\tvar _FileDrop2 = _interopRequireDefault(_FileDrop);\n\t\n\tvar _FileOver = __webpack_require__(10);\n\t\n\tvar _FileOver2 = _interopRequireDefault(_FileOver);\n\t\n\tvar _FileSelect3 = __webpack_require__(11);\n\t\n\tvar _FileSelect4 = _interopRequireDefault(_FileSelect3);\n\t\n\tvar _FileDrop3 = __webpack_require__(12);\n\t\n\tvar _FileDrop4 = _interopRequireDefault(_FileDrop3);\n\t\n\tvar _FileOver3 = __webpack_require__(13);\n\t\n\tvar _FileOver4 = _interopRequireDefault(_FileOver3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tangular.module(_config2.default.name, []).value('fileUploaderOptions', _options2.default).factory('FileUploader', _FileUploader2.default).factory('FileLikeObject', _FileLikeObject2.default).factory('FileItem', _FileItem2.default).factory('FileDirective', _FileDirective2.default).factory('FileSelect', _FileSelect2.default).factory('FileDrop', _FileDrop2.default).factory('FileOver', _FileOver2.default).factory('Pipeline', _Pipeline2.default).directive('nvFileSelect', _FileSelect4.default).directive('nvFileDrop', _FileDrop4.default).directive('nvFileOver', _FileOver4.default).run(['FileUploader', 'FileLikeObject', 'FileItem', 'FileDirective', 'FileSelect', 'FileDrop', 'FileOver', 'Pipeline', function (FileUploader, FileLikeObject, FileItem, FileDirective, FileSelect, FileDrop, FileOver, Pipeline) {\n\t    // only for compatibility\n\t    FileUploader.FileLikeObject = FileLikeObject;\n\t    FileUploader.FileItem = FileItem;\n\t    FileUploader.FileDirective = FileDirective;\n\t    FileUploader.FileSelect = FileSelect;\n\t    FileUploader.FileDrop = FileDrop;\n\t    FileUploader.FileOver = FileOver;\n\t    FileUploader.Pipeline = Pipeline;\n\t}]);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"name\": \"angularFileUpload\"\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = {\n\t    url: '/',\n\t    alias: 'file',\n\t    headers: {},\n\t    queue: [],\n\t    progress: 0,\n\t    autoUpload: false,\n\t    removeAfterUpload: false,\n\t    method: 'POST',\n\t    filters: [],\n\t    formData: [],\n\t    queueLimit: Number.MAX_VALUE,\n\t    withCredentials: false,\n\t    disableMultipart: false\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _angular = angular;\n\tvar bind = _angular.bind;\n\tvar copy = _angular.copy;\n\tvar extend = _angular.extend;\n\tvar forEach = _angular.forEach;\n\tvar isObject = _angular.isObject;\n\tvar isNumber = _angular.isNumber;\n\tvar isDefined = _angular.isDefined;\n\tvar isArray = _angular.isArray;\n\tvar isUndefined = _angular.isUndefined;\n\tvar element = _angular.element;\n\tfunction __identity(fileUploaderOptions, $rootScope, $http, $window, $timeout, FileLikeObject, FileItem, Pipeline) {\n\t    var File = $window.File;\n\t    var FormData = $window.FormData;\n\t\n\t    var FileUploader = function () {\n\t        /**********************\n\t         * PUBLIC\n\t         **********************/\n\t        /**\n\t         * Creates an instance of FileUploader\n\t         * @param {Object} [options]\n\t         * @constructor\n\t         */\n\t\n\t        function FileUploader(options) {\n\t            _classCallCheck(this, FileUploader);\n\t\n\t            var settings = copy(fileUploaderOptions);\n\t\n\t            extend(this, settings, options, {\n\t                isUploading: false,\n\t                _nextIndex: 0,\n\t                _directives: { select: [], drop: [], over: [] }\n\t            });\n\t\n\t            // add default filters\n\t            this.filters.unshift({ name: 'queueLimit', fn: this._queueLimitFilter });\n\t            this.filters.unshift({ name: 'folder', fn: this._folderFilter });\n\t        }\n\t        /**\n\t         * Adds items to the queue\n\t         * @param {File|HTMLInputElement|Object|FileList|Array<Object>} files\n\t         * @param {Object} [options]\n\t         * @param {Array<Function>|String} filters\n\t         */\n\t\n\t\n\t        FileUploader.prototype.addToQueue = function addToQueue(files, options, filters) {\n\t            var _this = this;\n\t\n\t            var incomingQueue = this.isArrayLikeObject(files) ? Array.prototype.slice.call(files) : [files];\n\t            var arrayOfFilters = this._getFilters(filters);\n\t            var count = this.queue.length;\n\t            var addedFileItems = [];\n\t\n\t            var next = function next() {\n\t                var something = incomingQueue.shift();\n\t\n\t                if (isUndefined(something)) {\n\t                    return done();\n\t                }\n\t\n\t                var fileLikeObject = _this.isFile(something) ? something : new FileLikeObject(something);\n\t                var pipes = _this._convertFiltersToPipes(arrayOfFilters);\n\t                var pipeline = new Pipeline(pipes);\n\t                var onThrown = function onThrown(err) {\n\t                    var originalFilter = err.pipe.originalFilter;\n\t\n\t                    var _err$args = _slicedToArray(err.args, 2);\n\t\n\t                    var fileLikeObject = _err$args[0];\n\t                    var options = _err$args[1];\n\t\n\t                    _this._onWhenAddingFileFailed(fileLikeObject, originalFilter, options);\n\t                    next();\n\t                };\n\t                var onSuccessful = function onSuccessful(fileLikeObject, options) {\n\t                    var fileItem = new FileItem(_this, fileLikeObject, options);\n\t                    addedFileItems.push(fileItem);\n\t                    _this.queue.push(fileItem);\n\t                    _this._onAfterAddingFile(fileItem);\n\t                    next();\n\t                };\n\t                pipeline.onThrown = onThrown;\n\t                pipeline.onSuccessful = onSuccessful;\n\t                pipeline.exec(fileLikeObject, options);\n\t            };\n\t\n\t            var done = function done() {\n\t                if (_this.queue.length !== count) {\n\t                    _this._onAfterAddingAll(addedFileItems);\n\t                    _this.progress = _this._getTotalProgress();\n\t                }\n\t\n\t                _this._render();\n\t                if (_this.autoUpload) _this.uploadAll();\n\t            };\n\t\n\t            next();\n\t        };\n\t        /**\n\t         * Remove items from the queue. Remove last: index = -1\n\t         * @param {FileItem|Number} value\n\t         */\n\t\n\t\n\t        FileUploader.prototype.removeFromQueue = function removeFromQueue(value) {\n\t            var index = this.getIndexOfItem(value);\n\t            var item = this.queue[index];\n\t            if (item.isUploading) item.cancel();\n\t            this.queue.splice(index, 1);\n\t            item._destroy();\n\t            this.progress = this._getTotalProgress();\n\t        };\n\t        /**\n\t         * Clears the queue\n\t         */\n\t\n\t\n\t        FileUploader.prototype.clearQueue = function clearQueue() {\n\t            while (this.queue.length) {\n\t                this.queue[0].remove();\n\t            }\n\t            this.progress = 0;\n\t        };\n\t        /**\n\t         * Uploads a item from the queue\n\t         * @param {FileItem|Number} value\n\t         */\n\t\n\t\n\t        FileUploader.prototype.uploadItem = function uploadItem(value) {\n\t            var index = this.getIndexOfItem(value);\n\t            var item = this.queue[index];\n\t            var transport = this.isHTML5 ? '_xhrTransport' : '_iframeTransport';\n\t\n\t            item._prepareToUploading();\n\t            if (this.isUploading) return;\n\t\n\t            this._onBeforeUploadItem(item);\n\t            if (item.isCancel) return;\n\t\n\t            item.isUploading = true;\n\t            this.isUploading = true;\n\t            this[transport](item);\n\t            this._render();\n\t        };\n\t        /**\n\t         * Cancels uploading of item from the queue\n\t         * @param {FileItem|Number} value\n\t         */\n\t\n\t\n\t        FileUploader.prototype.cancelItem = function cancelItem(value) {\n\t            var _this2 = this;\n\t\n\t            var index = this.getIndexOfItem(value);\n\t            var item = this.queue[index];\n\t            var prop = this.isHTML5 ? '_xhr' : '_form';\n\t            if (!item) return;\n\t            item.isCancel = true;\n\t            if (item.isUploading) {\n\t                // It will call this._onCancelItem() & this._onCompleteItem() asynchronously\n\t                item[prop].abort();\n\t            } else {\n\t                (function () {\n\t                    var dummy = [undefined, 0, {}];\n\t                    var onNextTick = function onNextTick() {\n\t                        _this2._onCancelItem.apply(_this2, [item].concat(dummy));\n\t                        _this2._onCompleteItem.apply(_this2, [item].concat(dummy));\n\t                    };\n\t                    $timeout(onNextTick); // Trigger callbacks asynchronously (setImmediate emulation)\n\t                })();\n\t            }\n\t        };\n\t        /**\n\t         * Uploads all not uploaded items of queue\n\t         */\n\t\n\t\n\t        FileUploader.prototype.uploadAll = function uploadAll() {\n\t            var items = this.getNotUploadedItems().filter(function (item) {\n\t                return !item.isUploading;\n\t            });\n\t            if (!items.length) return;\n\t\n\t            forEach(items, function (item) {\n\t                return item._prepareToUploading();\n\t            });\n\t            items[0].upload();\n\t        };\n\t        /**\n\t         * Cancels all uploads\n\t         */\n\t\n\t\n\t        FileUploader.prototype.cancelAll = function cancelAll() {\n\t            var items = this.getNotUploadedItems();\n\t            forEach(items, function (item) {\n\t                return item.cancel();\n\t            });\n\t        };\n\t        /**\n\t         * Returns \"true\" if value an instance of File\n\t         * @param {*} value\n\t         * @returns {Boolean}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype.isFile = function isFile(value) {\n\t            return this.constructor.isFile(value);\n\t        };\n\t        /**\n\t         * Returns \"true\" if value an instance of FileLikeObject\n\t         * @param {*} value\n\t         * @returns {Boolean}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype.isFileLikeObject = function isFileLikeObject(value) {\n\t            return this.constructor.isFileLikeObject(value);\n\t        };\n\t        /**\n\t         * Returns \"true\" if value is array like object\n\t         * @param {*} value\n\t         * @returns {Boolean}\n\t         */\n\t\n\t\n\t        FileUploader.prototype.isArrayLikeObject = function isArrayLikeObject(value) {\n\t            return this.constructor.isArrayLikeObject(value);\n\t        };\n\t        /**\n\t         * Returns a index of item from the queue\n\t         * @param {Item|Number} value\n\t         * @returns {Number}\n\t         */\n\t\n\t\n\t        FileUploader.prototype.getIndexOfItem = function getIndexOfItem(value) {\n\t            return isNumber(value) ? value : this.queue.indexOf(value);\n\t        };\n\t        /**\n\t         * Returns not uploaded items\n\t         * @returns {Array}\n\t         */\n\t\n\t\n\t        FileUploader.prototype.getNotUploadedItems = function getNotUploadedItems() {\n\t            return this.queue.filter(function (item) {\n\t                return !item.isUploaded;\n\t            });\n\t        };\n\t        /**\n\t         * Returns items ready for upload\n\t         * @returns {Array}\n\t         */\n\t\n\t\n\t        FileUploader.prototype.getReadyItems = function getReadyItems() {\n\t            return this.queue.filter(function (item) {\n\t                return item.isReady && !item.isUploading;\n\t            }).sort(function (item1, item2) {\n\t                return item1.index - item2.index;\n\t            });\n\t        };\n\t        /**\n\t         * Destroys instance of FileUploader\n\t         */\n\t\n\t\n\t        FileUploader.prototype.destroy = function destroy() {\n\t            var _this3 = this;\n\t\n\t            forEach(this._directives, function (key) {\n\t                forEach(_this3._directives[key], function (object) {\n\t                    object.destroy();\n\t                });\n\t            });\n\t        };\n\t        /**\n\t         * Callback\n\t         * @param {Array} fileItems\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onAfterAddingAll = function onAfterAddingAll(fileItems) {};\n\t        /**\n\t         * Callback\n\t         * @param {FileItem} fileItem\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onAfterAddingFile = function onAfterAddingFile(fileItem) {};\n\t        /**\n\t         * Callback\n\t         * @param {File|Object} item\n\t         * @param {Object} filter\n\t         * @param {Object} options\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onWhenAddingFileFailed = function onWhenAddingFileFailed(item, filter, options) {};\n\t        /**\n\t         * Callback\n\t         * @param {FileItem} fileItem\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onBeforeUploadItem = function onBeforeUploadItem(fileItem) {};\n\t        /**\n\t         * Callback\n\t         * @param {FileItem} fileItem\n\t         * @param {Number} progress\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onProgressItem = function onProgressItem(fileItem, progress) {};\n\t        /**\n\t         * Callback\n\t         * @param {Number} progress\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onProgressAll = function onProgressAll(progress) {};\n\t        /**\n\t         * Callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onSuccessItem = function onSuccessItem(item, response, status, headers) {};\n\t        /**\n\t         * Callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onErrorItem = function onErrorItem(item, response, status, headers) {};\n\t        /**\n\t         * Callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onCancelItem = function onCancelItem(item, response, status, headers) {};\n\t        /**\n\t         * Callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onCompleteItem = function onCompleteItem(item, response, status, headers) {};\n\t        /**\n\t         * Callback\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onCompleteAll = function onCompleteAll() {};\n\t        /**********************\n\t         * PRIVATE\n\t         **********************/\n\t        /**\n\t         * Returns the total progress\n\t         * @param {Number} [value]\n\t         * @returns {Number}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._getTotalProgress = function _getTotalProgress(value) {\n\t            if (this.removeAfterUpload) return value || 0;\n\t\n\t            var notUploaded = this.getNotUploadedItems().length;\n\t            var uploaded = notUploaded ? this.queue.length - notUploaded : this.queue.length;\n\t            var ratio = 100 / this.queue.length;\n\t            var current = (value || 0) * ratio / 100;\n\t\n\t            return Math.round(uploaded * ratio + current);\n\t        };\n\t        /**\n\t         * Returns array of filters\n\t         * @param {Array<Function>|String} filters\n\t         * @returns {Array<Function>}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._getFilters = function _getFilters(filters) {\n\t            if (!filters) return this.filters;\n\t            if (isArray(filters)) return filters;\n\t            var names = filters.match(/[^\\s,]+/g);\n\t            return this.filters.filter(function (filter) {\n\t                return names.indexOf(filter.name) !== -1;\n\t            });\n\t        };\n\t        /**\n\t        * @param {Array<Function>} filters\n\t        * @returns {Array<Function>}\n\t        * @private\n\t        */\n\t\n\t\n\t        FileUploader.prototype._convertFiltersToPipes = function _convertFiltersToPipes(filters) {\n\t            var _this4 = this;\n\t\n\t            return filters.map(function (filter) {\n\t                var fn = bind(_this4, filter.fn);\n\t                fn.isAsync = filter.fn.length === 3;\n\t                fn.originalFilter = filter;\n\t                return fn;\n\t            });\n\t        };\n\t        /**\n\t         * Updates html\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._render = function _render() {\n\t            if (!$rootScope.$$phase) $rootScope.$apply();\n\t        };\n\t        /**\n\t         * Returns \"true\" if item is a file (not folder)\n\t         * @param {File|FileLikeObject} item\n\t         * @returns {Boolean}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._folderFilter = function _folderFilter(item) {\n\t            return !!(item.size || item.type);\n\t        };\n\t        /**\n\t         * Returns \"true\" if the limit has not been reached\n\t         * @returns {Boolean}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._queueLimitFilter = function _queueLimitFilter() {\n\t            return this.queue.length < this.queueLimit;\n\t        };\n\t        /**\n\t         * Checks whether upload successful\n\t         * @param {Number} status\n\t         * @returns {Boolean}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._isSuccessCode = function _isSuccessCode(status) {\n\t            return status >= 200 && status < 300 || status === 304;\n\t        };\n\t        /**\n\t         * Transforms the server response\n\t         * @param {*} response\n\t         * @param {Object} headers\n\t         * @returns {*}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._transformResponse = function _transformResponse(response, headers) {\n\t            var headersGetter = this._headersGetter(headers);\n\t            forEach($http.defaults.transformResponse, function (transformFn) {\n\t                response = transformFn(response, headersGetter);\n\t            });\n\t            return response;\n\t        };\n\t        /**\n\t         * Parsed response headers\n\t         * @param headers\n\t         * @returns {Object}\n\t         * @see https://github.com/angular/angular.js/blob/master/src/ng/http.js\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._parseHeaders = function _parseHeaders(headers) {\n\t            var parsed = {},\n\t                key,\n\t                val,\n\t                i;\n\t\n\t            if (!headers) return parsed;\n\t\n\t            forEach(headers.split('\\n'), function (line) {\n\t                i = line.indexOf(':');\n\t                key = line.slice(0, i).trim().toLowerCase();\n\t                val = line.slice(i + 1).trim();\n\t\n\t                if (key) {\n\t                    parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n\t                }\n\t            });\n\t\n\t            return parsed;\n\t        };\n\t        /**\n\t         * Returns function that returns headers\n\t         * @param {Object} parsedHeaders\n\t         * @returns {Function}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._headersGetter = function _headersGetter(parsedHeaders) {\n\t            return function (name) {\n\t                if (name) {\n\t                    return parsedHeaders[name.toLowerCase()] || null;\n\t                }\n\t                return parsedHeaders;\n\t            };\n\t        };\n\t        /**\n\t         * The XMLHttpRequest transport\n\t         * @param {FileItem} item\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._xhrTransport = function _xhrTransport(item) {\n\t            var _this5 = this;\n\t\n\t            var xhr = item._xhr = new XMLHttpRequest();\n\t            var sendable;\n\t\n\t            if (!item.disableMultipart) {\n\t                sendable = new FormData();\n\t                forEach(item.formData, function (obj) {\n\t                    forEach(obj, function (value, key) {\n\t                        sendable.append(key, value);\n\t                    });\n\t                });\n\t\n\t                sendable.append(item.alias, item._file, item.file.name);\n\t            } else {\n\t                sendable = item._file;\n\t            }\n\t\n\t            if (typeof item._file.size != 'number') {\n\t                throw new TypeError('The file specified is no longer valid');\n\t            }\n\t\n\t            xhr.upload.onprogress = function (event) {\n\t                var progress = Math.round(event.lengthComputable ? event.loaded * 100 / event.total : 0);\n\t                _this5._onProgressItem(item, progress);\n\t            };\n\t\n\t            xhr.onload = function () {\n\t                var headers = _this5._parseHeaders(xhr.getAllResponseHeaders());\n\t                var response = _this5._transformResponse(xhr.response, headers);\n\t                var gist = _this5._isSuccessCode(xhr.status) ? 'Success' : 'Error';\n\t                var method = '_on' + gist + 'Item';\n\t                _this5[method](item, response, xhr.status, headers);\n\t                _this5._onCompleteItem(item, response, xhr.status, headers);\n\t            };\n\t\n\t            xhr.onerror = function () {\n\t                var headers = _this5._parseHeaders(xhr.getAllResponseHeaders());\n\t                var response = _this5._transformResponse(xhr.response, headers);\n\t                _this5._onErrorItem(item, response, xhr.status, headers);\n\t                _this5._onCompleteItem(item, response, xhr.status, headers);\n\t            };\n\t\n\t            xhr.onabort = function () {\n\t                var headers = _this5._parseHeaders(xhr.getAllResponseHeaders());\n\t                var response = _this5._transformResponse(xhr.response, headers);\n\t                _this5._onCancelItem(item, response, xhr.status, headers);\n\t                _this5._onCompleteItem(item, response, xhr.status, headers);\n\t            };\n\t\n\t            xhr.open(item.method, item.url, true);\n\t\n\t            xhr.withCredentials = item.withCredentials;\n\t\n\t            forEach(item.headers, function (value, name) {\n\t                xhr.setRequestHeader(name, value);\n\t            });\n\t\n\t            xhr.send(sendable);\n\t        };\n\t        /**\n\t         * The IFrame transport\n\t         * @param {FileItem} item\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._iframeTransport = function _iframeTransport(item) {\n\t            var _this6 = this;\n\t\n\t            var form = element('<form style=\"display: none;\" />');\n\t            var iframe = element('<iframe name=\"iframeTransport' + Date.now() + '\">');\n\t            var input = item._input;\n\t\n\t            if (item._form) item._form.replaceWith(input); // remove old form\n\t            item._form = form; // save link to new form\n\t\n\t            input.prop('name', item.alias);\n\t\n\t            forEach(item.formData, function (obj) {\n\t                forEach(obj, function (value, key) {\n\t                    var element_ = element('<input type=\"hidden\" name=\"' + key + '\" />');\n\t                    element_.val(value);\n\t                    form.append(element_);\n\t                });\n\t            });\n\t\n\t            form.prop({\n\t                action: item.url,\n\t                method: 'POST',\n\t                target: iframe.prop('name'),\n\t                enctype: 'multipart/form-data',\n\t                encoding: 'multipart/form-data' // old IE\n\t            });\n\t\n\t            iframe.bind('load', function () {\n\t                var html = '';\n\t                var status = 200;\n\t\n\t                try {\n\t                    // Fix for legacy IE browsers that loads internal error page\n\t                    // when failed WS response received. In consequence iframe\n\t                    // content access denied error is thrown becouse trying to\n\t                    // access cross domain page. When such thing occurs notifying\n\t                    // with empty response object. See more info at:\n\t                    // http://stackoverflow.com/questions/151362/access-is-denied-error-on-accessing-iframe-document-object\n\t                    // Note that if non standard 4xx or 5xx error code returned\n\t                    // from WS then response content can be accessed without error\n\t                    // but 'XHR' status becomes 200. In order to avoid confusion\n\t                    // returning response via same 'success' event handler.\n\t\n\t                    // fixed angular.contents() for iframes\n\t                    html = iframe[0].contentDocument.body.innerHTML;\n\t                } catch (e) {\n\t                    // in case we run into the access-is-denied error or we have another error on the server side\n\t                    // (intentional 500,40... errors), we at least say 'something went wrong' -> 500\n\t                    status = 500;\n\t                }\n\t\n\t                var xhr = { response: html, status: status, dummy: true };\n\t                var headers = {};\n\t                var response = _this6._transformResponse(xhr.response, headers);\n\t\n\t                _this6._onSuccessItem(item, response, xhr.status, headers);\n\t                _this6._onCompleteItem(item, response, xhr.status, headers);\n\t            });\n\t\n\t            form.abort = function () {\n\t                var xhr = { status: 0, dummy: true };\n\t                var headers = {};\n\t                var response;\n\t\n\t                iframe.unbind('load').prop('src', 'javascript:false;');\n\t                form.replaceWith(input);\n\t\n\t                _this6._onCancelItem(item, response, xhr.status, headers);\n\t                _this6._onCompleteItem(item, response, xhr.status, headers);\n\t            };\n\t\n\t            input.after(form);\n\t            form.append(input).append(iframe);\n\t\n\t            form[0].submit();\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {File|Object} item\n\t         * @param {Object} filter\n\t         * @param {Object} options\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onWhenAddingFileFailed = function _onWhenAddingFileFailed(item, filter, options) {\n\t            this.onWhenAddingFileFailed(item, filter, options);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {FileItem} item\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onAfterAddingFile = function _onAfterAddingFile(item) {\n\t            this.onAfterAddingFile(item);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {Array<FileItem>} items\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onAfterAddingAll = function _onAfterAddingAll(items) {\n\t            this.onAfterAddingAll(items);\n\t        };\n\t        /**\n\t         *  Inner callback\n\t         * @param {FileItem} item\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onBeforeUploadItem = function _onBeforeUploadItem(item) {\n\t            item._onBeforeUpload();\n\t            this.onBeforeUploadItem(item);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {FileItem} item\n\t         * @param {Number} progress\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onProgressItem = function _onProgressItem(item, progress) {\n\t            var total = this._getTotalProgress(progress);\n\t            this.progress = total;\n\t            item._onProgress(progress);\n\t            this.onProgressItem(item, progress);\n\t            this.onProgressAll(total);\n\t            this._render();\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onSuccessItem = function _onSuccessItem(item, response, status, headers) {\n\t            item._onSuccess(response, status, headers);\n\t            this.onSuccessItem(item, response, status, headers);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onErrorItem = function _onErrorItem(item, response, status, headers) {\n\t            item._onError(response, status, headers);\n\t            this.onErrorItem(item, response, status, headers);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onCancelItem = function _onCancelItem(item, response, status, headers) {\n\t            item._onCancel(response, status, headers);\n\t            this.onCancelItem(item, response, status, headers);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onCompleteItem = function _onCompleteItem(item, response, status, headers) {\n\t            item._onComplete(response, status, headers);\n\t            this.onCompleteItem(item, response, status, headers);\n\t\n\t            var nextItem = this.getReadyItems()[0];\n\t            this.isUploading = false;\n\t\n\t            if (isDefined(nextItem)) {\n\t                nextItem.upload();\n\t                return;\n\t            }\n\t\n\t            this.onCompleteAll();\n\t            this.progress = this._getTotalProgress();\n\t            this._render();\n\t        };\n\t        /**********************\n\t         * STATIC\n\t         **********************/\n\t        /**\n\t         * Returns \"true\" if value an instance of File\n\t         * @param {*} value\n\t         * @returns {Boolean}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.isFile = function isFile(value) {\n\t            return File && value instanceof File;\n\t        };\n\t        /**\n\t         * Returns \"true\" if value an instance of FileLikeObject\n\t         * @param {*} value\n\t         * @returns {Boolean}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.isFileLikeObject = function isFileLikeObject(value) {\n\t            return value instanceof FileLikeObject;\n\t        };\n\t        /**\n\t         * Returns \"true\" if value is array like object\n\t         * @param {*} value\n\t         * @returns {Boolean}\n\t         */\n\t\n\t\n\t        FileUploader.isArrayLikeObject = function isArrayLikeObject(value) {\n\t            return isObject(value) && 'length' in value;\n\t        };\n\t        /**\n\t         * Inherits a target (Class_1) by a source (Class_2)\n\t         * @param {Function} target\n\t         * @param {Function} source\n\t         */\n\t\n\t\n\t        FileUploader.inherit = function inherit(target, source) {\n\t            target.prototype = Object.create(source.prototype);\n\t            target.prototype.constructor = target;\n\t            target.super_ = source;\n\t        };\n\t\n\t        return FileUploader;\n\t    }();\n\t\n\t    /**********************\n\t     * PUBLIC\n\t     **********************/\n\t    /**\n\t     * Checks a support the html5 uploader\n\t     * @returns {Boolean}\n\t     * @readonly\n\t     */\n\t\n\t\n\t    FileUploader.prototype.isHTML5 = !!(File && FormData);\n\t    /**********************\n\t     * STATIC\n\t     **********************/\n\t    /**\n\t     * @borrows FileUploader.prototype.isHTML5\n\t     */\n\t    FileUploader.isHTML5 = FileUploader.prototype.isHTML5;\n\t\n\t    return FileUploader;\n\t}\n\t\n\t__identity.$inject = ['fileUploaderOptions', '$rootScope', '$http', '$window', '$timeout', 'FileLikeObject', 'FileItem', 'Pipeline'];\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _angular = angular;\n\tvar copy = _angular.copy;\n\tvar isElement = _angular.isElement;\n\tvar isString = _angular.isString;\n\tfunction __identity() {\n\t\n\t    return function () {\n\t        /**\n\t         * Creates an instance of FileLikeObject\n\t         * @param {File|HTMLInputElement|Object} fileOrInput\n\t         * @constructor\n\t         */\n\t\n\t        function FileLikeObject(fileOrInput) {\n\t            _classCallCheck(this, FileLikeObject);\n\t\n\t            var isInput = isElement(fileOrInput);\n\t            var fakePathOrObject = isInput ? fileOrInput.value : fileOrInput;\n\t            var postfix = isString(fakePathOrObject) ? 'FakePath' : 'Object';\n\t            var method = '_createFrom' + postfix;\n\t            this[method](fakePathOrObject);\n\t        }\n\t        /**\n\t         * Creates file like object from fake path string\n\t         * @param {String} path\n\t         * @private\n\t         */\n\t\n\t\n\t        FileLikeObject.prototype._createFromFakePath = function _createFromFakePath(path) {\n\t            this.lastModifiedDate = null;\n\t            this.size = null;\n\t            this.type = 'like/' + path.slice(path.lastIndexOf('.') + 1).toLowerCase();\n\t            this.name = path.slice(path.lastIndexOf('/') + path.lastIndexOf('\\\\') + 2);\n\t        };\n\t        /**\n\t         * Creates file like object from object\n\t         * @param {File|FileLikeObject} object\n\t         * @private\n\t         */\n\t\n\t\n\t        FileLikeObject.prototype._createFromObject = function _createFromObject(object) {\n\t            this.lastModifiedDate = copy(object.lastModifiedDate);\n\t            this.size = object.size;\n\t            this.type = object.type;\n\t            this.name = object.name;\n\t        };\n\t\n\t        return FileLikeObject;\n\t    }();\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _angular = angular;\n\tvar copy = _angular.copy;\n\tvar extend = _angular.extend;\n\tvar element = _angular.element;\n\tvar isElement = _angular.isElement;\n\tfunction __identity($compile, FileLikeObject) {\n\t\n\t    return function () {\n\t        /**\n\t         * Creates an instance of FileItem\n\t         * @param {FileUploader} uploader\n\t         * @param {File|HTMLInputElement|Object} some\n\t         * @param {Object} options\n\t         * @constructor\n\t         */\n\t\n\t        function FileItem(uploader, some, options) {\n\t            _classCallCheck(this, FileItem);\n\t\n\t            var isInput = isElement(some);\n\t            var input = isInput ? element(some) : null;\n\t            var file = !isInput ? some : null;\n\t\n\t            extend(this, {\n\t                url: uploader.url,\n\t                alias: uploader.alias,\n\t                headers: copy(uploader.headers),\n\t                formData: copy(uploader.formData),\n\t                removeAfterUpload: uploader.removeAfterUpload,\n\t                withCredentials: uploader.withCredentials,\n\t                disableMultipart: uploader.disableMultipart,\n\t                method: uploader.method\n\t            }, options, {\n\t                uploader: uploader,\n\t                file: new FileLikeObject(some),\n\t                isReady: false,\n\t                isUploading: false,\n\t                isUploaded: false,\n\t                isSuccess: false,\n\t                isCancel: false,\n\t                isError: false,\n\t                progress: 0,\n\t                index: null,\n\t                _file: file,\n\t                _input: input\n\t            });\n\t\n\t            if (input) this._replaceNode(input);\n\t        }\n\t        /**********************\n\t         * PUBLIC\n\t         **********************/\n\t        /**\n\t         * Uploads a FileItem\n\t         */\n\t\n\t\n\t        FileItem.prototype.upload = function upload() {\n\t            try {\n\t                this.uploader.uploadItem(this);\n\t            } catch (e) {\n\t                var message = e.name + ':' + e.message;\n\t                this.uploader._onCompleteItem(this, message, e.code, []);\n\t                this.uploader._onErrorItem(this, message, e.code, []);\n\t            }\n\t        };\n\t        /**\n\t         * Cancels uploading of FileItem\n\t         */\n\t\n\t\n\t        FileItem.prototype.cancel = function cancel() {\n\t            this.uploader.cancelItem(this);\n\t        };\n\t        /**\n\t         * Removes a FileItem\n\t         */\n\t\n\t\n\t        FileItem.prototype.remove = function remove() {\n\t            this.uploader.removeFromQueue(this);\n\t        };\n\t        /**\n\t         * Callback\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype.onBeforeUpload = function onBeforeUpload() {};\n\t        /**\n\t         * Callback\n\t         * @param {Number} progress\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype.onProgress = function onProgress(progress) {};\n\t        /**\n\t         * Callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileItem.prototype.onSuccess = function onSuccess(response, status, headers) {};\n\t        /**\n\t         * Callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileItem.prototype.onError = function onError(response, status, headers) {};\n\t        /**\n\t         * Callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileItem.prototype.onCancel = function onCancel(response, status, headers) {};\n\t        /**\n\t         * Callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileItem.prototype.onComplete = function onComplete(response, status, headers) {};\n\t        /**********************\n\t         * PRIVATE\n\t         **********************/\n\t        /**\n\t         * Inner callback\n\t         */\n\t\n\t\n\t        FileItem.prototype._onBeforeUpload = function _onBeforeUpload() {\n\t            this.isReady = true;\n\t            this.isUploading = false;\n\t            this.isUploaded = false;\n\t            this.isSuccess = false;\n\t            this.isCancel = false;\n\t            this.isError = false;\n\t            this.progress = 0;\n\t            this.onBeforeUpload();\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {Number} progress\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype._onProgress = function _onProgress(progress) {\n\t            this.progress = progress;\n\t            this.onProgress(progress);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype._onSuccess = function _onSuccess(response, status, headers) {\n\t            this.isReady = false;\n\t            this.isUploading = false;\n\t            this.isUploaded = true;\n\t            this.isSuccess = true;\n\t            this.isCancel = false;\n\t            this.isError = false;\n\t            this.progress = 100;\n\t            this.index = null;\n\t            this.onSuccess(response, status, headers);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype._onError = function _onError(response, status, headers) {\n\t            this.isReady = false;\n\t            this.isUploading = false;\n\t            this.isUploaded = true;\n\t            this.isSuccess = false;\n\t            this.isCancel = false;\n\t            this.isError = true;\n\t            this.progress = 0;\n\t            this.index = null;\n\t            this.onError(response, status, headers);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype._onCancel = function _onCancel(response, status, headers) {\n\t            this.isReady = false;\n\t            this.isUploading = false;\n\t            this.isUploaded = false;\n\t            this.isSuccess = false;\n\t            this.isCancel = true;\n\t            this.isError = false;\n\t            this.progress = 0;\n\t            this.index = null;\n\t            this.onCancel(response, status, headers);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype._onComplete = function _onComplete(response, status, headers) {\n\t            this.onComplete(response, status, headers);\n\t            if (this.removeAfterUpload) this.remove();\n\t        };\n\t        /**\n\t         * Destroys a FileItem\n\t         */\n\t\n\t\n\t        FileItem.prototype._destroy = function _destroy() {\n\t            if (this._input) this._input.remove();\n\t            if (this._form) this._form.remove();\n\t            delete this._form;\n\t            delete this._input;\n\t        };\n\t        /**\n\t         * Prepares to uploading\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype._prepareToUploading = function _prepareToUploading() {\n\t            this.index = this.index || ++this.uploader._nextIndex;\n\t            this.isReady = true;\n\t        };\n\t        /**\n\t         * Replaces input element on his clone\n\t         * @param {JQLite|jQuery} input\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype._replaceNode = function _replaceNode(input) {\n\t            var clone = $compile(input.clone())(input.scope());\n\t            clone.prop('value', null); // FF fix\n\t            input.css('display', 'none');\n\t            input.after(clone); // remove jquery dependency\n\t        };\n\t\n\t        return FileItem;\n\t    }();\n\t}\n\t\n\t__identity.$inject = ['$compile', 'FileLikeObject'];\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _angular = angular;\n\tvar extend = _angular.extend;\n\tfunction __identity() {\n\t    var FileDirective = function () {\n\t        /**\n\t         * Creates instance of {FileDirective} object\n\t         * @param {Object} options\n\t         * @param {Object} options.uploader\n\t         * @param {HTMLElement} options.element\n\t         * @param {Object} options.events\n\t         * @param {String} options.prop\n\t         * @constructor\n\t         */\n\t\n\t        function FileDirective(options) {\n\t            _classCallCheck(this, FileDirective);\n\t\n\t            extend(this, options);\n\t            this.uploader._directives[this.prop].push(this);\n\t            this._saveLinks();\n\t            this.bind();\n\t        }\n\t        /**\n\t         * Binds events handles\n\t         */\n\t\n\t\n\t        FileDirective.prototype.bind = function bind() {\n\t            for (var key in this.events) {\n\t                var prop = this.events[key];\n\t                this.element.bind(key, this[prop]);\n\t            }\n\t        };\n\t        /**\n\t         * Unbinds events handles\n\t         */\n\t\n\t\n\t        FileDirective.prototype.unbind = function unbind() {\n\t            for (var key in this.events) {\n\t                this.element.unbind(key, this.events[key]);\n\t            }\n\t        };\n\t        /**\n\t         * Destroys directive\n\t         */\n\t\n\t\n\t        FileDirective.prototype.destroy = function destroy() {\n\t            var index = this.uploader._directives[this.prop].indexOf(this);\n\t            this.uploader._directives[this.prop].splice(index, 1);\n\t            this.unbind();\n\t            // this.element = null;\n\t        };\n\t        /**\n\t         * Saves links to functions\n\t         * @private\n\t         */\n\t\n\t\n\t        FileDirective.prototype._saveLinks = function _saveLinks() {\n\t            for (var key in this.events) {\n\t                var prop = this.events[key];\n\t                this[prop] = this[prop].bind(this);\n\t            }\n\t        };\n\t\n\t        return FileDirective;\n\t    }();\n\t\n\t    /**\n\t     * Map of events\n\t     * @type {Object}\n\t     */\n\t\n\t\n\t    FileDirective.prototype.events = {};\n\t\n\t    return FileDirective;\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _angular = angular;\n\tvar extend = _angular.extend;\n\tfunction __identity($compile, FileDirective) {\n\t\n\t    return function (_FileDirective) {\n\t        _inherits(FileSelect, _FileDirective);\n\t\n\t        /**\n\t         * Creates instance of {FileSelect} object\n\t         * @param {Object} options\n\t         * @constructor\n\t         */\n\t\n\t        function FileSelect(options) {\n\t            _classCallCheck(this, FileSelect);\n\t\n\t            var extendedOptions = extend(options, {\n\t                // Map of events\n\t                events: {\n\t                    $destroy: 'destroy',\n\t                    change: 'onChange'\n\t                },\n\t                // Name of property inside uploader._directive object\n\t                prop: 'select'\n\t            });\n\t\n\t            var _this = _possibleConstructorReturn(this, _FileDirective.call(this, extendedOptions));\n\t\n\t            if (!_this.uploader.isHTML5) {\n\t                _this.element.removeAttr('multiple');\n\t            }\n\t            _this.element.prop('value', null); // FF fix\n\t            return _this;\n\t        }\n\t        /**\n\t         * Returns options\n\t         * @return {Object|undefined}\n\t         */\n\t\n\t\n\t        FileSelect.prototype.getOptions = function getOptions() {};\n\t        /**\n\t         * Returns filters\n\t         * @return {Array<Function>|String|undefined}\n\t         */\n\t\n\t\n\t        FileSelect.prototype.getFilters = function getFilters() {};\n\t        /**\n\t         * If returns \"true\" then HTMLInputElement will be cleared\n\t         * @returns {Boolean}\n\t         */\n\t\n\t\n\t        FileSelect.prototype.isEmptyAfterSelection = function isEmptyAfterSelection() {\n\t            return !!this.element.attr('multiple');\n\t        };\n\t        /**\n\t         * Event handler\n\t         */\n\t\n\t\n\t        FileSelect.prototype.onChange = function onChange() {\n\t            var files = this.uploader.isHTML5 ? this.element[0].files : this.element[0];\n\t            var options = this.getOptions();\n\t            var filters = this.getFilters();\n\t\n\t            if (!this.uploader.isHTML5) this.destroy();\n\t            this.uploader.addToQueue(files, options, filters);\n\t            if (this.isEmptyAfterSelection()) {\n\t                this.element.prop('value', null);\n\t                this.element.replaceWith($compile(this.element.clone())(this.scope)); // IE fix\n\t            }\n\t        };\n\t\n\t        return FileSelect;\n\t    }(FileDirective);\n\t}\n\t\n\t__identity.$inject = ['$compile', 'FileDirective'];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = __identity;\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _angular = angular;\n\tvar bind = _angular.bind;\n\tvar isUndefined = _angular.isUndefined;\n\tfunction __identity($q) {\n\t\n\t  return function () {\n\t    /**\n\t     * @param {Array<Function>} pipes\n\t     */\n\t\n\t    function Pipeline() {\n\t      var pipes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\t\n\t      _classCallCheck(this, Pipeline);\n\t\n\t      this.pipes = pipes;\n\t    }\n\t\n\t    Pipeline.prototype.next = function next(args) {\n\t      var pipe = this.pipes.shift();\n\t      if (isUndefined(pipe)) {\n\t        this.onSuccessful.apply(this, _toConsumableArray(args));\n\t        return;\n\t      }\n\t      var err = new Error('The filter has not passed');\n\t      err.pipe = pipe;\n\t      err.args = args;\n\t      if (pipe.isAsync) {\n\t        var deferred = $q.defer();\n\t        var onFulfilled = bind(this, this.next, args);\n\t        var onRejected = bind(this, this.onThrown, err);\n\t        deferred.promise.then(onFulfilled, onRejected);\n\t        pipe.apply(undefined, _toConsumableArray(args).concat([deferred]));\n\t      } else {\n\t        var isDone = Boolean(pipe.apply(undefined, _toConsumableArray(args)));\n\t        if (isDone) {\n\t          this.next(args);\n\t        } else {\n\t          this.onThrown(err);\n\t        }\n\t      }\n\t    };\n\t\n\t    Pipeline.prototype.exec = function exec() {\n\t      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t      }\n\t\n\t      this.next(args);\n\t    };\n\t\n\t    Pipeline.prototype.onThrown = function onThrown(err) {};\n\t\n\t    Pipeline.prototype.onSuccessful = function onSuccessful() {};\n\t\n\t    return Pipeline;\n\t  }();\n\t}\n\t\n\t__identity.$inject = ['$q'];\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _angular = angular;\n\tvar extend = _angular.extend;\n\tvar forEach = _angular.forEach;\n\tfunction __identity(FileDirective) {\n\t\n\t    return function (_FileDirective) {\n\t        _inherits(FileDrop, _FileDirective);\n\t\n\t        /**\n\t         * Creates instance of {FileDrop} object\n\t         * @param {Object} options\n\t         * @constructor\n\t         */\n\t\n\t        function FileDrop(options) {\n\t            _classCallCheck(this, FileDrop);\n\t\n\t            var extendedOptions = extend(options, {\n\t                // Map of events\n\t                events: {\n\t                    $destroy: 'destroy',\n\t                    drop: 'onDrop',\n\t                    dragover: 'onDragOver',\n\t                    dragleave: 'onDragLeave'\n\t                },\n\t                // Name of property inside uploader._directive object\n\t                prop: 'drop'\n\t            });\n\t\n\t            return _possibleConstructorReturn(this, _FileDirective.call(this, extendedOptions));\n\t        }\n\t        /**\n\t         * Returns options\n\t         * @return {Object|undefined}\n\t         */\n\t\n\t\n\t        FileDrop.prototype.getOptions = function getOptions() {};\n\t        /**\n\t         * Returns filters\n\t         * @return {Array<Function>|String|undefined}\n\t         */\n\t\n\t\n\t        FileDrop.prototype.getFilters = function getFilters() {};\n\t        /**\n\t         * Event handler\n\t         */\n\t\n\t\n\t        FileDrop.prototype.onDrop = function onDrop(event) {\n\t            var transfer = this._getTransfer(event);\n\t            if (!transfer) return;\n\t            var options = this.getOptions();\n\t            var filters = this.getFilters();\n\t            this._preventAndStop(event);\n\t            forEach(this.uploader._directives.over, this._removeOverClass, this);\n\t            this.uploader.addToQueue(transfer.files, options, filters);\n\t        };\n\t        /**\n\t         * Event handler\n\t         */\n\t\n\t\n\t        FileDrop.prototype.onDragOver = function onDragOver(event) {\n\t            var transfer = this._getTransfer(event);\n\t            if (!this._haveFiles(transfer.types)) return;\n\t            transfer.dropEffect = 'copy';\n\t            this._preventAndStop(event);\n\t            forEach(this.uploader._directives.over, this._addOverClass, this);\n\t        };\n\t        /**\n\t         * Event handler\n\t         */\n\t\n\t\n\t        FileDrop.prototype.onDragLeave = function onDragLeave(event) {\n\t            if (event.currentTarget === this.element[0]) return;\n\t            this._preventAndStop(event);\n\t            forEach(this.uploader._directives.over, this._removeOverClass, this);\n\t        };\n\t        /**\n\t         * Helper\n\t         */\n\t\n\t\n\t        FileDrop.prototype._getTransfer = function _getTransfer(event) {\n\t            return event.dataTransfer ? event.dataTransfer : event.originalEvent.dataTransfer; // jQuery fix;\n\t        };\n\t        /**\n\t         * Helper\n\t         */\n\t\n\t\n\t        FileDrop.prototype._preventAndStop = function _preventAndStop(event) {\n\t            event.preventDefault();\n\t            event.stopPropagation();\n\t        };\n\t        /**\n\t         * Returns \"true\" if types contains files\n\t         * @param {Object} types\n\t         */\n\t\n\t\n\t        FileDrop.prototype._haveFiles = function _haveFiles(types) {\n\t            if (!types) return false;\n\t            if (types.indexOf) {\n\t                return types.indexOf('Files') !== -1;\n\t            } else if (types.contains) {\n\t                return types.contains('Files');\n\t            } else {\n\t                return false;\n\t            }\n\t        };\n\t        /**\n\t         * Callback\n\t         */\n\t\n\t\n\t        FileDrop.prototype._addOverClass = function _addOverClass(item) {\n\t            item.addOverClass();\n\t        };\n\t        /**\n\t         * Callback\n\t         */\n\t\n\t\n\t        FileDrop.prototype._removeOverClass = function _removeOverClass(item) {\n\t            item.removeOverClass();\n\t        };\n\t\n\t        return FileDrop;\n\t    }(FileDirective);\n\t}\n\t\n\t__identity.$inject = ['FileDirective'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _angular = angular;\n\tvar extend = _angular.extend;\n\tfunction __identity(FileDirective) {\n\t\n\t    return function (_FileDirective) {\n\t        _inherits(FileOver, _FileDirective);\n\t\n\t        /**\n\t         * Creates instance of {FileDrop} object\n\t         * @param {Object} options\n\t         * @constructor\n\t         */\n\t\n\t        function FileOver(options) {\n\t            _classCallCheck(this, FileOver);\n\t\n\t            var extendedOptions = extend(options, {\n\t                // Map of events\n\t                events: {\n\t                    $destroy: 'destroy'\n\t                },\n\t                // Name of property inside uploader._directive object\n\t                prop: 'over',\n\t                // Over class\n\t                overClass: 'nv-file-over'\n\t            });\n\t\n\t            return _possibleConstructorReturn(this, _FileDirective.call(this, extendedOptions));\n\t        }\n\t        /**\n\t         * Adds over class\n\t         */\n\t\n\t\n\t        FileOver.prototype.addOverClass = function addOverClass() {\n\t            this.element.addClass(this.getOverClass());\n\t        };\n\t        /**\n\t         * Removes over class\n\t         */\n\t\n\t\n\t        FileOver.prototype.removeOverClass = function removeOverClass() {\n\t            this.element.removeClass(this.getOverClass());\n\t        };\n\t        /**\n\t         * Returns over class\n\t         * @returns {String}\n\t         */\n\t\n\t\n\t        FileOver.prototype.getOverClass = function getOverClass() {\n\t            return this.overClass;\n\t        };\n\t\n\t        return FileOver;\n\t    }(FileDirective);\n\t}\n\t\n\t__identity.$inject = ['FileDirective'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction __identity($parse, FileUploader, FileSelect) {\n\t\n\t    return {\n\t        link: function link(scope, element, attributes) {\n\t            var uploader = scope.$eval(attributes.uploader);\n\t\n\t            if (!(uploader instanceof FileUploader)) {\n\t                throw new TypeError('\"Uploader\" must be an instance of FileUploader');\n\t            }\n\t\n\t            var object = new FileSelect({\n\t                uploader: uploader,\n\t                element: element,\n\t                scope: scope\n\t            });\n\t\n\t            object.getOptions = $parse(attributes.options).bind(object, scope);\n\t            object.getFilters = function () {\n\t                return attributes.filters;\n\t            };\n\t        }\n\t    };\n\t}\n\t\n\t__identity.$inject = ['$parse', 'FileUploader', 'FileSelect'];\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction __identity($parse, FileUploader, FileDrop) {\n\t\n\t    return {\n\t        link: function link(scope, element, attributes) {\n\t            var uploader = scope.$eval(attributes.uploader);\n\t\n\t            if (!(uploader instanceof FileUploader)) {\n\t                throw new TypeError('\"Uploader\" must be an instance of FileUploader');\n\t            }\n\t\n\t            if (!uploader.isHTML5) return;\n\t\n\t            var object = new FileDrop({\n\t                uploader: uploader,\n\t                element: element\n\t            });\n\t\n\t            object.getOptions = $parse(attributes.options).bind(object, scope);\n\t            object.getFilters = function () {\n\t                return attributes.filters;\n\t            };\n\t        }\n\t    };\n\t}\n\t\n\t__identity.$inject = ['$parse', 'FileUploader', 'FileDrop'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction __identity(FileUploader, FileOver) {\n\t\n\t    return {\n\t        link: function link(scope, element, attributes) {\n\t            var uploader = scope.$eval(attributes.uploader);\n\t\n\t            if (!(uploader instanceof FileUploader)) {\n\t                throw new TypeError('\"Uploader\" must be an instance of FileUploader');\n\t            }\n\t\n\t            var object = new FileOver({\n\t                uploader: uploader,\n\t                element: element\n\t            });\n\t\n\t            object.getOverClass = function () {\n\t                return attributes.overClass || object.overClass;\n\t            };\n\t        }\n\t    };\n\t}\n\t\n\t__identity.$inject = ['FileUploader', 'FileOver'];\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=angular-file-upload.js.map","/**\n * Bunch of useful filters for angularJS(with no external dependencies!)\n * @version v0.5.15 - 2017-01-17 * @link https://github.com/a8m/angular-filter\n * @author Ariel Mashraki <ariel@mashraki.co.il>\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n(function ( window, angular, undefined ) {\n/*jshint globalstrict:true*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isUndefined = angular.isUndefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isNumber = angular.isNumber,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy,\n    equals = angular.equals;\n\n\n/**\n * @description\n * get an object and return array of values\n * @param object\n * @returns {Array}\n */\nfunction toArray(object) {\n  return isArray(object) \n    ? object \n    : Object.keys(object).map(function(key) {\n      return object[key];\n    });\n}\n\n/**\n * @param value\n * @returns {boolean}\n */\nfunction isNull(value) {\n    return value === null;\n}\n\n/**\n * @description\n * return if object contains partial object\n * @param partial{object}\n * @param object{object}\n * @returns {boolean}\n */\nfunction objectContains(partial, object) {\n  var keys = Object.keys(partial);\n\n  return keys.map(function(el) {\n    return (object[el] !== undefined) && (object[el] == partial[el]);\n  }).indexOf(false) == -1;\n\n}\n\n/**\n * @description\n * search for approximate pattern in string\n * @param word\n * @param pattern\n * @returns {*}\n */\nfunction hasApproxPattern(word, pattern) {\n  // cheaper version of indexOf; instead of creating each\n  // iteration new str.\n  function indexOf(word, p, c) {\n    var j = 0;\n    while ((p + j) <= word.length) {\n      if (word.charAt(p + j) == c) return j;\n      j++;\n    }\n    return -1;\n  }\n  var p = 0;\n  for (var i = 0; i <= pattern.length; i++) {\n    var index = indexOf(word, p, pattern.charAt(i));\n    if (index == -1) return false;\n    p += index + 1;\n  }\n  return true\n}\n\n/**\n * @description\n * return the first n element of an array,\n * if expression provided, is returns as long the expression return truthy\n * @param array\n * @param n {number}\n * @param expression {$parse}\n * @return array or single object\n */\nfunction getFirstMatches(array, n, expression) {\n  var count = 0;\n\n  return array.filter(function(elm) {\n    var rest = isDefined(expression) ? (count < n && expression(elm)) : count < n;\n    count = rest ? count+1 : count;\n\n    return rest;\n  });\n}\n/**\n * Polyfill to ECMA6 String.prototype.contains\n */\nif (!String.prototype.contains) {\n  String.prototype.contains = function() {\n    return String.prototype.indexOf.apply(this, arguments) !== -1;\n  };\n}\n\n/**\n * @param num {Number}\n * @param decimal {Number}\n * @returns {Number}\n */\nfunction convertToDecimal(num, decimal){\n  return Math.round(num * Math.pow(10,decimal)) / (Math.pow(10, decimal));\n}\n\n/**\n * @description\n * Get an object, and return an array composed of it's properties names(nested too).\n * @param obj {Object}\n * @param stack {Array}\n * @param parent {String}\n * @returns {Array}\n * @example\n * parseKeys({ a:1, b: { c:2, d: { e: 3 } } }) ==> [\"a\", \"b.c\", \"b.d.e\"]\n */\nfunction deepKeys(obj, stack, parent) {\n  stack = stack || [];\n  var keys = Object.keys(obj);\n\n  keys.forEach(function(el) {\n    //if it's a nested object\n    if(isObject(obj[el]) && !isArray(obj[el])) {\n      //concatenate the new parent if exist\n      var p = parent ? parent + '.' + el : parent;\n      deepKeys(obj[el], stack, p || el);\n    } else {\n      //create and save the key\n      var key = parent ? parent + '.' + el : el;\n      stack.push(key)\n    }\n  });\n  return stack\n}\n\n/**\n * @description\n * Test if given object is a Scope instance\n * @param obj\n * @returns {Boolean}\n */\nfunction isScope(obj) {\n  return obj && obj.$evalAsync && obj.$watch;\n}\n\n/**\n * @ngdoc filter\n * @name a8m.angular\n * @kind function\n *\n * @description\n * reference to angular function\n */\n\nangular.module('a8m.angular', [])\n\n    .filter('isUndefined', function () {\n      return function (input) {\n        return angular.isUndefined(input);\n      }\n    })\n    .filter('isDefined', function() {\n      return function (input) {\n        return angular.isDefined(input);\n      }\n    })\n    .filter('isFunction', function() {\n      return function (input) {\n        return angular.isFunction(input);\n      }\n    })\n    .filter('isString', function() {\n      return function (input) {\n        return angular.isString(input)\n      }\n    })\n    .filter('isNumber', function() {\n      return function (input) {\n        return angular.isNumber(input);\n      }\n    })\n    .filter('isArray', function() {\n      return function (input) {\n        return angular.isArray(input);\n      }\n    })\n    .filter('isObject', function() {\n      return function (input) {\n        return angular.isObject(input);\n      }\n    })\n    .filter('isEqual', function() {\n      return function (o1, o2) {\n        return angular.equals(o1, o2);\n      }\n    });\n\n/**\n * @ngdoc filter\n * @name a8m.conditions\n * @kind function\n *\n * @description\n * reference to math conditions\n */\n angular.module('a8m.conditions', [])\n\n  .filter({\n    isGreaterThan  : isGreaterThanFilter,\n    '>'            : isGreaterThanFilter,\n\n    isGreaterThanOrEqualTo  : isGreaterThanOrEqualToFilter,\n    '>='                    : isGreaterThanOrEqualToFilter,\n\n    isLessThan  : isLessThanFilter,\n    '<'         : isLessThanFilter,\n\n    isLessThanOrEqualTo  : isLessThanOrEqualToFilter,\n    '<='                 : isLessThanOrEqualToFilter,\n\n    isEqualTo  : isEqualToFilter,\n    '=='       : isEqualToFilter,\n\n    isNotEqualTo  : isNotEqualToFilter,\n    '!='          : isNotEqualToFilter,\n\n    isIdenticalTo  : isIdenticalToFilter,\n    '==='          : isIdenticalToFilter,\n\n    isNotIdenticalTo  : isNotIdenticalToFilter,\n    '!=='             : isNotIdenticalToFilter\n  });\n\n  function isGreaterThanFilter() {\n    return function (input, check) {\n      return input > check;\n    };\n  }\n\n  function isGreaterThanOrEqualToFilter() {\n    return function (input, check) {\n      return input >= check;\n    };\n  }\n\n  function isLessThanFilter() {\n    return function (input, check) {\n      return input < check;\n    };\n  }\n\n  function isLessThanOrEqualToFilter() {\n    return function (input, check) {\n      return input <= check;\n    };\n  }\n\n  function isEqualToFilter() {\n    return function (input, check) {\n      return input == check;\n    };\n  }\n\n  function isNotEqualToFilter() {\n    return function (input, check) {\n      return input != check;\n    };\n  }\n\n  function isIdenticalToFilter() {\n    return function (input, check) {\n      return input === check;\n    };\n  }\n\n  function isNotIdenticalToFilter() {\n    return function (input, check) {\n      return input !== check;\n    };\n  }\n/**\n * @ngdoc filter\n * @name isNull\n * @kind function\n *\n * @description\n * checks if value is null or not\n * @return Boolean\n */\nangular.module('a8m.is-null', [])\n    .filter('isNull', function () {\n      return function(input) {\n        return isNull(input);\n      }\n    });\n\n/**\n * @ngdoc filter\n * @name after-where\n * @kind function\n *\n * @description\n * get a collection and properties object, and returns all of the items\n * in the collection after the first that found with the given properties.\n *\n */\nangular.module('a8m.after-where', [])\n    .filter('afterWhere', function() {\n      return function (collection, object) {\n\n        collection = isObject(collection)\n          ? toArray(collection)\n          : collection;\n\n        if(!isArray(collection) || isUndefined(object)) return collection;\n\n        var index = collection.map( function( elm ) {\n          return objectContains(object, elm);\n        }).indexOf( true );\n\n        return collection.slice((index === -1) ? 0 : index);\n      }\n    });\n\n/**\n * @ngdoc filter\n * @name after\n * @kind function\n *\n * @description\n * get a collection and specified count, and returns all of the items\n * in the collection after the specified count.\n *\n */\n\nangular.module('a8m.after', [])\n    .filter('after', function() {\n      return function (collection, count) {\n        collection = isObject(collection)\n          ? toArray(collection)\n          : collection;\n\n        return (isArray(collection))\n          ? collection.slice(count)\n          : collection;\n      }\n    });\n\n/**\n * @ngdoc filter\n * @name before-where\n * @kind function\n *\n * @description\n * get a collection and properties object, and returns all of the items\n * in the collection before the first that found with the given properties.\n */\nangular.module('a8m.before-where', [])\n  .filter('beforeWhere', function() {\n    return function (collection, object) {\n\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      if(!isArray(collection) || isUndefined(object)) return collection;\n\n      var index = collection.map( function( elm ) {\n        return objectContains(object, elm);\n      }).indexOf( true );\n\n      return collection.slice(0, (index === -1) ? collection.length : ++index);\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name before\n * @kind function\n *\n * @description\n * get a collection and specified count, and returns all of the items\n * in the collection before the specified count.\n */\nangular.module('a8m.before', [])\n    .filter('before', function() {\n      return function (collection, count) {\n        collection = isObject(collection)\n          ? toArray(collection)\n          : collection;\n\n        return (isArray(collection))\n          ? collection.slice(0, (!count) ? count : --count)\n          : collection;\n      }\n    });\n\n/**\n * @ngdoc filter\n * @name chunkBy\n * @kind function\n *\n * @description\n * Collect data into fixed-length chunks or blocks\n */\n\nangular.module('a8m.chunk-by', ['a8m.filter-watcher'])\n    .filter('chunkBy', ['filterWatcher', function (filterWatcher) {\n      return function (array, n, fillVal) {\n\n        return filterWatcher.isMemoized('chunkBy', arguments) ||\n            filterWatcher.memoize('chunkBy', arguments, this,\n                _chunkBy(array, n, fillVal));\n        /**\n         * @description\n         * Get array with size `n` in `val` inside it.\n         * @param n\n         * @param val\n         * @returns {Array}\n         */\n        function fill(n, val) {\n          var ret = [];\n          while (n--) ret[n] = val;\n          return ret;\n        }\n\n        function _chunkBy(array, n, fillVal) {\n          if (!isArray(array)) return array;\n          return array.map(function (el, i, self) {\n            i = i * n;\n            el = self.slice(i, i + n);\n            return !isUndefined(fillVal) && el.length < n\n                ? el.concat(fill(n - el.length, fillVal))\n                : el;\n          }).slice(0, Math.ceil(array.length / n));\n        }\n      }\n    }]);\n\n/**\n * @ngdoc filter\n * @name concat\n * @kind function\n *\n * @description\n * get (array/object, object/array) and return merged collection\n */\nangular.module('a8m.concat', [])\n  .filter('concat', [function () {\n    return function (collection, joined) {\n\n      if (isUndefined(joined)) return collection;\n\n      if (isArray(collection)) {\n        return isObject(joined)\n          ? collection.concat(toArray(joined))\n          : collection.concat(joined);\n      }\n\n      if (isObject(collection)) {\n        var array = toArray(collection);\n        return (isObject(joined))\n          ? array.concat(toArray(joined))\n          : array.concat(joined);\n      }\n      return collection;\n    };\n  }\n]);\n\n/**\n * @ngdoc filter\n * @name contains\n * @kind function\n *\n * @description\n * Checks if given expression is present in one or more object in the collection\n */\nangular.module('a8m.contains', [])\n  .filter({\n    contains: ['$parse', containsFilter],\n    some: ['$parse', containsFilter]\n  });\n\nfunction containsFilter($parse) {\n    return function (collection, expression) {\n\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      if(!isArray(collection) || isUndefined(expression)) {\n        return false;\n      }\n\n      return collection.some(function(elm) {\n        return ((isString(expression) && isObject(elm)) || isFunction(expression))\n          ? $parse(expression)(elm)\n          : elm === expression;\n      });\n\n    }\n }\n\n/**\n * @ngdoc filter\n * @name countBy\n * @kind function\n *\n * @description\n * Sorts a list into groups and returns a count for the number of objects in each group.\n */\n\nangular.module('a8m.count-by', [])\n\n  .filter('countBy', [ '$parse', function ( $parse ) {\n    return function (collection, property) {\n\n      var result = {},\n        get = $parse(property),\n        prop;\n\n      collection = (isObject(collection)) ? toArray(collection) : collection;\n\n      if(!isArray(collection) || isUndefined(property)) {\n        return collection;\n      }\n\n      collection.forEach( function( elm ) {\n        prop = get(elm);\n\n        if(!result[prop]) {\n          result[prop] = 0;\n        }\n\n        result[prop]++;\n      });\n\n      return result;\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name defaults\n * @kind function\n *\n * @description\n * defaultsFilter allows to specify a default fallback value for properties that resolve to undefined.\n */\nangular.module('a8m.defaults', [])\n  .filter('defaults', ['$parse', function( $parse ) {\n    return function(collection, defaults) {\n\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      if(!isArray(collection) || !isObject(defaults)) {\n        return collection;\n      }\n\n      var keys = deepKeys(defaults);\n\n      collection.forEach(function(elm) {\n        //loop through all the keys\n        keys.forEach(function(key) {\n          var getter = $parse(key);\n          var setter = getter.assign;\n          //if it's not exist\n          if(isUndefined(getter(elm))) {\n            //get from defaults, and set to the returned object\n            setter(elm, getter(defaults))\n          }\n        });\n      });\n\n      return collection;\n    }\n  }]);\n/**\n * @ngdoc filter\n * @name every\n * @kind function\n *\n * @description\n * Checks if given expression is present in all members in the collection\n *\n */\nangular.module('a8m.every', [])\n  .filter('every', ['$parse', function($parse) {\n    return function (collection, expression) {\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      if(!isArray(collection) || isUndefined(expression)) {\n        return true;\n      }\n\n      return collection.every( function(elm) {\n        return (isObject(elm) || isFunction(expression))\n          ? $parse(expression)(elm)\n          : elm === expression;\n      });\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name filterBy\n * @kind function\n *\n * @description\n * filter by specific properties, avoid the rest\n */\nangular.module('a8m.filter-by', [])\n  .filter('filterBy', ['$parse', function( $parse ) {\n    return function(collection, properties, search, strict) {\n      var comparator;\n\n      search = (isString(search) || isNumber(search)) ?\n        String(search).toLowerCase() : undefined;\n\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      if(!isArray(collection) || isUndefined(search)) {\n        return collection;\n      }\n\n      return collection.filter(function(elm) {\n        return properties.some(function(prop) {\n\n          /**\n           * check if there is concatenate properties\n           * example:\n           * object: { first: 'foo', last:'bar' }\n           * filterBy: ['first + last'] => search by full name(i.e 'foo bar')\n           */\n          if(!~prop.indexOf('+')) {\n            comparator = $parse(prop)(elm)\n          } else {\n            var propList = prop.replace(/\\s+/g, '').split('+');\n            comparator = propList\n              .map(function(prop) { return $parse(prop)(elm); })\n              .join(' ');\n          }\n\n          if (!isString(comparator) && !isNumber(comparator)) {\n            return false;\n          }\n\n          comparator = String(comparator).toLowerCase();\n\n          return strict ? comparator === search : comparator.contains(search);\n        });\n      });\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name first\n * @kind function\n *\n * @description\n * Gets the first element or first n elements of an array\n * if callback is provided, is returns as long the callback return truthy\n */\nangular.module('a8m.first', [])\n  .filter('first', ['$parse', function( $parse ) {\n    return function(collection) {\n      var n\n        , getter\n        , args;\n\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      if(!isArray(collection)) {\n        return collection;\n      }\n\n      args = Array.prototype.slice.call(arguments, 1);\n      n = (isNumber(args[0])) ? args[0] : 1;\n      getter = (!isNumber(args[0]))  ? args[0] : (!isNumber(args[1])) ? args[1] : undefined;\n\n      return (args.length) ? getFirstMatches(collection, n,(getter) ? $parse(getter) : getter) :\n        collection[0];\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name flatten\n * @kind function\n *\n * @description\n * Flattens a nested array (the nesting can be to any depth).\n * If you pass shallow, the array will only be flattened a single level\n */\nangular.module('a8m.flatten', [])\n  .filter('flatten', function () {\n    return function(collection, shallow) {\n\n      shallow = shallow || false;\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      if(!isArray(collection)) {\n        return collection;\n      }\n\n      return !shallow\n        ? flatten(collection, 0)\n        : [].concat.apply([], collection);\n    }\n  });\n\n/**\n * flatten nested array (the nesting can be to any depth).\n * @param array {Array}\n * @param i {int}\n * @returns {Array}\n * @private\n */\nfunction flatten(array, i) {\n  i = i || 0;\n\n  if(i >= array.length)\n    return array;\n\n  if(isArray(array[i])) {\n    return flatten(array.slice(0,i)\n      .concat(array[i], array.slice(i+1)), i);\n  }\n  return flatten(array, i+1);\n}\n\n/**\n * @ngdoc filter\n * @name fuzzyByKey\n * @kind function\n *\n * @description\n * fuzzy string searching by key\n */\nangular.module('a8m.fuzzy-by', [])\n  .filter('fuzzyBy', ['$parse', function ( $parse ) {\n    return function (collection, property, search, csensitive) {\n\n      var sensitive = csensitive || false,\n        prop, getter;\n\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      if(!isArray(collection) || isUndefined(property)\n        || isUndefined(search)) {\n        return collection;\n      }\n\n      getter = $parse(property);\n\n      return collection.filter(function(elm) {\n\n        prop = getter(elm);\n        if(!isString(prop)) {\n          return false;\n        }\n\n        prop = (sensitive) ? prop : prop.toLowerCase();\n        search = (sensitive) ? search : search.toLowerCase();\n\n        return hasApproxPattern(prop, search) !== false\n      })\n    }\n\n }]);\n/**\n * @ngdoc filter\n * @name fuzzy\n * @kind function\n *\n * @description\n * fuzzy string searching for array of strings, objects\n */\nangular.module('a8m.fuzzy', [])\n  .filter('fuzzy', function () {\n    return function (collection, search, csensitive) {\n      var sensitive = csensitive || false;\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      if(!isArray(collection) || isUndefined(search)) {\n        return collection;\n      }\n\n      search = (sensitive) ? search : search.toLowerCase();\n\n      return collection.filter(function(elm) {\n        if(isString(elm)) {\n          elm = (sensitive) ? elm : elm.toLowerCase();\n          return hasApproxPattern(elm, search) !== false\n        }\n        return (isObject(elm)) ? _hasApproximateKey(elm, search) : false;\n      });\n\n      /**\n       * checks if object has key{string} that match\n       * to fuzzy search pattern\n       * @param object\n       * @param search\n       * @returns {boolean}\n       * @private\n       */\n      function _hasApproximateKey(object, search) {\n        var properties = Object.keys(object),\n          prop, flag;\n        return 0 < properties.filter(function (elm) {\n          prop = object[elm];\n\n          //avoid iteration if we found some key that equal[performance]\n          if(flag) return true;\n\n          if (isString(prop)) {\n            prop = (sensitive) ? prop : prop.toLowerCase();\n            return flag = (hasApproxPattern(prop, search) !== false);\n          }\n\n          return false;\n\n        }).length;\n      }\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name groupBy\n * @kind function\n *\n * @description\n * Create an object composed of keys generated from the result of running each element of a collection,\n * each key is an array of the elements.\n */\n\nangular.module('a8m.group-by', [ 'a8m.filter-watcher' ])\n  .filter('groupBy', [ '$parse', 'filterWatcher', function ( $parse, filterWatcher ) {\n    return function (collection, property) {\n\n      if(!isObject(collection) || isUndefined(property)) {\n        return collection;\n      }\n\n      return filterWatcher.isMemoized('groupBy', arguments) ||\n        filterWatcher.memoize('groupBy', arguments, this,\n          _groupBy(collection, $parse(property)));\n\n      /**\n       * groupBy function\n       * @param collection\n       * @param getter\n       * @returns {{}}\n       */\n      function _groupBy(collection, getter) {\n        var result = {};\n        var prop;\n\n        forEach( collection, function( elm ) {\n          prop = getter(elm);\n\n          if(!result[prop]) {\n            result[prop] = [];\n          }\n          result[prop].push(elm);\n        });\n        return result;\n      }\n    }\n }]);\n\n/**\n * @ngdoc filter\n * @name isEmpty\n * @kind function\n *\n * @description\n * get collection or string and return if it empty\n */\nangular.module('a8m.is-empty', [])\n  .filter('isEmpty', function () {\n    return function(collection) {\n      return isObject(collection)\n        ? !toArray(collection).length\n        : !collection.length;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name join\n * @kind function\n *\n * @description\n * join a collection by a provided delimiter (space by default)\n */\nangular.module('a8m.join', [])\n  .filter('join', function () {\n    return function (input, delimiter) {\n      if (isUndefined(input) || !isArray(input)) {\n        return input;\n      }\n      if (isUndefined(delimiter)) delimiter = ' ';\n\n      return input.join(delimiter);\n    };\n  })\n;\n\n/**\n * @ngdoc filter\n * @name last\n * @kind function\n *\n * @description\n * Gets the last element or last n elements of an array\n * if callback is provided, is returns as long the callback return truthy\n */\nangular.module('a8m.last', [])\n  .filter('last', ['$parse', function( $parse ) {\n    return function(collection) {\n      var n\n        , getter\n        , args\n        //cuz reverse change our src collection\n        //and we don't want side effects\n        , reversed = copy(collection);\n\n      reversed = isObject(reversed)\n        ? toArray(reversed)\n        : reversed;\n\n      if(!isArray(reversed)) {\n        return reversed;\n      }\n\n      args = Array.prototype.slice.call(arguments, 1);\n      n = (isNumber(args[0])) ? args[0] : 1;\n      getter = (!isNumber(args[0]))  ? args[0] : (!isNumber(args[1])) ? args[1] : undefined;\n\n      return (args.length)\n        //send reversed collection as arguments, and reverse it back as result\n        ? getFirstMatches(reversed.reverse(), n,(getter) ? $parse(getter) : getter).reverse()\n        //get the last element\n        : reversed[reversed.length-1];\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name map\n * @kind function\n *\n * @description\n * Returns a new collection of the results of each expression execution.\n */\nangular.module('a8m.map', [])\n  .filter('map', ['$parse', function($parse) {\n    return function (collection, expression) {\n\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      if(!isArray(collection) || isUndefined(expression)) {\n        return collection;\n      }\n\n      return collection.map(function (elm) {\n        return $parse(expression)(elm);\n      });\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name omit\n * @kind function\n *\n * @description\n * filter collection by expression\n */\n\nangular.module('a8m.omit', [])\n\n  .filter('omit', ['$parse', function($parse) {\n    return function (collection, expression) {\n\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      if(!isArray(collection) || isUndefined(expression)) {\n        return collection;\n      }\n\n      return collection.filter(function (elm) {\n        return !($parse(expression)(elm));\n      });\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name pick\n * @kind function\n *\n * @description\n * filter collection by expression\n */\n\nangular.module('a8m.pick', [])\n\n  .filter('pick', ['$parse', function($parse) {\n    return function (collection, expression) {\n\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      if(!isArray(collection) || isUndefined(expression)) {\n        return collection;\n      }\n\n      return collection.filter(function (elm) {\n        return $parse(expression)(elm);\n      });\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name range\n * @kind function\n *\n * @description\n * rangeFilter provides some support for a for loop using numbers\n */\nangular.module('a8m.range', [])\n  .filter('range', function () {\n    return function (input, total, start, increment, cb) {\n      start = start || 0;\n      increment = increment || 1;\n      for (var i = 0; i < parseInt(total); i++) {\n        var j = start + i * increment;\n        input.push(isFunction(cb) ? cb(j) : j);\n      }\n      return input;\n    };\n  });\n/**\n * @ngdoc filter\n * @name removeWith\n * @kind function\n *\n * @description\n * get collection and properties object, and removed elements\n * with this properties\n */\n\nangular.module('a8m.remove-with', [])\n  .filter('removeWith', function() {\n    return function (collection, object) {\n\n      if(isUndefined(object)) {\n        return collection;\n      }\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      return collection.filter(function (elm) {\n        return !objectContains(object, elm);\n      });\n    }\n  });\n\n\n/**\n * @ngdoc filter\n * @name remove\n * @kind function\n *\n * @description\n * remove specific members from collection\n */\n\nangular.module('a8m.remove', [])\n\n  .filter('remove', function () {\n    return function (collection) {\n      collection = isObject(collection) ? toArray(collection) : collection;\n      var args = Array.prototype.slice.call(arguments, 1);\n\n      if(!isArray(collection)) {\n        return collection;\n      }\n\n      return collection.filter( function( member ) {\n        return !args.some(function(nest) {\n          return equals(nest, member);\n        })\n      });\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name reverse\n * @kind function\n *\n * @description\n * Reverses a string or collection\n */\nangular.module('a8m.reverse', [])\n    .filter('reverse',[ function () {\n      return function (input) {\n        input = isObject(input) ? toArray(input) : input;\n\n        if(isString(input)) {\n          return input.split('').reverse().join('');\n        }\n\n        return isArray(input)\n          ? input.slice().reverse()\n          : input;\n      }\n    }]);\n\n/**\n * @ngdoc filter\n * @name searchField\n * @kind function\n *\n * @description\n * for each member, join several strings field and add them to\n * new field called 'searchField' (use for search filtering)\n */\nangular.module('a8m.search-field', [])\n  .filter('searchField', ['$parse', function ($parse) {\n    return function (collection) {\n\n      var get, field;\n\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      var args = Array.prototype.slice.call(arguments, 1);\n\n      if(!isArray(collection) || !args.length) {\n        return collection;\n      }\n\n      return collection.map(function(member) {\n\n        field = args.map(function(field) {\n          get = $parse(field);\n          return get(member);\n        }).join(' ');\n\n        return extend(member, { searchField: field });\n      });\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name toArray\n * @kind function\n *\n * @description\n * Convert objects into stable arrays.\n * if addKey set to true,the filter also attaches a new property\n * $key to the value containing the original key that was used in\n * the object we are iterating over to reference the property\n */\nangular.module('a8m.to-array', [])\n  .filter('toArray', function() {\n    return function (collection, addKey) {\n\n      if(!isObject(collection)) {\n        return collection;\n      }\n\n      return !addKey\n        ? toArray(collection)\n        : Object.keys(collection).map(function (key) {\n            return extend(collection[key], { $key: key });\n          });\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name unique/uniq\n * @kind function\n *\n * @description\n * get collection and filter duplicate members\n * if uniqueFilter get a property(nested to) as argument it's\n * filter by this property as unique identifier\n */\n\nangular.module('a8m.unique', [])\n  .filter({\n      unique: ['$parse', uniqFilter],\n      uniq: ['$parse', uniqFilter]\n    });\n\nfunction uniqFilter($parse) {\n    return function (collection, property) {\n\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      if (!isArray(collection)) {\n        return collection;\n      }\n\n      //store all unique identifiers\n      var uniqueItems = [],\n          get = $parse(property);\n\n      return (isUndefined(property))\n        //if it's kind of primitive array\n        ? collection.filter(function (elm, pos, self) {\n          return self.indexOf(elm) === pos;\n        })\n        //else compare with equals\n        : collection.filter(function (elm) {\n          var prop = get(elm);\n          if(some(uniqueItems, prop)) {\n            return false;\n          }\n          uniqueItems.push(prop);\n          return true;\n      });\n\n      //checked if the unique identifier is already exist\n      function some(array, member) {\n        if(isUndefined(member)) {\n          return false;\n        }\n        return array.some(function(el) {\n          return equals(el, member);\n        });\n      }\n    }\n}\n\n/**\n * @ngdoc filter\n * @name where\n * @kind function\n *\n * @description\n * of each element in a collection to the given properties object,\n * returning an array of all elements that have equivalent property values.\n *\n */\nangular.module('a8m.where', [])\n  .filter('where', function() {\n    return function (collection, object) {\n      if(isUndefined(object)) return collection;\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      return collection.filter(function (elm) {\n        return objectContains(object, elm);\n      });\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name xor\n * @kind function\n *\n * @description\n * Exclusive or filter by expression\n */\n\nangular.module('a8m.xor', [])\n\n  .filter('xor', ['$parse', function($parse) {\n    return function (col1, col2, expression) {\n\n      expression = expression || false;\n\n      col1 = isObject(col1) ? toArray(col1) : col1;\n      col2 = isObject(col2) ? toArray(col2) : col2;\n\n      if(!isArray(col1) || !isArray(col2)) return col1;\n\n      return col1.concat(col2)\n        .filter(function(elm) {\n          return !(some(elm, col1) && some(elm, col2));\n        });\n\n      function some(el, col) {\n        var getter = $parse(expression);\n        return col.some(function(dElm) {\n          return expression\n            ? equals(getter(dElm), getter(el))\n            : equals(dElm, el);\n        });\n      }\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name abs\n * @kind function\n *\n * @description\n * Will return the absolute value of a number\n */\nangular.module('a8m.math.abs', [])\n  .filter('abs', function () {\n    return function (input) {\n      return Math.abs(input);\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name formatBytes\n * @kind function\n *\n * @description\n * Convert bytes into appropriate display \n * 1024 bytes => 1 KB\n */\nangular.module('a8m.math.byteFmt', [])\n  .filter('byteFmt', function () {\n    var compared = [{str: 'B', val: 1024}];\n    ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'].forEach(function(el, i) {\n      compared.push({str: el, val: compared[i].val * 1024 });\n    });\n    return function (bytes, decimal) {\n      if(isNumber(decimal) && isFinite(decimal) && decimal%1===0 && decimal >= 0 &&\n        isNumber(bytes) && isFinite(bytes)) {\n        var i = 0;\n        while (i < compared.length-1 && bytes >= compared[i].val) i++;\n        bytes /= i > 0 ? compared[i-1].val : 1;\n        return convertToDecimal(bytes, decimal) + ' ' + compared[i].str;\n      }\n      return 'NaN';\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name degrees\n * @kind function\n *\n * @description\n * Convert angle from radians to degrees\n */\nangular.module('a8m.math.degrees', [])\n  .filter('degrees', function () {\n    return function (radians, decimal) {\n      // if decimal is not an integer greater than -1, we cannot do. quit with error \"NaN\"\n      // if degrees is not a real number, we cannot do also. quit with error \"NaN\"\n      if(isNumber(decimal) && isFinite(decimal) && decimal%1===0 && decimal >= 0 &&\n        isNumber(radians) && isFinite(radians)) {\n        var degrees = (radians * 180) / Math.PI;\n        return Math.round(degrees * Math.pow(10,decimal)) / (Math.pow(10,decimal));\n      } else {\n        return 'NaN';\n      }\n    }\n  });\n\n \n \n/**\n * @ngdoc filter\n * @name formatBytes\n * @kind function\n *\n * @description\n * Convert bytes into appropriate display \n * 1024 kilobytes => 1 MB\n */\nangular.module('a8m.math.kbFmt', [])\n  .filter('kbFmt', function () {\n    var compared = [{str: 'KB', val: 1024}];\n    ['MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'].forEach(function(el, i) {\n      compared.push({str: el, val: compared[i].val * 1024 });\n    });\n    return function (bytes, decimal) {\n      if(isNumber(decimal) && isFinite(decimal) && decimal%1===0 && decimal >= 0 &&\n        isNumber(bytes) && isFinite(bytes)) {\n        var i = 0;\n        while (i < compared.length-1 && bytes >= compared[i].val) i++;\n        bytes /= i > 0 ? compared[i-1].val : 1;\n        return convertToDecimal(bytes, decimal) + ' ' + compared[i].str;\n      }\n      return 'NaN';\n    }\n  });\n/**\n * @ngdoc filter\n * @name max\n * @kind function\n *\n * @description\n * Math.max will get an array and return the max value. if an expression\n * is provided, will return max value by expression.\n */\nangular.module('a8m.math.max', [])\n  .filter('max', ['$parse', function ($parse) {\n    return function (input, expression) {\n\n      if(!isArray(input)) {\n        return input;\n      }\n      return isUndefined(expression)\n        ? Math.max.apply(Math, input)\n        : input[indexByMax(input, expression)];\n    };\n\n    /**\n     * @private\n     * @param array\n     * @param exp\n     * @returns {number|*|Number}\n     */\n    function indexByMax(array, exp) {\n      var mappedArray = array.map(function(elm){\n        return $parse(exp)(elm);\n      });\n      return mappedArray.indexOf(Math.max.apply(Math, mappedArray));\n    }\n  }]);\n/**\n * @ngdoc filter\n * @name min\n * @kind function\n *\n * @description\n * Math.min will get an array and return the min value. if an expression\n * is provided, will return min value by expression.\n */\nangular.module('a8m.math.min', [])\n  .filter('min', ['$parse', function ($parse) {\n    return function (input, expression) {\n\n      if(!isArray(input)) {\n        return input;\n      }\n      return isUndefined(expression)\n        ? Math.min.apply(Math, input)\n        : input[indexByMin(input, expression)];\n    };\n\n    /**\n     * @private\n     * @param array\n     * @param exp\n     * @returns {number|*|Number}\n     */\n    function indexByMin(array, exp) {\n      var mappedArray = array.map(function(elm){\n        return $parse(exp)(elm);\n      });\n      return mappedArray.indexOf(Math.min.apply(Math, mappedArray));\n    }\n  }]);\n/**\n * @ngdoc filter\n * @name Percent\n * @kind function\n *\n * @description\n * percentage between two numbers\n */\nangular.module('a8m.math.percent', [])\n  .filter('percent', function () {\n    return function (input, divided, round) {\n\n      var divider = isString(input) ? Number(input) : input;\n      divided = divided || 100;\n      round = round || false;\n\n      if (!isNumber(divider) || isNaN(divider)) return input;\n\n      return round\n        ? Math.round((divider / divided) * 100)\n        : (divider / divided) * 100;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name toRadians\n * @kind function\n *\n * @description\n * Convert angle from degrees to radians\n */\nangular.module('a8m.math.radians', [])\n  .filter('radians', function() {\n    return function (degrees, decimal) {\n      // if decimal is not an integer greater than -1, we cannot do. quit with error \"NaN\"\n      // if degrees is not a real number, we cannot do also. quit with error \"NaN\"\n      if(isNumber(decimal) && isFinite(decimal) && decimal%1===0 && decimal >= 0 &&\n        isNumber(degrees) && isFinite(degrees)) {\n        var radians = (degrees * 3.14159265359) / 180;\n        return Math.round(radians * Math.pow(10,decimal)) / (Math.pow(10,decimal));\n      }\n      return 'NaN';\n    }\n  });\n\n \n \n/**\n * @ngdoc filter\n * @name Radix\n * @kind function\n *\n * @description\n * converting decimal numbers to different bases(radix)\n */\nangular.module('a8m.math.radix', [])\n  .filter('radix', function () {\n    return function (input, radix) {\n      var RANGE = /^[2-9]$|^[1-2]\\d$|^3[0-6]$/;\n\n      if(!isNumber(input) || !RANGE.test(radix)) {\n        return input;\n      }\n\n      return input.toString(radix).toUpperCase();\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name formatBytes\n * @kind function\n *\n * @description\n * Convert number into abbreviations.\n * i.e: K for one thousand, M for Million, B for billion\n * e.g: number of users:235,221, decimal:1 => 235.2 K\n */\nangular.module('a8m.math.shortFmt', [])\n  .filter('shortFmt', function () {\n    return function (number, decimal) {\n      if(isNumber(decimal) && isFinite(decimal) && decimal%1===0 && decimal >= 0 &&\n        isNumber(number) && isFinite(number)){\n        if(number < 1e3) {\n          return '' + number;  // Coerce to string\n        } else if(number < 1e6) {\n          return convertToDecimal((number / 1e3), decimal) + ' K';\n        } else if(number < 1e9){\n          return convertToDecimal((number / 1e6), decimal) + ' M';\n        } else {\n          return convertToDecimal((number / 1e9), decimal) + ' B';\n        }\n\n      }\n      return 'NaN';\n    }\n  });\n/**\n * @ngdoc filter\n * @name sum\n * @kind function\n *\n * @description\n * Sum up all values within an array\n */\nangular.module('a8m.math.sum', [])\n  .filter('sum', function () {\n    return function (input, initial) {\n      return !isArray(input)\n        ? input\n        : input.reduce(function(prev, curr) {\n          return prev + curr;\n        }, initial || 0);\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name endsWith\n * @kind function\n *\n * @description\n * checks whether string ends with the ends parameter.\n */\nangular.module('a8m.ends-with', [])\n\n  .filter('endsWith', function () {\n    return function (input, ends, csensitive) {\n\n      var sensitive = csensitive || false,\n        position;\n\n      if(!isString(input) || isUndefined(ends)) {\n        return input;\n      }\n\n      input = (sensitive) ? input : input.toLowerCase();\n      position = input.length - ends.length;\n\n      return input.indexOf((sensitive) ? ends : ends.toLowerCase(), position) !== -1;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name latinize\n * @kind function\n *\n * @description\n * remove accents/diacritics from a string\n */\nangular.module('a8m.latinize', [])\n  .filter('latinize',[ function () {\n    var defaultDiacriticsRemovalap = [\n      {'base':'A', 'letters':'\\u0041\\u24B6\\uFF21\\u00C0\\u00C1\\u00C2\\u1EA6\\u1EA4\\u1EAA\\u1EA8\\u00C3\\u0100\\u0102\\u1EB0\\u1EAE\\u1EB4\\u1EB2\\u0226\\u01E0\\u00C4\\u01DE\\u1EA2\\u00C5\\u01FA\\u01CD\\u0200\\u0202\\u1EA0\\u1EAC\\u1EB6\\u1E00\\u0104\\u023A\\u2C6F'},\n      {'base':'AA','letters':'\\uA732'},\n      {'base':'AE','letters':'\\u00C6\\u01FC\\u01E2'},\n      {'base':'AO','letters':'\\uA734'},\n      {'base':'AU','letters':'\\uA736'},\n      {'base':'AV','letters':'\\uA738\\uA73A'},\n      {'base':'AY','letters':'\\uA73C'},\n      {'base':'B', 'letters':'\\u0042\\u24B7\\uFF22\\u1E02\\u1E04\\u1E06\\u0243\\u0182\\u0181'},\n      {'base':'C', 'letters':'\\u0043\\u24B8\\uFF23\\u0106\\u0108\\u010A\\u010C\\u00C7\\u1E08\\u0187\\u023B\\uA73E'},\n      {'base':'D', 'letters':'\\u0044\\u24B9\\uFF24\\u1E0A\\u010E\\u1E0C\\u1E10\\u1E12\\u1E0E\\u0110\\u018B\\u018A\\u0189\\uA779'},\n      {'base':'DZ','letters':'\\u01F1\\u01C4'},\n      {'base':'Dz','letters':'\\u01F2\\u01C5'},\n      {'base':'E', 'letters':'\\u0045\\u24BA\\uFF25\\u00C8\\u00C9\\u00CA\\u1EC0\\u1EBE\\u1EC4\\u1EC2\\u1EBC\\u0112\\u1E14\\u1E16\\u0114\\u0116\\u00CB\\u1EBA\\u011A\\u0204\\u0206\\u1EB8\\u1EC6\\u0228\\u1E1C\\u0118\\u1E18\\u1E1A\\u0190\\u018E'},\n      {'base':'F', 'letters':'\\u0046\\u24BB\\uFF26\\u1E1E\\u0191\\uA77B'},\n      {'base':'G', 'letters':'\\u0047\\u24BC\\uFF27\\u01F4\\u011C\\u1E20\\u011E\\u0120\\u01E6\\u0122\\u01E4\\u0193\\uA7A0\\uA77D\\uA77E'},\n      {'base':'H', 'letters':'\\u0048\\u24BD\\uFF28\\u0124\\u1E22\\u1E26\\u021E\\u1E24\\u1E28\\u1E2A\\u0126\\u2C67\\u2C75\\uA78D'},\n      {'base':'I', 'letters':'\\u0049\\u24BE\\uFF29\\u00CC\\u00CD\\u00CE\\u0128\\u012A\\u012C\\u0130\\u00CF\\u1E2E\\u1EC8\\u01CF\\u0208\\u020A\\u1ECA\\u012E\\u1E2C\\u0197'},\n      {'base':'J', 'letters':'\\u004A\\u24BF\\uFF2A\\u0134\\u0248'},\n      {'base':'K', 'letters':'\\u004B\\u24C0\\uFF2B\\u1E30\\u01E8\\u1E32\\u0136\\u1E34\\u0198\\u2C69\\uA740\\uA742\\uA744\\uA7A2'},\n      {'base':'L', 'letters':'\\u004C\\u24C1\\uFF2C\\u013F\\u0139\\u013D\\u1E36\\u1E38\\u013B\\u1E3C\\u1E3A\\u0141\\u023D\\u2C62\\u2C60\\uA748\\uA746\\uA780'},\n      {'base':'LJ','letters':'\\u01C7'},\n      {'base':'Lj','letters':'\\u01C8'},\n      {'base':'M', 'letters':'\\u004D\\u24C2\\uFF2D\\u1E3E\\u1E40\\u1E42\\u2C6E\\u019C'},\n      {'base':'N', 'letters':'\\u004E\\u24C3\\uFF2E\\u01F8\\u0143\\u00D1\\u1E44\\u0147\\u1E46\\u0145\\u1E4A\\u1E48\\u0220\\u019D\\uA790\\uA7A4'},\n      {'base':'NJ','letters':'\\u01CA'},\n      {'base':'Nj','letters':'\\u01CB'},\n      {'base':'O', 'letters':'\\u004F\\u24C4\\uFF2F\\u00D2\\u00D3\\u00D4\\u1ED2\\u1ED0\\u1ED6\\u1ED4\\u00D5\\u1E4C\\u022C\\u1E4E\\u014C\\u1E50\\u1E52\\u014E\\u022E\\u0230\\u00D6\\u022A\\u1ECE\\u0150\\u01D1\\u020C\\u020E\\u01A0\\u1EDC\\u1EDA\\u1EE0\\u1EDE\\u1EE2\\u1ECC\\u1ED8\\u01EA\\u01EC\\u00D8\\u01FE\\u0186\\u019F\\uA74A\\uA74C'},\n      {'base':'OI','letters':'\\u01A2'},\n      {'base':'OO','letters':'\\uA74E'},\n      {'base':'OU','letters':'\\u0222'},\n      {'base':'OE','letters':'\\u008C\\u0152'},\n      {'base':'oe','letters':'\\u009C\\u0153'},\n      {'base':'P', 'letters':'\\u0050\\u24C5\\uFF30\\u1E54\\u1E56\\u01A4\\u2C63\\uA750\\uA752\\uA754'},\n      {'base':'Q', 'letters':'\\u0051\\u24C6\\uFF31\\uA756\\uA758\\u024A'},\n      {'base':'R', 'letters':'\\u0052\\u24C7\\uFF32\\u0154\\u1E58\\u0158\\u0210\\u0212\\u1E5A\\u1E5C\\u0156\\u1E5E\\u024C\\u2C64\\uA75A\\uA7A6\\uA782'},\n      {'base':'S', 'letters':'\\u0053\\u24C8\\uFF33\\u1E9E\\u015A\\u1E64\\u015C\\u1E60\\u0160\\u1E66\\u1E62\\u1E68\\u0218\\u015E\\u2C7E\\uA7A8\\uA784'},\n      {'base':'T', 'letters':'\\u0054\\u24C9\\uFF34\\u1E6A\\u0164\\u1E6C\\u021A\\u0162\\u1E70\\u1E6E\\u0166\\u01AC\\u01AE\\u023E\\uA786'},\n      {'base':'TZ','letters':'\\uA728'},\n      {'base':'U', 'letters':'\\u0055\\u24CA\\uFF35\\u00D9\\u00DA\\u00DB\\u0168\\u1E78\\u016A\\u1E7A\\u016C\\u00DC\\u01DB\\u01D7\\u01D5\\u01D9\\u1EE6\\u016E\\u0170\\u01D3\\u0214\\u0216\\u01AF\\u1EEA\\u1EE8\\u1EEE\\u1EEC\\u1EF0\\u1EE4\\u1E72\\u0172\\u1E76\\u1E74\\u0244'},\n      {'base':'V', 'letters':'\\u0056\\u24CB\\uFF36\\u1E7C\\u1E7E\\u01B2\\uA75E\\u0245'},\n      {'base':'VY','letters':'\\uA760'},\n      {'base':'W', 'letters':'\\u0057\\u24CC\\uFF37\\u1E80\\u1E82\\u0174\\u1E86\\u1E84\\u1E88\\u2C72'},\n      {'base':'X', 'letters':'\\u0058\\u24CD\\uFF38\\u1E8A\\u1E8C'},\n      {'base':'Y', 'letters':'\\u0059\\u24CE\\uFF39\\u1EF2\\u00DD\\u0176\\u1EF8\\u0232\\u1E8E\\u0178\\u1EF6\\u1EF4\\u01B3\\u024E\\u1EFE'},\n      {'base':'Z', 'letters':'\\u005A\\u24CF\\uFF3A\\u0179\\u1E90\\u017B\\u017D\\u1E92\\u1E94\\u01B5\\u0224\\u2C7F\\u2C6B\\uA762'},\n      {'base':'a', 'letters':'\\u0061\\u24D0\\uFF41\\u1E9A\\u00E0\\u00E1\\u00E2\\u1EA7\\u1EA5\\u1EAB\\u1EA9\\u00E3\\u0101\\u0103\\u1EB1\\u1EAF\\u1EB5\\u1EB3\\u0227\\u01E1\\u00E4\\u01DF\\u1EA3\\u00E5\\u01FB\\u01CE\\u0201\\u0203\\u1EA1\\u1EAD\\u1EB7\\u1E01\\u0105\\u2C65\\u0250'},\n      {'base':'aa','letters':'\\uA733'},\n      {'base':'ae','letters':'\\u00E6\\u01FD\\u01E3'},\n      {'base':'ao','letters':'\\uA735'},\n      {'base':'au','letters':'\\uA737'},\n      {'base':'av','letters':'\\uA739\\uA73B'},\n      {'base':'ay','letters':'\\uA73D'},\n      {'base':'b', 'letters':'\\u0062\\u24D1\\uFF42\\u1E03\\u1E05\\u1E07\\u0180\\u0183\\u0253'},\n      {'base':'c', 'letters':'\\u0063\\u24D2\\uFF43\\u0107\\u0109\\u010B\\u010D\\u00E7\\u1E09\\u0188\\u023C\\uA73F\\u2184'},\n      {'base':'d', 'letters':'\\u0064\\u24D3\\uFF44\\u1E0B\\u010F\\u1E0D\\u1E11\\u1E13\\u1E0F\\u0111\\u018C\\u0256\\u0257\\uA77A'},\n      {'base':'dz','letters':'\\u01F3\\u01C6'},\n      {'base':'e', 'letters':'\\u0065\\u24D4\\uFF45\\u00E8\\u00E9\\u00EA\\u1EC1\\u1EBF\\u1EC5\\u1EC3\\u1EBD\\u0113\\u1E15\\u1E17\\u0115\\u0117\\u00EB\\u1EBB\\u011B\\u0205\\u0207\\u1EB9\\u1EC7\\u0229\\u1E1D\\u0119\\u1E19\\u1E1B\\u0247\\u025B\\u01DD'},\n      {'base':'f', 'letters':'\\u0066\\u24D5\\uFF46\\u1E1F\\u0192\\uA77C'},\n      {'base':'g', 'letters':'\\u0067\\u24D6\\uFF47\\u01F5\\u011D\\u1E21\\u011F\\u0121\\u01E7\\u0123\\u01E5\\u0260\\uA7A1\\u1D79\\uA77F'},\n      {'base':'h', 'letters':'\\u0068\\u24D7\\uFF48\\u0125\\u1E23\\u1E27\\u021F\\u1E25\\u1E29\\u1E2B\\u1E96\\u0127\\u2C68\\u2C76\\u0265'},\n      {'base':'hv','letters':'\\u0195'},\n      {'base':'i', 'letters':'\\u0069\\u24D8\\uFF49\\u00EC\\u00ED\\u00EE\\u0129\\u012B\\u012D\\u00EF\\u1E2F\\u1EC9\\u01D0\\u0209\\u020B\\u1ECB\\u012F\\u1E2D\\u0268\\u0131'},\n      {'base':'j', 'letters':'\\u006A\\u24D9\\uFF4A\\u0135\\u01F0\\u0249'},\n      {'base':'k', 'letters':'\\u006B\\u24DA\\uFF4B\\u1E31\\u01E9\\u1E33\\u0137\\u1E35\\u0199\\u2C6A\\uA741\\uA743\\uA745\\uA7A3'},\n      {'base':'l', 'letters':'\\u006C\\u24DB\\uFF4C\\u0140\\u013A\\u013E\\u1E37\\u1E39\\u013C\\u1E3D\\u1E3B\\u017F\\u0142\\u019A\\u026B\\u2C61\\uA749\\uA781\\uA747'},\n      {'base':'lj','letters':'\\u01C9'},\n      {'base':'m', 'letters':'\\u006D\\u24DC\\uFF4D\\u1E3F\\u1E41\\u1E43\\u0271\\u026F'},\n      {'base':'n', 'letters':'\\u006E\\u24DD\\uFF4E\\u01F9\\u0144\\u00F1\\u1E45\\u0148\\u1E47\\u0146\\u1E4B\\u1E49\\u019E\\u0272\\u0149\\uA791\\uA7A5'},\n      {'base':'nj','letters':'\\u01CC'},\n      {'base':'o', 'letters':'\\u006F\\u24DE\\uFF4F\\u00F2\\u00F3\\u00F4\\u1ED3\\u1ED1\\u1ED7\\u1ED5\\u00F5\\u1E4D\\u022D\\u1E4F\\u014D\\u1E51\\u1E53\\u014F\\u022F\\u0231\\u00F6\\u022B\\u1ECF\\u0151\\u01D2\\u020D\\u020F\\u01A1\\u1EDD\\u1EDB\\u1EE1\\u1EDF\\u1EE3\\u1ECD\\u1ED9\\u01EB\\u01ED\\u00F8\\u01FF\\u0254\\uA74B\\uA74D\\u0275'},\n      {'base':'oi','letters':'\\u01A3'},\n      {'base':'ou','letters':'\\u0223'},\n      {'base':'oo','letters':'\\uA74F'},\n      {'base':'p','letters':'\\u0070\\u24DF\\uFF50\\u1E55\\u1E57\\u01A5\\u1D7D\\uA751\\uA753\\uA755'},\n      {'base':'q','letters':'\\u0071\\u24E0\\uFF51\\u024B\\uA757\\uA759'},\n      {'base':'r','letters':'\\u0072\\u24E1\\uFF52\\u0155\\u1E59\\u0159\\u0211\\u0213\\u1E5B\\u1E5D\\u0157\\u1E5F\\u024D\\u027D\\uA75B\\uA7A7\\uA783'},\n      {'base':'s','letters':'\\u0073\\u24E2\\uFF53\\u00DF\\u015B\\u1E65\\u015D\\u1E61\\u0161\\u1E67\\u1E63\\u1E69\\u0219\\u015F\\u023F\\uA7A9\\uA785\\u1E9B'},\n      {'base':'t','letters':'\\u0074\\u24E3\\uFF54\\u1E6B\\u1E97\\u0165\\u1E6D\\u021B\\u0163\\u1E71\\u1E6F\\u0167\\u01AD\\u0288\\u2C66\\uA787'},\n      {'base':'tz','letters':'\\uA729'},\n      {'base':'u','letters': '\\u0075\\u24E4\\uFF55\\u00F9\\u00FA\\u00FB\\u0169\\u1E79\\u016B\\u1E7B\\u016D\\u00FC\\u01DC\\u01D8\\u01D6\\u01DA\\u1EE7\\u016F\\u0171\\u01D4\\u0215\\u0217\\u01B0\\u1EEB\\u1EE9\\u1EEF\\u1EED\\u1EF1\\u1EE5\\u1E73\\u0173\\u1E77\\u1E75\\u0289'},\n      {'base':'v','letters':'\\u0076\\u24E5\\uFF56\\u1E7D\\u1E7F\\u028B\\uA75F\\u028C'},\n      {'base':'vy','letters':'\\uA761'},\n      {'base':'w','letters':'\\u0077\\u24E6\\uFF57\\u1E81\\u1E83\\u0175\\u1E87\\u1E85\\u1E98\\u1E89\\u2C73'},\n      {'base':'x','letters':'\\u0078\\u24E7\\uFF58\\u1E8B\\u1E8D'},\n      {'base':'y','letters':'\\u0079\\u24E8\\uFF59\\u1EF3\\u00FD\\u0177\\u1EF9\\u0233\\u1E8F\\u00FF\\u1EF7\\u1E99\\u1EF5\\u01B4\\u024F\\u1EFF'},\n      {'base':'z','letters':'\\u007A\\u24E9\\uFF5A\\u017A\\u1E91\\u017C\\u017E\\u1E93\\u1E95\\u01B6\\u0225\\u0240\\u2C6C\\uA763'}\n    ];\n\n    var diacriticsMap = {};\n    for (var i = 0; i < defaultDiacriticsRemovalap.length; i++) {\n      var letters = defaultDiacriticsRemovalap[i].letters.split(\"\");\n      for (var j = 0; j < letters.length ; j++){\n        diacriticsMap[letters[j]] = defaultDiacriticsRemovalap[i].base;\n      }\n    }\n\n    // \"what?\" version ... http://jsperf.com/diacritics/12\n    function removeDiacritics (str) {\n      return str.replace(/[^\\u0000-\\u007E]/g, function(a){\n        return diacriticsMap[a] || a;\n      });\n    }\n\n    return function (input) {\n\n      return isString(input)\n        ? removeDiacritics(input)\n        : input;\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name ltrim\n * @kind function\n *\n * @description\n * Left trim. Similar to trimFilter, but only for left side.\n */\nangular.module('a8m.ltrim', [])\n  .filter('ltrim', function () {\n    return function(input, chars) {\n\n      var trim = chars || '\\\\s';\n\n      return isString(input)\n        ? input.replace(new RegExp('^' + trim + '+'), '')\n        : input;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name match\n * @kind function\n *\n * @description\n * Return the matched pattern in a string.\n */\nangular.module('a8m.match', [])\n  .filter('match', function () {\n    return function (input, pattern, flag) {\n\n      var reg = new RegExp(pattern, flag);\n\n      return isString(input)\n        ? input.match(reg)\n        : null;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name phone-us\n * @kind function\n *\n * @description\n * format a string or a number into a us-style\n * phone number in the form (***) ***-****\n */\nangular.module('a8m.phoneUS', [])\n  .filter('phoneUS', function () {\n    return function(num) {\n      num += '';\n      return '(' + num.slice(0, 3) + ') ' + num.slice(3, 6) + '-' + num.slice(6);\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name repeat\n * @kind function\n *\n * @description\n * Repeats a string n times\n */\nangular.module('a8m.repeat', [])\n  .filter('repeat',[ function () {\n    return function (input, n, separator) {\n\n      var times = ~~n;\n\n      if(!isString(input)) {\n        return input;\n      }\n\n      return !times\n        ? input\n        : strRepeat(input, --n, separator || '');\n    }\n  }]);\n\n/**\n * Repeats a string n times with given separator\n * @param str string to repeat\n * @param n number of times\n * @param sep separator\n * @returns {*}\n */\nfunction strRepeat(str, n, sep) {\n  if(!n) {\n    return str;\n  }\n  return str + sep + strRepeat(str, --n, sep);\n}\n/**\n* @ngdoc filter\n* @name rtrim\n* @kind function\n*\n* @description\n* Right trim. Similar to trimFilter, but only for right side.\n*/\nangular.module('a8m.rtrim', [])\n  .filter('rtrim', function () {\n    return function(input, chars) {\n\n      var trim = chars || '\\\\s';\n\n      return isString(input)\n        ? input.replace(new RegExp(trim + '+$'), '')\n        : input;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name slugify\n * @kind function\n *\n * @description\n * remove spaces from string, replace with \"-\" or given argument\n */\nangular.module('a8m.slugify', [])\n  .filter('slugify',[ function () {\n    return function (input, sub) {\n\n      var replace = (isUndefined(sub)) ? '-' : sub;\n\n      return isString(input)\n        ? input.toLowerCase().replace(/\\s+/g, replace)\n        : input;\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name split\n * @kind function\n *\n * @description\n * split a string by a provided delimiter (none '' by default) and skip first n-delimiters\n */\nangular.module('a8m.split', [])\n  .filter('split', function () {\n    function escapeRegExp(str) {\n      return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n    }\n\n    return function (input, delimiter, skip) {\n      var _regexp, _matches, _splitted, _temp;\n\n      if (isUndefined(input) || !isString(input)) {\n        return null;\n      }\n      if (isUndefined(delimiter)) delimiter = '';\n      if (isNaN(skip)) skip = 0;\n\n      _regexp = new RegExp(escapeRegExp(delimiter), 'g');\n      _matches = input.match(_regexp);\n      \n      if (isNull(_matches) || skip >= _matches.length) {\n        return [input];\n      }\n\n      if (skip === 0) return input.split(delimiter);\n      \n      _splitted = input.split(delimiter);\n      _temp = _splitted.splice(0, skip + 1);\n      _splitted.unshift(_temp.join(delimiter));\n    \n      return _splitted;\n    };\n  })\n;\n\n/**\n * @ngdoc filter\n * @name startWith\n * @kind function\n *\n * @description\n * checks whether string starts with the starts parameter.\n */\nangular.module('a8m.starts-with', [])\n  .filter('startsWith', function () {\n    return function (input, start, csensitive) {\n\n      var sensitive = csensitive || false;\n\n      if(!isString(input) || isUndefined(start)) {\n        return input;\n      }\n\n      input = (sensitive) ? input : input.toLowerCase();\n\n      return !input.indexOf((sensitive) ? start : start.toLowerCase());\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name stringular\n * @kind function\n *\n * @description\n * get string with {n} and replace match with enumeration values\n */\nangular.module('a8m.stringular', [])\n  .filter('stringular', function () {\n    return function(input) {\n\n      var args = Array.prototype.slice.call(arguments, 1);\n\n      return input.replace(/{(\\d+)}/g, function (match, number) {\n        return isUndefined(args[number]) ? match : args[number];\n      });\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name stripTags\n * @kind function\n *\n * @description\n * strip html tags from string\n */\nangular.module('a8m.strip-tags', [])\n  .filter('stripTags', function () {\n    return function(input) {\n      return isString(input)\n        ? input.replace(/<\\S[^><]*>/g, '')\n        : input;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name test\n * @kind function\n *\n * @description\n * test if a string match a pattern.\n */\nangular.module('a8m.test', [])\n  .filter('test', function () {\n    return function (input, pattern, flag) {\n\n      var reg = new RegExp(pattern, flag);\n\n      return isString(input)\n        ? reg.test(input)\n        : input;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name trim\n * @kind function\n *\n * @description\n *  Strip whitespace (or other characters) from the beginning and end of a string\n */\nangular.module('a8m.trim', [])\n  .filter('trim', function () {\n    return function(input, chars) {\n\n      var trim = chars || '\\\\s';\n\n      return isString(input)\n        ? input.replace(new RegExp('^' + trim + '+|' + trim + '+$', 'g'), '')\n        : input;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name truncate\n * @kind function\n *\n * @description\n * truncates a string given a specified length, providing a custom string to denote an omission.\n */\nangular.module('a8m.truncate', [])\n  .filter('truncate', function () {\n    return function(input, length, suffix, preserve) {\n\n      length = isUndefined(length) ? input.length : length;\n      preserve = preserve || false;\n      suffix = suffix || '';\n\n      if(!isString(input) || (input.length <= length)) return input;\n\n      return input.substring(0, (preserve)\n        ? ((input.indexOf(' ', length) === -1) ? input.length : input.indexOf(' ', length))\n        : length) + suffix;\n    };\n  });\n\n/**\n * @ngdoc filter\n * @name ucfirst\n * @kind function\n *\n * @description\n * ucfirst\n */\nangular.module('a8m.ucfirst', [])\n  .filter({\n    ucfirst: ucfirstFilter,\n    titleize: ucfirstFilter\n  });\n\nfunction ucfirstFilter() {\n  return function (input) {\n    return isString(input)\n      ? input\n      .split(' ')\n      .map(function (ch) {\n        return ch.charAt(0).toUpperCase() + ch.substring(1);\n      })\n      .join(' ')\n      : input;\n  }\n}\n\n/**\n * @ngdoc filter\n * @name uriComponentEncode\n * @kind function\n *\n * @description\n * get string as parameter and return encoded string\n */\nangular.module('a8m.uri-component-encode', [])\n  .filter('uriComponentEncode',['$window', function ($window) {\n      return function (input) {\n        return isString(input)\n          ? $window.encodeURIComponent(input)\n          : input;\n      }\n    }]);\n\n/**\n * @ngdoc filter\n * @name uriEncode\n * @kind function\n *\n * @description\n * get string as parameter and return encoded string\n */\nangular.module('a8m.uri-encode', [])\n  .filter('uriEncode',['$window', function ($window) {\n      return function (input) {\n        return isString(input)\n          ? $window.encodeURI(input)\n          : input;\n      }\n    }]);\n\n/**\n * @ngdoc filter\n * @name wrap\n * @kind function\n *\n * @description\n * Wrap a string with another string\n */\nangular.module('a8m.wrap', [])\n  .filter('wrap', function () {\n    return function(input, wrap, ends) {\n      return isString(input) && isDefined(wrap)\n        ? [wrap, input, ends || wrap].join('')\n        : input;\n    }\n  });\n\n/**\n * @ngdoc provider\n * @name filterWatcher\n * @kind function\n *\n * @description\n * store specific filters result in $$cache, based on scope life time(avoid memory leak).\n * on scope.$destroy remove it's cache from $$cache container\n */\n\nangular.module('a8m.filter-watcher', [])\n  .provider('filterWatcher', function() {\n\n    this.$get = ['$window', '$rootScope', function($window, $rootScope) {\n\n      /**\n       * Cache storing\n       * @type {Object}\n       */\n      var $$cache = {};\n\n      /**\n       * Scope listeners container\n       * scope.$destroy => remove all cache keys\n       * bind to current scope.\n       * @type {Object}\n       */\n      var $$listeners = {};\n\n      /**\n       * $timeout without triggering the digest cycle\n       * @type {function}\n       */\n      var $$timeout = $window.setTimeout;\n\n      /**\n       * @description\n       * get `HashKey` string based on the given arguments.\n       * @param fName\n       * @param args\n       * @returns {string}\n       */\n      function getHashKey(fName, args) {\n        function replacerFactory() {\n          var cache = [];\n          return function(key, val) {\n            if(isObject(val) && !isNull(val)) {\n              if (~cache.indexOf(val)) return '[Circular]';\n              cache.push(val)\n            }\n            if($window == val) return '$WINDOW';\n            if($window.document == val) return '$DOCUMENT';\n            if(isScope(val)) return '$SCOPE';\n            return val;\n          }\n        }\n        return [fName, JSON.stringify(args, replacerFactory())]\n          .join('#')\n          .replace(/\"/g,'');\n      }\n\n      /**\n       * @description\n       * fir on $scope.$destroy,\n       * remove cache based scope from `$$cache`,\n       * and remove itself from `$$listeners`\n       * @param event\n       */\n      function removeCache(event) {\n        var id = event.targetScope.$id;\n        forEach($$listeners[id], function(key) {\n          delete $$cache[key];\n        });\n        delete $$listeners[id];\n      }\n\n      /**\n       * @description\n       * for angular version that greater than v.1.3.0\n       * it clear cache when the digest cycle is end.\n       */\n      function cleanStateless() {\n        $$timeout(function() {\n          if(!$rootScope.$$phase)\n            $$cache = {};\n        }, 2000);\n      }\n\n      /**\n       * @description\n       * Store hashKeys in $$listeners container\n       * on scope.$destroy, remove them all(bind an event).\n       * @param scope\n       * @param hashKey\n       * @returns {*}\n       */\n      function addListener(scope, hashKey) {\n        var id = scope.$id;\n        if(isUndefined($$listeners[id])) {\n          scope.$on('$destroy', removeCache);\n          $$listeners[id] = [];\n        }\n        return $$listeners[id].push(hashKey);\n      }\n\n      /**\n       * @description\n       * return the `cacheKey` or undefined.\n       * @param filterName\n       * @param args\n       * @returns {*}\n       */\n      function $$isMemoized(filterName, args) {\n        var hashKey = getHashKey(filterName, args);\n        return $$cache[hashKey];\n      }\n\n      /**\n       * @description\n       * store `result` in `$$cache` container, based on the hashKey.\n       * add $destroy listener and return result\n       * @param filterName\n       * @param args\n       * @param scope\n       * @param result\n       * @returns {*}\n       */\n      function $$memoize(filterName, args, scope, result) {\n        var hashKey = getHashKey(filterName, args);\n        //store result in `$$cache` container\n        $$cache[hashKey] = result;\n        // for angular versions that less than 1.3\n        // add to `$destroy` listener, a cleaner callback\n        if(isScope(scope)) {\n          addListener(scope, hashKey);\n        } else {\n          cleanStateless();\n        }\n        return result;\n      }\n\n      return {\n        isMemoized: $$isMemoized,\n        memoize: $$memoize\n      }\n    }];\n  });\n  \n\n/**\n * @ngdoc module\n * @name angular.filters\n * @description\n * Bunch of useful filters for angularJS\n */\n\nangular.module('angular.filter', [\n\n  'a8m.ucfirst',\n  'a8m.uri-encode',\n  'a8m.uri-component-encode',\n  'a8m.slugify',\n  'a8m.latinize',\n  'a8m.strip-tags',\n  'a8m.stringular',\n  'a8m.truncate',\n  'a8m.starts-with',\n  'a8m.ends-with',\n  'a8m.wrap',\n  'a8m.trim',\n  'a8m.ltrim',\n  'a8m.rtrim',\n  'a8m.repeat',\n  'a8m.test',\n  'a8m.match',\n  'a8m.split',\n\n  'a8m.to-array',\n  'a8m.concat',\n  'a8m.contains',\n  'a8m.unique',\n  'a8m.is-empty',\n  'a8m.after',\n  'a8m.after-where',\n  'a8m.before',\n  'a8m.before-where',\n  'a8m.defaults',\n  'a8m.where',\n  'a8m.reverse',\n  'a8m.remove',\n  'a8m.remove-with',\n  'a8m.group-by',\n  'a8m.count-by',\n  'a8m.chunk-by',\n  'a8m.search-field',\n  'a8m.fuzzy-by',\n  'a8m.fuzzy',\n  'a8m.omit',\n  'a8m.pick',\n  'a8m.every',\n  'a8m.filter-by',\n  'a8m.xor',\n  'a8m.map',\n  'a8m.first',\n  'a8m.last',\n  'a8m.flatten',\n  'a8m.join',\n  'a8m.range',\n\n  'a8m.math.max',\n  'a8m.math.min',\n  'a8m.math.abs',\n  'a8m.math.percent',\n  'a8m.math.radix',\n  'a8m.math.sum',\n  'a8m.math.degrees',\n  'a8m.math.radians',\n  'a8m.math.byteFmt',\n  'a8m.math.kbFmt',\n  'a8m.math.shortFmt',\n\n  'a8m.angular',\n  'a8m.conditions',\n  'a8m.is-null',\n\n  'a8m.filter-watcher'\n]);\n})( window, window.angular );","/**\n * @license AngularJS v1.6.1\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\n/* global shallowCopy: true */\n\n/**\n * Creates a shallow copy of an object, an array or a primitive.\n *\n * Assumes that there are no proto properties for objects.\n */\nfunction shallowCopy(src, dst) {\n  if (isArray(src)) {\n    dst = dst || [];\n\n    for (var i = 0, ii = src.length; i < ii; i++) {\n      dst[i] = src[i];\n    }\n  } else if (isObject(src)) {\n    dst = dst || {};\n\n    for (var key in src) {\n      if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {\n        dst[key] = src[key];\n      }\n    }\n  }\n\n  return dst || src;\n}\n\n/* global shallowCopy: false */\n\n// `isArray` and `isObject` are necessary for `shallowCopy()` (included via `src/shallowCopy.js`).\n// They are initialized inside the `$RouteProvider`, to ensure `window.angular` is available.\nvar isArray;\nvar isObject;\nvar isDefined;\n\n/**\n * @ngdoc module\n * @name ngRoute\n * @description\n *\n * # ngRoute\n *\n * The `ngRoute` module provides routing and deeplinking services and directives for angular apps.\n *\n * ## Example\n * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.\n *\n *\n * <div doc-module-components=\"ngRoute\"></div>\n */\n/* global -ngRouteModule */\nvar ngRouteModule = angular.\n  module('ngRoute', []).\n  provider('$route', $RouteProvider).\n  // Ensure `$route` will be instantiated in time to capture the initial `$locationChangeSuccess`\n  // event (unless explicitly disabled). This is necessary in case `ngView` is included in an\n  // asynchronously loaded template.\n  run(instantiateRoute);\nvar $routeMinErr = angular.$$minErr('ngRoute');\nvar isEagerInstantiationEnabled;\n\n\n/**\n * @ngdoc provider\n * @name $routeProvider\n * @this\n *\n * @description\n *\n * Used for configuring routes.\n *\n * ## Example\n * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.\n *\n * ## Dependencies\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n */\nfunction $RouteProvider() {\n  isArray = angular.isArray;\n  isObject = angular.isObject;\n  isDefined = angular.isDefined;\n\n  function inherit(parent, extra) {\n    return angular.extend(Object.create(parent), extra);\n  }\n\n  var routes = {};\n\n  /**\n   * @ngdoc method\n   * @name $routeProvider#when\n   *\n   * @param {string} path Route path (matched against `$location.path`). If `$location.path`\n   *    contains redundant trailing slash or is missing one, the route will still match and the\n   *    `$location.path` will be updated to add or drop the trailing slash to exactly match the\n   *    route definition.\n   *\n   *    * `path` can contain named groups starting with a colon: e.g. `:name`. All characters up\n   *        to the next slash are matched and stored in `$routeParams` under the given `name`\n   *        when the route matches.\n   *    * `path` can contain named groups starting with a colon and ending with a star:\n   *        e.g.`:name*`. All characters are eagerly stored in `$routeParams` under the given `name`\n   *        when the route matches.\n   *    * `path` can contain optional named groups with a question mark: e.g.`:name?`.\n   *\n   *    For example, routes like `/color/:color/largecode/:largecode*\\/edit` will match\n   *    `/color/brown/largecode/code/with/slashes/edit` and extract:\n   *\n   *    * `color: brown`\n   *    * `largecode: code/with/slashes`.\n   *\n   *\n   * @param {Object} route Mapping information to be assigned to `$route.current` on route\n   *    match.\n   *\n   *    Object properties:\n   *\n   *    - `controller` – `{(string|Function)=}` – Controller fn that should be associated with\n   *      newly created scope or the name of a {@link angular.Module#controller registered\n   *      controller} if passed as a string.\n   *    - `controllerAs` – `{string=}` – An identifier name for a reference to the controller.\n   *      If present, the controller will be published to scope under the `controllerAs` name.\n   *    - `template` – `{(string|Function)=}` – html template as a string or a function that\n   *      returns an html template as a string which should be used by {@link\n   *      ngRoute.directive:ngView ngView} or {@link ng.directive:ngInclude ngInclude} directives.\n   *      This property takes precedence over `templateUrl`.\n   *\n   *      If `template` is a function, it will be called with the following parameters:\n   *\n   *      - `{Array.<Object>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route\n   *\n   *      One of `template` or `templateUrl` is required.\n   *\n   *    - `templateUrl` – `{(string|Function)=}` – path or function that returns a path to an html\n   *      template that should be used by {@link ngRoute.directive:ngView ngView}.\n   *\n   *      If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *      - `{Array.<Object>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route\n   *\n   *      One of `templateUrl` or `template` is required.\n   *\n   *    - `resolve` - `{Object.<string, Function>=}` - An optional map of dependencies which should\n   *      be injected into the controller. If any of these dependencies are promises, the router\n   *      will wait for them all to be resolved or one to be rejected before the controller is\n   *      instantiated.\n   *      If all the promises are resolved successfully, the values of the resolved promises are\n   *      injected and {@link ngRoute.$route#$routeChangeSuccess $routeChangeSuccess} event is\n   *      fired. If any of the promises are rejected the\n   *      {@link ngRoute.$route#$routeChangeError $routeChangeError} event is fired.\n   *      For easier access to the resolved dependencies from the template, the `resolve` map will\n   *      be available on the scope of the route, under `$resolve` (by default) or a custom name\n   *      specified by the `resolveAs` property (see below). This can be particularly useful, when\n   *      working with {@link angular.Module#component components} as route templates.<br />\n   *      <div class=\"alert alert-warning\">\n   *        **Note:** If your scope already contains a property with this name, it will be hidden\n   *        or overwritten. Make sure, you specify an appropriate name for this property, that\n   *        does not collide with other properties on the scope.\n   *      </div>\n   *      The map object is:\n   *\n   *      - `key` – `{string}`: a name of a dependency to be injected into the controller.\n   *      - `factory` - `{string|Function}`: If `string` then it is an alias for a service.\n   *        Otherwise if function, then it is {@link auto.$injector#invoke injected}\n   *        and the return value is treated as the dependency. If the result is a promise, it is\n   *        resolved before its value is injected into the controller. Be aware that\n   *        `ngRoute.$routeParams` will still refer to the previous route within these resolve\n   *        functions.  Use `$route.current.params` to access the new route parameters, instead.\n   *\n   *    - `resolveAs` - `{string=}` - The name under which the `resolve` map will be available on\n   *      the scope of the route. If omitted, defaults to `$resolve`.\n   *\n   *    - `redirectTo` – `{(string|Function)=}` – value to update\n   *      {@link ng.$location $location} path with and trigger route redirection.\n   *\n   *      If `redirectTo` is a function, it will be called with the following parameters:\n   *\n   *      - `{Object.<string>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route templateUrl.\n   *      - `{string}` - current `$location.path()`\n   *      - `{Object}` - current `$location.search()`\n   *\n   *      The custom `redirectTo` function is expected to return a string which will be used\n   *      to update `$location.url()`. If the function throws an error, no further processing will\n   *      take place and the {@link ngRoute.$route#$routeChangeError $routeChangeError} event will\n   *      be fired.\n   *\n   *      Routes that specify `redirectTo` will not have their controllers, template functions\n   *      or resolves called, the `$location` will be changed to the redirect url and route\n   *      processing will stop. The exception to this is if the `redirectTo` is a function that\n   *      returns `undefined`. In this case the route transition occurs as though there was no\n   *      redirection.\n   *\n   *    - `resolveRedirectTo` – `{Function=}` – a function that will (eventually) return the value\n   *      to update {@link ng.$location $location} URL with and trigger route redirection. In\n   *      contrast to `redirectTo`, dependencies can be injected into `resolveRedirectTo` and the\n   *      return value can be either a string or a promise that will be resolved to a string.\n   *\n   *      Similar to `redirectTo`, if the return value is `undefined` (or a promise that gets\n   *      resolved to `undefined`), no redirection takes place and the route transition occurs as\n   *      though there was no redirection.\n   *\n   *      If the function throws an error or the returned promise gets rejected, no further\n   *      processing will take place and the\n   *      {@link ngRoute.$route#$routeChangeError $routeChangeError} event will be fired.\n   *\n   *      `redirectTo` takes precedence over `resolveRedirectTo`, so specifying both on the same\n   *      route definition, will cause the latter to be ignored.\n   *\n   *    - `[reloadOnSearch=true]` - `{boolean=}` - reload route when only `$location.search()`\n   *      or `$location.hash()` changes.\n   *\n   *      If the option is set to `false` and url in the browser changes, then\n   *      `$routeUpdate` event is broadcasted on the root scope.\n   *\n   *    - `[caseInsensitiveMatch=false]` - `{boolean=}` - match routes without being case sensitive\n   *\n   *      If the option is set to `true`, then the particular route can be matched without being\n   *      case sensitive\n   *\n   * @returns {Object} self\n   *\n   * @description\n   * Adds a new route definition to the `$route` service.\n   */\n  this.when = function(path, route) {\n    //copy original route object to preserve params inherited from proto chain\n    var routeCopy = shallowCopy(route);\n    if (angular.isUndefined(routeCopy.reloadOnSearch)) {\n      routeCopy.reloadOnSearch = true;\n    }\n    if (angular.isUndefined(routeCopy.caseInsensitiveMatch)) {\n      routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch;\n    }\n    routes[path] = angular.extend(\n      routeCopy,\n      path && pathRegExp(path, routeCopy)\n    );\n\n    // create redirection for trailing slashes\n    if (path) {\n      var redirectPath = (path[path.length - 1] === '/')\n            ? path.substr(0, path.length - 1)\n            : path + '/';\n\n      routes[redirectPath] = angular.extend(\n        {redirectTo: path},\n        pathRegExp(redirectPath, routeCopy)\n      );\n    }\n\n    return this;\n  };\n\n  /**\n   * @ngdoc property\n   * @name $routeProvider#caseInsensitiveMatch\n   * @description\n   *\n   * A boolean property indicating if routes defined\n   * using this provider should be matched using a case insensitive\n   * algorithm. Defaults to `false`.\n   */\n  this.caseInsensitiveMatch = false;\n\n   /**\n    * @param path {string} path\n    * @param opts {Object} options\n    * @return {?Object}\n    *\n    * @description\n    * Normalizes the given path, returning a regular expression\n    * and the original path.\n    *\n    * Inspired by pathRexp in visionmedia/express/lib/utils.js.\n    */\n  function pathRegExp(path, opts) {\n    var insensitive = opts.caseInsensitiveMatch,\n        ret = {\n          originalPath: path,\n          regexp: path\n        },\n        keys = ret.keys = [];\n\n    path = path\n      .replace(/([().])/g, '\\\\$1')\n      .replace(/(\\/)?:(\\w+)(\\*\\?|[?*])?/g, function(_, slash, key, option) {\n        var optional = (option === '?' || option === '*?') ? '?' : null;\n        var star = (option === '*' || option === '*?') ? '*' : null;\n        keys.push({ name: key, optional: !!optional });\n        slash = slash || '';\n        return ''\n          + (optional ? '' : slash)\n          + '(?:'\n          + (optional ? slash : '')\n          + (star && '(.+?)' || '([^/]+)')\n          + (optional || '')\n          + ')'\n          + (optional || '');\n      })\n      .replace(/([/$*])/g, '\\\\$1');\n\n    ret.regexp = new RegExp('^' + path + '$', insensitive ? 'i' : '');\n    return ret;\n  }\n\n  /**\n   * @ngdoc method\n   * @name $routeProvider#otherwise\n   *\n   * @description\n   * Sets route definition that will be used on route change when no other route definition\n   * is matched.\n   *\n   * @param {Object|string} params Mapping information to be assigned to `$route.current`.\n   * If called with a string, the value maps to `redirectTo`.\n   * @returns {Object} self\n   */\n  this.otherwise = function(params) {\n    if (typeof params === 'string') {\n      params = {redirectTo: params};\n    }\n    this.when(null, params);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @name $routeProvider#eagerInstantiationEnabled\n   * @kind function\n   *\n   * @description\n   * Call this method as a setter to enable/disable eager instantiation of the\n   * {@link ngRoute.$route $route} service upon application bootstrap. You can also call it as a\n   * getter (i.e. without any arguments) to get the current value of the\n   * `eagerInstantiationEnabled` flag.\n   *\n   * Instantiating `$route` early is necessary for capturing the initial\n   * {@link ng.$location#$locationChangeStart $locationChangeStart} event and navigating to the\n   * appropriate route. Usually, `$route` is instantiated in time by the\n   * {@link ngRoute.ngView ngView} directive. Yet, in cases where `ngView` is included in an\n   * asynchronously loaded template (e.g. in another directive's template), the directive factory\n   * might not be called soon enough for `$route` to be instantiated _before_ the initial\n   * `$locationChangeSuccess` event is fired. Eager instantiation ensures that `$route` is always\n   * instantiated in time, regardless of when `ngView` will be loaded.\n   *\n   * The default value is true.\n   *\n   * **Note**:<br />\n   * You may want to disable the default behavior when unit-testing modules that depend on\n   * `ngRoute`, in order to avoid an unexpected request for the default route's template.\n   *\n   * @param {boolean=} enabled - If provided, update the internal `eagerInstantiationEnabled` flag.\n   *\n   * @returns {*} The current value of the `eagerInstantiationEnabled` flag if used as a getter or\n   *     itself (for chaining) if used as a setter.\n   */\n  isEagerInstantiationEnabled = true;\n  this.eagerInstantiationEnabled = function eagerInstantiationEnabled(enabled) {\n    if (isDefined(enabled)) {\n      isEagerInstantiationEnabled = enabled;\n      return this;\n    }\n\n    return isEagerInstantiationEnabled;\n  };\n\n\n  this.$get = ['$rootScope',\n               '$location',\n               '$routeParams',\n               '$q',\n               '$injector',\n               '$templateRequest',\n               '$sce',\n      function($rootScope, $location, $routeParams, $q, $injector, $templateRequest, $sce) {\n\n    /**\n     * @ngdoc service\n     * @name $route\n     * @requires $location\n     * @requires $routeParams\n     *\n     * @property {Object} current Reference to the current route definition.\n     * The route definition contains:\n     *\n     *   - `controller`: The controller constructor as defined in the route definition.\n     *   - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for\n     *     controller instantiation. The `locals` contain\n     *     the resolved values of the `resolve` map. Additionally the `locals` also contain:\n     *\n     *     - `$scope` - The current route scope.\n     *     - `$template` - The current route template HTML.\n     *\n     *     The `locals` will be assigned to the route scope's `$resolve` property. You can override\n     *     the property name, using `resolveAs` in the route definition. See\n     *     {@link ngRoute.$routeProvider $routeProvider} for more info.\n     *\n     * @property {Object} routes Object with all route configuration Objects as its properties.\n     *\n     * @description\n     * `$route` is used for deep-linking URLs to controllers and views (HTML partials).\n     * It watches `$location.url()` and tries to map the path to an existing route definition.\n     *\n     * Requires the {@link ngRoute `ngRoute`} module to be installed.\n     *\n     * You can define routes through {@link ngRoute.$routeProvider $routeProvider}'s API.\n     *\n     * The `$route` service is typically used in conjunction with the\n     * {@link ngRoute.directive:ngView `ngView`} directive and the\n     * {@link ngRoute.$routeParams `$routeParams`} service.\n     *\n     * @example\n     * This example shows how changing the URL hash causes the `$route` to match a route against the\n     * URL, and the `ngView` pulls in the partial.\n     *\n     * <example name=\"$route-service\" module=\"ngRouteExample\"\n     *          deps=\"angular-route.js\" fixBase=\"true\">\n     *   <file name=\"index.html\">\n     *     <div ng-controller=\"MainController\">\n     *       Choose:\n     *       <a href=\"Book/Moby\">Moby</a> |\n     *       <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n     *       <a href=\"Book/Gatsby\">Gatsby</a> |\n     *       <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n     *       <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n     *\n     *       <div ng-view></div>\n     *\n     *       <hr />\n     *\n     *       <pre>$location.path() = {{$location.path()}}</pre>\n     *       <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>\n     *       <pre>$route.current.params = {{$route.current.params}}</pre>\n     *       <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>\n     *       <pre>$routeParams = {{$routeParams}}</pre>\n     *     </div>\n     *   </file>\n     *\n     *   <file name=\"book.html\">\n     *     controller: {{name}}<br />\n     *     Book Id: {{params.bookId}}<br />\n     *   </file>\n     *\n     *   <file name=\"chapter.html\">\n     *     controller: {{name}}<br />\n     *     Book Id: {{params.bookId}}<br />\n     *     Chapter Id: {{params.chapterId}}\n     *   </file>\n     *\n     *   <file name=\"script.js\">\n     *     angular.module('ngRouteExample', ['ngRoute'])\n     *\n     *      .controller('MainController', function($scope, $route, $routeParams, $location) {\n     *          $scope.$route = $route;\n     *          $scope.$location = $location;\n     *          $scope.$routeParams = $routeParams;\n     *      })\n     *\n     *      .controller('BookController', function($scope, $routeParams) {\n     *          $scope.name = 'BookController';\n     *          $scope.params = $routeParams;\n     *      })\n     *\n     *      .controller('ChapterController', function($scope, $routeParams) {\n     *          $scope.name = 'ChapterController';\n     *          $scope.params = $routeParams;\n     *      })\n     *\n     *     .config(function($routeProvider, $locationProvider) {\n     *       $routeProvider\n     *        .when('/Book/:bookId', {\n     *         templateUrl: 'book.html',\n     *         controller: 'BookController',\n     *         resolve: {\n     *           // I will cause a 1 second delay\n     *           delay: function($q, $timeout) {\n     *             var delay = $q.defer();\n     *             $timeout(delay.resolve, 1000);\n     *             return delay.promise;\n     *           }\n     *         }\n     *       })\n     *       .when('/Book/:bookId/ch/:chapterId', {\n     *         templateUrl: 'chapter.html',\n     *         controller: 'ChapterController'\n     *       });\n     *\n     *       // configure html5 to get links working on jsfiddle\n     *       $locationProvider.html5Mode(true);\n     *     });\n     *\n     *   </file>\n     *\n     *   <file name=\"protractor.js\" type=\"protractor\">\n     *     it('should load and compile correct template', function() {\n     *       element(by.linkText('Moby: Ch1')).click();\n     *       var content = element(by.css('[ng-view]')).getText();\n     *       expect(content).toMatch(/controller: ChapterController/);\n     *       expect(content).toMatch(/Book Id: Moby/);\n     *       expect(content).toMatch(/Chapter Id: 1/);\n     *\n     *       element(by.partialLinkText('Scarlet')).click();\n     *\n     *       content = element(by.css('[ng-view]')).getText();\n     *       expect(content).toMatch(/controller: BookController/);\n     *       expect(content).toMatch(/Book Id: Scarlet/);\n     *     });\n     *   </file>\n     * </example>\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeStart\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted before a route change. At this  point the route services starts\n     * resolving all of the dependencies needed for the route change to occur.\n     * Typically this involves fetching the view template as well as any dependencies\n     * defined in `resolve` route property. Once  all of the dependencies are resolved\n     * `$routeChangeSuccess` is fired.\n     *\n     * The route change (and the `$location` change that triggered it) can be prevented\n     * by calling `preventDefault` method of the event. See {@link ng.$rootScope.Scope#$on}\n     * for more details about event object.\n     *\n     * @param {Object} angularEvent Synthetic event object.\n     * @param {Route} next Future route information.\n     * @param {Route} current Current route information.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeSuccess\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted after a route change has happened successfully.\n     * The `resolve` dependencies are now available in the `current.locals` property.\n     *\n     * {@link ngRoute.directive:ngView ngView} listens for the directive\n     * to instantiate the controller and render the view.\n     *\n     * @param {Object} angularEvent Synthetic event object.\n     * @param {Route} current Current route information.\n     * @param {Route|Undefined} previous Previous route information, or undefined if current is\n     * first route entered.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeError\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted if a redirection function fails or any redirection or resolve promises are\n     * rejected.\n     *\n     * @param {Object} angularEvent Synthetic event object\n     * @param {Route} current Current route information.\n     * @param {Route} previous Previous route information.\n     * @param {Route} rejection The thrown error or the rejection reason of the promise. Usually\n     * the rejection reason is the error that caused the promise to get rejected.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeUpdate\n     * @eventType broadcast on root scope\n     * @description\n     * The `reloadOnSearch` property has been set to false, and we are reusing the same\n     * instance of the Controller.\n     *\n     * @param {Object} angularEvent Synthetic event object\n     * @param {Route} current Current/previous route information.\n     */\n\n    var forceReload = false,\n        preparedRoute,\n        preparedRouteIsUpdateOnly,\n        $route = {\n          routes: routes,\n\n          /**\n           * @ngdoc method\n           * @name $route#reload\n           *\n           * @description\n           * Causes `$route` service to reload the current route even if\n           * {@link ng.$location $location} hasn't changed.\n           *\n           * As a result of that, {@link ngRoute.directive:ngView ngView}\n           * creates new scope and reinstantiates the controller.\n           */\n          reload: function() {\n            forceReload = true;\n\n            var fakeLocationEvent = {\n              defaultPrevented: false,\n              preventDefault: function fakePreventDefault() {\n                this.defaultPrevented = true;\n                forceReload = false;\n              }\n            };\n\n            $rootScope.$evalAsync(function() {\n              prepareRoute(fakeLocationEvent);\n              if (!fakeLocationEvent.defaultPrevented) commitRoute();\n            });\n          },\n\n          /**\n           * @ngdoc method\n           * @name $route#updateParams\n           *\n           * @description\n           * Causes `$route` service to update the current URL, replacing\n           * current route parameters with those specified in `newParams`.\n           * Provided property names that match the route's path segment\n           * definitions will be interpolated into the location's path, while\n           * remaining properties will be treated as query params.\n           *\n           * @param {!Object<string, string>} newParams mapping of URL parameter names to values\n           */\n          updateParams: function(newParams) {\n            if (this.current && this.current.$$route) {\n              newParams = angular.extend({}, this.current.params, newParams);\n              $location.path(interpolate(this.current.$$route.originalPath, newParams));\n              // interpolate modifies newParams, only query params are left\n              $location.search(newParams);\n            } else {\n              throw $routeMinErr('norout', 'Tried updating route when with no current route');\n            }\n          }\n        };\n\n    $rootScope.$on('$locationChangeStart', prepareRoute);\n    $rootScope.$on('$locationChangeSuccess', commitRoute);\n\n    return $route;\n\n    /////////////////////////////////////////////////////\n\n    /**\n     * @param on {string} current url\n     * @param route {Object} route regexp to match the url against\n     * @return {?Object}\n     *\n     * @description\n     * Check if the route matches the current url.\n     *\n     * Inspired by match in\n     * visionmedia/express/lib/router/router.js.\n     */\n    function switchRouteMatcher(on, route) {\n      var keys = route.keys,\n          params = {};\n\n      if (!route.regexp) return null;\n\n      var m = route.regexp.exec(on);\n      if (!m) return null;\n\n      for (var i = 1, len = m.length; i < len; ++i) {\n        var key = keys[i - 1];\n\n        var val = m[i];\n\n        if (key && val) {\n          params[key.name] = val;\n        }\n      }\n      return params;\n    }\n\n    function prepareRoute($locationEvent) {\n      var lastRoute = $route.current;\n\n      preparedRoute = parseRoute();\n      preparedRouteIsUpdateOnly = preparedRoute && lastRoute && preparedRoute.$$route === lastRoute.$$route\n          && angular.equals(preparedRoute.pathParams, lastRoute.pathParams)\n          && !preparedRoute.reloadOnSearch && !forceReload;\n\n      if (!preparedRouteIsUpdateOnly && (lastRoute || preparedRoute)) {\n        if ($rootScope.$broadcast('$routeChangeStart', preparedRoute, lastRoute).defaultPrevented) {\n          if ($locationEvent) {\n            $locationEvent.preventDefault();\n          }\n        }\n      }\n    }\n\n    function commitRoute() {\n      var lastRoute = $route.current;\n      var nextRoute = preparedRoute;\n\n      if (preparedRouteIsUpdateOnly) {\n        lastRoute.params = nextRoute.params;\n        angular.copy(lastRoute.params, $routeParams);\n        $rootScope.$broadcast('$routeUpdate', lastRoute);\n      } else if (nextRoute || lastRoute) {\n        forceReload = false;\n        $route.current = nextRoute;\n\n        var nextRoutePromise = $q.resolve(nextRoute);\n\n        nextRoutePromise.\n          then(getRedirectionData).\n          then(handlePossibleRedirection).\n          then(function(keepProcessingRoute) {\n            return keepProcessingRoute && nextRoutePromise.\n              then(resolveLocals).\n              then(function(locals) {\n                // after route change\n                if (nextRoute === $route.current) {\n                  if (nextRoute) {\n                    nextRoute.locals = locals;\n                    angular.copy(nextRoute.params, $routeParams);\n                  }\n                  $rootScope.$broadcast('$routeChangeSuccess', nextRoute, lastRoute);\n                }\n              });\n          }).catch(function(error) {\n            if (nextRoute === $route.current) {\n              $rootScope.$broadcast('$routeChangeError', nextRoute, lastRoute, error);\n            }\n          });\n      }\n    }\n\n    function getRedirectionData(route) {\n      var data = {\n        route: route,\n        hasRedirection: false\n      };\n\n      if (route) {\n        if (route.redirectTo) {\n          if (angular.isString(route.redirectTo)) {\n            data.path = interpolate(route.redirectTo, route.params);\n            data.search = route.params;\n            data.hasRedirection = true;\n          } else {\n            var oldPath = $location.path();\n            var oldSearch = $location.search();\n            var newUrl = route.redirectTo(route.pathParams, oldPath, oldSearch);\n\n            if (angular.isDefined(newUrl)) {\n              data.url = newUrl;\n              data.hasRedirection = true;\n            }\n          }\n        } else if (route.resolveRedirectTo) {\n          return $q.\n            resolve($injector.invoke(route.resolveRedirectTo)).\n            then(function(newUrl) {\n              if (angular.isDefined(newUrl)) {\n                data.url = newUrl;\n                data.hasRedirection = true;\n              }\n\n              return data;\n            });\n        }\n      }\n\n      return data;\n    }\n\n    function handlePossibleRedirection(data) {\n      var keepProcessingRoute = true;\n\n      if (data.route !== $route.current) {\n        keepProcessingRoute = false;\n      } else if (data.hasRedirection) {\n        var oldUrl = $location.url();\n        var newUrl = data.url;\n\n        if (newUrl) {\n          $location.\n            url(newUrl).\n            replace();\n        } else {\n          newUrl = $location.\n            path(data.path).\n            search(data.search).\n            replace().\n            url();\n        }\n\n        if (newUrl !== oldUrl) {\n          // Exit out and don't process current next value,\n          // wait for next location change from redirect\n          keepProcessingRoute = false;\n        }\n      }\n\n      return keepProcessingRoute;\n    }\n\n    function resolveLocals(route) {\n      if (route) {\n        var locals = angular.extend({}, route.resolve);\n        angular.forEach(locals, function(value, key) {\n          locals[key] = angular.isString(value) ?\n              $injector.get(value) :\n              $injector.invoke(value, null, null, key);\n        });\n        var template = getTemplateFor(route);\n        if (angular.isDefined(template)) {\n          locals['$template'] = template;\n        }\n        return $q.all(locals);\n      }\n    }\n\n    function getTemplateFor(route) {\n      var template, templateUrl;\n      if (angular.isDefined(template = route.template)) {\n        if (angular.isFunction(template)) {\n          template = template(route.params);\n        }\n      } else if (angular.isDefined(templateUrl = route.templateUrl)) {\n        if (angular.isFunction(templateUrl)) {\n          templateUrl = templateUrl(route.params);\n        }\n        if (angular.isDefined(templateUrl)) {\n          route.loadedTemplateUrl = $sce.valueOf(templateUrl);\n          template = $templateRequest(templateUrl);\n        }\n      }\n      return template;\n    }\n\n    /**\n     * @returns {Object} the current active route, by matching it against the URL\n     */\n    function parseRoute() {\n      // Match a route\n      var params, match;\n      angular.forEach(routes, function(route, path) {\n        if (!match && (params = switchRouteMatcher($location.path(), route))) {\n          match = inherit(route, {\n            params: angular.extend({}, $location.search(), params),\n            pathParams: params});\n          match.$$route = route;\n        }\n      });\n      // No route matched; fallback to \"otherwise\" route\n      return match || routes[null] && inherit(routes[null], {params: {}, pathParams:{}});\n    }\n\n    /**\n     * @returns {string} interpolation of the redirect path with the parameters\n     */\n    function interpolate(string, params) {\n      var result = [];\n      angular.forEach((string || '').split(':'), function(segment, i) {\n        if (i === 0) {\n          result.push(segment);\n        } else {\n          var segmentMatch = segment.match(/(\\w+)(?:[?*])?(.*)/);\n          var key = segmentMatch[1];\n          result.push(params[key]);\n          result.push(segmentMatch[2] || '');\n          delete params[key];\n        }\n      });\n      return result.join('');\n    }\n  }];\n}\n\ninstantiateRoute.$inject = ['$injector'];\nfunction instantiateRoute($injector) {\n  if (isEagerInstantiationEnabled) {\n    // Instantiate `$route`\n    $injector.get('$route');\n  }\n}\n\nngRouteModule.provider('$routeParams', $RouteParamsProvider);\n\n\n/**\n * @ngdoc service\n * @name $routeParams\n * @requires $route\n * @this\n *\n * @description\n * The `$routeParams` service allows you to retrieve the current set of route parameters.\n *\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n *\n * The route parameters are a combination of {@link ng.$location `$location`}'s\n * {@link ng.$location#search `search()`} and {@link ng.$location#path `path()`}.\n * The `path` parameters are extracted when the {@link ngRoute.$route `$route`} path is matched.\n *\n * In case of parameter name collision, `path` params take precedence over `search` params.\n *\n * The service guarantees that the identity of the `$routeParams` object will remain unchanged\n * (but its properties will likely change) even when a route change occurs.\n *\n * Note that the `$routeParams` are only updated *after* a route change completes successfully.\n * This means that you cannot rely on `$routeParams` being correct in route resolve functions.\n * Instead you can use `$route.current.params` to access the new route's parameters.\n *\n * @example\n * ```js\n *  // Given:\n *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby\n *  // Route: /Chapter/:chapterId/Section/:sectionId\n *  //\n *  // Then\n *  $routeParams ==> {chapterId:'1', sectionId:'2', search:'moby'}\n * ```\n */\nfunction $RouteParamsProvider() {\n  this.$get = function() { return {}; };\n}\n\nngRouteModule.directive('ngView', ngViewFactory);\nngRouteModule.directive('ngView', ngViewFillContentFactory);\n\n\n/**\n * @ngdoc directive\n * @name ngView\n * @restrict ECA\n *\n * @description\n * # Overview\n * `ngView` is a directive that complements the {@link ngRoute.$route $route} service by\n * including the rendered template of the current route into the main layout (`index.html`) file.\n * Every time the current route changes, the included view changes with it according to the\n * configuration of the `$route` service.\n *\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n *\n * @animations\n * | Animation                        | Occurs                              |\n * |----------------------------------|-------------------------------------|\n * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM |\n * | {@link ng.$animate#leave leave}  | when the old element is removed from to the DOM  |\n *\n * The enter and leave animation occur concurrently.\n *\n * @scope\n * @priority 400\n * @param {string=} onload Expression to evaluate whenever the view updates.\n *\n * @param {string=} autoscroll Whether `ngView` should call {@link ng.$anchorScroll\n *                  $anchorScroll} to scroll the viewport after the view is updated.\n *\n *                  - If the attribute is not set, disable scrolling.\n *                  - If the attribute is set without value, enable scrolling.\n *                  - Otherwise enable scrolling only if the `autoscroll` attribute value evaluated\n *                    as an expression yields a truthy value.\n * @example\n    <example name=\"ngView-directive\" module=\"ngViewExample\"\n             deps=\"angular-route.js;angular-animate.js\"\n             animations=\"true\" fixBase=\"true\">\n      <file name=\"index.html\">\n        <div ng-controller=\"MainCtrl as main\">\n          Choose:\n          <a href=\"Book/Moby\">Moby</a> |\n          <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n          <a href=\"Book/Gatsby\">Gatsby</a> |\n          <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n          <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n\n          <div class=\"view-animate-container\">\n            <div ng-view class=\"view-animate\"></div>\n          </div>\n          <hr />\n\n          <pre>$location.path() = {{main.$location.path()}}</pre>\n          <pre>$route.current.templateUrl = {{main.$route.current.templateUrl}}</pre>\n          <pre>$route.current.params = {{main.$route.current.params}}</pre>\n          <pre>$routeParams = {{main.$routeParams}}</pre>\n        </div>\n      </file>\n\n      <file name=\"book.html\">\n        <div>\n          controller: {{book.name}}<br />\n          Book Id: {{book.params.bookId}}<br />\n        </div>\n      </file>\n\n      <file name=\"chapter.html\">\n        <div>\n          controller: {{chapter.name}}<br />\n          Book Id: {{chapter.params.bookId}}<br />\n          Chapter Id: {{chapter.params.chapterId}}\n        </div>\n      </file>\n\n      <file name=\"animations.css\">\n        .view-animate-container {\n          position:relative;\n          height:100px!important;\n          background:white;\n          border:1px solid black;\n          height:40px;\n          overflow:hidden;\n        }\n\n        .view-animate {\n          padding:10px;\n        }\n\n        .view-animate.ng-enter, .view-animate.ng-leave {\n          transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\n\n          display:block;\n          width:100%;\n          border-left:1px solid black;\n\n          position:absolute;\n          top:0;\n          left:0;\n          right:0;\n          bottom:0;\n          padding:10px;\n        }\n\n        .view-animate.ng-enter {\n          left:100%;\n        }\n        .view-animate.ng-enter.ng-enter-active {\n          left:0;\n        }\n        .view-animate.ng-leave.ng-leave-active {\n          left:-100%;\n        }\n      </file>\n\n      <file name=\"script.js\">\n        angular.module('ngViewExample', ['ngRoute', 'ngAnimate'])\n          .config(['$routeProvider', '$locationProvider',\n            function($routeProvider, $locationProvider) {\n              $routeProvider\n                .when('/Book/:bookId', {\n                  templateUrl: 'book.html',\n                  controller: 'BookCtrl',\n                  controllerAs: 'book'\n                })\n                .when('/Book/:bookId/ch/:chapterId', {\n                  templateUrl: 'chapter.html',\n                  controller: 'ChapterCtrl',\n                  controllerAs: 'chapter'\n                });\n\n              $locationProvider.html5Mode(true);\n          }])\n          .controller('MainCtrl', ['$route', '$routeParams', '$location',\n            function MainCtrl($route, $routeParams, $location) {\n              this.$route = $route;\n              this.$location = $location;\n              this.$routeParams = $routeParams;\n          }])\n          .controller('BookCtrl', ['$routeParams', function BookCtrl($routeParams) {\n            this.name = 'BookCtrl';\n            this.params = $routeParams;\n          }])\n          .controller('ChapterCtrl', ['$routeParams', function ChapterCtrl($routeParams) {\n            this.name = 'ChapterCtrl';\n            this.params = $routeParams;\n          }]);\n\n      </file>\n\n      <file name=\"protractor.js\" type=\"protractor\">\n        it('should load and compile correct template', function() {\n          element(by.linkText('Moby: Ch1')).click();\n          var content = element(by.css('[ng-view]')).getText();\n          expect(content).toMatch(/controller: ChapterCtrl/);\n          expect(content).toMatch(/Book Id: Moby/);\n          expect(content).toMatch(/Chapter Id: 1/);\n\n          element(by.partialLinkText('Scarlet')).click();\n\n          content = element(by.css('[ng-view]')).getText();\n          expect(content).toMatch(/controller: BookCtrl/);\n          expect(content).toMatch(/Book Id: Scarlet/);\n        });\n      </file>\n    </example>\n */\n\n\n/**\n * @ngdoc event\n * @name ngView#$viewContentLoaded\n * @eventType emit on the current ngView scope\n * @description\n * Emitted every time the ngView content is reloaded.\n */\nngViewFactory.$inject = ['$route', '$anchorScroll', '$animate'];\nfunction ngViewFactory($route, $anchorScroll, $animate) {\n  return {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    link: function(scope, $element, attr, ctrl, $transclude) {\n        var currentScope,\n            currentElement,\n            previousLeaveAnimation,\n            autoScrollExp = attr.autoscroll,\n            onloadExp = attr.onload || '';\n\n        scope.$on('$routeChangeSuccess', update);\n        update();\n\n        function cleanupLastView() {\n          if (previousLeaveAnimation) {\n            $animate.cancel(previousLeaveAnimation);\n            previousLeaveAnimation = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n          if (currentElement) {\n            previousLeaveAnimation = $animate.leave(currentElement);\n            previousLeaveAnimation.done(function(response) {\n              if (response !== false) previousLeaveAnimation = null;\n            });\n            currentElement = null;\n          }\n        }\n\n        function update() {\n          var locals = $route.current && $route.current.locals,\n              template = locals && locals.$template;\n\n          if (angular.isDefined(template)) {\n            var newScope = scope.$new();\n            var current = $route.current;\n\n            // Note: This will also link all children of ng-view that were contained in the original\n            // html. If that content contains controllers, ... they could pollute/change the scope.\n            // However, using ng-view on an element with additional content does not make sense...\n            // Note: We can't remove them in the cloneAttchFn of $transclude as that\n            // function is called before linking the content, which would apply child\n            // directives to non existing elements.\n            var clone = $transclude(newScope, function(clone) {\n              $animate.enter(clone, null, currentElement || $element).done(function onNgViewEnter(response) {\n                if (response !== false && angular.isDefined(autoScrollExp)\n                  && (!autoScrollExp || scope.$eval(autoScrollExp))) {\n                  $anchorScroll();\n                }\n              });\n              cleanupLastView();\n            });\n\n            currentElement = clone;\n            currentScope = current.scope = newScope;\n            currentScope.$emit('$viewContentLoaded');\n            currentScope.$eval(onloadExp);\n          } else {\n            cleanupLastView();\n          }\n        }\n    }\n  };\n}\n\n// This directive is called during the $transclude call of the first `ngView` directive.\n// It will replace and compile the content of the element with the loaded template.\n// We need this directive so that the element content is already filled when\n// the link function of another directive on the same element as ngView\n// is called.\nngViewFillContentFactory.$inject = ['$compile', '$controller', '$route'];\nfunction ngViewFillContentFactory($compile, $controller, $route) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    link: function(scope, $element) {\n      var current = $route.current,\n          locals = current.locals;\n\n      $element.html(locals.$template);\n\n      var link = $compile($element.contents());\n\n      if (current.controller) {\n        locals.$scope = scope;\n        var controller = $controller(current.controller, locals);\n        if (current.controllerAs) {\n          scope[current.controllerAs] = controller;\n        }\n        $element.data('$ngControllerController', controller);\n        $element.children().data('$ngControllerController', controller);\n      }\n      scope[current.resolveAs || '$resolve'] = locals;\n\n      link(scope);\n    }\n  };\n}\n\n\n})(window, window.angular);\n","/**\n * @license AngularJS v1.6.1\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $sanitizeMinErr = angular.$$minErr('$sanitize');\nvar bind;\nvar extend;\nvar forEach;\nvar isDefined;\nvar lowercase;\nvar noop;\nvar htmlParser;\nvar htmlSanitizeWriter;\n\n/**\n * @ngdoc module\n * @name ngSanitize\n * @description\n *\n * # ngSanitize\n *\n * The `ngSanitize` module provides functionality to sanitize HTML.\n *\n *\n * <div doc-module-components=\"ngSanitize\"></div>\n *\n * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n */\n\n/**\n * @ngdoc service\n * @name $sanitize\n * @kind function\n *\n * @description\n *   Sanitizes an html string by stripping all potentially dangerous tokens.\n *\n *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n *   then serialized back to properly escaped html string. This means that no unsafe input can make\n *   it into the returned string.\n *\n *   The whitelist for URL sanitization of attribute values is configured using the functions\n *   `aHrefSanitizationWhitelist` and `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider\n *   `$compileProvider`}.\n *\n *   The input may also contain SVG markup if this is enabled via {@link $sanitizeProvider}.\n *\n * @param {string} html HTML input.\n * @returns {string} Sanitized HTML.\n *\n * @example\n   <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\" name=\"sanitize-service\">\n   <file name=\"index.html\">\n     <script>\n         angular.module('sanitizeExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n             $scope.snippet =\n               '<p style=\"color:blue\">an html\\n' +\n               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n               'snippet</p>';\n             $scope.deliberatelyTrustDangerousSnippet = function() {\n               return $sce.trustAsHtml($scope.snippet);\n             };\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n        Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Directive</td>\n           <td>How</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"bind-html-with-sanitize\">\n           <td>ng-bind-html</td>\n           <td>Automatically uses $sanitize</td>\n           <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind-html=\"snippet\"></div></td>\n         </tr>\n         <tr id=\"bind-html-with-trust\">\n           <td>ng-bind-html</td>\n           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n           <td>\n           <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n&lt;/div&gt;</pre>\n           </td>\n           <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n         </tr>\n         <tr id=\"bind-default\">\n           <td>ng-bind</td>\n           <td>Automatically escapes</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n       </div>\n   </file>\n   <file name=\"protractor.js\" type=\"protractor\">\n     it('should sanitize the html snippet by default', function() {\n       expect(element(by.css('#bind-html-with-sanitize div')).getAttribute('innerHTML')).\n         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n     });\n\n     it('should inline raw snippet if bound to a trusted value', function() {\n       expect(element(by.css('#bind-html-with-trust div')).getAttribute('innerHTML')).\n         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n              \"snippet</p>\");\n     });\n\n     it('should escape snippet without any filter', function() {\n       expect(element(by.css('#bind-default div')).getAttribute('innerHTML')).\n         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n              \"snippet&lt;/p&gt;\");\n     });\n\n     it('should update', function() {\n       element(by.model('snippet')).clear();\n       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-html-with-sanitize div')).getAttribute('innerHTML')).\n         toBe('new <b>text</b>');\n       expect(element(by.css('#bind-html-with-trust div')).getAttribute('innerHTML')).toBe(\n         'new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-default div')).getAttribute('innerHTML')).toBe(\n         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n     });\n   </file>\n   </example>\n */\n\n\n/**\n * @ngdoc provider\n * @name $sanitizeProvider\n * @this\n *\n * @description\n * Creates and configures {@link $sanitize} instance.\n */\nfunction $SanitizeProvider() {\n  var svgEnabled = false;\n\n  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {\n    if (svgEnabled) {\n      extend(validElements, svgElements);\n    }\n    return function(html) {\n      var buf = [];\n      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {\n        return !/^unsafe:/.test($$sanitizeUri(uri, isImage));\n      }));\n      return buf.join('');\n    };\n  }];\n\n\n  /**\n   * @ngdoc method\n   * @name $sanitizeProvider#enableSvg\n   * @kind function\n   *\n   * @description\n   * Enables a subset of svg to be supported by the sanitizer.\n   *\n   * <div class=\"alert alert-warning\">\n   *   <p>By enabling this setting without taking other precautions, you might expose your\n   *   application to click-hijacking attacks. In these attacks, sanitized svg elements could be positioned\n   *   outside of the containing element and be rendered over other elements on the page (e.g. a login\n   *   link). Such behavior can then result in phishing incidents.</p>\n   *\n   *   <p>To protect against these, explicitly setup `overflow: hidden` css rule for all potential svg\n   *   tags within the sanitized content:</p>\n   *\n   *   <br>\n   *\n   *   <pre><code>\n   *   .rootOfTheIncludedContent svg {\n   *     overflow: hidden !important;\n   *   }\n   *   </code></pre>\n   * </div>\n   *\n   * @param {boolean=} flag Enable or disable SVG support in the sanitizer.\n   * @returns {boolean|ng.$sanitizeProvider} Returns the currently configured value if called\n   *    without an argument or self for chaining otherwise.\n   */\n  this.enableSvg = function(enableSvg) {\n    if (isDefined(enableSvg)) {\n      svgEnabled = enableSvg;\n      return this;\n    } else {\n      return svgEnabled;\n    }\n  };\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n  // Private stuff\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n\n  bind = angular.bind;\n  extend = angular.extend;\n  forEach = angular.forEach;\n  isDefined = angular.isDefined;\n  lowercase = angular.lowercase;\n  noop = angular.noop;\n\n  htmlParser = htmlParserImpl;\n  htmlSanitizeWriter = htmlSanitizeWriterImpl;\n\n  // Regular Expressions for parsing tags and attributes\n  var SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n    // Match everything outside of normal chars and \" (quote character)\n    NON_ALPHANUMERIC_REGEXP = /([^#-~ |!])/g;\n\n\n  // Good source of info about elements and attributes\n  // http://dev.w3.org/html5/spec/Overview.html#semantics\n  // http://simon.html5.org/html-elements\n\n  // Safe Void Elements - HTML5\n  // http://dev.w3.org/html5/spec/Overview.html#void-elements\n  var voidElements = toMap('area,br,col,hr,img,wbr');\n\n  // Elements that you can, intentionally, leave open (and which close themselves)\n  // http://dev.w3.org/html5/spec/Overview.html#optional-tags\n  var optionalEndTagBlockElements = toMap('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr'),\n      optionalEndTagInlineElements = toMap('rp,rt'),\n      optionalEndTagElements = extend({},\n                                              optionalEndTagInlineElements,\n                                              optionalEndTagBlockElements);\n\n  // Safe Block Elements - HTML5\n  var blockElements = extend({}, optionalEndTagBlockElements, toMap('address,article,' +\n          'aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +\n          'h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul'));\n\n  // Inline Elements - HTML5\n  var inlineElements = extend({}, optionalEndTagInlineElements, toMap('a,abbr,acronym,b,' +\n          'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,' +\n          'samp,small,span,strike,strong,sub,sup,time,tt,u,var'));\n\n  // SVG Elements\n  // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements\n  // Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.\n  // They can potentially allow for arbitrary javascript to be executed. See #11290\n  var svgElements = toMap('circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,' +\n          'hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,' +\n          'radialGradient,rect,stop,svg,switch,text,title,tspan');\n\n  // Blocked Elements (will be stripped)\n  var blockedElements = toMap('script,style');\n\n  var validElements = extend({},\n                                     voidElements,\n                                     blockElements,\n                                     inlineElements,\n                                     optionalEndTagElements);\n\n  //Attributes that have href and hence need to be sanitized\n  var uriAttrs = toMap('background,cite,href,longdesc,src,xlink:href');\n\n  var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +\n      'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +\n      'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +\n      'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +\n      'valign,value,vspace,width');\n\n  // SVG attributes (without \"id\" and \"name\" attributes)\n  // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes\n  var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +\n      'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +\n      'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +\n      'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +\n      'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +\n      'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +\n      'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +\n      'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +\n      'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +\n      'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +\n      'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +\n      'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +\n      'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +\n      'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:display,xlink:title,' +\n      'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);\n\n  var validAttrs = extend({},\n                                  uriAttrs,\n                                  svgAttrs,\n                                  htmlAttrs);\n\n  function toMap(str, lowercaseKeys) {\n    var obj = {}, items = str.split(','), i;\n    for (i = 0; i < items.length; i++) {\n      obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = true;\n    }\n    return obj;\n  }\n\n  var inertBodyElement;\n  (function(window) {\n    var doc;\n    if (window.document && window.document.implementation) {\n      doc = window.document.implementation.createHTMLDocument('inert');\n    } else {\n      throw $sanitizeMinErr('noinert', 'Can\\'t create an inert html document');\n    }\n    var docElement = doc.documentElement || doc.getDocumentElement();\n    var bodyElements = docElement.getElementsByTagName('body');\n\n    // usually there should be only one body element in the document, but IE doesn't have any, so we need to create one\n    if (bodyElements.length === 1) {\n      inertBodyElement = bodyElements[0];\n    } else {\n      var html = doc.createElement('html');\n      inertBodyElement = doc.createElement('body');\n      html.appendChild(inertBodyElement);\n      doc.appendChild(html);\n    }\n  })(window);\n\n  /**\n   * @example\n   * htmlParser(htmlString, {\n   *     start: function(tag, attrs) {},\n   *     end: function(tag) {},\n   *     chars: function(text) {},\n   *     comment: function(text) {}\n   * });\n   *\n   * @param {string} html string\n   * @param {object} handler\n   */\n  function htmlParserImpl(html, handler) {\n    if (html === null || html === undefined) {\n      html = '';\n    } else if (typeof html !== 'string') {\n      html = '' + html;\n    }\n    inertBodyElement.innerHTML = html;\n\n    //mXSS protection\n    var mXSSAttempts = 5;\n    do {\n      if (mXSSAttempts === 0) {\n        throw $sanitizeMinErr('uinput', 'Failed to sanitize html because the input is unstable');\n      }\n      mXSSAttempts--;\n\n      // strip custom-namespaced attributes on IE<=11\n      if (window.document.documentMode) {\n        stripCustomNsAttrs(inertBodyElement);\n      }\n      html = inertBodyElement.innerHTML; //trigger mXSS\n      inertBodyElement.innerHTML = html;\n    } while (html !== inertBodyElement.innerHTML);\n\n    var node = inertBodyElement.firstChild;\n    while (node) {\n      switch (node.nodeType) {\n        case 1: // ELEMENT_NODE\n          handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));\n          break;\n        case 3: // TEXT NODE\n          handler.chars(node.textContent);\n          break;\n      }\n\n      var nextNode;\n      if (!(nextNode = node.firstChild)) {\n        if (node.nodeType === 1) {\n          handler.end(node.nodeName.toLowerCase());\n        }\n        nextNode = node.nextSibling;\n        if (!nextNode) {\n          while (nextNode == null) {\n            node = node.parentNode;\n            if (node === inertBodyElement) break;\n            nextNode = node.nextSibling;\n            if (node.nodeType === 1) {\n              handler.end(node.nodeName.toLowerCase());\n            }\n          }\n        }\n      }\n      node = nextNode;\n    }\n\n    while ((node = inertBodyElement.firstChild)) {\n      inertBodyElement.removeChild(node);\n    }\n  }\n\n  function attrToMap(attrs) {\n    var map = {};\n    for (var i = 0, ii = attrs.length; i < ii; i++) {\n      var attr = attrs[i];\n      map[attr.name] = attr.value;\n    }\n    return map;\n  }\n\n\n  /**\n   * Escapes all potentially dangerous characters, so that the\n   * resulting string can be safely inserted into attribute or\n   * element text.\n   * @param value\n   * @returns {string} escaped text\n   */\n  function encodeEntities(value) {\n    return value.\n      replace(/&/g, '&amp;').\n      replace(SURROGATE_PAIR_REGEXP, function(value) {\n        var hi = value.charCodeAt(0);\n        var low = value.charCodeAt(1);\n        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n      }).\n      replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n        return '&#' + value.charCodeAt(0) + ';';\n      }).\n      replace(/</g, '&lt;').\n      replace(/>/g, '&gt;');\n  }\n\n  /**\n   * create an HTML/XML writer which writes to buffer\n   * @param {Array} buf use buf.join('') to get out sanitized html string\n   * @returns {object} in the form of {\n   *     start: function(tag, attrs) {},\n   *     end: function(tag) {},\n   *     chars: function(text) {},\n   *     comment: function(text) {}\n   * }\n   */\n  function htmlSanitizeWriterImpl(buf, uriValidator) {\n    var ignoreCurrentElement = false;\n    var out = bind(buf, buf.push);\n    return {\n      start: function(tag, attrs) {\n        tag = lowercase(tag);\n        if (!ignoreCurrentElement && blockedElements[tag]) {\n          ignoreCurrentElement = tag;\n        }\n        if (!ignoreCurrentElement && validElements[tag] === true) {\n          out('<');\n          out(tag);\n          forEach(attrs, function(value, key) {\n            var lkey = lowercase(key);\n            var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');\n            if (validAttrs[lkey] === true &&\n              (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {\n              out(' ');\n              out(key);\n              out('=\"');\n              out(encodeEntities(value));\n              out('\"');\n            }\n          });\n          out('>');\n        }\n      },\n      end: function(tag) {\n        tag = lowercase(tag);\n        if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {\n          out('</');\n          out(tag);\n          out('>');\n        }\n        // eslint-disable-next-line eqeqeq\n        if (tag == ignoreCurrentElement) {\n          ignoreCurrentElement = false;\n        }\n      },\n      chars: function(chars) {\n        if (!ignoreCurrentElement) {\n          out(encodeEntities(chars));\n        }\n      }\n    };\n  }\n\n\n  /**\n   * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1' attribute to declare\n   * ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo'). This is undesirable since we don't want\n   * to allow any of these custom attributes. This method strips them all.\n   *\n   * @param node Root element to process\n   */\n  function stripCustomNsAttrs(node) {\n    while (node) {\n      if (node.nodeType === window.Node.ELEMENT_NODE) {\n        var attrs = node.attributes;\n        for (var i = 0, l = attrs.length; i < l; i++) {\n          var attrNode = attrs[i];\n          var attrName = attrNode.name.toLowerCase();\n          if (attrName === 'xmlns:ns1' || attrName.lastIndexOf('ns1:', 0) === 0) {\n            node.removeAttributeNode(attrNode);\n            i--;\n            l--;\n          }\n        }\n      }\n\n      var nextNode = node.firstChild;\n      if (nextNode) {\n        stripCustomNsAttrs(nextNode);\n      }\n\n      node = node.nextSibling;\n    }\n  }\n}\n\nfunction sanitizeText(chars) {\n  var buf = [];\n  var writer = htmlSanitizeWriter(buf, noop);\n  writer.chars(chars);\n  return buf.join('');\n}\n\n\n// define ngSanitize module and register $sanitize service\nangular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);\n\n/**\n * @ngdoc filter\n * @name linky\n * @kind function\n *\n * @description\n * Finds links in text input and turns them into html links. Supports `http/https/ftp/mailto` and\n * plain email address links.\n *\n * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n *\n * @param {string} text Input text.\n * @param {string} target Window (`_blank|_self|_parent|_top`) or named frame to open links in.\n * @param {object|function(url)} [attributes] Add custom attributes to the link element.\n *\n *    Can be one of:\n *\n *    - `object`: A map of attributes\n *    - `function`: Takes the url as a parameter and returns a map of attributes\n *\n *    If the map of attributes contains a value for `target`, it overrides the value of\n *    the target parameter.\n *\n *\n * @returns {string} Html-linkified and {@link $sanitize sanitized} text.\n *\n * @usage\n   <span ng-bind-html=\"linky_expression | linky\"></span>\n *\n * @example\n   <example module=\"linkyExample\" deps=\"angular-sanitize.js\" name=\"linky-filter\">\n     <file name=\"index.html\">\n       <div ng-controller=\"ExampleController\">\n       Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <th>Filter</th>\n           <th>Source</th>\n           <th>Rendered</th>\n         </tr>\n         <tr id=\"linky-filter\">\n           <td>linky filter</td>\n           <td>\n             <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n           </td>\n           <td>\n             <div ng-bind-html=\"snippet | linky\"></div>\n           </td>\n         </tr>\n         <tr id=\"linky-target\">\n          <td>linky target</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithSingleURL | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithSingleURL | linky:'_blank'\"></div>\n          </td>\n         </tr>\n         <tr id=\"linky-custom-attributes\">\n          <td>linky custom attributes</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}\"></div>\n          </td>\n         </tr>\n         <tr id=\"escaped-html\">\n           <td>no filter</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n     </file>\n     <file name=\"script.js\">\n       angular.module('linkyExample', ['ngSanitize'])\n         .controller('ExampleController', ['$scope', function($scope) {\n           $scope.snippet =\n             'Pretty text with some links:\\n' +\n             'http://angularjs.org/,\\n' +\n             'mailto:us@somewhere.org,\\n' +\n             'another@somewhere.org,\\n' +\n             'and one more: ftp://127.0.0.1/.';\n           $scope.snippetWithSingleURL = 'http://angularjs.org/';\n         }]);\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n       it('should linkify the snippet with urls', function() {\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n       });\n\n       it('should not linkify snippet without the linky filter', function() {\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n       });\n\n       it('should update', function() {\n         element(by.model('snippet')).clear();\n         element(by.model('snippet')).sendKeys('new http://link.');\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('new http://link.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n             .toBe('new http://link.');\n       });\n\n       it('should work with the target property', function() {\n        expect(element(by.id('linky-target')).\n            element(by.binding(\"snippetWithSingleURL | linky:'_blank'\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n       });\n\n       it('should optionally add custom attributes', function() {\n        expect(element(by.id('linky-custom-attributes')).\n            element(by.binding(\"snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-custom-attributes a')).getAttribute('rel')).toEqual('nofollow');\n       });\n     </file>\n   </example>\n */\nangular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {\n  var LINKY_URL_REGEXP =\n        /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"\\u201d\\u2019]/i,\n      MAILTO_REGEXP = /^mailto:/i;\n\n  var linkyMinErr = angular.$$minErr('linky');\n  var isDefined = angular.isDefined;\n  var isFunction = angular.isFunction;\n  var isObject = angular.isObject;\n  var isString = angular.isString;\n\n  return function(text, target, attributes) {\n    if (text == null || text === '') return text;\n    if (!isString(text)) throw linkyMinErr('notstring', 'Expected string but received: {0}', text);\n\n    var attributesFn =\n      isFunction(attributes) ? attributes :\n      isObject(attributes) ? function getAttributesObject() {return attributes;} :\n      function getEmptyAttributesObject() {return {};};\n\n    var match;\n    var raw = text;\n    var html = [];\n    var url;\n    var i;\n    while ((match = raw.match(LINKY_URL_REGEXP))) {\n      // We can not end in these as they are sometimes found at the end of the sentence\n      url = match[0];\n      // if we did not match ftp/http/www/mailto then assume mailto\n      if (!match[2] && !match[4]) {\n        url = (match[3] ? 'http://' : 'mailto:') + url;\n      }\n      i = match.index;\n      addText(raw.substr(0, i));\n      addLink(url, match[0].replace(MAILTO_REGEXP, ''));\n      raw = raw.substring(i + match[0].length);\n    }\n    addText(raw);\n    return $sanitize(html.join(''));\n\n    function addText(text) {\n      if (!text) {\n        return;\n      }\n      html.push(sanitizeText(text));\n    }\n\n    function addLink(url, text) {\n      var key, linkAttributes = attributesFn(url);\n      html.push('<a ');\n\n      for (key in linkAttributes) {\n        html.push(key + '=\"' + linkAttributes[key] + '\" ');\n      }\n\n      if (isDefined(target) && !('target' in linkAttributes)) {\n        html.push('target=\"',\n                  target,\n                  '\" ');\n      }\n      html.push('href=\"',\n                url.replace(/\"/g, '&quot;'),\n                '\">');\n      addText(text);\n      html.push('</a>');\n    }\n  };\n}]);\n\n\n})(window, window.angular);\n","/*! angularjs-slider - v6.2.2 -\n (c) Rafal Zajac <rzajac@gmail.com>, Valentin Hervieu <valentin@hervieu.me>, Jussi Saarivirta <jusasi@gmail.com>, Angelin Sirbu <angelin.sirbu@gmail.com> -\n https://github.com/angular-slider/angularjs-slider -\n 2017-05-26 */\n/*jslint unparam: true */\n/*global angular: false, console: false, define, module */\n(function(root, factory) {\n    'use strict';\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['angular'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        // to support bundler like browserify\n        var angularObj = angular || require('angular');\n        if ((!angularObj || !angularObj.module) && typeof angular != 'undefined') {\n            angularObj = angular;\n        }\n        module.exports = factory(angularObj);\n    } else {\n        // Browser globals (root is window)\n        factory(root.angular);\n    }\n\n}(this, function(angular) {\n    'use strict';\n    var module = angular.module('rzModule', [])\n\n        .factory('RzSliderOptions', function() {\n            var defaultOptions = {\n                floor: 0,\n                ceil: null, //defaults to rz-slider-model\n                step: 1,\n                precision: 0,\n                minRange: null,\n                maxRange: null,\n                pushRange: false,\n                minLimit: null,\n                maxLimit: null,\n                id: null,\n                translate: null,\n                getLegend: null,\n                stepsArray: null,\n                bindIndexForStepsArray: false,\n                draggableRange: false,\n                draggableRangeOnly: false,\n                showSelectionBar: false,\n                showSelectionBarEnd: false,\n                showSelectionBarFromValue: null,\n                hidePointerLabels: false,\n                hideLimitLabels: false,\n                autoHideLimitLabels: true,\n                readOnly: false,\n                disabled: false,\n                interval: 350,\n                showTicks: false,\n                showTicksValues: false,\n                ticksArray: null,\n                ticksTooltip: null,\n                ticksValuesTooltip: null,\n                vertical: false,\n                getSelectionBarColor: null,\n                getTickColor: null,\n                getPointerColor: null,\n                keyboardSupport: true,\n                scale: 1,\n                enforceStep: true,\n                enforceRange: false,\n                noSwitching: false,\n                onlyBindHandles: false,\n                onStart: null,\n                onChange: null,\n                onEnd: null,\n                rightToLeft: false,\n                boundPointerLabels: true,\n                mergeRangeLabelsIfSame: false,\n                customTemplateScope: null,\n                logScale: false,\n                customValueToPosition: null,\n                customPositionToValue: null,\n                selectionBarGradient: null,\n                ariaLabel: null,\n                ariaLabelledBy: null,\n                ariaLabelHigh: null,\n                ariaLabelledByHigh: null\n            };\n            var globalOptions = {};\n\n            var factory = {};\n            /**\n             * `options({})` allows global configuration of all sliders in the\n             * application.\n             *\n             *   var app = angular.module( 'App', ['rzModule'], function( RzSliderOptions ) {\n     *     // display ticks for all sliders\n     *     RzSliderOptions.options( { showTicks: true } );\n     *   });\n             */\n            factory.options = function(value) {\n                angular.extend(globalOptions, value);\n            };\n\n            factory.getOptions = function(options) {\n                return angular.extend({}, defaultOptions, globalOptions, options);\n            };\n\n            return factory;\n        })\n\n        .factory('rzThrottle', ['$timeout', function($timeout) {\n            /**\n             * rzThrottle\n             *\n             * Taken from underscore project\n             *\n             * @param {Function} func\n             * @param {number} wait\n             * @param {ThrottleOptions} options\n             * @returns {Function}\n             */\n            return function(func, wait, options) {\n                'use strict';\n                /* istanbul ignore next */\n                var getTime = (Date.now || function() {\n                    return new Date().getTime();\n                });\n                var context, args, result;\n                var timeout = null;\n                var previous = 0;\n                options = options || {};\n                var later = function() {\n                    previous = getTime();\n                    timeout = null;\n                    result = func.apply(context, args);\n                    context = args = null;\n                };\n                return function() {\n                    var now = getTime();\n                    var remaining = wait - (now - previous);\n                    context = this;\n                    args = arguments;\n                    if (remaining <= 0) {\n                        $timeout.cancel(timeout);\n                        timeout = null;\n                        previous = now;\n                        result = func.apply(context, args);\n                        context = args = null;\n                    } else if (!timeout && options.trailing !== false) {\n                        timeout = $timeout(later, remaining);\n                    }\n                    return result;\n                };\n            }\n        }])\n\n        .factory('RzSlider', ['$timeout', '$document', '$window', '$compile', 'RzSliderOptions', 'rzThrottle', function($timeout, $document, $window, $compile, RzSliderOptions, rzThrottle) {\n            'use strict';\n\n            /**\n             * Slider\n             *\n             * @param {ngScope} scope            The AngularJS scope\n             * @param {Element} sliderElem The slider directive element wrapped in jqLite\n             * @constructor\n             */\n            var Slider = function(scope, sliderElem) {\n                /**\n                 * The slider's scope\n                 *\n                 * @type {ngScope}\n                 */\n                this.scope = scope;\n\n                /**\n                 * The slider inner low value (linked to rzSliderModel)\n                 * @type {number}\n                 */\n                this.lowValue = 0;\n\n                /**\n                 * The slider inner high value (linked to rzSliderHigh)\n                 * @type {number}\n                 */\n                this.highValue = 0;\n\n                /**\n                 * Slider element wrapped in jqLite\n                 *\n                 * @type {jqLite}\n                 */\n                this.sliderElem = sliderElem;\n\n                /**\n                 * Slider type\n                 *\n                 * @type {boolean} Set to true for range slider\n                 */\n                this.range = this.scope.rzSliderModel !== undefined && this.scope.rzSliderHigh !== undefined;\n\n                /**\n                 * Values recorded when first dragging the bar\n                 *\n                 * @type {Object}\n                 */\n                this.dragging = {\n                    active: false,\n                    value: 0,\n                    difference: 0,\n                    position: 0,\n                    lowLimit: 0,\n                    highLimit: 0\n                };\n\n                /**\n                 * property that handle position (defaults to left for horizontal)\n                 * @type {string}\n                 */\n                this.positionProperty = 'left';\n\n                /**\n                 * property that handle dimension (defaults to width for horizontal)\n                 * @type {string}\n                 */\n                this.dimensionProperty = 'width';\n\n                /**\n                 * Half of the width or height of the slider handles\n                 *\n                 * @type {number}\n                 */\n                this.handleHalfDim = 0;\n\n                /**\n                 * Maximum position the slider handle can have\n                 *\n                 * @type {number}\n                 */\n                this.maxPos = 0;\n\n                /**\n                 * Precision\n                 *\n                 * @type {number}\n                 */\n                this.precision = 0;\n\n                /**\n                 * Step\n                 *\n                 * @type {number}\n                 */\n                this.step = 1;\n\n                /**\n                 * The name of the handle we are currently tracking\n                 *\n                 * @type {string}\n                 */\n                this.tracking = '';\n\n                /**\n                 * Minimum value (floor) of the model\n                 *\n                 * @type {number}\n                 */\n                this.minValue = 0;\n\n                /**\n                 * Maximum value (ceiling) of the model\n                 *\n                 * @type {number}\n                 */\n                this.maxValue = 0;\n\n\n                /**\n                 * The delta between min and max value\n                 *\n                 * @type {number}\n                 */\n                this.valueRange = 0;\n\n\n                /**\n                 * If showTicks/showTicksValues options are number.\n                 * In this case, ticks values should be displayed below the slider.\n                 * @type {boolean}\n                 */\n                this.intermediateTicks = false;\n\n                /**\n                 * Set to true if init method already executed\n                 *\n                 * @type {boolean}\n                 */\n                this.initHasRun = false;\n\n                /**\n                 * Used to call onStart on the first keydown event\n                 *\n                 * @type {boolean}\n                 */\n                this.firstKeyDown = false;\n\n                /**\n                 * Internal flag to prevent watchers to be called when the sliders value are modified internally.\n                 * @type {boolean}\n                 */\n                this.internalChange = false;\n\n                /**\n                 * Internal flag to keep track of the visibility of combo label\n                 * @type {boolean}\n                 */\n                this.cmbLabelShown = false;\n\n                /**\n                 * Internal variable to keep track of the focus element\n                 */\n                this.currentFocusElement = null;\n\n                // Slider DOM elements wrapped in jqLite\n                this.fullBar = null; // The whole slider bar\n                this.selBar = null; // Highlight between two handles\n                this.minH = null; // Left slider handle\n                this.maxH = null; // Right slider handle\n                this.flrLab = null; // Floor label\n                this.ceilLab = null; // Ceiling label\n                this.minLab = null; // Label above the low value\n                this.maxLab = null; // Label above the high value\n                this.cmbLab = null; // Combined label\n                this.ticks = null; // The ticks\n\n                // Initialize slider\n                this.init();\n            };\n\n            // Add instance methods\n            Slider.prototype = {\n\n                /**\n                 * Initialize slider\n                 *\n                 * @returns {undefined}\n                 */\n                init: function() {\n                    var thrLow, thrHigh,\n                        self = this;\n\n                    var calcDimFn = function() {\n                        self.calcViewDimensions();\n                    };\n\n                    this.applyOptions();\n                    this.syncLowValue();\n                    if (this.range)\n                        this.syncHighValue();\n                    this.initElemHandles();\n                    this.manageElementsStyle();\n                    this.setDisabledState();\n                    this.calcViewDimensions();\n                    this.setMinAndMax();\n                    this.addAccessibility();\n                    this.updateCeilLab();\n                    this.updateFloorLab();\n                    this.initHandles();\n                    this.manageEventsBindings();\n\n                    // Recalculate slider view dimensions\n                    this.scope.$on('reCalcViewDimensions', calcDimFn);\n\n                    // Recalculate stuff if view port dimensions have changed\n                    angular.element($window).on('resize', calcDimFn);\n\n                    this.initHasRun = true;\n\n                    // Watch for changes to the model\n                    thrLow = rzThrottle(function() {\n                        self.onLowHandleChange();\n                    }, self.options.interval);\n\n                    thrHigh = rzThrottle(function() {\n                        self.onHighHandleChange();\n                    }, self.options.interval);\n\n                    this.scope.$on('rzSliderForceRender', function() {\n                        self.resetLabelsValue();\n                        thrLow();\n                        if (self.range) {\n                            thrHigh();\n                        }\n                        self.resetSlider();\n                    });\n\n                    // Watchers (order is important because in case of simultaneous change,\n                    // watchers will be called in the same order)\n                    this.scope.$watch('rzSliderOptions()', function(newValue, oldValue) {\n                        if (newValue === oldValue)\n                            return;\n                        self.applyOptions(); // need to be called before synchronizing the values\n                        self.syncLowValue();\n                        if (self.range)\n                            self.syncHighValue();\n                        self.resetSlider();\n                    }, true);\n\n                    this.scope.$watch('rzSliderModel', function(newValue, oldValue) {\n                        if (self.internalChange)\n                            return;\n                        if (newValue === oldValue)\n                            return;\n                        thrLow();\n                    });\n\n                    this.scope.$watch('rzSliderHigh', function(newValue, oldValue) {\n                        if (self.internalChange)\n                            return;\n                        if (newValue === oldValue)\n                            return;\n                        if (newValue != null)\n                            thrHigh();\n                        if (self.range && newValue == null || !self.range && newValue != null) {\n                            self.applyOptions();\n                            self.resetSlider();\n                        }\n                    });\n\n                    this.scope.$on('$destroy', function() {\n                        self.unbindEvents();\n                        angular.element($window).off('resize', calcDimFn);\n                        self.currentFocusElement = null;\n                    });\n                },\n\n                findStepIndex: function(modelValue) {\n                    var index = 0;\n                    for (var i = 0; i < this.options.stepsArray.length; i++) {\n                        var step = this.options.stepsArray[i];\n                        if (step === modelValue) {\n                            index = i;\n                            break;\n                        }\n                        else if (angular.isDate(step)) {\n                            if (step.getTime() === modelValue.getTime()) {\n                                index = i;\n                                break;\n                            }\n                        }\n                        else if (angular.isObject(step)) {\n                            if (angular.isDate(step.value) && step.value.getTime() === modelValue.getTime() || step.value === modelValue) {\n                                index = i;\n                                break;\n                            }\n                        }\n                    }\n                    return index;\n                },\n\n                syncLowValue: function() {\n                    if (this.options.stepsArray) {\n                        if (!this.options.bindIndexForStepsArray)\n                            this.lowValue = this.findStepIndex(this.scope.rzSliderModel);\n                        else\n                            this.lowValue = this.scope.rzSliderModel\n                    }\n                    else\n                        this.lowValue = this.scope.rzSliderModel;\n                },\n\n                syncHighValue: function() {\n                    if (this.options.stepsArray) {\n                        if (!this.options.bindIndexForStepsArray)\n                            this.highValue = this.findStepIndex(this.scope.rzSliderHigh);\n                        else\n                            this.highValue = this.scope.rzSliderHigh\n                    }\n                    else\n                        this.highValue = this.scope.rzSliderHigh;\n                },\n\n                getStepValue: function(sliderValue) {\n                    var step = this.options.stepsArray[sliderValue];\n                    if (angular.isDate(step))\n                        return step;\n                    if (angular.isObject(step))\n                        return step.value;\n                    return step;\n                },\n\n                applyLowValue: function() {\n                    if (this.options.stepsArray) {\n                        if (!this.options.bindIndexForStepsArray)\n                            this.scope.rzSliderModel = this.getStepValue(this.lowValue);\n                        else\n                            this.scope.rzSliderModel = this.lowValue\n                    }\n                    else\n                        this.scope.rzSliderModel = this.lowValue;\n                },\n\n                applyHighValue: function() {\n                    if (this.options.stepsArray) {\n                        if (!this.options.bindIndexForStepsArray)\n                            this.scope.rzSliderHigh = this.getStepValue(this.highValue);\n                        else\n                            this.scope.rzSliderHigh = this.highValue\n                    }\n                    else\n                        this.scope.rzSliderHigh = this.highValue;\n                },\n\n                /*\n                 * Reflow the slider when the low handle changes (called with throttle)\n                 */\n                onLowHandleChange: function() {\n                    this.syncLowValue();\n                    if (this.range)\n                        this.syncHighValue();\n                    this.setMinAndMax();\n                    this.updateLowHandle(this.valueToPosition(this.lowValue));\n                    this.updateSelectionBar();\n                    this.updateTicksScale();\n                    this.updateAriaAttributes();\n                    if (this.range) {\n                        this.updateCmbLabel();\n                    }\n                },\n\n                /*\n                 * Reflow the slider when the high handle changes (called with throttle)\n                 */\n                onHighHandleChange: function() {\n                    this.syncLowValue();\n                    this.syncHighValue();\n                    this.setMinAndMax();\n                    this.updateHighHandle(this.valueToPosition(this.highValue));\n                    this.updateSelectionBar();\n                    this.updateTicksScale();\n                    this.updateCmbLabel();\n                    this.updateAriaAttributes();\n                },\n\n                /**\n                 * Read the user options and apply them to the slider model\n                 */\n                applyOptions: function() {\n                    var sliderOptions;\n                    if (this.scope.rzSliderOptions)\n                        sliderOptions = this.scope.rzSliderOptions();\n                    else\n                        sliderOptions = {};\n\n                    this.options = RzSliderOptions.getOptions(sliderOptions);\n\n                    if (this.options.step <= 0)\n                        this.options.step = 1;\n\n                    this.range = this.scope.rzSliderModel !== undefined && this.scope.rzSliderHigh !== undefined;\n                    this.options.draggableRange = this.range && this.options.draggableRange;\n                    this.options.draggableRangeOnly = this.range && this.options.draggableRangeOnly;\n                    if (this.options.draggableRangeOnly) {\n                        this.options.draggableRange = true;\n                    }\n\n                    this.options.showTicks = this.options.showTicks || this.options.showTicksValues || !!this.options.ticksArray;\n                    this.scope.showTicks = this.options.showTicks; //scope is used in the template\n                    if (angular.isNumber(this.options.showTicks) || this.options.ticksArray)\n                        this.intermediateTicks = true;\n\n                    this.options.showSelectionBar = this.options.showSelectionBar || this.options.showSelectionBarEnd\n                        || this.options.showSelectionBarFromValue !== null;\n\n                    if (this.options.stepsArray) {\n                        this.parseStepsArray();\n                    } else {\n                        if (this.options.translate)\n                            this.customTrFn = this.options.translate;\n                        else\n                            this.customTrFn = function(value) {\n                                return String(value);\n                            };\n\n                        this.getLegend = this.options.getLegend;\n                    }\n\n                    if (this.options.vertical) {\n                        this.positionProperty = 'bottom';\n                        this.dimensionProperty = 'height';\n                    }\n\n                    if (this.options.customTemplateScope)\n                        this.scope.custom = this.options.customTemplateScope;\n                },\n\n                parseStepsArray: function() {\n                    this.options.floor = 0;\n                    this.options.ceil = this.options.stepsArray.length - 1;\n                    this.options.step = 1;\n\n                    if (this.options.translate) {\n                        this.customTrFn = this.options.translate;\n                    }\n                    else {\n                        this.customTrFn = function(modelValue) {\n                            if (this.options.bindIndexForStepsArray)\n                                return this.getStepValue(modelValue);\n                            return modelValue;\n                        };\n                    }\n\n                    this.getLegend = function(index) {\n                        var step = this.options.stepsArray[index];\n                        if (angular.isObject(step))\n                            return step.legend;\n                        return null;\n                    };\n                },\n\n                /**\n                 * Resets slider\n                 *\n                 * @returns {undefined}\n                 */\n                resetSlider: function() {\n                    this.manageElementsStyle();\n                    this.addAccessibility();\n                    this.setMinAndMax();\n                    this.updateCeilLab();\n                    this.updateFloorLab();\n                    this.unbindEvents();\n                    this.manageEventsBindings();\n                    this.setDisabledState();\n                    this.calcViewDimensions();\n                    this.refocusPointerIfNeeded();\n                },\n\n                refocusPointerIfNeeded: function() {\n                    if (this.currentFocusElement) {\n                        this.onPointerFocus(this.currentFocusElement.pointer, this.currentFocusElement.ref);\n                        this.focusElement(this.currentFocusElement.pointer)\n                    }\n                },\n\n                /**\n                 * Set the slider children to variables for easy access\n                 *\n                 * Run only once during initialization\n                 *\n                 * @returns {undefined}\n                 */\n                initElemHandles: function() {\n                    // Assign all slider elements to object properties for easy access\n                    angular.forEach(this.sliderElem.children(), function(elem, index) {\n                        var jElem = angular.element(elem);\n\n                        switch (index) {\n                            case 0:\n                                this.fullBar = jElem;\n                                break;\n                            case 1:\n                                this.selBar = jElem;\n                                break;\n                            case 2:\n                                this.minH = jElem;\n                                break;\n                            case 3:\n                                this.maxH = jElem;\n                                break;\n                            case 4:\n                                this.flrLab = jElem;\n                                break;\n                            case 5:\n                                this.ceilLab = jElem;\n                                break;\n                            case 6:\n                                this.minLab = jElem;\n                                break;\n                            case 7:\n                                this.maxLab = jElem;\n                                break;\n                            case 8:\n                                this.cmbLab = jElem;\n                                break;\n                            case 9:\n                                this.ticks = jElem;\n                                break;\n                        }\n\n                    }, this);\n\n                    // Initialize position cache properties\n                    this.selBar.rzsp = 0;\n                    this.minH.rzsp = 0;\n                    this.maxH.rzsp = 0;\n                    this.flrLab.rzsp = 0;\n                    this.ceilLab.rzsp = 0;\n                    this.minLab.rzsp = 0;\n                    this.maxLab.rzsp = 0;\n                    this.cmbLab.rzsp = 0;\n                },\n\n                /**\n                 * Update each elements style based on options\n                 */\n                manageElementsStyle: function() {\n\n                    if (!this.range)\n                        this.maxH.css('display', 'none');\n                    else\n                        this.maxH.css('display', '');\n\n\n                    this.alwaysHide(this.flrLab, this.options.showTicksValues || this.options.hideLimitLabels);\n                    this.alwaysHide(this.ceilLab, this.options.showTicksValues || this.options.hideLimitLabels);\n\n                    var hideLabelsForTicks = this.options.showTicksValues && !this.intermediateTicks;\n                    this.alwaysHide(this.minLab, hideLabelsForTicks || this.options.hidePointerLabels);\n                    this.alwaysHide(this.maxLab, hideLabelsForTicks || !this.range || this.options.hidePointerLabels);\n                    this.alwaysHide(this.cmbLab, hideLabelsForTicks || !this.range || this.options.hidePointerLabels);\n                    this.alwaysHide(this.selBar, !this.range && !this.options.showSelectionBar);\n\n                    if (this.options.vertical)\n                        this.sliderElem.addClass('rz-vertical');\n\n                    if (this.options.draggableRange)\n                        this.selBar.addClass('rz-draggable');\n                    else\n                        this.selBar.removeClass('rz-draggable');\n\n                    if (this.intermediateTicks && this.options.showTicksValues)\n                        this.ticks.addClass('rz-ticks-values-under');\n                },\n\n                alwaysHide: function(el, hide) {\n                    el.rzAlwaysHide = hide;\n                    if (hide)\n                        this.hideEl(el);\n                    else\n                        this.showEl(el)\n                },\n\n                /**\n                 * Manage the events bindings based on readOnly and disabled options\n                 *\n                 * @returns {undefined}\n                 */\n                manageEventsBindings: function() {\n                    if (this.options.disabled || this.options.readOnly)\n                        this.unbindEvents();\n                    else\n                        this.bindEvents();\n                },\n\n                /**\n                 * Set the disabled state based on rzSliderDisabled\n                 *\n                 * @returns {undefined}\n                 */\n                setDisabledState: function() {\n                    if (this.options.disabled) {\n                        this.sliderElem.attr('disabled', 'disabled');\n                    } else {\n                        this.sliderElem.attr('disabled', null);\n                    }\n                },\n\n                /**\n                 * Reset label values\n                 *\n                 * @return {undefined}\n                 */\n                resetLabelsValue: function() {\n                    this.minLab.rzsv = undefined;\n                    this.maxLab.rzsv = undefined;\n                },\n\n                /**\n                 * Initialize slider handles positions and labels\n                 *\n                 * Run only once during initialization and every time view port changes size\n                 *\n                 * @returns {undefined}\n                 */\n                initHandles: function() {\n                    this.updateLowHandle(this.valueToPosition(this.lowValue));\n\n                    /*\n                     the order here is important since the selection bar should be\n                     updated after the high handle but before the combined label\n                     */\n                    if (this.range)\n                        this.updateHighHandle(this.valueToPosition(this.highValue));\n                    this.updateSelectionBar();\n                    if (this.range)\n                        this.updateCmbLabel();\n\n                    this.updateTicksScale();\n                },\n\n                /**\n                 * Translate value to human readable format\n                 *\n                 * @param {number|string} value\n                 * @param {jqLite} label\n                 * @param {String} which\n                 * @param {boolean} [useCustomTr]\n                 * @returns {undefined}\n                 */\n                translateFn: function(value, label, which, useCustomTr) {\n                    useCustomTr = useCustomTr === undefined ? true : useCustomTr;\n\n                    var valStr = '',\n                        getDimension = false,\n                        noLabelInjection = label.hasClass('no-label-injection');\n\n                    if (useCustomTr) {\n                        if (this.options.stepsArray && !this.options.bindIndexForStepsArray)\n                            value = this.getStepValue(value);\n                        valStr = String(this.customTrFn(value, this.options.id, which));\n                    }\n                    else {\n                        valStr = String(value)\n                    }\n\n                    if (label.rzsv === undefined || label.rzsv.length !== valStr.length || (label.rzsv.length > 0 && label.rzsd === 0)) {\n                        getDimension = true;\n                        label.rzsv = valStr;\n                    }\n\n                    if (!noLabelInjection) {\n                        label.html(valStr);\n                    }\n                    ;\n\n                    this.scope[which + 'Label'] = valStr;\n\n                    // Update width only when length of the label have changed\n                    if (getDimension) {\n                        this.getDimension(label);\n                    }\n                },\n\n                /**\n                 * Set maximum and minimum values for the slider and ensure the model and high\n                 * value match these limits\n                 * @returns {undefined}\n                 */\n                setMinAndMax: function() {\n\n                    this.step = +this.options.step;\n                    this.precision = +this.options.precision;\n\n                    this.minValue = this.options.floor;\n                    if (this.options.logScale && this.minValue === 0)\n                        throw Error(\"Can't use floor=0 with logarithmic scale\");\n\n                    if (this.options.enforceStep) {\n                        this.lowValue = this.roundStep(this.lowValue);\n                        if (this.range)\n                            this.highValue = this.roundStep(this.highValue);\n                    }\n\n                    if (this.options.ceil != null)\n                        this.maxValue = this.options.ceil;\n                    else\n                        this.maxValue = this.options.ceil = this.range ? this.highValue : this.lowValue;\n\n                    if (this.options.enforceRange) {\n                        this.lowValue = this.sanitizeValue(this.lowValue);\n                        if (this.range)\n                            this.highValue = this.sanitizeValue(this.highValue);\n                    }\n\n                    this.applyLowValue();\n                    if (this.range)\n                        this.applyHighValue();\n\n                    this.valueRange = this.maxValue - this.minValue;\n                },\n\n                /**\n                 * Adds accessibility attributes\n                 *\n                 * Run only once during initialization\n                 *\n                 * @returns {undefined}\n                 */\n                addAccessibility: function() {\n                    this.minH.attr('role', 'slider');\n                    this.updateAriaAttributes();\n                    if (this.options.keyboardSupport && !(this.options.readOnly || this.options.disabled))\n                        this.minH.attr('tabindex', '0');\n                    else\n                        this.minH.attr('tabindex', '');\n                    if (this.options.vertical)\n                        this.minH.attr('aria-orientation', 'vertical');\n                    if (this.options.ariaLabel)\n                        this.minH.attr('aria-label', this.options.ariaLabel);\n                    else if (this.options.ariaLabelledBy)\n                        this.minH.attr('aria-labelledby', this.options.ariaLabelledBy);\n\n                    if (this.range) {\n                        this.maxH.attr('role', 'slider');\n                        if (this.options.keyboardSupport && !(this.options.readOnly || this.options.disabled))\n                            this.maxH.attr('tabindex', '0');\n                        else\n                            this.maxH.attr('tabindex', '');\n                        if (this.options.vertical)\n                            this.maxH.attr('aria-orientation', 'vertical');\n                        if (this.options.ariaLabelHigh)\n                            this.maxH.attr('aria-label', this.options.ariaLabelHigh);\n                        else if (this.options.ariaLabelledByHigh)\n                            this.maxH.attr('aria-labelledby', this.options.ariaLabelledByHigh);\n                    }\n                },\n\n                /**\n                 * Updates aria attributes according to current values\n                 */\n                updateAriaAttributes: function() {\n                    this.minH.attr({\n                        'aria-valuenow': this.scope.rzSliderModel,\n                        'aria-valuetext': this.customTrFn(this.scope.rzSliderModel, this.options.id, 'model'),\n                        'aria-valuemin': this.minValue,\n                        'aria-valuemax': this.maxValue\n                    });\n                    if (this.range) {\n                        this.maxH.attr({\n                            'aria-valuenow': this.scope.rzSliderHigh,\n                            'aria-valuetext': this.customTrFn(this.scope.rzSliderHigh, this.options.id, 'high'),\n                            'aria-valuemin': this.minValue,\n                            'aria-valuemax': this.maxValue\n                        });\n                    }\n                },\n\n                /**\n                 * Calculate dimensions that are dependent on view port size\n                 *\n                 * Run once during initialization and every time view port changes size.\n                 *\n                 * @returns {undefined}\n                 */\n                calcViewDimensions: function() {\n                    var handleWidth = this.getDimension(this.minH);\n\n                    this.handleHalfDim = handleWidth / 2;\n                    this.barDimension = this.getDimension(this.fullBar);\n\n                    this.maxPos = this.barDimension - handleWidth;\n\n                    this.getDimension(this.sliderElem);\n                    this.sliderElem.rzsp = this.sliderElem[0].getBoundingClientRect()[this.positionProperty];\n\n                    if (this.initHasRun) {\n                        this.updateFloorLab();\n                        this.updateCeilLab();\n                        this.initHandles();\n                        var self = this;\n                        $timeout(function() {\n                            self.updateTicksScale();\n                        });\n                    }\n                },\n\n                /**\n                 * Update the ticks position\n                 *\n                 * @returns {undefined}\n                 */\n                updateTicksScale: function() {\n                    if (!this.options.showTicks) return;\n\n                    var ticksArray = this.options.ticksArray || this.getTicksArray(),\n                        translate = this.options.vertical ? 'translateY' : 'translateX',\n                        self = this;\n\n                    if (this.options.rightToLeft)\n                        ticksArray.reverse();\n\n                    this.scope.ticks = ticksArray.map(function(value) {\n                        var position = self.valueToPosition(value);\n\n                        if (self.options.vertical)\n                            position = self.maxPos - position;\n\n                        var translation = translate + '(' + Math.round(position) + 'px)';\n                        var tick = {\n                            selected: self.isTickSelected(value),\n                            style: {\n                                '-webkit-transform': translation,\n                                '-moz-transform': translation,\n                                '-o-transform': translation,\n                                '-ms-transform': translation,\n                                'transform': translation\n                            }\n                        };\n                        if (tick.selected && self.options.getSelectionBarColor) {\n                            tick.style['background-color'] = self.getSelectionBarColor();\n                        }\n                        if (!tick.selected && self.options.getTickColor) {\n                            tick.style['background-color'] = self.getTickColor(value);\n                        }\n                        if (self.options.ticksTooltip) {\n                            tick.tooltip = self.options.ticksTooltip(value);\n                            tick.tooltipPlacement = self.options.vertical ? 'right' : 'top';\n                        }\n                        if (self.options.showTicksValues) {\n                            tick.value = self.getDisplayValue(value, 'tick-value');\n                            if (self.options.ticksValuesTooltip) {\n                                tick.valueTooltip = self.options.ticksValuesTooltip(value);\n                                tick.valueTooltipPlacement = self.options.vertical ? 'right' : 'top';\n                            }\n                        }\n                        if (self.getLegend) {\n                            var legend = self.getLegend(value, self.options.id);\n                            if (legend)\n                                tick.legend = legend;\n                        }\n                        return tick;\n                    });\n                },\n\n                getTicksArray: function() {\n                    var step = this.step,\n                        ticksArray = [];\n                    if (this.intermediateTicks)\n                        step = this.options.showTicks;\n                    for (var value = this.minValue; value <= this.maxValue; value += step) {\n                        ticksArray.push(value);\n                    }\n                    return ticksArray;\n                },\n\n                isTickSelected: function(value) {\n                    if (!this.range) {\n                        if (this.options.showSelectionBarFromValue !== null) {\n                            var center = this.options.showSelectionBarFromValue;\n                            if (this.lowValue > center && value >= center && value <= this.lowValue)\n                                return true;\n                            else if (this.lowValue < center && value <= center && value >= this.lowValue)\n                                return true;\n                        }\n                        else if (this.options.showSelectionBarEnd) {\n                            if (value >= this.lowValue)\n                                return true;\n                        }\n                        else if (this.options.showSelectionBar && value <= this.lowValue)\n                            return true;\n                    }\n                    if (this.range && value >= this.lowValue && value <= this.highValue)\n                        return true;\n                    return false;\n                },\n\n                /**\n                 * Update position of the floor label\n                 *\n                 * @returns {undefined}\n                 */\n                updateFloorLab: function() {\n                    this.translateFn(this.minValue, this.flrLab, 'floor');\n                    this.getDimension(this.flrLab);\n                    var position = this.options.rightToLeft ? this.barDimension - this.flrLab.rzsd : 0;\n                    this.setPosition(this.flrLab, position);\n                },\n\n                /**\n                 * Update position of the ceiling label\n                 *\n                 * @returns {undefined}\n                 */\n                updateCeilLab: function() {\n                    this.translateFn(this.maxValue, this.ceilLab, 'ceil');\n                    this.getDimension(this.ceilLab);\n                    var position = this.options.rightToLeft ? 0 : this.barDimension - this.ceilLab.rzsd;\n                    this.setPosition(this.ceilLab, position);\n                },\n\n                /**\n                 * Update slider handles and label positions\n                 *\n                 * @param {string} which\n                 * @param {number} newPos\n                 */\n                updateHandles: function(which, newPos) {\n                    if (which === 'lowValue')\n                        this.updateLowHandle(newPos);\n                    else\n                        this.updateHighHandle(newPos);\n\n                    this.updateSelectionBar();\n                    this.updateTicksScale();\n                    if (this.range)\n                        this.updateCmbLabel();\n                },\n\n                /**\n                 * Helper function to work out the position for handle labels depending on RTL or not\n                 *\n                 * @param {string} labelName maxLab or minLab\n                 * @param newPos\n                 *\n                 * @returns {number}\n                 */\n                getHandleLabelPos: function(labelName, newPos) {\n                    var labelRzsd = this[labelName].rzsd,\n                        nearHandlePos = newPos - labelRzsd / 2 + this.handleHalfDim,\n                        endOfBarPos = this.barDimension - labelRzsd;\n\n                    if (!this.options.boundPointerLabels)\n                        return nearHandlePos;\n\n                    if (this.options.rightToLeft && labelName === 'minLab' || !this.options.rightToLeft && labelName === 'maxLab') {\n                        return Math.min(nearHandlePos, endOfBarPos);\n                    } else {\n                        return Math.min(Math.max(nearHandlePos, 0), endOfBarPos);\n                    }\n                },\n\n                /**\n                 * Update low slider handle position and label\n                 *\n                 * @param {number} newPos\n                 * @returns {undefined}\n                 */\n                updateLowHandle: function(newPos) {\n                    this.setPosition(this.minH, newPos);\n                    this.translateFn(this.lowValue, this.minLab, 'model');\n                    this.setPosition(this.minLab, this.getHandleLabelPos('minLab', newPos));\n\n                    if (this.options.getPointerColor) {\n                        var pointercolor = this.getPointerColor('min');\n                        this.scope.minPointerStyle = {\n                            backgroundColor: pointercolor\n                        };\n                    }\n\n                    if (this.options.autoHideLimitLabels) {\n                        this.shFloorCeil();\n                    }\n                },\n\n                /**\n                 * Update high slider handle position and label\n                 *\n                 * @param {number} newPos\n                 * @returns {undefined}\n                 */\n                updateHighHandle: function(newPos) {\n                    this.setPosition(this.maxH, newPos);\n                    this.translateFn(this.highValue, this.maxLab, 'high');\n                    this.setPosition(this.maxLab, this.getHandleLabelPos('maxLab', newPos));\n\n                    if (this.options.getPointerColor) {\n                        var pointercolor = this.getPointerColor('max');\n                        this.scope.maxPointerStyle = {\n                            backgroundColor: pointercolor\n                        };\n                    }\n                    if (this.options.autoHideLimitLabels) {\n                        this.shFloorCeil();\n                    }\n\n                },\n\n                /**\n                 * Show/hide floor/ceiling label\n                 *\n                 * @returns {undefined}\n                 */\n                shFloorCeil: function() {\n                    // Show based only on hideLimitLabels if pointer labels are hidden\n                    if (this.options.hidePointerLabels) {\n                        return;\n                    }\n                    var flHidden = false,\n                        clHidden = false,\n                        isMinLabAtFloor = this.isLabelBelowFloorLab(this.minLab),\n                        isMinLabAtCeil = this.isLabelAboveCeilLab(this.minLab),\n                        isMaxLabAtCeil = this.isLabelAboveCeilLab(this.maxLab),\n                        isCmbLabAtFloor = this.isLabelBelowFloorLab(this.cmbLab),\n                        isCmbLabAtCeil = this.isLabelAboveCeilLab(this.cmbLab);\n\n                    if (isMinLabAtFloor) {\n                        flHidden = true;\n                        this.hideEl(this.flrLab);\n                    } else {\n                        flHidden = false;\n                        this.showEl(this.flrLab);\n                    }\n\n                    if (isMinLabAtCeil) {\n                        clHidden = true;\n                        this.hideEl(this.ceilLab);\n                    } else {\n                        clHidden = false;\n                        this.showEl(this.ceilLab);\n                    }\n\n                    if (this.range) {\n                        var hideCeil = this.cmbLabelShown ? isCmbLabAtCeil : isMaxLabAtCeil;\n                        var hideFloor = this.cmbLabelShown ? isCmbLabAtFloor : isMinLabAtFloor;\n\n                        if (hideCeil) {\n                            this.hideEl(this.ceilLab);\n                        } else if (!clHidden) {\n                            this.showEl(this.ceilLab);\n                        }\n\n                        // Hide or display floor label\n                        if (hideFloor) {\n                            this.hideEl(this.flrLab);\n                        } else if (!flHidden) {\n                            this.showEl(this.flrLab);\n                        }\n                    }\n                },\n\n                isLabelBelowFloorLab: function(label) {\n                    var isRTL = this.options.rightToLeft,\n                        pos = label.rzsp,\n                        dim = label.rzsd,\n                        floorPos = this.flrLab.rzsp,\n                        floorDim = this.flrLab.rzsd;\n                    return isRTL ?\n                        pos + dim >= floorPos - 2 :\n                        pos <= floorPos + floorDim + 2;\n                },\n\n                isLabelAboveCeilLab: function(label) {\n                    var isRTL = this.options.rightToLeft,\n                        pos = label.rzsp,\n                        dim = label.rzsd,\n                        ceilPos = this.ceilLab.rzsp,\n                        ceilDim = this.ceilLab.rzsd;\n                    return isRTL ?\n                        pos <= ceilPos + ceilDim + 2 :\n                        pos + dim >= ceilPos - 2;\n                },\n\n                /**\n                 * Update slider selection bar, combined label and range label\n                 *\n                 * @returns {undefined}\n                 */\n                updateSelectionBar: function() {\n                    var position = 0,\n                        dimension = 0,\n                        isSelectionBarFromRight = this.options.rightToLeft ? !this.options.showSelectionBarEnd : this.options.showSelectionBarEnd,\n                        positionForRange = this.options.rightToLeft ? this.maxH.rzsp + this.handleHalfDim : this.minH.rzsp + this.handleHalfDim;\n\n                    if (this.range) {\n                        dimension = Math.abs(this.maxH.rzsp - this.minH.rzsp);\n                        position = positionForRange;\n                    }\n                    else {\n                        if (this.options.showSelectionBarFromValue !== null) {\n                            var center = this.options.showSelectionBarFromValue,\n                                centerPosition = this.valueToPosition(center),\n                                isModelGreaterThanCenter = this.options.rightToLeft ? this.lowValue <= center : this.lowValue > center;\n                            if (isModelGreaterThanCenter) {\n                                dimension = this.minH.rzsp - centerPosition;\n                                position = centerPosition + this.handleHalfDim;\n                            }\n                            else {\n                                dimension = centerPosition - this.minH.rzsp;\n                                position = this.minH.rzsp + this.handleHalfDim;\n                            }\n                        }\n                        else if (isSelectionBarFromRight) {\n                            dimension = Math.abs(this.maxPos - this.minH.rzsp) + this.handleHalfDim;\n                            position = this.minH.rzsp + this.handleHalfDim;\n                        } else {\n                            dimension = this.minH.rzsp + this.handleHalfDim;\n                            position = 0;\n                        }\n                    }\n                    this.setDimension(this.selBar, dimension);\n                    this.setPosition(this.selBar, position);\n                    if (this.options.getSelectionBarColor) {\n                        var color = this.getSelectionBarColor();\n                        this.scope.barStyle = {\n                            backgroundColor: color\n                        };\n                    } else if (this.options.selectionBarGradient) {\n                        var offset = this.options.showSelectionBarFromValue !== null ? this.valueToPosition(this.options.showSelectionBarFromValue) : 0,\n                            reversed = offset - position > 0 ^ isSelectionBarFromRight,\n                            direction = this.options.vertical ? (reversed ? 'bottom' : 'top') : (reversed ? 'left' : 'right');\n                        this.scope.barStyle = {\n                            backgroundImage: 'linear-gradient(to ' + direction + ', ' + this.options.selectionBarGradient.from + ' 0%,' + this.options.selectionBarGradient.to + ' 100%)'\n                        };\n                        if (this.options.vertical) {\n                            this.scope.barStyle.backgroundPosition = 'center ' + (offset + dimension + position + (reversed ? -this.handleHalfDim : 0)) + 'px';\n                            this.scope.barStyle.backgroundSize = '100% ' + (this.barDimension - this.handleHalfDim) + 'px';\n                        } else {\n                            this.scope.barStyle.backgroundPosition = (offset - position + (reversed ? this.handleHalfDim : 0)) + 'px center';\n                            this.scope.barStyle.backgroundSize = (this.barDimension - this.handleHalfDim) + 'px 100%';\n                        }\n                    }\n                },\n\n                /**\n                 * Wrapper around the getSelectionBarColor of the user to pass to\n                 * correct parameters\n                 */\n                getSelectionBarColor: function() {\n                    if (this.range)\n                        return this.options.getSelectionBarColor(this.scope.rzSliderModel, this.scope.rzSliderHigh);\n                    return this.options.getSelectionBarColor(this.scope.rzSliderModel);\n                },\n\n                /**\n                 * Wrapper around the getPointerColor of the user to pass to\n                 * correct parameters\n                 */\n                getPointerColor: function(pointerType) {\n                    if (pointerType === 'max') {\n                        return this.options.getPointerColor(this.scope.rzSliderHigh, pointerType);\n                    }\n                    return this.options.getPointerColor(this.scope.rzSliderModel, pointerType);\n                },\n\n                /**\n                 * Wrapper around the getTickColor of the user to pass to\n                 * correct parameters\n                 */\n                getTickColor: function(value) {\n                    return this.options.getTickColor(value);\n                },\n\n                /**\n                 * Update combined label position and value\n                 *\n                 * @returns {undefined}\n                 */\n                updateCmbLabel: function() {\n                    var isLabelOverlap = null;\n                    if (this.options.rightToLeft) {\n                        isLabelOverlap = this.minLab.rzsp - this.minLab.rzsd - 10 <= this.maxLab.rzsp;\n                    } else {\n                        isLabelOverlap = this.minLab.rzsp + this.minLab.rzsd + 10 >= this.maxLab.rzsp;\n                    }\n\n                    if (isLabelOverlap) {\n                        var lowTr = this.getDisplayValue(this.lowValue, 'model'),\n                            highTr = this.getDisplayValue(this.highValue, 'high'),\n                            labelVal = '';\n                        if (this.options.mergeRangeLabelsIfSame && lowTr === highTr) {\n                            labelVal = lowTr;\n                        } else {\n                            labelVal = this.options.rightToLeft ? highTr + ' - ' + lowTr : lowTr + ' - ' + highTr;\n                        }\n\n                        this.translateFn(labelVal, this.cmbLab, 'cmb', false);\n                        var pos = this.options.boundPointerLabels ? Math.min(\n                            Math.max(\n                                this.selBar.rzsp + this.selBar.rzsd / 2 - this.cmbLab.rzsd / 2,\n                                0\n                            ),\n                            this.barDimension - this.cmbLab.rzsd\n                        ) : this.selBar.rzsp + this.selBar.rzsd / 2 - this.cmbLab.rzsd / 2;\n\n                        this.setPosition(this.cmbLab, pos);\n                        this.cmbLabelShown = true;\n                        this.hideEl(this.minLab);\n                        this.hideEl(this.maxLab);\n                        this.showEl(this.cmbLab);\n                    } else {\n                        this.cmbLabelShown = false;\n                        this.updateHighHandle(this.valueToPosition(this.highValue));\n                        this.updateLowHandle(this.valueToPosition(this.lowValue));\n                        this.showEl(this.maxLab);\n                        this.showEl(this.minLab);\n                        this.hideEl(this.cmbLab);\n                    }\n                    if (this.options.autoHideLimitLabels) {\n                        this.shFloorCeil();\n                    }\n                },\n\n                /**\n                 * Return the translated value if a translate function is provided else the original value\n                 * @param value\n                 * @param which if it's min or max handle\n                 * @returns {*}\n                 */\n                getDisplayValue: function(value, which) {\n                    if (this.options.stepsArray && !this.options.bindIndexForStepsArray) {\n                        value = this.getStepValue(value);\n                    }\n                    return this.customTrFn(value, this.options.id, which);\n                },\n\n                /**\n                 * Round value to step and precision based on minValue\n                 *\n                 * @param {number} value\n                 * @param {number} customStep a custom step to override the defined step\n                 * @returns {number}\n                 */\n                roundStep: function(value, customStep) {\n                    var step = customStep ? customStep : this.step,\n                        steppedDifference = parseFloat((value - this.minValue) / step).toPrecision(12);\n                    steppedDifference = Math.round(+steppedDifference) * step;\n                    var newValue = (this.minValue + steppedDifference).toFixed(this.precision);\n                    return +newValue;\n                },\n\n                /**\n                 * Hide element\n                 *\n                 * @param element\n                 * @returns {jqLite} The jqLite wrapped DOM element\n                 */\n                hideEl: function(element) {\n                    return element.css({\n                        visibility: 'hidden'\n                    });\n                },\n\n                /**\n                 * Show element\n                 *\n                 * @param element The jqLite wrapped DOM element\n                 * @returns {jqLite} The jqLite\n                 */\n                showEl: function(element) {\n                    if (!!element.rzAlwaysHide) {\n                        return element;\n                    }\n\n                    return element.css({\n                        visibility: 'visible'\n                    });\n                },\n\n                /**\n                 * Set element left/top position depending on whether slider is horizontal or vertical\n                 *\n                 * @param {jqLite} elem The jqLite wrapped DOM element\n                 * @param {number} pos\n                 * @returns {number}\n                 */\n                setPosition: function(elem, pos) {\n                    elem.rzsp = pos;\n                    var css = {};\n                    css[this.positionProperty] = Math.round(pos) + 'px';\n                    elem.css(css);\n                    return pos;\n                },\n\n                /**\n                 * Get element width/height depending on whether slider is horizontal or vertical\n                 *\n                 * @param {jqLite} elem The jqLite wrapped DOM element\n                 * @returns {number}\n                 */\n                getDimension: function(elem) {\n                    var val = elem[0].getBoundingClientRect();\n                    if (this.options.vertical)\n                        elem.rzsd = (val.bottom - val.top) * this.options.scale;\n                    else\n                        elem.rzsd = (val.right - val.left) * this.options.scale;\n                    return elem.rzsd;\n                },\n\n                /**\n                 * Set element width/height depending on whether slider is horizontal or vertical\n                 *\n                 * @param {jqLite} elem  The jqLite wrapped DOM element\n                 * @param {number} dim\n                 * @returns {number}\n                 */\n                setDimension: function(elem, dim) {\n                    elem.rzsd = dim;\n                    var css = {};\n                    css[this.dimensionProperty] = Math.round(dim) + 'px';\n                    elem.css(css);\n                    return dim;\n                },\n\n                /**\n                 * Returns a value that is within slider range\n                 *\n                 * @param {number} val\n                 * @returns {number}\n                 */\n                sanitizeValue: function(val) {\n                    return Math.min(Math.max(val, this.minValue), this.maxValue);\n                },\n\n                /**\n                 * Translate value to pixel position\n                 *\n                 * @param {number} val\n                 * @returns {number}\n                 */\n                valueToPosition: function(val) {\n                    var fn = this.linearValueToPosition;\n                    if (this.options.customValueToPosition)\n                        fn = this.options.customValueToPosition;\n                    else if (this.options.logScale)\n                        fn = this.logValueToPosition;\n\n                    val = this.sanitizeValue(val);\n                    var percent = fn(val, this.minValue, this.maxValue) || 0;\n                    if (this.options.rightToLeft)\n                        percent = 1 - percent;\n                    return percent * this.maxPos;\n                },\n\n                linearValueToPosition: function(val, minVal, maxVal) {\n                    var range = maxVal - minVal;\n                    return (val - minVal) / range;\n                },\n\n                logValueToPosition: function(val, minVal, maxVal) {\n                    val = Math.log(val);\n                    minVal = Math.log(minVal);\n                    maxVal = Math.log(maxVal);\n                    var range = maxVal - minVal;\n                    return (val - minVal) / range;\n                },\n\n                /**\n                 * Translate position to model value\n                 *\n                 * @param {number} position\n                 * @returns {number}\n                 */\n                positionToValue: function(position) {\n                    var percent = position / this.maxPos;\n                    if (this.options.rightToLeft)\n                        percent = 1 - percent;\n                    var fn = this.linearPositionToValue;\n                    if (this.options.customPositionToValue)\n                        fn = this.options.customPositionToValue;\n                    else if (this.options.logScale)\n                        fn = this.logPositionToValue;\n                    return fn(percent, this.minValue, this.maxValue) || 0;\n                },\n\n                linearPositionToValue: function(percent, minVal, maxVal) {\n                    return percent * (maxVal - minVal) + minVal;\n                },\n\n                logPositionToValue: function(percent, minVal, maxVal) {\n                    minVal = Math.log(minVal);\n                    maxVal = Math.log(maxVal);\n                    var value = percent * (maxVal - minVal) + minVal;\n                    return Math.exp(value);\n                },\n\n                getEventAttr: function(event, attr) {\n                    return event.originalEvent === undefined ? event[attr] : event.originalEvent[attr]\n                },\n\n                // Events\n                /**\n                 * Get the X-coordinate or Y-coordinate of an event\n                 *\n                 * @param {Object} event  The event\n                 * @param targetTouchId The identifier of the touch with the X/Y coordinates\n                 * @returns {number}\n                 */\n                getEventXY: function(event, targetTouchId) {\n                    /* http://stackoverflow.com/a/12336075/282882 */\n                    //noinspection JSLint\n                    var clientXY = this.options.vertical ? 'clientY' : 'clientX';\n                    if (event[clientXY] !== undefined) {\n                        return event[clientXY];\n                    }\n\n                    var touches = this.getEventAttr(event, 'touches');\n\n                    if (targetTouchId !== undefined) {\n                        for (var i = 0; i < touches.length; i++) {\n                            if (touches[i].identifier === targetTouchId) {\n                                return touches[i][clientXY];\n                            }\n                        }\n                    }\n\n                    // If no target touch or the target touch was not found in the event\n                    // returns the coordinates of the first touch\n                    return touches[0][clientXY];\n                },\n\n                /**\n                 * Compute the event position depending on whether the slider is horizontal or vertical\n                 * @param event\n                 * @param targetTouchId If targetTouchId is provided it will be considered the position of that\n                 * @returns {number}\n                 */\n                getEventPosition: function(event, targetTouchId) {\n                    var sliderPos = this.sliderElem.rzsp,\n                        eventPos = 0;\n                    if (this.options.vertical)\n                        eventPos = -this.getEventXY(event, targetTouchId) + sliderPos;\n                    else\n                        eventPos = this.getEventXY(event, targetTouchId) - sliderPos;\n                    return eventPos * this.options.scale - this.handleHalfDim; // #346 handleHalfDim is already scaled\n                },\n\n                /**\n                 * Get event names for move and event end\n                 *\n                 * @param {Event}    event    The event\n                 *\n                 * @return {{moveEvent: string, endEvent: string}}\n                 */\n                getEventNames: function(event) {\n                    var eventNames = {\n                        moveEvent: '',\n                        endEvent: ''\n                    };\n\n                    if (this.getEventAttr(event, 'touches')) {\n                        eventNames.moveEvent = 'touchmove';\n                        eventNames.endEvent = 'touchend';\n                    } else {\n                        eventNames.moveEvent = 'mousemove';\n                        eventNames.endEvent = 'mouseup';\n                    }\n\n                    return eventNames;\n                },\n\n                /**\n                 * Get the handle closest to an event.\n                 *\n                 * @param event {Event} The event\n                 * @returns {jqLite} The handle closest to the event.\n                 */\n                getNearestHandle: function(event) {\n                    if (!this.range) {\n                        return this.minH;\n                    }\n                    var position = this.getEventPosition(event),\n                        distanceMin = Math.abs(position - this.minH.rzsp),\n                        distanceMax = Math.abs(position - this.maxH.rzsp);\n                    if (distanceMin < distanceMax)\n                        return this.minH;\n                    else if (distanceMin > distanceMax)\n                        return this.maxH;\n                    else if (!this.options.rightToLeft)\n                    //if event is at the same distance from min/max then if it's at left of minH, we return minH else maxH\n                        return position < this.minH.rzsp ? this.minH : this.maxH;\n                    else\n                    //reverse in rtl\n                        return position > this.minH.rzsp ? this.minH : this.maxH;\n                },\n\n                /**\n                 * Wrapper function to focus an angular element\n                 *\n                 * @param el {AngularElement} the element to focus\n                 */\n                focusElement: function(el) {\n                    var DOM_ELEMENT = 0;\n                    el[DOM_ELEMENT].focus();\n                },\n\n                /**\n                 * Bind mouse and touch events to slider handles\n                 *\n                 * @returns {undefined}\n                 */\n                bindEvents: function() {\n                    var barTracking, barStart, barMove;\n\n                    if (this.options.draggableRange) {\n                        barTracking = 'rzSliderDrag';\n                        barStart = this.onDragStart;\n                        barMove = this.onDragMove;\n                    } else {\n                        barTracking = 'lowValue';\n                        barStart = this.onStart;\n                        barMove = this.onMove;\n                    }\n\n                    if (!this.options.onlyBindHandles) {\n                        this.selBar.on('mousedown', angular.bind(this, barStart, null, barTracking));\n                        this.selBar.on('mousedown', angular.bind(this, barMove, this.selBar));\n                    }\n\n                    if (this.options.draggableRangeOnly) {\n                        this.minH.on('mousedown', angular.bind(this, barStart, null, barTracking));\n                        this.maxH.on('mousedown', angular.bind(this, barStart, null, barTracking));\n                    } else {\n                        this.minH.on('mousedown', angular.bind(this, this.onStart, this.minH, 'lowValue'));\n                        if (this.range) {\n                            this.maxH.on('mousedown', angular.bind(this, this.onStart, this.maxH, 'highValue'));\n                        }\n                        if (!this.options.onlyBindHandles) {\n                            this.fullBar.on('mousedown', angular.bind(this, this.onStart, null, null));\n                            this.fullBar.on('mousedown', angular.bind(this, this.onMove, this.fullBar));\n                            this.ticks.on('mousedown', angular.bind(this, this.onStart, null, null));\n                            this.ticks.on('mousedown', angular.bind(this, this.onTickClick, this.ticks));\n                        }\n                    }\n\n                    if (!this.options.onlyBindHandles) {\n                        this.selBar.on('touchstart', angular.bind(this, barStart, null, barTracking));\n                        this.selBar.on('touchstart', angular.bind(this, barMove, this.selBar));\n                    }\n                    if (this.options.draggableRangeOnly) {\n                        this.minH.on('touchstart', angular.bind(this, barStart, null, barTracking));\n                        this.maxH.on('touchstart', angular.bind(this, barStart, null, barTracking));\n                    } else {\n                        this.minH.on('touchstart', angular.bind(this, this.onStart, this.minH, 'lowValue'));\n                        if (this.range) {\n                            this.maxH.on('touchstart', angular.bind(this, this.onStart, this.maxH, 'highValue'));\n                        }\n                        if (!this.options.onlyBindHandles) {\n                            this.fullBar.on('touchstart', angular.bind(this, this.onStart, null, null));\n                            this.fullBar.on('touchstart', angular.bind(this, this.onMove, this.fullBar));\n                            this.ticks.on('touchstart', angular.bind(this, this.onStart, null, null));\n                            this.ticks.on('touchstart', angular.bind(this, this.onTickClick, this.ticks));\n                        }\n                    }\n\n                    if (this.options.keyboardSupport) {\n                        this.minH.on('focus', angular.bind(this, this.onPointerFocus, this.minH, 'lowValue'));\n                        if (this.range) {\n                            this.maxH.on('focus', angular.bind(this, this.onPointerFocus, this.maxH, 'highValue'));\n                        }\n                    }\n                },\n\n                /**\n                 * Unbind mouse and touch events to slider handles\n                 *\n                 * @returns {undefined}\n                 */\n                unbindEvents: function() {\n                    this.minH.off();\n                    this.maxH.off();\n                    this.fullBar.off();\n                    this.selBar.off();\n                    this.ticks.off();\n                },\n\n                /**\n                 * onStart event handler\n                 *\n                 * @param {?Object} pointer The jqLite wrapped DOM element; if null, the closest handle is used\n                 * @param {?string} ref     The name of the handle being changed; if null, the closest handle's value is modified\n                 * @param {Event}   event   The event\n                 * @returns {undefined}\n                 */\n                onStart: function(pointer, ref, event) {\n                    var ehMove, ehEnd,\n                        eventNames = this.getEventNames(event);\n\n                    event.stopPropagation();\n                    event.preventDefault();\n\n                    // We have to do this in case the HTML where the sliders are on\n                    // have been animated into view.\n                    this.calcViewDimensions();\n\n                    if (pointer) {\n                        this.tracking = ref;\n                    } else {\n                        pointer = this.getNearestHandle(event);\n                        this.tracking = pointer === this.minH ? 'lowValue' : 'highValue';\n                    }\n\n                    pointer.addClass('rz-active');\n\n                    if (this.options.keyboardSupport)\n                        this.focusElement(pointer);\n\n                    ehMove = angular.bind(this, this.dragging.active ? this.onDragMove : this.onMove, pointer);\n                    ehEnd = angular.bind(this, this.onEnd, ehMove);\n\n                    $document.on(eventNames.moveEvent, ehMove)\n                    $document.on(eventNames.endEvent, ehEnd);\n                    this.endHandlerToBeRemovedOnEnd = ehEnd;\n\n                    this.callOnStart();\n\n                    var changedTouches = this.getEventAttr(event, 'changedTouches');\n                    if (changedTouches) {\n                        // Store the touch identifier\n                        if (!this.touchId) {\n                            this.isDragging = true;\n                            this.touchId = changedTouches[0].identifier;\n                        }\n                    }\n                },\n\n                /**\n                 * onMove event handler\n                 *\n                 * @param {jqLite} pointer\n                 * @param {Event}  event The event\n                 * @param {boolean}  fromTick if the event occured on a tick or not\n                 * @returns {undefined}\n                 */\n                onMove: function(pointer, event, fromTick) {\n                    var changedTouches = this.getEventAttr(event, 'changedTouches');\n                    var touchForThisSlider;\n                    if (changedTouches) {\n                        for (var i = 0; i < changedTouches.length; i++) {\n                            if (changedTouches[i].identifier === this.touchId) {\n                                touchForThisSlider = changedTouches[i];\n                                break;\n                            }\n                        }\n                    }\n\n                    if (changedTouches && !touchForThisSlider) {\n                        return;\n                    }\n\n                    var newPos = this.getEventPosition(event, touchForThisSlider ? touchForThisSlider.identifier : undefined),\n                        newValue,\n                        ceilValue = this.options.rightToLeft ? this.minValue : this.maxValue,\n                        flrValue = this.options.rightToLeft ? this.maxValue : this.minValue;\n\n                    if (newPos <= 0) {\n                        newValue = flrValue;\n                    } else if (newPos >= this.maxPos) {\n                        newValue = ceilValue;\n                    } else {\n                        newValue = this.positionToValue(newPos);\n                        if (fromTick && angular.isNumber(this.options.showTicks))\n                            newValue = this.roundStep(newValue, this.options.showTicks);\n                        else\n                            newValue = this.roundStep(newValue);\n                    }\n                    this.positionTrackingHandle(newValue);\n                },\n\n                /**\n                 * onEnd event handler\n                 *\n                 * @param {Event}    event    The event\n                 * @param {Function} ehMove   The bound move event handler\n                 * @returns {undefined}\n                 */\n                onEnd: function(ehMove, event) {\n                    var changedTouches = this.getEventAttr(event, 'changedTouches');\n                    if (changedTouches && changedTouches[0].identifier !== this.touchId) {\n                        return;\n                    }\n                    this.isDragging = false;\n                    this.touchId = null;\n\n                    if (!this.options.keyboardSupport) {\n                        this.minH.removeClass('rz-active');\n                        this.maxH.removeClass('rz-active');\n                        this.tracking = '';\n                    }\n                    this.dragging.active = false;\n\n                    var eventName = this.getEventNames(event);\n                    $document.off(eventName.moveEvent, ehMove);\n                    $document.off(eventName.endEvent, this.endHandlerToBeRemovedOnEnd);\n                    this.endHandlerToBeRemovedOnEnd = null;\n                    this.callOnEnd();\n                },\n\n                onTickClick: function(pointer, event) {\n                    this.onMove(pointer, event, true);\n                },\n\n                onPointerFocus: function(pointer, ref) {\n                    this.tracking = ref;\n                    pointer.one('blur', angular.bind(this, this.onPointerBlur, pointer));\n                    pointer.on('keydown', angular.bind(this, this.onKeyboardEvent));\n                    pointer.on('keyup', angular.bind(this, this.onKeyUp));\n                    this.firstKeyDown = true;\n                    pointer.addClass('rz-active');\n\n                    this.currentFocusElement = {\n                        pointer: pointer,\n                        ref: ref\n                    };\n                },\n\n                onKeyUp: function() {\n                    this.firstKeyDown = true;\n                    this.callOnEnd();\n                },\n\n                onPointerBlur: function(pointer) {\n                    pointer.off('keydown');\n                    pointer.off('keyup');\n                    pointer.removeClass('rz-active');\n                    if (!this.isDragging) {\n                        this.tracking = '';\n                        this.currentFocusElement = null\n                    }\n                },\n\n                /**\n                 * Key actions helper function\n                 *\n                 * @param {number} currentValue value of the slider\n                 *\n                 * @returns {?Object} action value mappings\n                 */\n                getKeyActions: function(currentValue) {\n                    var increaseStep = currentValue + this.step,\n                        decreaseStep = currentValue - this.step,\n                        increasePage = currentValue + this.valueRange / 10,\n                        decreasePage = currentValue - this.valueRange / 10;\n\n                    //Left to right default actions\n                    var actions = {\n                        'UP': increaseStep,\n                        'DOWN': decreaseStep,\n                        'LEFT': decreaseStep,\n                        'RIGHT': increaseStep,\n                        'PAGEUP': increasePage,\n                        'PAGEDOWN': decreasePage,\n                        'HOME': this.minValue,\n                        'END': this.maxValue\n                    };\n                    //right to left means swapping right and left arrows\n                    if (this.options.rightToLeft) {\n                        actions.LEFT = increaseStep;\n                        actions.RIGHT = decreaseStep;\n                        // right to left and vertical means we also swap up and down\n                        if (this.options.vertical) {\n                            actions.UP = decreaseStep;\n                            actions.DOWN = increaseStep;\n                        }\n                    }\n                    return actions;\n                },\n\n                onKeyboardEvent: function(event) {\n                    var currentValue = this[this.tracking],\n                        keyCode = event.keyCode || event.which,\n                        keys = {\n                            38: 'UP',\n                            40: 'DOWN',\n                            37: 'LEFT',\n                            39: 'RIGHT',\n                            33: 'PAGEUP',\n                            34: 'PAGEDOWN',\n                            36: 'HOME',\n                            35: 'END'\n                        },\n                        actions = this.getKeyActions(currentValue),\n                        key = keys[keyCode],\n                        action = actions[key];\n                    if (action == null || this.tracking === '') return;\n                    event.preventDefault();\n\n                    if (this.firstKeyDown) {\n                        this.firstKeyDown = false;\n                        this.callOnStart();\n                    }\n\n                    var self = this;\n                    $timeout(function() {\n                        var newValue = self.roundStep(self.sanitizeValue(action));\n                        if (!self.options.draggableRangeOnly) {\n                            self.positionTrackingHandle(newValue);\n                        }\n                        else {\n                            var difference = self.highValue - self.lowValue,\n                                newMinValue, newMaxValue;\n                            if (self.tracking === 'lowValue') {\n                                newMinValue = newValue;\n                                newMaxValue = newValue + difference;\n                                if (newMaxValue > self.maxValue) {\n                                    newMaxValue = self.maxValue;\n                                    newMinValue = newMaxValue - difference;\n                                }\n                            } else {\n                                newMaxValue = newValue;\n                                newMinValue = newValue - difference;\n                                if (newMinValue < self.minValue) {\n                                    newMinValue = self.minValue;\n                                    newMaxValue = newMinValue + difference;\n                                }\n                            }\n                            self.positionTrackingBar(newMinValue, newMaxValue);\n                        }\n                    });\n                },\n\n                /**\n                 * onDragStart event handler\n                 *\n                 * Handles dragging of the middle bar.\n                 *\n                 * @param {Object} pointer The jqLite wrapped DOM element\n                 * @param {string} ref     One of the refLow, refHigh values\n                 * @param {Event}  event   The event\n                 * @returns {undefined}\n                 */\n                onDragStart: function(pointer, ref, event) {\n                    var position = this.getEventPosition(event);\n                    this.dragging = {\n                        active: true,\n                        value: this.positionToValue(position),\n                        difference: this.highValue - this.lowValue,\n                        lowLimit: this.options.rightToLeft ? this.minH.rzsp - position : position - this.minH.rzsp,\n                        highLimit: this.options.rightToLeft ? position - this.maxH.rzsp : this.maxH.rzsp - position\n                    };\n\n                    this.onStart(pointer, ref, event);\n                },\n\n                /**\n                 * getValue helper function\n                 *\n                 * gets max or min value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft\n                 *\n                 * @param {string} type 'max' || 'min' The value we are calculating\n                 * @param {number} newPos  The new position\n                 * @param {boolean} outOfBounds Is the new position above or below the max/min?\n                 * @param {boolean} isAbove Is the new position above the bar if out of bounds?\n                 *\n                 * @returns {number}\n                 */\n                getValue: function(type, newPos, outOfBounds, isAbove) {\n                    var isRTL = this.options.rightToLeft,\n                        value = null;\n\n                    if (type === 'min') {\n                        if (outOfBounds) {\n                            if (isAbove) {\n                                value = isRTL ? this.minValue : this.maxValue - this.dragging.difference;\n                            } else {\n                                value = isRTL ? this.maxValue - this.dragging.difference : this.minValue;\n                            }\n                        } else {\n                            value = isRTL ? this.positionToValue(newPos + this.dragging.lowLimit) : this.positionToValue(newPos - this.dragging.lowLimit)\n                        }\n                    } else {\n                        if (outOfBounds) {\n                            if (isAbove) {\n                                value = isRTL ? this.minValue + this.dragging.difference : this.maxValue;\n                            } else {\n                                value = isRTL ? this.maxValue : this.minValue + this.dragging.difference;\n                            }\n                        } else {\n                            if (isRTL) {\n                                value = this.positionToValue(newPos + this.dragging.lowLimit) + this.dragging.difference\n                            } else {\n                                value = this.positionToValue(newPos - this.dragging.lowLimit) + this.dragging.difference;\n                            }\n                        }\n                    }\n                    return this.roundStep(value);\n                },\n\n                /**\n                 * onDragMove event handler\n                 *\n                 * Handles dragging of the middle bar.\n                 *\n                 * @param {jqLite} pointer\n                 * @param {Event}  event The event\n                 * @returns {undefined}\n                 */\n                onDragMove: function(pointer, event) {\n                    var newPos = this.getEventPosition(event),\n                        newMinValue, newMaxValue,\n                        ceilLimit, flrLimit,\n                        isUnderFlrLimit, isOverCeilLimit,\n                        flrH, ceilH;\n\n                    if (this.options.rightToLeft) {\n                        ceilLimit = this.dragging.lowLimit;\n                        flrLimit = this.dragging.highLimit;\n                        flrH = this.maxH;\n                        ceilH = this.minH;\n                    } else {\n                        ceilLimit = this.dragging.highLimit;\n                        flrLimit = this.dragging.lowLimit;\n                        flrH = this.minH;\n                        ceilH = this.maxH;\n                    }\n                    isUnderFlrLimit = newPos <= flrLimit;\n                    isOverCeilLimit = newPos >= this.maxPos - ceilLimit;\n\n                    if (isUnderFlrLimit) {\n                        if (flrH.rzsp === 0)\n                            return;\n                        newMinValue = this.getValue('min', newPos, true, false);\n                        newMaxValue = this.getValue('max', newPos, true, false);\n                    } else if (isOverCeilLimit) {\n                        if (ceilH.rzsp === this.maxPos)\n                            return;\n                        newMaxValue = this.getValue('max', newPos, true, true);\n                        newMinValue = this.getValue('min', newPos, true, true);\n                    } else {\n                        newMinValue = this.getValue('min', newPos, false);\n                        newMaxValue = this.getValue('max', newPos, false);\n                    }\n                    this.positionTrackingBar(newMinValue, newMaxValue);\n                },\n\n                /**\n                 * Set the new value and position for the entire bar\n                 *\n                 * @param {number} newMinValue   the new minimum value\n                 * @param {number} newMaxValue   the new maximum value\n                 */\n                positionTrackingBar: function(newMinValue, newMaxValue) {\n\n                    if (this.options.minLimit != null && newMinValue < this.options.minLimit) {\n                        newMinValue = this.options.minLimit;\n                        newMaxValue = newMinValue + this.dragging.difference;\n                    }\n                    if (this.options.maxLimit != null && newMaxValue > this.options.maxLimit) {\n                        newMaxValue = this.options.maxLimit;\n                        newMinValue = newMaxValue - this.dragging.difference;\n                    }\n\n                    this.lowValue = newMinValue;\n                    this.highValue = newMaxValue;\n                    this.applyLowValue();\n                    if (this.range)\n                        this.applyHighValue();\n                    this.applyModel(true);\n                    this.updateHandles('lowValue', this.valueToPosition(newMinValue));\n                    this.updateHandles('highValue', this.valueToPosition(newMaxValue));\n                },\n\n                /**\n                 * Set the new value and position to the current tracking handle\n                 *\n                 * @param {number} newValue new model value\n                 */\n                positionTrackingHandle: function(newValue) {\n                    var valueChanged = false;\n                    newValue = this.applyMinMaxLimit(newValue);\n                    if (this.range) {\n                        if (this.options.pushRange) {\n                            newValue = this.applyPushRange(newValue);\n                            valueChanged = true;\n                        }\n                        else {\n                            if (this.options.noSwitching) {\n                                if (this.tracking === 'lowValue' && newValue > this.highValue)\n                                    newValue = this.applyMinMaxRange(this.highValue);\n                                else if (this.tracking === 'highValue' && newValue < this.lowValue)\n                                    newValue = this.applyMinMaxRange(this.lowValue);\n                            }\n                            newValue = this.applyMinMaxRange(newValue);\n                            /* This is to check if we need to switch the min and max handles */\n                            if (this.tracking === 'lowValue' && newValue > this.highValue) {\n                                this.lowValue = this.highValue;\n                                this.applyLowValue();\n                                this.applyModel();\n                                this.updateHandles(this.tracking, this.maxH.rzsp);\n                                this.updateAriaAttributes();\n                                this.tracking = 'highValue';\n                                this.minH.removeClass('rz-active');\n                                this.maxH.addClass('rz-active');\n                                if (this.options.keyboardSupport)\n                                    this.focusElement(this.maxH);\n                                valueChanged = true;\n                            }\n                            else if (this.tracking === 'highValue' && newValue < this.lowValue) {\n                                this.highValue = this.lowValue;\n                                this.applyHighValue();\n                                this.applyModel();\n                                this.updateHandles(this.tracking, this.minH.rzsp);\n                                this.updateAriaAttributes();\n                                this.tracking = 'lowValue';\n                                this.maxH.removeClass('rz-active');\n                                this.minH.addClass('rz-active');\n                                if (this.options.keyboardSupport)\n                                    this.focusElement(this.minH);\n                                valueChanged = true;\n                            }\n                        }\n                    }\n\n                    if (this[this.tracking] !== newValue) {\n                        this[this.tracking] = newValue;\n                        if (this.tracking === 'lowValue')\n                            this.applyLowValue();\n                        else\n                            this.applyHighValue();\n                        this.applyModel();\n                        this.updateHandles(this.tracking, this.valueToPosition(newValue));\n                        this.updateAriaAttributes();\n                        valueChanged = true;\n                    }\n\n                    if (valueChanged)\n                        this.applyModel(true);\n                },\n\n                applyMinMaxLimit: function(newValue) {\n                    if (this.options.minLimit != null && newValue < this.options.minLimit)\n                        return this.options.minLimit;\n                    if (this.options.maxLimit != null && newValue > this.options.maxLimit)\n                        return this.options.maxLimit;\n                    return newValue;\n                },\n\n                applyMinMaxRange: function(newValue) {\n                    var oppositeValue = this.tracking === 'lowValue' ? this.highValue : this.lowValue,\n                        difference = Math.abs(newValue - oppositeValue);\n                    if (this.options.minRange != null) {\n                        if (difference < this.options.minRange) {\n                            if (this.tracking === 'lowValue')\n                                return this.highValue - this.options.minRange;\n                            else\n                                return this.lowValue + this.options.minRange;\n                        }\n                    }\n                    if (this.options.maxRange != null) {\n                        if (difference > this.options.maxRange) {\n                            if (this.tracking === 'lowValue')\n                                return this.highValue - this.options.maxRange;\n                            else\n                                return this.lowValue + this.options.maxRange;\n                        }\n                    }\n                    return newValue;\n                },\n\n                applyPushRange: function(newValue) {\n                    var difference = this.tracking === 'lowValue' ? this.highValue - newValue : newValue - this.lowValue,\n                        minRange = this.options.minRange !== null ? this.options.minRange : this.options.step,\n                        maxRange = this.options.maxRange;\n                    // if smaller than minRange\n                    if (difference < minRange) {\n                        if (this.tracking === 'lowValue') {\n                            this.highValue = Math.min(newValue + minRange, this.maxValue);\n                            newValue = this.highValue - minRange;\n                            this.applyHighValue();\n                            this.updateHandles('highValue', this.valueToPosition(this.highValue));\n                        }\n                        else {\n                            this.lowValue = Math.max(newValue - minRange, this.minValue);\n                            newValue = this.lowValue + minRange;\n                            this.applyLowValue();\n                            this.updateHandles('lowValue', this.valueToPosition(this.lowValue));\n                        }\n                        this.updateAriaAttributes();\n                    }\n                    // if greater than maxRange\n                    else if (maxRange !== null && difference > maxRange) {\n                        if (this.tracking === 'lowValue') {\n                            this.highValue = newValue + maxRange;\n                            this.applyHighValue();\n                            this.updateHandles('highValue', this.valueToPosition(this.highValue));\n                        }\n                        else {\n                            this.lowValue = newValue - maxRange;\n                            this.applyLowValue();\n                            this.updateHandles('lowValue', this.valueToPosition(this.lowValue));\n                        }\n                        this.updateAriaAttributes();\n                    }\n                    return newValue;\n                },\n\n                /**\n                 * Apply the model values using scope.$apply.\n                 * We wrap it with the internalChange flag to avoid the watchers to be called\n                 */\n                applyModel: function(callOnChange) {\n                    this.internalChange = true;\n                    this.scope.$apply();\n                    callOnChange && this.callOnChange();\n                    this.internalChange = false;\n                },\n\n                /**\n                 * Call the onStart callback if defined\n                 * The callback call is wrapped in a $evalAsync to ensure that its result will be applied to the scope.\n                 *\n                 * @returns {undefined}\n                 */\n                callOnStart: function() {\n                    if (this.options.onStart) {\n                        var self = this,\n                            pointerType = this.tracking === 'lowValue' ? 'min' : 'max';\n                        this.scope.$evalAsync(function() {\n                            self.options.onStart(self.options.id, self.scope.rzSliderModel, self.scope.rzSliderHigh, pointerType);\n                        });\n                    }\n                },\n\n                /**\n                 * Call the onChange callback if defined\n                 * The callback call is wrapped in a $evalAsync to ensure that its result will be applied to the scope.\n                 *\n                 * @returns {undefined}\n                 */\n                callOnChange: function() {\n                    if (this.options.onChange) {\n                        var self = this,\n                            pointerType = this.tracking === 'lowValue' ? 'min' : 'max';\n                        this.scope.$evalAsync(function() {\n                            self.options.onChange(self.options.id, self.scope.rzSliderModel, self.scope.rzSliderHigh, pointerType);\n                        });\n                    }\n                },\n\n                /**\n                 * Call the onEnd callback if defined\n                 * The callback call is wrapped in a $evalAsync to ensure that its result will be applied to the scope.\n                 *\n                 * @returns {undefined}\n                 */\n                callOnEnd: function() {\n                    if (this.options.onEnd) {\n                        var self = this,\n                            pointerType = this.tracking === 'lowValue' ? 'min' : 'max';\n                        this.scope.$evalAsync(function() {\n                            self.options.onEnd(self.options.id, self.scope.rzSliderModel, self.scope.rzSliderHigh, pointerType);\n                        });\n                    }\n                    this.scope.$emit('slideEnded');\n                }\n            };\n\n            return Slider;\n        }])\n\n        .directive('rzslider', ['RzSlider', function(RzSlider) {\n            'use strict';\n\n            return {\n                restrict: 'AE',\n                replace: true,\n                scope: {\n                    rzSliderModel: '=?',\n                    rzSliderHigh: '=?',\n                    rzSliderOptions: '&?',\n                    rzSliderTplUrl: '@'\n                },\n\n                /**\n                 * Return template URL\n                 *\n                 * @param {jqLite} elem\n                 * @param {Object} attrs\n                 * @return {string}\n                 */\n                templateUrl: function(elem, attrs) {\n                    //noinspection JSUnresolvedVariable\n                    return attrs.rzSliderTplUrl || 'rzSliderTpl.html';\n                },\n\n                link: function(scope, elem) {\n                    scope.slider = new RzSlider(scope, elem); //attach on scope so we can test it\n                }\n            };\n        }]);\n\n    // IDE assist\n\n    /**\n     * @name ngScope\n     *\n     * @property {number} rzSliderModel\n     * @property {number} rzSliderHigh\n     * @property {Object} rzSliderOptions\n     */\n\n    /**\n     * @name jqLite\n     *\n     * @property {number|undefined} rzsp rzslider label position position\n     * @property {number|undefined} rzsd rzslider element dimension\n     * @property {string|undefined} rzsv rzslider label value/text\n     * @property {Function} css\n     * @property {Function} text\n     */\n\n    /**\n     * @name Event\n     * @property {Array} touches\n     * @property {Event} originalEvent\n     */\n\n    /**\n     * @name ThrottleOptions\n     *\n     * @property {boolean} leading\n     * @property {boolean} trailing\n     */\n\n    module.run(['$templateCache', function($templateCache) {\n        'use strict';\n\n        $templateCache.put('rzSliderTpl.html',\n            \"<div class=rzslider><span class=rz-bar-wrapper><span class=rz-bar></span></span> <span class=rz-bar-wrapper><span class=\\\"rz-bar rz-selection\\\" ng-style=barStyle></span></span> <span class=\\\"rz-pointer rz-pointer-min\\\" ng-style=minPointerStyle></span> <span class=\\\"rz-pointer rz-pointer-max\\\" ng-style=maxPointerStyle></span> <span class=\\\"rz-bubble rz-limit rz-floor\\\"></span> <span class=\\\"rz-bubble rz-limit rz-ceil\\\"></span> <span class=rz-bubble></span> <span class=rz-bubble></span> <span class=rz-bubble></span><ul ng-display=showTicks class=rz-ticks><li ng-repeat=\\\"t in ticks track by $index\\\" class=rz-tick ng-class=\\\"{'rz-selected': t.selected}\\\" ng-style=t.style ng-attr-uib-tooltip=\\\"{{ t.tooltip }}\\\" ng-attr-tooltip-placement={{t.tooltipPlacement}} ng-attr-tooltip-append-to-body=\\\"{{ t.tooltip ? true : undefined}}\\\"><span ng-if=\\\"t.value != null\\\" class=rz-tick-value ng-attr-uib-tooltip=\\\"{{ t.valueTooltip }}\\\" ng-attr-tooltip-placement={{t.valueTooltipPlacement}}>{{ t.value }}</span> <span ng-if=\\\"t.legend != null\\\" class=rz-tick-legend>{{ t.legend }}</span></li></ul></div>\"\n        );\n\n    }]);\n\n    return module.name\n}));","/**\n * @license AngularJS v1.3.10\n * (c) 2010-2014 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n    var $sanitizeMinErr = angular.$$minErr('$sanitize');\n\n    /**\n     * @ngdoc module\n     * @name ngSanitize\n     * @description\n     *\n     * # ngSanitize\n     *\n     * The `ngSanitize` module provides functionality to sanitize HTML.\n     *\n     *\n     * <div doc-module-components=\"ngSanitize\"></div>\n     *\n     * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n     */\n\n    /*\n     * HTML Parser By Misko Hevery (misko@hevery.com)\n     * based on:  HTML Parser By John Resig (ejohn.org)\n     * Original code by Erik Arvidsson, Mozilla Public License\n     * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n     *\n     * // Use like so:\n     * htmlParser(htmlString, {\n     *     start: function(tag, attrs, unary) {},\n     *     end: function(tag) {},\n     *     chars: function(text) {},\n     *     comment: function(text) {}\n     * });\n     *\n     */\n\n\n    /**\n     * @ngdoc service\n     * @name $sanitize\n     * @kind function\n     *\n     * @description\n     *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n     *   then serialized back to properly escaped html string. This means that no unsafe input can make\n     *   it into the returned string, however, since our parser is more strict than a typical browser\n     *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a\n     *   browser, won't make it through the sanitizer. The input may also contain SVG markup.\n     *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and\n     *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.\n     *\n     * @param {string} html HTML input.\n     * @returns {string} Sanitized HTML.\n     *\n     * @example\n     <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\">\n     <file name=\"index.html\">\n     <script>\n     angular.module('sanitizeExample', ['ngSanitize'])\n     .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n             $scope.snippet =\n               '<p style=\"color:blue\">an html\\n' +\n               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n               'snippet</p>';\n             $scope.deliberatelyTrustDangerousSnippet = function() {\n               return $sce.trustAsHtml($scope.snippet);\n             };\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n     Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n     <table>\n     <tr>\n     <td>Directive</td>\n     <td>How</td>\n     <td>Source</td>\n     <td>Rendered</td>\n     </tr>\n     <tr id=\"bind-html-with-sanitize\">\n     <td>ng-bind-html</td>\n     <td>Automatically uses $sanitize</td>\n     <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n     <td><div ng-bind-html=\"snippet\"></div></td>\n     </tr>\n     <tr id=\"bind-html-with-trust\">\n     <td>ng-bind-html</td>\n     <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n     <td>\n     <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n     &lt;/div&gt;</pre>\n     </td>\n     <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n     </tr>\n     <tr id=\"bind-default\">\n     <td>ng-bind</td>\n     <td>Automatically escapes</td>\n     <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n     <td><div ng-bind=\"snippet\"></div></td>\n     </tr>\n     </table>\n     </div>\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n     it('should sanitize the html snippet by default', function() {\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n     });\n\n     it('should inline raw snippet if bound to a trusted value', function() {\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).\n         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n              \"snippet</p>\");\n     });\n\n     it('should escape snippet without any filter', function() {\n       expect(element(by.css('#bind-default div')).getInnerHtml()).\n         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n              \"snippet&lt;/p&gt;\");\n     });\n\n     it('should update', function() {\n       element(by.model('snippet')).clear();\n       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('new <b>text</b>');\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(\n         'new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(\n         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n     });\n     </file>\n     </example>\n     */\n    function $SanitizeProvider() {\n        this.$get = ['$$sanitizeUri', function($$sanitizeUri) {\n            return function(html) {\n                if (typeof arguments[1] != 'undefined') {\n                    arguments[1].version = 'taSanitize';\n                }\n                var buf = [];\n                htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {\n                    return !/^unsafe/.test($$sanitizeUri(uri, isImage));\n                }));\n                return buf.join('');\n            };\n        }];\n    }\n\n    function sanitizeText(chars) {\n        var buf = [];\n        var writer = htmlSanitizeWriter(buf, angular.noop);\n        writer.chars(chars);\n        return buf.join('');\n    }\n\n\n// Regular Expressions for parsing tags and attributes\n    var START_TAG_REGEXP =\n            /^<((?:[a-zA-Z])[\\w:-]*)((?:\\s+[\\w:-]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)\\s*(>?)/,\n        END_TAG_REGEXP = /^<\\/\\s*([\\w:-]+)[^>]*>/,\n        ATTR_REGEXP = /([\\w:-]+)(?:\\s*=\\s*(?:(?:\"((?:[^\"])*)\")|(?:'((?:[^'])*)')|([^>\\s]+)))?/g,\n        BEGIN_TAG_REGEXP = /^</,\n        BEGING_END_TAGE_REGEXP = /^<\\//,\n        COMMENT_REGEXP = /<!--(.*?)-->/g,\n        SINGLE_COMMENT_REGEXP = /(^<!--.*?-->)/,\n        DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,\n        CDATA_REGEXP = /<!\\[CDATA\\[(.*?)]]>/g,\n        SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n        // Match everything outside of normal chars and \" (quote character)\n        NON_ALPHANUMERIC_REGEXP = /([^\\#-~| |!])/g,\n        WHITE_SPACE_REGEXP = /^(\\s+)/;\n\n\n// Good source of info about elements and attributes\n// http://dev.w3.org/html5/spec/Overview.html#semantics\n// http://simon.html5.org/html-elements\n\n// Safe Void Elements - HTML5\n// http://dev.w3.org/html5/spec/Overview.html#void-elements\n    var voidElements = makeMap(\"area,br,col,hr,img,wbr,input\");\n\n// Elements that you can, intentionally, leave open (and which close themselves)\n// http://dev.w3.org/html5/spec/Overview.html#optional-tags\n    var optionalEndTagBlockElements = makeMap(\"colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr\"),\n        optionalEndTagInlineElements = makeMap(\"rp,rt\"),\n        optionalEndTagElements = angular.extend({},\n            optionalEndTagInlineElements,\n            optionalEndTagBlockElements);\n\n// Safe Block Elements - HTML5\n    var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap(\"address,article,\" +\n        \"aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,\" +\n        \"h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul\"));\n\n// Inline Elements - HTML5\n    var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap(\"a,abbr,acronym,b,\" +\n        \"bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,\" +\n        \"samp,small,span,strike,strong,sub,sup,time,tt,u,var\"));\n\n// SVG Elements\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements\n    var svgElements = makeMap(\"animate,animateColor,animateMotion,animateTransform,circle,defs,\" +\n        \"desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,\" +\n        \"line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set,\" +\n        \"stop,svg,switch,text,title,tspan,use\");\n\n// Special Elements (can contain anything)\n    var specialElements = makeMap(\"script,style\");\n\n    var validElements = angular.extend({},\n        voidElements,\n        blockElements,\n        inlineElements,\n        optionalEndTagElements,\n        svgElements);\n\n//Attributes that have href and hence need to be sanitized\n    var uriAttrs = makeMap(\"background,cite,href,longdesc,src,usemap,xlink:href\");\n\n    var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,'+\n        'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,'+\n        'id,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,'+\n        'scope,scrolling,shape,size,span,start,summary,target,title,type,'+\n        'valign,value,vspace,width');\n\n// SVG attributes (without \"id\" and \"name\" attributes)\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes\n    var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +\n        'attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,' +\n        'color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,' +\n        'font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,' +\n        'gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,' +\n        'keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,' +\n        'markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,' +\n        'overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,' +\n        'repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,' +\n        'stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,' +\n        'stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,' +\n        'stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,' +\n        'underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,' +\n        'viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,' +\n        'xlink:display,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,' +\n        'zoomAndPan');\n\n    var validAttrs = angular.extend({},\n        uriAttrs,\n        svgAttrs,\n        htmlAttrs);\n\n    function makeMap(str) {\n        var obj = {}, items = str.split(','), i;\n        for (i = 0; i < items.length; i++) obj[items[i]] = true;\n        return obj;\n    }\n\n\n    /**\n     * @example\n     * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n     *\n     * @param {string} html string\n     * @param {object} handler\n     */\n    function htmlParser(html, handler) {\n        if (typeof html !== 'string') {\n            if (html === null || typeof html === 'undefined') {\n                html = '';\n            } else {\n                html = '' + html;\n            }\n        }\n        var index, chars, match, stack = [], last = html, text;\n        stack.last = function() { return stack[ stack.length - 1 ]; };\n\n        while (html) {\n            text = '';\n            chars = true;\n\n            // Make sure we're not in a script or style element\n            if (!stack.last() || !specialElements[ stack.last() ]) {\n\n                // White space\n                if (WHITE_SPACE_REGEXP.test(html)) {\n                    match = html.match(WHITE_SPACE_REGEXP);\n\n                    if (match) {\n                        var mat = match[0];\n                        if (handler.whitespace) handler.whitespace(match[0]);\n                        html = html.replace(match[0], '');\n                        chars = false;\n                    }\n                    //Comment\n                } else if (SINGLE_COMMENT_REGEXP.test(html)) {\n                    match = html.match(SINGLE_COMMENT_REGEXP);\n\n                    if (match) {\n                        if (handler.comment) handler.comment(match[1]);\n                        html = html.replace(match[0], '');\n                        chars = false;\n                    }\n                    // DOCTYPE\n                } else if (DOCTYPE_REGEXP.test(html)) {\n                    match = html.match(DOCTYPE_REGEXP);\n\n                    if (match) {\n                        html = html.replace(match[0], '');\n                        chars = false;\n                    }\n                    // end tag\n                } else if (BEGING_END_TAGE_REGEXP.test(html)) {\n                    match = html.match(END_TAG_REGEXP);\n\n                    if (match) {\n                        html = html.substring(match[0].length);\n                        match[0].replace(END_TAG_REGEXP, parseEndTag);\n                        chars = false;\n                    }\n\n                    // start tag\n                } else if (BEGIN_TAG_REGEXP.test(html)) {\n                    match = html.match(START_TAG_REGEXP);\n\n                    if (match) {\n                        // We only have a valid start-tag if there is a '>'.\n                        if (match[4]) {\n                            html = html.substring(match[0].length);\n                            match[0].replace(START_TAG_REGEXP, parseStartTag);\n                        }\n                        chars = false;\n                    } else {\n                        // no ending tag found --- this piece should be encoded as an entity.\n                        text += '<';\n                        html = html.substring(1);\n                    }\n                }\n\n                if (chars) {\n                    index = html.indexOf(\"<\");\n\n                    text += index < 0 ? html : html.substring(0, index);\n                    html = index < 0 ? \"\" : html.substring(index);\n\n                    if (handler.chars) handler.chars(decodeEntities(text));\n                }\n\n            } else {\n                html = html.replace(new RegExp(\"([^]*)<\\\\s*\\\\/\\\\s*\" + stack.last() + \"[^>]*>\", 'i'),\n                    function(all, text) {\n                        text = text.replace(COMMENT_REGEXP, \"$1\").replace(CDATA_REGEXP, \"$1\");\n\n                        if (handler.chars) handler.chars(decodeEntities(text));\n\n                        return \"\";\n                    });\n\n                parseEndTag(\"\", stack.last());\n            }\n\n            if (html == last) {\n                throw $sanitizeMinErr('badparse', \"The sanitizer was unable to parse the following block \" +\n                    \"of html: {0}\", html);\n            }\n            last = html;\n        }\n\n        // Clean up any remaining tags\n        parseEndTag();\n\n        function parseStartTag(tag, tagName, rest, unary) {\n            tagName = angular.lowercase(tagName);\n            if (blockElements[ tagName ]) {\n                while (stack.last() && inlineElements[ stack.last() ]) {\n                    parseEndTag(\"\", stack.last());\n                }\n            }\n\n            if (optionalEndTagElements[ tagName ] && stack.last() == tagName) {\n                parseEndTag(\"\", tagName);\n            }\n\n            unary = voidElements[ tagName ] || !!unary;\n\n            if (!unary)\n                stack.push(tagName);\n\n            var attrs = {};\n\n            rest.replace(ATTR_REGEXP,\n                function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {\n                    var value = doubleQuotedValue\n                        || singleQuotedValue\n                        || unquotedValue\n                        || '';\n\n                    attrs[name] = decodeEntities(value);\n                });\n            if (handler.start) handler.start(tagName, attrs, unary);\n        }\n\n        function parseEndTag(tag, tagName) {\n            var pos = 0, i;\n            tagName = angular.lowercase(tagName);\n            if (tagName)\n            // Find the closest opened tag of the same type\n                for (pos = stack.length - 1; pos >= 0; pos--)\n                    if (stack[ pos ] == tagName)\n                        break;\n\n            if (pos >= 0) {\n                // Close all the open elements, up the stack\n                for (i = stack.length - 1; i >= pos; i--)\n                    if (handler.end) handler.end(stack[ i ]);\n\n                // Remove the open elements from the stack\n                stack.length = pos;\n            }\n        }\n    }\n\n    var hiddenPre=document.createElement(\"pre\");\n    var spaceRe = /^(\\s*)([\\s\\S]*?)(\\s*)$/;\n    /**\n     * decodes all entities into regular string\n     * @param value\n     * @returns {string} A string with decoded entities.\n     */\n    function decodeEntities(value) {\n        if (!value) { return ''; }\n\n        // Note: IE8 does not preserve spaces at the start/end of innerHTML\n        // so we must capture them and reattach them afterward\n        var parts = spaceRe.exec(value);\n        var spaceBefore = parts[1];\n        var spaceAfter = parts[3];\n        var content = parts[2];\n        if (content) {\n            hiddenPre.innerHTML=content.replace(/</g,\"&lt;\");\n            // innerText depends on styling as it doesn't display hidden elements.\n            // Therefore, it's better to use textContent not to cause unnecessary\n            // reflows. However, IE<9 don't support textContent so the innerText\n            // fallback is necessary.\n            content = 'textContent' in hiddenPre ?\n                hiddenPre.textContent : hiddenPre.innerText;\n        }\n        return spaceBefore + content + spaceAfter;\n    }\n\n    /**\n     * Escapes all potentially dangerous characters, so that the\n     * resulting string can be safely inserted into attribute or\n     * element text.\n     * @param value\n     * @returns {string} escaped text\n     */\n    function encodeEntities(value) {\n        return value.\n        replace(/&/g, '&amp;').\n        replace(SURROGATE_PAIR_REGEXP, function(value) {\n            var hi = value.charCodeAt(0);\n            var low = value.charCodeAt(1);\n            return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n        }).\n        replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n            // unsafe chars are: \\u0000-\\u001f \\u007f-\\u009f \\u00ad \\u0600-\\u0604 \\u070f \\u17b4 \\u17b5 \\u200c-\\u200f \\u2028-\\u202f \\u2060-\\u206f \\ufeff \\ufff0-\\uffff from jslint.com/lint.html\n            // decimal values are: 0-31, 127-159, 173, 1536-1540, 1807, 6068, 6069, 8204-8207, 8232-8239, 8288-8303, 65279, 65520-65535\n            var c = value.charCodeAt(0);\n            // if unsafe character encode\n            if(c <= 159 ||\n                c == 173 ||\n                (c >= 1536 && c <= 1540) ||\n                c == 1807 ||\n                c == 6068 ||\n                c == 6069 ||\n                (c >= 8204 && c <= 8207) ||\n                (c >= 8232 && c <= 8239) ||\n                (c >= 8288 && c <= 8303) ||\n                c == 65279 ||\n                (c >= 65520 && c <= 65535)) return '&#' + c + ';';\n            return value; // avoids multilingual issues\n        }).\n        replace(/</g, '&lt;').\n        replace(/>/g, '&gt;');\n    }\n\n    var trim = (function() {\n        // native trim is way faster: http://jsperf.com/angular-trim-test\n        // but IE doesn't have it... :-(\n        // TODO: we should move this into IE/ES5 polyfill\n        if (!String.prototype.trim) {\n            return function(value) {\n                return angular.isString(value) ? value.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '') : value;\n            };\n        }\n        return function(value) {\n            return angular.isString(value) ? value.trim() : value;\n        };\n    })();\n\n// Custom logic for accepting certain style options only - textAngular\n// Currently allows only the color, background-color, text-align, float, width and height attributes\n// all other attributes should be easily done through classes.\n    function validStyles(styleAttr){\n        var result = '';\n        var styleArray = styleAttr.split(';');\n        angular.forEach(styleArray, function(value){\n            var v = value.split(':');\n            if(v.length == 2){\n                var key = trim(angular.lowercase(v[0]));\n                var value = trim(angular.lowercase(v[1]));\n                if(\n                    (key === 'color' || key === 'background-color') && (\n                        value.match(/^rgb\\([0-9%,\\. ]*\\)$/i)\n                        || value.match(/^rgba\\([0-9%,\\. ]*\\)$/i)\n                        || value.match(/^hsl\\([0-9%,\\. ]*\\)$/i)\n                        || value.match(/^hsla\\([0-9%,\\. ]*\\)$/i)\n                        || value.match(/^#[0-9a-f]{3,6}$/i)\n                        || value.match(/^[a-z]*$/i)\n                    )\n                    ||\n                    key === 'text-align' && (\n                        value === 'left'\n                        || value === 'right'\n                        || value === 'center'\n                        || value === 'justify'\n                    )\n                    ||\n                    key === 'text-decoration' && (\n                        value === 'underline'\n                        || value === 'line-through'\n                    )\n                    ||\n                    key === 'font-weight' && (\n                        value === 'bold'\n                    )\n                    ||\n                    key === 'font-style' && (\n                        value === 'italic'\n                    )\n                    ||\n                    key === 'float' && (\n                        value === 'left'\n                        || value === 'right'\n                        || value === 'none'\n                    )\n                    ||\n                    key === 'vertical-align' && (\n                        value === 'baseline'\n                        || value === 'sub'\n                        || value === 'super'\n                        || value === 'test-top'\n                        || value === 'text-bottom'\n                        || value === 'middle'\n                        || value === 'top'\n                        || value === 'bottom'\n                        || value.match(/[0-9]*(px|em)/)\n                        || value.match(/[0-9]+?%/)\n                    )\n                    ||\n                    key === 'font-size' && (\n                        value === 'xx-small'\n                        || value === 'x-small'\n                        || value === 'small'\n                        || value === 'medium'\n                        || value === 'large'\n                        || value === 'x-large'\n                        || value === 'xx-large'\n                        || value === 'larger'\n                        || value === 'smaller'\n                        || value.match(/[0-9]*\\.?[0-9]*(px|em|rem|mm|q|cm|in|pt|pc|%)/)\n                    )\n                    ||\n                    (key === 'width' || key === 'height') && (\n                        value.match(/[0-9\\.]*(px|em|rem|%)/)\n                    )\n                    || // Reference #520\n                    (key === 'direction' && value.match(/^ltr|rtl|initial|inherit$/))\n                ) result += key + ': ' + value + ';';\n            }\n        });\n        return result;\n    }\n\n// this function is used to manually allow specific attributes on specific tags with certain prerequisites\n    function validCustomTag(tag, attrs, lkey, value){\n        // catch the div placeholder for the iframe replacement\n        if (tag === 'img' && attrs['ta-insert-video']){\n            if(lkey === 'ta-insert-video' || lkey === 'allowfullscreen' || lkey === 'frameborder' || (lkey === 'contenteditable' && value === 'false')) return true;\n        }\n        return false;\n    }\n\n    /**\n     * create an HTML/XML writer which writes to buffer\n     * @param {Array} buf use buf.jain('') to get out sanitized html string\n     * @returns {object} in the form of {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * }\n     */\n    function htmlSanitizeWriter(buf, uriValidator) {\n        var ignore = false;\n        var out = angular.bind(buf, buf.push);\n        return {\n            start: function(tag, attrs, unary) {\n                tag = angular.lowercase(tag);\n                if (!ignore && specialElements[tag]) {\n                    ignore = tag;\n                }\n                if (!ignore && validElements[tag] === true) {\n                    out('<');\n                    out(tag);\n                    angular.forEach(attrs, function(value, key) {\n                        var lkey=angular.lowercase(key);\n                        var isImage=(tag === 'img' && lkey === 'src') || (lkey === 'background');\n                        if ((lkey === 'style' && (value = validStyles(value)) !== '') || validCustomTag(tag, attrs, lkey, value) || validAttrs[lkey] === true &&\n                            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {\n                            out(' ');\n                            out(key);\n                            out('=\"');\n                            out(encodeEntities(value));\n                            out('\"');\n                        }\n                    });\n                    out(unary ? '/>' : '>');\n                }\n            },\n            comment: function (com) {\n                out(com);\n            },\n            whitespace: function (ws) {\n                out(encodeEntities(ws));\n            },\n            end: function(tag) {\n                tag = angular.lowercase(tag);\n                if (!ignore && validElements[tag] === true) {\n                    out('</');\n                    out(tag);\n                    out('>');\n                }\n                if (tag == ignore) {\n                    ignore = false;\n                }\n            },\n            chars: function(chars) {\n                if (!ignore) {\n                    out(encodeEntities(chars));\n                }\n            }\n        };\n    }\n\n\n// define ngSanitize module and register $sanitize service\n    angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);\n\n    /* global sanitizeText: false */\n\n    /**\n     * @ngdoc filter\n     * @name linky\n     * @kind function\n     *\n     * @description\n     * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and\n     * plain email address links.\n     *\n     * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n     *\n     * @param {string} text Input text.\n     * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.\n     * @returns {string} Html-linkified text.\n     *\n     * @usage\n     <span ng-bind-html=\"linky_expression | linky\"></span>\n     *\n     * @example\n     <example module=\"linkyExample\" deps=\"angular-sanitize.js\">\n     <file name=\"index.html\">\n     <script>\n     angular.module('linkyExample', ['ngSanitize'])\n     .controller('ExampleController', ['$scope', function($scope) {\n             $scope.snippet =\n               'Pretty text with some links:\\n'+\n               'http://angularjs.org/,\\n'+\n               'mailto:us@somewhere.org,\\n'+\n               'another@somewhere.org,\\n'+\n               'and one more: ftp://127.0.0.1/.';\n             $scope.snippetWithTarget = 'http://angularjs.org/';\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n     Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n     <table>\n     <tr>\n     <td>Filter</td>\n     <td>Source</td>\n     <td>Rendered</td>\n     </tr>\n     <tr id=\"linky-filter\">\n     <td>linky filter</td>\n     <td>\n     <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n     </td>\n     <td>\n     <div ng-bind-html=\"snippet | linky\"></div>\n     </td>\n     </tr>\n     <tr id=\"linky-target\">\n     <td>linky target</td>\n     <td>\n     <pre>&lt;div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n     </td>\n     <td>\n     <div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"></div>\n     </td>\n     </tr>\n     <tr id=\"escaped-html\">\n     <td>no filter</td>\n     <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n     <td><div ng-bind=\"snippet\"></div></td>\n     </tr>\n     </table>\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n     it('should linkify the snippet with urls', function() {\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n       });\n\n     it('should not linkify snippet without the linky filter', function() {\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n       });\n\n     it('should update', function() {\n         element(by.model('snippet')).clear();\n         element(by.model('snippet')).sendKeys('new http://link.');\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('new http://link.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n             .toBe('new http://link.');\n       });\n\n     it('should work with the target property', function() {\n        expect(element(by.id('linky-target')).\n            element(by.binding(\"snippetWithTarget | linky:'_blank'\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n       });\n     </file>\n     </example>\n     */\n    angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {\n        var LINKY_URL_REGEXP =\n                /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"”’]/,\n            MAILTO_REGEXP = /^mailto:/;\n\n        return function(text, target) {\n            if (!text) return text;\n            var match;\n            var raw = text;\n            var html = [];\n            var url;\n            var i;\n            while ((match = raw.match(LINKY_URL_REGEXP))) {\n                // We can not end in these as they are sometimes found at the end of the sentence\n                url = match[0];\n                // if we did not match ftp/http/www/mailto then assume mailto\n                if (!match[2] && !match[4]) {\n                    url = (match[3] ? 'http://' : 'mailto:') + url;\n                }\n                i = match.index;\n                addText(raw.substr(0, i));\n                addLink(url, match[0].replace(MAILTO_REGEXP, ''));\n                raw = raw.substring(i + match[0].length);\n            }\n            addText(raw);\n            return $sanitize(html.join(''));\n\n            function addText(text) {\n                if (!text) {\n                    return;\n                }\n                html.push(sanitizeText(text));\n            }\n\n            function addLink(url, text) {\n                html.push('<a ');\n                if (angular.isDefined(target)) {\n                    html.push('target=\"',\n                        target,\n                        '\" ');\n                }\n                html.push('href=\"',\n                    url.replace(/\"/g, '&quot;'),\n                    '\">');\n                addText(text);\n                html.push('</a>');\n            }\n        };\n    }]);\n\n\n})(window, window.angular);","/*\n @license textAngular\n Author : Austin Anderson\n License : 2013 MIT\n Version 1.5.16\n\n See README.md or https://github.com/fraywing/textAngular/wiki for requirements and use.\n */\n\n/*\n Commonjs package manager support (eg componentjs).\n */\n\n\n\"use strict\";// NOTE: textAngularVersion must match the Gruntfile.js 'setVersion' task.... and have format v/d+./d+./d+\nvar textAngularVersion = 'v1.5.16';   // This is automatically updated during the build process to the current release!\n\n\n// IE version detection - http://stackoverflow.com/questions/4169160/javascript-ie-detection-why-not-use-simple-conditional-comments\n// We need this as IE sometimes plays funny tricks with the contenteditable.\n// ----------------------------------------------------------\n// If you're not in IE (or IE version is less than 5) then:\n// ie === undefined\n// If you're in IE (>=5) then you can determine which version:\n// ie === 7; // IE7\n// Thus, to detect IE:\n// if (ie) {}\n// And to detect the version:\n// ie === 6 // IE6\n// ie > 7 // IE8, IE9, IE10 ...\n// ie < 9 // Anything less than IE9\n// ----------------------------------------------------------\n/* istanbul ignore next: untestable browser check */\nvar _browserDetect = {\n    ie: (function(){\n        var undef,\n            v = 3,\n            div = document.createElement('div'),\n            all = div.getElementsByTagName('i');\n\n        while (\n            div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->',\n                all[0]\n            );\n\n        return v > 4 ? v : undef;\n    }()),\n    webkit: /AppleWebKit\\/([\\d.]+)/i.test(navigator.userAgent),\n    isFirefox: navigator.userAgent.toLowerCase().indexOf('firefox') > -1\n};\n\n// Global to textAngular to measure performance where needed\n/* istanbul ignore next: untestable browser check */\nvar performance = performance || {};\n/* istanbul ignore next: untestable browser check */\nperformance.now = (function() {\n    return performance.now       ||\n        performance.mozNow    ||\n        performance.msNow     ||\n        performance.oNow      ||\n        performance.webkitNow ||\n        function() { return new Date().getTime(); };\n})();\n// usage is:\n// var t0 = performance.now();\n// doSomething();\n// var t1 = performance.now();\n// console.log('Took', (t1 - t0).toFixed(4), 'milliseconds to do something!');\n//\n\n// turn html into pure text that shows visiblity\nfunction stripHtmlToText(html)\n{\n    var tmp = document.createElement(\"DIV\");\n    tmp.innerHTML = html;\n    var res = tmp.textContent || tmp.innerText || '';\n    res.replace('\\u200B', ''); // zero width space\n    res = res.trim();\n    return res;\n}\n// get html\nfunction getDomFromHtml(html)\n{\n    var tmp = document.createElement(\"DIV\");\n    tmp.innerHTML = html;\n    return tmp;\n}\n\n\n// Global to textAngular REGEXP vars for block and list elements.\n\nvar BLOCKELEMENTS = /^(address|article|aside|audio|blockquote|canvas|center|dd|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|noscript|ol|output|p|pre|section|table|tfoot|ul|video)$/i;\nvar LISTELEMENTS = /^(ul|li|ol)$/i;\n// updated VALIDELEMENTS to include #text and span so that we can use nodeName instead of tagName\nvar VALIDELEMENTS = /^(#text|span|address|article|aside|audio|blockquote|canvas|center|dd|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|noscript|ol|output|p|pre|section|table|tfoot|ul|video|li)$/i;\n\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Compatibility\n/* istanbul ignore next: trim shim for older browsers */\nif (!String.prototype.trim) {\n    String.prototype.trim = function () {\n        return this.replace(/^\\s+|\\s+$/g, '');\n    };\n}\n\n/*\n Custom stylesheet for the placeholders rules.\n Credit to: http://davidwalsh.name/add-rules-stylesheets\n */\nvar sheet, addCSSRule, removeCSSRule, _addCSSRule, _removeCSSRule, _getRuleIndex;\n/* istanbul ignore else: IE <8 test*/\nif(_browserDetect.ie > 8 || _browserDetect.ie === undefined){\n    var _sheets = document.styleSheets;\n    /* istanbul ignore next: preference for stylesheet loaded externally */\n    for(var i = 0; i < _sheets.length; i++){\n        if(_sheets[i].media.length === 0 || _sheets[i].media.mediaText.match(/(all|screen)/ig)){\n            if(_sheets[i].href){\n                if(_sheets[i].href.match(/textangular\\.(min\\.|)css/ig)){\n                    sheet = _sheets[i];\n                    break;\n                }\n            }\n        }\n    }\n    /* istanbul ignore next: preference for stylesheet loaded externally */\n    if(!sheet){\n        // this sheet is used for the placeholders later on.\n        sheet = (function() {\n            // Create the <style> tag\n            var style = document.createElement(\"style\");\n            /* istanbul ignore else : WebKit hack :( */\n            if(_browserDetect.webkit) style.appendChild(document.createTextNode(\"\"));\n\n            // Add the <style> element to the page, add as first so the styles can be overridden by custom stylesheets\n            document.getElementsByTagName('head')[0].appendChild(style);\n\n            return style.sheet;\n        })();\n    }\n\n    // use as: addCSSRule(\"header\", \"float: left\");\n    addCSSRule = function(selector, rules) {\n        return _addCSSRule(sheet, selector, rules);\n    };\n    _addCSSRule = function(_sheet, selector, rules){\n        var insertIndex;\n        var insertedRule;\n        // This order is important as IE 11 has both cssRules and rules but they have different lengths - cssRules is correct, rules gives an error in IE 11\n        /* istanbul ignore next: browser catches */\n        if(_sheet.cssRules) insertIndex = Math.max(_sheet.cssRules.length - 1, 0);\n        else if(_sheet.rules) insertIndex = Math.max(_sheet.rules.length - 1, 0);\n\n        /* istanbul ignore else: untestable IE option */\n        if(_sheet.insertRule) {\n            _sheet.insertRule(selector + \"{\" + rules + \"}\", insertIndex);\n        }\n        else {\n            _sheet.addRule(selector, rules, insertIndex);\n        }\n        /* istanbul ignore next: browser catches */\n        if(sheet.rules) insertedRule = sheet.rules[insertIndex];\n        else if(sheet.cssRules) insertedRule = sheet.cssRules[insertIndex];\n        // return the inserted stylesheet rule\n        return insertedRule;\n    };\n\n    _getRuleIndex = function(rule, rules) {\n        var i, ruleIndex;\n        for (i=0; i < rules.length; i++) {\n            /* istanbul ignore else: check for correct rule */\n            if (rules[i].cssText === rule.cssText) {\n                ruleIndex = i;\n                break;\n            }\n        }\n        return ruleIndex;\n    };\n\n    removeCSSRule = function(rule){\n        _removeCSSRule(sheet, rule);\n    };\n    /* istanbul ignore next: tests are browser specific */\n    _removeCSSRule = function(sheet, rule){\n        var rules = sheet.cssRules || sheet.rules;\n        if(!rules || rules.length === 0) return;\n        var ruleIndex = _getRuleIndex(rule, rules);\n        if(sheet.removeRule){\n            sheet.removeRule(ruleIndex);\n        }else{\n            sheet.deleteRule(ruleIndex);\n        }\n    };\n}\n\nangular.module('textAngular.factories', [])\n    .factory('taBrowserTag', [function(){\n        return function(tag){\n            /* istanbul ignore next: ie specific test */\n            if(!tag) return (_browserDetect.ie <= 8)? 'P' : 'p';\n            else if(tag === '') return (_browserDetect.ie === undefined)? 'div' : (_browserDetect.ie <= 8)? 'P' : 'p';\n            else return (_browserDetect.ie <= 8)? tag.toUpperCase() : tag;\n        };\n    }]).factory('taApplyCustomRenderers', ['taCustomRenderers', 'taDOM', function(taCustomRenderers, taDOM){\n    return function(val){\n        var element = angular.element('<div></div>');\n        element[0].innerHTML = val;\n\n        angular.forEach(taCustomRenderers, function(renderer){\n            var elements = [];\n            // get elements based on what is defined. If both defined do secondary filter in the forEach after using selector string\n            if(renderer.selector && renderer.selector !== '')\n                elements = element.find(renderer.selector);\n            /* istanbul ignore else: shouldn't fire, if it does we're ignoring everything */\n            else if(renderer.customAttribute && renderer.customAttribute !== '')\n                elements = taDOM.getByAttribute(element, renderer.customAttribute);\n            // process elements if any found\n            angular.forEach(elements, function(_element){\n                _element = angular.element(_element);\n                if(renderer.selector && renderer.selector !== '' && renderer.customAttribute && renderer.customAttribute !== ''){\n                    if(_element.attr(renderer.customAttribute) !== undefined) renderer.renderLogic(_element);\n                } else renderer.renderLogic(_element);\n            });\n        });\n\n        return element[0].innerHTML;\n    };\n}]).factory('taFixChrome', function(){\n    // get whaterever rubbish is inserted in chrome\n    // should be passed an html string, returns an html string\n    var taFixChrome = function(html, keepStyles){\n        if(!html || !angular.isString(html) || html.length <= 0) return html;\n        // grab all elements with a style attibute\n        // a betterSpanMatch matches only a style=... with matching quotes\n        // this captures the whole:\n        // 'style=\"background-color: rgb(255, 255, 255);\"'\n        var betterSpanMatch = /style\\s?=\\s?([\"'])(?:(?=(\\\\?))\\2.)*?\\1/ig;\n        // where the original spanMatch = /<([^>\\/]+?)style=(\"([^\\\"]+)\"|'([^']+)')([^>]*)>/ig;\n        // captures too much and includes the front tag!\n        var spanMatch = /<([^>\\/]+?)style=(\"([^\\\"]+)\"|'([^']+)')([^>]*)>/ig;\n        var appleConvertedSpaceMatch = /<span class=\"Apple-converted-space\">([^<]+)<\\/span>/ig;\n        var match, styleVal, appleSpaceVal, newTag, finalHtml = '', lastIndex = 0;\n        // remove all the Apple-converted-space spans and replace with the content of the span\n        //console.log('before:', html);\n        /* istanbul ignore next: apple-contereted-space span match */\n        while(match = appleConvertedSpaceMatch.exec(html)){\n            appleSpaceVal = match[1];\n            appleSpaceVal = appleSpaceVal.replace(/&nbsp;/ig, ' ');\n            finalHtml += html.substring(lastIndex, match.index) + appleSpaceVal;\n            lastIndex = match.index + match[0].length;\n        }\n        /* istanbul ignore next: apple-contereted-space span has matched */\n        if (lastIndex) {\n            // modified....\n            finalHtml += html.substring(lastIndex);\n            html=finalHtml;\n            finalHtml='';\n            lastIndex=0;\n        }\n        /////////////////////////////////////////////////////////////\n        //\n        // Allow control of this modification\n        // taKeepStyles: False - removes these modification\n        //\n        // taFixChrome removes the following styles:\n        //    font-family: inherit;\n        //    line-height: <number>\n        //    color: inherit;\n        //    color: rgb( <rgb-component>#{3} )\n        //    background-color: rgb( <rgb-component>#{3} )\n        //\n        /////////////////////////////////////////////////////////////\n        if (!keepStyles) {\n            while (match = betterSpanMatch.exec(html)) {\n                finalHtml += html.substring(lastIndex, match.index-1);\n                styleVal = match[0];\n                // test for chrome inserted junk\n                match = /font-family: inherit;|line-height: 1.[0-9]{3,12};|color: inherit; line-height: 1.1;|color: rgb\\(\\d{1,3}, \\d{1,3}, \\d{1,3}\\);|background-color: rgb\\(\\d{1,3}, \\d{1,3}, \\d{1,3}\\);/gi.exec(styleVal);\n                if (match) {\n                    styleVal = styleVal.replace(/( |)font-family: inherit;|( |)line-height: 1.[0-9]{3,12};|( |)color: inherit;|( |)color: rgb\\(\\d{1,3}, \\d{1,3}, \\d{1,3}\\);|( |)background-color: rgb\\(\\d{1,3}, \\d{1,3}, \\d{1,3}\\);/ig, '');\n                    //console.log(styleVal, styleVal.length);\n                    if (styleVal.length > 8) {\n                        finalHtml += ' ' + styleVal;\n                    }\n                } else {\n                    finalHtml += ' ' + styleVal;\n                }\n                lastIndex = betterSpanMatch.lastIndex;\n            }\n            finalHtml += html.substring(lastIndex);\n        }\n        //console.log('final:', finalHtml);\n        // only replace when something has changed, else we get focus problems on inserting lists\n        if(lastIndex > 0){\n            // replace all empty strings\n            var fe = finalHtml.replace(/<span\\s?>(.*?)<\\/span>(<br(\\/|)>|)/ig, '$1');\n            return fe;\n        } else return html;\n    };\n    return taFixChrome;\n}).factory('taSanitize', ['$sanitize', function taSanitizeFactory($sanitize){\n\n    var convert_infos = [\n        {\n            property: 'font-weight',\n            values: [ 'bold' ],\n            tag: 'b'\n        },\n        {\n            property: 'font-style',\n            values: [ 'italic' ],\n            tag: 'i'\n        }\n    ];\n\n    var styleMatch = [];\n    for(var i = 0; i < convert_infos.length; i++){\n        var _partialStyle = '(' + convert_infos[i].property + ':\\\\s*(';\n        for(var j = 0; j < convert_infos[i].values.length; j++){\n            /* istanbul ignore next: not needed to be tested yet */\n            if(j > 0) _partialStyle += '|';\n            _partialStyle += convert_infos[i].values[j];\n        }\n        _partialStyle += ');)';\n        styleMatch.push(_partialStyle);\n    }\n    var styleRegexString = '(' + styleMatch.join('|') + ')';\n\n    function wrapNested(html, wrapTag) {\n        var depth = 0;\n        var lastIndex = 0;\n        var match;\n        var tagRegex = /<[^>]*>/ig;\n        while(match = tagRegex.exec(html)){\n            lastIndex = match.index;\n            if(match[0].substr(1, 1) === '/'){\n                if(depth === 0) break;\n                else depth--;\n            }else depth++;\n        }\n        return wrapTag +\n            html.substring(0, lastIndex) +\n            // get the start tags reversed - this is safe as we construct the strings with no content except the tags\n            angular.element(wrapTag)[0].outerHTML.substring(wrapTag.length) +\n            html.substring(lastIndex);\n    }\n\n    function transformLegacyStyles(html){\n        if(!html || !angular.isString(html) || html.length <= 0) return html;\n        var i;\n        var styleElementMatch = /<([^>\\/]+?)style=(\"([^\"]+)\"|'([^']+)')([^>]*)>/ig;\n        var match, subMatch, styleVal, newTag, lastNewTag = '', newHtml, finalHtml = '', lastIndex = 0;\n        while(match = styleElementMatch.exec(html)){\n            // one of the quoted values ' or \"\n            /* istanbul ignore next: quotations match */\n            styleVal = match[3] || match[4];\n            var styleRegex = new RegExp(styleRegexString, 'i');\n            // test for style values to change\n            if(angular.isString(styleVal) && styleRegex.test(styleVal)){\n                // remove build tag list\n                newTag = '';\n                // init regex here for exec\n                var styleRegexExec = new RegExp(styleRegexString, 'ig');\n                // find relevand tags and build a string of them\n                while(subMatch = styleRegexExec.exec(styleVal)){\n                    for(i = 0; i < convert_infos.length; i++){\n                        if(!!subMatch[(i*2) + 2]){\n                            newTag += '<' + convert_infos[i].tag + '>';\n                        }\n                    }\n                }\n                // recursively find more legacy styles in html before this tag and after the previous match (if any)\n                newHtml = transformLegacyStyles(html.substring(lastIndex, match.index));\n                // build up html\n                if(lastNewTag.length > 0){\n                    finalHtml += wrapNested(newHtml, lastNewTag);\n                }else finalHtml += newHtml;\n                // grab the style val without the transformed values\n                styleVal = styleVal.replace(new RegExp(styleRegexString, 'ig'), '');\n                // build the html tag\n                finalHtml += '<' + match[1].trim();\n                if(styleVal.length > 0) finalHtml += ' style=\"' + styleVal + '\"';\n                finalHtml += match[5] + '>';\n                // update the start index to after this tag\n                lastIndex = match.index + match[0].length;\n                lastNewTag = newTag;\n            }\n        }\n        if(lastNewTag.length > 0){\n            finalHtml += wrapNested(html.substring(lastIndex), lastNewTag);\n        }\n        else finalHtml += html.substring(lastIndex);\n        return finalHtml;\n    }\n\n    function transformLegacyAttributes(html){\n        if(!html || !angular.isString(html) || html.length <= 0) return html;\n        // replace all align='...' tags with text-align attributes\n        var attrElementMatch = /<([^>\\/]+?)align=(\"([^\"]+)\"|'([^']+)')([^>]*)>/ig;\n        var match, finalHtml = '', lastIndex = 0;\n        // match all attr tags\n        while(match = attrElementMatch.exec(html)){\n            // add all html before this tag\n            finalHtml += html.substring(lastIndex, match.index);\n            // record last index after this tag\n            lastIndex = match.index + match[0].length;\n            // construct tag without the align attribute\n            var newTag = '<' + match[1] + match[5];\n            // add the style attribute\n            if(/style=(\"([^\"]+)\"|'([^']+)')/ig.test(newTag)){\n                /* istanbul ignore next: quotations match */\n                newTag = newTag.replace(/style=(\"([^\"]+)\"|'([^']+)')/i, 'style=\"$2$3 text-align:' + (match[3] || match[4]) + ';\"');\n            }else{\n                /* istanbul ignore next: quotations match */\n                newTag += ' style=\"text-align:' + (match[3] || match[4]) + ';\"';\n            }\n            newTag += '>';\n            // add to html\n            finalHtml += newTag;\n        }\n        // return with remaining html\n        return finalHtml + html.substring(lastIndex);\n    }\n\n    // use precompiled regexp for speed\n    var rsb1 = new RegExp(/<span id=\"selectionBoundary_\\d+_\\d+\" class=\"rangySelectionBoundary\">[^<>]+?<\\/span>/ig);\n    var rsb2 = new RegExp(/<span class=\"rangySelectionBoundary\" id=\"selectionBoundary_\\d+_\\d+\">[^<>]+?<\\/span>/ig);\n    var rsb3 = new RegExp(/<span id=\"selectionBoundary_\\d+_\\d+\" class=\"rangySelectionBoundary\">[^<>]+?<\\/span>/ig);\n\n    return function taSanitize(unsafe, oldsafe, ignore){\n        // unsafe html should NEVER built into a DOM object via angular.element. This allows XSS to be inserted and run.\n        if ( !ignore ) {\n            try {\n                unsafe = transformLegacyStyles(unsafe);\n            } catch (e) {\n            }\n        }\n\n        // unsafe and oldsafe should be valid HTML strings\n        // any exceptions (lets say, color for example) should be made here but with great care\n        // setup unsafe element for modification\n        unsafe = transformLegacyAttributes(unsafe);\n\n        // we had an issue in the past, where we dumped a whole bunch of <span>'s into the content...\n        // so we remove them here\n        // IN A FUTURE release this can be removed after all have updated through release 1.5.9\n        if (unsafe) {\n            try {\n                unsafe = unsafe.replace(rsb1, '');\n                unsafe = unsafe.replace(rsb2, '');\n                unsafe = unsafe.replace(rsb1, '');\n                unsafe = unsafe.replace(rsb3, '');\n            } catch (e) {\n            }\n        }\n\n        var safe;\n        try {\n            safe = $sanitize(unsafe);\n            // do this afterwards, then the $sanitizer should still throw for bad markup\n            if(ignore) safe = unsafe;\n        } catch (e){\n            safe = oldsafe || '';\n        }\n\n        // Do processing for <pre> tags, removing tabs and return carriages outside of them\n\n        var _preTags = safe.match(/(<pre[^>]*>.*?<\\/pre[^>]*>)/ig);\n        var processedSafe = safe.replace(/(&#(9|10);)*/ig, '');\n        var re = /<pre[^>]*>.*?<\\/pre[^>]*>/ig;\n        var index = 0;\n        var lastIndex = 0;\n        var origTag;\n        safe = '';\n        while((origTag = re.exec(processedSafe)) !== null && index < _preTags.length){\n            safe += processedSafe.substring(lastIndex, origTag.index) + _preTags[index];\n            lastIndex = origTag.index + origTag[0].length;\n            index++;\n        }\n        return safe + processedSafe.substring(lastIndex);\n    };\n}]).factory('taToolExecuteAction', ['$q', '$log', function($q, $log){\n    // this must be called on a toolScope or instance\n    return function(editor){\n        if(editor !== undefined) this.$editor = function(){ return editor; };\n        var deferred = $q.defer(),\n            promise = deferred.promise,\n            _editor = this.$editor();\n        // pass into the action the deferred function and also the function to reload the current selection if rangy available\n        var result;\n        try{\n            result = this.action(deferred, _editor.startAction());\n            // We set the .finally callback here to make sure it doesn't get executed before any other .then callback.\n            promise['finally'](function(){\n                _editor.endAction.call(_editor);\n            });\n        }catch(exc){\n            $log.error(exc);\n        }\n        if(result || result === undefined){\n            // if true or undefined is returned then the action has finished. Otherwise the deferred action will be resolved manually.\n            deferred.resolve();\n        }\n    };\n}]);\n\nangular.module('textAngular.DOM', ['textAngular.factories'])\n    .factory('taExecCommand', ['taSelection', 'taBrowserTag', '$document', function(taSelection, taBrowserTag, $document){\n        var listToDefault = function(listElement, defaultWrap){\n            var $target, i;\n            // if all selected then we should remove the list\n            // grab all li elements and convert to taDefaultWrap tags\n            var children = listElement.find('li');\n            for(i = children.length - 1; i >= 0; i--){\n                $target = angular.element('<' + defaultWrap + '>' + children[i].innerHTML + '</' + defaultWrap + '>');\n                listElement.after($target);\n            }\n            listElement.remove();\n            taSelection.setSelectionToElementEnd($target[0]);\n        };\n        var listElementToSelfTag = function(list, listElement, selfTag, bDefault, defaultWrap){\n            var $target, i;\n            // if all selected then we should remove the list\n            // grab all li elements\n            var priorElement;\n            var nextElement;\n            var children = list.find('li');\n            var foundIndex;\n            for (i = 0; i<children.length; i++) {\n                if (children[i].outerHTML === listElement[0].outerHTML) {\n                    // found it...\n                    foundIndex = i;\n                    if (i>0) {\n                        priorElement = children[i-1];\n                    }\n                    if (i+1<children.length) {\n                        nextElement = children[i+1];\n                    }\n                    break;\n                }\n            }\n            //console.log('listElementToSelfTag', list, listElement, selfTag, bDefault, priorElement, nextElement);\n            // un-list the listElement\n            var html = '';\n            if (bDefault) {\n                html += '<' + defaultWrap + '>' + listElement[0].innerHTML + '</' + defaultWrap + '>';\n            } else {\n                html += '<' + taBrowserTag(selfTag) + '>';\n                html += '<li>' + listElement[0].innerHTML + '</li>';\n                html += '</' + taBrowserTag(selfTag) + '>';\n            }\n            $target = angular.element(html);\n            //console.log('$target', $target[0]);\n            if (!priorElement) {\n                // this is the first the list, so we just remove it...\n                listElement.remove();\n                list.after(angular.element(list[0].outerHTML));\n                list.after($target);\n                list.remove();\n                taSelection.setSelectionToElementEnd($target[0]);\n                return;\n            } else if (!nextElement) {\n                // this is the last in the list, so we just remove it..\n                listElement.remove();\n                list.after($target);\n                taSelection.setSelectionToElementEnd($target[0]);\n            } else {\n                var p = list.parent();\n                // okay it was some where in the middle... so we need to break apart the list...\n                var html1 = '';\n                var listTag = list[0].nodeName.toLowerCase();\n                html1 += '<' + listTag + '>';\n                for(i = 0; i < foundIndex; i++){\n                    html1 += '<li>' + children[i].innerHTML + '</li>';\n                }\n                html1 += '</' + listTag + '>';\n                var html2 = '';\n                html2 += '<' + listTag + '>';\n                for(i = foundIndex+1; i < children.length; i++){\n                    html2 += '<li>' + children[i].innerHTML + '</li>';\n                }\n                html2 += '</' + listTag + '>';\n                //console.log(html1, $target[0], html2);\n                list.after(angular.element(html2));\n                list.after($target);\n                list.after(angular.element(html1));\n                list.remove();\n                //console.log('parent ******XXX*****', p[0]);\n                taSelection.setSelectionToElementEnd($target[0]);\n            }\n        };\n        var listElementsToSelfTag = function(list, listElements, selfTag, bDefault, defaultWrap){\n            var $target, i, j, p;\n            // grab all li elements\n            var priorElement;\n            var afterElement;\n            //console.log('list:', list, 'listElements:', listElements, 'selfTag:', selfTag, 'bDefault:', bDefault);\n            var children = list.find('li');\n            var foundIndexes = [];\n            for (i = 0; i<children.length; i++) {\n                for (j = 0; j<listElements.length; j++) {\n                    if (children[i].isEqualNode(listElements[j])) {\n                        // found it...\n                        foundIndexes[j] = i;\n                    }\n                }\n            }\n            if (foundIndexes[0] > 0) {\n                priorElement = children[foundIndexes[0] - 1];\n            }\n            if (foundIndexes[listElements.length-1] + 1 < children.length) {\n                afterElement = children[foundIndexes[listElements.length-1] + 1];\n            }\n            //console.log('listElementsToSelfTag', list, listElements, selfTag, bDefault, !priorElement, !afterElement, foundIndexes[listElements.length-1], children.length);\n            // un-list the listElements\n            var html = '';\n            if (bDefault) {\n                for (j = 0; j < listElements.length; j++) {\n                    html += '<' + defaultWrap + '>' + listElements[j].innerHTML + '</' + defaultWrap + '>';\n                    listElements[j].remove();\n                }\n            } else {\n                html += '<' + taBrowserTag(selfTag) + '>';\n                for (j = 0; j < listElements.length; j++) {\n                    html += listElements[j].outerHTML;\n                    listElements[j].remove();\n                }\n                html += '</' + taBrowserTag(selfTag) + '>';\n            }\n            $target = angular.element(html);\n            if (!priorElement) {\n                // this is the first the list, so we just remove it...\n                list.after(angular.element(list[0].outerHTML));\n                list.after($target);\n                list.remove();\n                taSelection.setSelectionToElementEnd($target[0]);\n                return;\n            } else if (!afterElement) {\n                // this is the last in the list, so we just remove it..\n                list.after($target);\n                taSelection.setSelectionToElementEnd($target[0]);\n                return;\n            } else {\n                // okay it was some where in the middle... so we need to break apart the list...\n                var html1 = '';\n                var listTag = list[0].nodeName.toLowerCase();\n                html1 += '<' + listTag + '>';\n                for(i = 0; i < foundIndexes[0]; i++){\n                    html1 += '<li>' + children[i].innerHTML + '</li>';\n                }\n                html1 += '</' + listTag + '>';\n                var html2 = '';\n                html2 += '<' + listTag + '>';\n                for(i = foundIndexes[listElements.length-1]+1; i < children.length; i++){\n                    html2 += '<li>' + children[i].innerHTML + '</li>';\n                }\n                html2 += '</' + listTag + '>';\n                list.after(angular.element(html2));\n                list.after($target);\n                list.after(angular.element(html1));\n                list.remove();\n                //console.log('parent ******YYY*****', list.parent()[0]);\n                taSelection.setSelectionToElementEnd($target[0]);\n            }\n        };\n        var selectLi = function(liElement){\n            if(/(<br(|\\/)>)$/i.test(liElement.innerHTML.trim())) taSelection.setSelectionBeforeElement(angular.element(liElement).find(\"br\")[0]);\n            else taSelection.setSelectionToElementEnd(liElement);\n        };\n        var listToList = function(listElement, newListTag){\n            var $target = angular.element('<' + newListTag + '>' + listElement[0].innerHTML + '</' + newListTag + '>');\n            listElement.after($target);\n            listElement.remove();\n            selectLi($target.find('li')[0]);\n        };\n        var childElementsToList = function(elements, listElement, newListTag){\n            var html = '';\n            for(var i = 0; i < elements.length; i++){\n                html += '<' + taBrowserTag('li') + '>' + elements[i].innerHTML + '</' + taBrowserTag('li') + '>';\n            }\n            var $target = angular.element('<' + newListTag + '>' + html + '</' + newListTag + '>');\n            listElement.after($target);\n            listElement.remove();\n            selectLi($target.find('li')[0]);\n        };\n        var turnBlockIntoBlocks = function(element, options) {\n            for(var i = 0; i<element.childNodes.length; i++) {\n                var _n = element.childNodes[i];\n                /* istanbul ignore next - more complex testing*/\n                if (_n.tagName && _n.tagName.match(BLOCKELEMENTS)) {\n                    turnBlockIntoBlocks(_n, options);\n                }\n            }\n            /* istanbul ignore next - very rare condition that we do not test*/\n            if (element.parentNode === null) {\n                // nothing left to do..\n                return element;\n            }\n            /* istanbul ignore next - not sure have to test this */\n            if (options === '<br>'){\n                return element;\n            }\n            else {\n                var $target = angular.element(options);\n                $target[0].innerHTML = element.innerHTML;\n                element.parentNode.insertBefore($target[0], element);\n                element.parentNode.removeChild(element);\n                return $target;\n            }\n        };\n        return function(taDefaultWrap, topNode){\n            // NOTE: here we are dealing with the html directly from the browser and not the html the user sees.\n            // IF you want to modify the html the user sees, do it when the user does a switchView\n            taDefaultWrap = taBrowserTag(taDefaultWrap);\n            return function(command, showUI, options, defaultTagAttributes){\n                var i, $target, html, _nodes, next, optionsTagName, selectedElement, ourSelection;\n                var defaultWrapper = angular.element('<' + taDefaultWrap + '>');\n                try{\n                    if (taSelection.getSelection) {\n                        ourSelection = taSelection.getSelection();\n                    }\n                    selectedElement = taSelection.getSelectionElement();\n                    // special checks and fixes when we are selecting the whole container\n                    var __h, _innerNode;\n                    /* istanbul ignore next */\n                    if (selectedElement.tagName !== undefined) {\n                        if (selectedElement.tagName.toLowerCase() === 'div' &&\n                            /taTextElement.+/.test(selectedElement.id) &&\n                            ourSelection && ourSelection.start &&\n                            ourSelection.start.offset === 1 &&\n                            ourSelection.end.offset === 1) {\n                            // opps we are actually selecting the whole container!\n                            //console.log('selecting whole container!');\n                            __h = selectedElement.innerHTML;\n                            if (/<br>/i.test(__h)) {\n                                // Firefox adds <br>'s and so we remove the <br>\n                                __h = __h.replace(/<br>/i, '&#8203;');  // no space-space\n                            }\n                            if (/<br\\/>/i.test(__h)) {\n                                // Firefox adds <br/>'s and so we remove the <br/>\n                                __h = __h.replace(/<br\\/>/i, '&#8203;');  // no space-space\n                            }\n                            // remove stacked up <span>'s\n                            if (/<span>(<span>)+/i.test(__h)) {\n                                __h = __.replace(/<span>(<span>)+/i, '<span>');\n                            }\n                            // remove stacked up </span>'s\n                            if (/<\\/span>(<\\/span>)+/i.test(__h)) {\n                                __h = __.replace(/<\\/span>(<\\/span>)+/i, '<\\/span>');\n                            }\n                            if (/<span><\\/span>/i.test(__h)) {\n                                // if we end up with a <span></span> here we remove it...\n                                __h = __h.replace(/<span><\\/span>/i, '');\n                            }\n                            //console.log('inner whole container', selectedElement.childNodes);\n                            _innerNode = '<div>' + __h + '</div>';\n                            selectedElement.innerHTML = _innerNode;\n                            taSelection.setSelectionToElementEnd(selectedElement.childNodes[0]);\n                            selectedElement = taSelection.getSelectionElement();\n                        } else if (selectedElement.tagName.toLowerCase() === 'span' &&\n                            ourSelection && ourSelection.start &&\n                            ourSelection.start.offset === 1 &&\n                            ourSelection.end.offset === 1) {\n                            // just a span -- this is a problem...\n                            //console.log('selecting span!');\n                            __h = selectedElement.innerHTML;\n                            if (/<br>/i.test(__h)) {\n                                // Firefox adds <br>'s and so we remove the <br>\n                                __h = __h.replace(/<br>/i, '&#8203;');  // no space-space\n                            }\n                            if (/<br\\/>/i.test(__h)) {\n                                // Firefox adds <br/>'s and so we remove the <br/>\n                                __h = __h.replace(/<br\\/>/i, '&#8203;');  // no space-space\n                            }\n                            // remove stacked up <span>'s\n                            if (/<span>(<span>)+/i.test(__h)) {\n                                __h = __.replace(/<span>(<span>)+/i, '<span>');\n                            }\n                            // remove stacked up </span>'s\n                            if (/<\\/span>(<\\/span>)+/i.test(__h)) {\n                                __h = __.replace(/<\\/span>(<\\/span>)+/i, '<\\/span>');\n                            }\n                            if (/<span><\\/span>/i.test(__h)) {\n                                // if we end up with a <span></span> here we remove it...\n                                __h = __h.replace(/<span><\\/span>/i, '');\n                            }\n                            //console.log('inner span', selectedElement.childNodes);\n                            // we wrap this in a <div> because otherwise the browser get confused when we attempt to select the whole node\n                            // and the focus is not set correctly no matter what we do\n                            _innerNode = '<div>' + __h + '</div>';\n                            selectedElement.innerHTML = _innerNode;\n                            taSelection.setSelectionToElementEnd(selectedElement.childNodes[0]);\n                            selectedElement = taSelection.getSelectionElement();\n                            //console.log(selectedElement.innerHTML);\n                        } else if (selectedElement.tagName.toLowerCase() === 'p' &&\n                            ourSelection && ourSelection.start &&\n                            ourSelection.start.offset === 1 &&\n                            ourSelection.end.offset === 1) {\n                            //console.log('p special');\n                            // we need to remove the </br> that firefox adds!\n                            __h = selectedElement.innerHTML;\n                            if (/<br>/i.test(__h)) {\n                                // Firefox adds <br>'s and so we remove the <br>\n                                __h = __h.replace(/<br>/i, '&#8203;');  // no space-space\n                                selectedElement.innerHTML = __h;\n                            }\n                        } else if (selectedElement.tagName.toLowerCase() === 'li' &&\n                            ourSelection && ourSelection.start &&\n                            ourSelection.start.offset === ourSelection.end.offset) {\n                            // we need to remove the </br> that firefox adds!\n                            __h = selectedElement.innerHTML;\n                            if (/<br>/i.test(__h)) {\n                                // Firefox adds <br>'s and so we remove the <br>\n                                __h = __h.replace(/<br>/i, '');  // nothing\n                                selectedElement.innerHTML = __h;\n                            }\n                        }\n                    }\n                }catch(e){}\n                //console.log('************** selectedElement:', selectedElement);\n                /* istanbul ignore if: */\n                if (!selectedElement){return;}\n                var $selected = angular.element(selectedElement);\n                var tagName = (selectedElement && selectedElement.tagName && selectedElement.tagName.toLowerCase()) ||\n                    /* istanbul ignore next: */ \"\";\n                if(command.toLowerCase() === 'insertorderedlist' || command.toLowerCase() === 'insertunorderedlist'){\n                    var selfTag = taBrowserTag((command.toLowerCase() === 'insertorderedlist')? 'ol' : 'ul');\n                    var selectedElements = taSelection.getOnlySelectedElements();\n                    //console.log('PPPPPPPPPPPPP', tagName, selfTag, selectedElements, tagName.match(BLOCKELEMENTS), $selected.hasClass('ta-bind'), $selected.parent()[0].tagName);\n                    if (selectedElements.length>1 && (tagName === 'ol' ||  tagName === 'ul' )) {\n                        return listElementsToSelfTag($selected, selectedElements, selfTag, selfTag===tagName, taDefaultWrap);\n                    }\n                    if(tagName === selfTag){\n                        // if all selected then we should remove the list\n                        // grab all li elements and convert to taDefaultWrap tags\n                        //console.log('tagName===selfTag');\n                        if ($selected[0].childNodes.length !== selectedElements.length && selectedElements.length===1) {\n                            $selected = angular.element(selectedElements[0]);\n                            return listElementToSelfTag($selected.parent(), $selected, selfTag, true, taDefaultWrap);\n                        } else {\n                            return listToDefault($selected, taDefaultWrap);\n                        }\n                    }else if(tagName === 'li' &&\n                        $selected.parent()[0].tagName.toLowerCase() === selfTag &&\n                        $selected.parent().children().length === 1){\n                        // catch for the previous statement if only one li exists\n                        return listToDefault($selected.parent(), taDefaultWrap);\n                    }else if(tagName === 'li' &&\n                        $selected.parent()[0].tagName.toLowerCase() !== selfTag &&\n                        $selected.parent().children().length === 1){\n                        // catch for the previous statement if only one li exists\n                        return listToList($selected.parent(), selfTag);\n                    }else if(tagName.match(BLOCKELEMENTS) && !$selected.hasClass('ta-bind')){\n                        // if it's one of those block elements we have to change the contents\n                        // if it's a ol/ul we are changing from one to the other\n                        if (selectedElements.length) {\n                            if ($selected[0].childNodes.length !== selectedElements.length && selectedElements.length===1) {\n                                //console.log('&&&&&&&&&&&&&&& --------- &&&&&&&&&&&&&&&&', selectedElements[0], $selected[0].childNodes);\n                                $selected = angular.element(selectedElements[0]);\n                                return listElementToSelfTag($selected.parent(), $selected, selfTag, selfTag===tagName, taDefaultWrap);\n                            }\n                        }\n                        if(tagName === 'ol' || tagName === 'ul'){\n                            // now if this is a set of selected elements... behave diferently\n                            return listToList($selected, selfTag);\n                        }else{\n                            var childBlockElements = false;\n                            angular.forEach($selected.children(), function(elem){\n                                if(elem.tagName.match(BLOCKELEMENTS)) {\n                                    childBlockElements = true;\n                                }\n                            });\n                            if(childBlockElements){\n                                return childElementsToList($selected.children(), $selected, selfTag);\n                            }else{\n                                return childElementsToList([angular.element('<div>' + selectedElement.innerHTML + '</div>')[0]], $selected, selfTag);\n                            }\n                        }\n                    }else if(tagName.match(BLOCKELEMENTS)){\n                        // if we get here then the contents of the ta-bind are selected\n                        _nodes = taSelection.getOnlySelectedElements();\n                        //console.log('_nodes', _nodes, tagName);\n                        if(_nodes.length === 0){\n                            // here is if there is only text in ta-bind ie <div ta-bind>test content</div>\n                            $target = angular.element('<' + selfTag + '><li>' + selectedElement.innerHTML + '</li></' + selfTag + '>');\n                            $selected.html('');\n                            $selected.append($target);\n                        }else if(_nodes.length === 1 && (_nodes[0].tagName.toLowerCase() === 'ol' || _nodes[0].tagName.toLowerCase() === 'ul')){\n                            if(_nodes[0].tagName.toLowerCase() === selfTag){\n                                // remove\n                                return listToDefault(angular.element(_nodes[0]), taDefaultWrap);\n                            }else{\n                                return listToList(angular.element(_nodes[0]), selfTag);\n                            }\n                        }else{\n                            html = '';\n                            var $nodes = [];\n                            for(i = 0; i < _nodes.length; i++){\n                                /* istanbul ignore else: catch for real-world can't make it occur in testing */\n                                if(_nodes[i].nodeType !== 3){\n                                    var $n = angular.element(_nodes[i]);\n                                    /* istanbul ignore if: browser check only, phantomjs doesn't return children nodes but chrome at least does */\n                                    if(_nodes[i].tagName.toLowerCase() === 'li') continue;\n                                    else if(_nodes[i].tagName.toLowerCase() === 'ol' || _nodes[i].tagName.toLowerCase() === 'ul'){\n                                        html += $n[0].innerHTML; // if it's a list, add all it's children\n                                    }else if(_nodes[i].tagName.toLowerCase() === 'span' && (_nodes[i].childNodes[0].tagName.toLowerCase() === 'ol' || _nodes[i].childNodes[0].tagName.toLowerCase() === 'ul')){\n                                        html += $n[0].childNodes[0].innerHTML; // if it's a list, add all it's children\n                                    }else{\n                                        html += '<' + taBrowserTag('li') + '>' + $n[0].innerHTML + '</' + taBrowserTag('li') + '>';\n                                    }\n                                    $nodes.unshift($n);\n                                }\n                            }\n                            //console.log('$nodes', $nodes);\n                            $target = angular.element('<' + selfTag + '>' + html + '</' + selfTag + '>');\n                            $nodes.pop().replaceWith($target);\n                            angular.forEach($nodes, function($node){ $node.remove(); });\n                        }\n                        taSelection.setSelectionToElementEnd($target[0]);\n                        return;\n                    }\n                }else if(command.toLowerCase() === 'formatblock'){\n                    optionsTagName = options.toLowerCase().replace(/[<>]/ig, '');\n                    if(optionsTagName.trim() === 'default') {\n                        optionsTagName = taDefaultWrap;\n                        options = '<' + taDefaultWrap + '>';\n                    }\n                    if(tagName === 'li') {\n                        $target = $selected.parent();\n                    }\n                    else {\n                        $target = $selected;\n                    }\n                    // find the first blockElement\n                    while(!$target[0].tagName || !$target[0].tagName.match(BLOCKELEMENTS) && !$target.parent().attr('contenteditable')){\n                        $target = $target.parent();\n                        /* istanbul ignore next */\n                        tagName = ($target[0].tagName || '').toLowerCase();\n                    }\n                    if(tagName === optionsTagName){\n                        // $target is wrap element\n                        _nodes = $target.children();\n                        var hasBlock = false;\n                        for(i = 0; i < _nodes.length; i++){\n                            hasBlock = hasBlock || _nodes[i].tagName.match(BLOCKELEMENTS);\n                        }\n                        if(hasBlock){\n                            $target.after(_nodes);\n                            next = $target.next();\n                            $target.remove();\n                            $target = next;\n                        }else{\n                            defaultWrapper.append($target[0].childNodes);\n                            $target.after(defaultWrapper);\n                            $target.remove();\n                            $target = defaultWrapper;\n                        }\n                    }else if($target.parent()[0].tagName.toLowerCase() === optionsTagName &&\n                        !$target.parent().hasClass('ta-bind')){\n                        //unwrap logic for parent\n                        var blockElement = $target.parent();\n                        var contents = blockElement.contents();\n                        for(i = 0; i < contents.length; i ++){\n                            /* istanbul ignore next: can't test - some wierd thing with how phantomjs works */\n                            if(blockElement.parent().hasClass('ta-bind') && contents[i].nodeType === 3){\n                                defaultWrapper = angular.element('<' + taDefaultWrap + '>');\n                                defaultWrapper[0].innerHTML = contents[i].outerHTML;\n                                contents[i] = defaultWrapper[0];\n                            }\n                            blockElement.parent()[0].insertBefore(contents[i], blockElement[0]);\n                        }\n                        blockElement.remove();\n                    }else if(tagName.match(LISTELEMENTS)){\n                        // wrapping a list element\n                        $target.wrap(options);\n                    }else{\n                        // default wrap behaviour\n                        _nodes = taSelection.getOnlySelectedElements();\n                        if(_nodes.length === 0) {\n                            // no nodes at all....\n                            _nodes = [$target[0]];\n                        }\n                        // find the parent block element if any of the nodes are inline or text\n                        for(i = 0; i < _nodes.length; i++){\n                            if(_nodes[i].nodeType === 3 || !_nodes[i].tagName.match(BLOCKELEMENTS)){\n                                while(_nodes[i].nodeType === 3 || !_nodes[i].tagName || !_nodes[i].tagName.match(BLOCKELEMENTS)){\n                                    _nodes[i] = _nodes[i].parentNode;\n                                }\n                            }\n                        }\n                        // remove any duplicates from the array of _nodes!\n                        _nodes = _nodes.filter(function(value, index, self) {\n                            return self.indexOf(value) === index;\n                        });\n                        // remove all whole taTextElement if it is here... unless it is the only element!\n                        if (_nodes.length>1) {\n                            _nodes = _nodes.filter(function (value, index, self) {\n                                return !(value.nodeName.toLowerCase() === 'div' && /^taTextElement/.test(value.id));\n                            });\n                        }\n                        if(angular.element(_nodes[0]).hasClass('ta-bind')){\n                            $target = angular.element(options);\n                            $target[0].innerHTML = _nodes[0].innerHTML;\n                            _nodes[0].innerHTML = $target[0].outerHTML;\n                        }else if(optionsTagName === 'blockquote'){\n                            // blockquotes wrap other block elements\n                            html = '';\n                            for(i = 0; i < _nodes.length; i++){\n                                html += _nodes[i].outerHTML;\n                            }\n                            $target = angular.element(options);\n                            $target[0].innerHTML = html;\n                            _nodes[0].parentNode.insertBefore($target[0],_nodes[0]);\n                            for(i = _nodes.length - 1; i >= 0; i--){\n                                /* istanbul ignore else:  */\n                                if (_nodes[i].parentNode) _nodes[i].parentNode.removeChild(_nodes[i]);\n                            }\n                        } else /* istanbul ignore next: not tested since identical to blockquote */\n                        if (optionsTagName === 'pre' && taSelection.getStateShiftKey()) {\n                            //console.log('shift pre', _nodes);\n                            // pre wrap other block elements\n                            html = '';\n                            for (i = 0; i < _nodes.length; i++) {\n                                html += _nodes[i].outerHTML;\n                            }\n                            $target = angular.element(options);\n                            $target[0].innerHTML = html;\n                            _nodes[0].parentNode.insertBefore($target[0], _nodes[0]);\n                            for (i = _nodes.length - 1; i >= 0; i--) {\n                                /* istanbul ignore else:  */\n                                if (_nodes[i].parentNode) _nodes[i].parentNode.removeChild(_nodes[i]);\n                            }\n                        }\n                        else {\n                            //console.log(optionsTagName, _nodes);\n                            // regular block elements replace other block elements\n                            for (i = 0; i < _nodes.length; i++) {\n                                var newBlock = turnBlockIntoBlocks(_nodes[i], options);\n                                if (_nodes[i] === $target[0]) {\n                                    $target = angular.element(newBlock);\n                                }\n                            }\n                        }\n                    }\n                    taSelection.setSelectionToElementEnd($target[0]);\n                    // looses focus when we have the whole container selected and no text!\n                    // refocus on the shown display element, this fixes a bug when using firefox\n                    $target[0].focus();\n                    return;\n                }else if(command.toLowerCase() === 'createlink'){\n                    /* istanbul ignore next: firefox specific fix */\n                    if (tagName === 'a') {\n                        // already a link!!! we are just replacing it...\n                        taSelection.getSelectionElement().href = options;\n                        return;\n                    }\n                    var tagBegin = '<a href=\"' + options + '\" target=\"' +\n                            (defaultTagAttributes.a.target ? defaultTagAttributes.a.target : '') +\n                            '\">',\n                        tagEnd = '</a>',\n                        _selection = taSelection.getSelection();\n                    if(_selection.collapsed){\n                        //console.log('collapsed');\n                        // insert text at selection, then select then just let normal exec-command run\n                        taSelection.insertHtml(tagBegin + options + tagEnd, topNode);\n                    }else if(rangy.getSelection().getRangeAt(0).canSurroundContents()){\n                        var node = angular.element(tagBegin + tagEnd)[0];\n                        rangy.getSelection().getRangeAt(0).surroundContents(node);\n                    }\n                    return;\n                }else if(command.toLowerCase() === 'inserthtml'){\n                    //console.log('inserthtml');\n                    taSelection.insertHtml(options, topNode);\n                    return;\n                }\n                try{\n                    $document[0].execCommand(command, showUI, options);\n                }catch(e){}\n            };\n        };\n    }]).service('taSelection', ['$document', 'taDOM', '$log',\n    /* istanbul ignore next: all browser specifics and PhantomJS dosen't seem to support half of it */\n    function($document, taDOM, $log){\n        // need to dereference the document else the calls don't work correctly\n        var _document = $document[0];\n        var bShiftState;\n        var brException = function (element, offset) {\n            /* check if selection is a BR element at the beginning of a container. If so, get\n             * the parentNode instead.\n             * offset should be zero in this case. Otherwise, return the original\n             * element.\n             */\n            if (element.tagName && element.tagName.match(/^br$/i) && offset === 0 && !element.previousSibling) {\n                return {\n                    element: element.parentNode,\n                    offset: 0\n                };\n            } else {\n                return {\n                    element: element,\n                    offset: offset\n                };\n            }\n        };\n        var api = {\n            getSelection: function(){\n                var range;\n                try {\n                    // catch any errors from rangy and ignore the issue\n                    range = rangy.getSelection().getRangeAt(0);\n                } catch(e) {\n                    //console.info(e);\n                    return undefined;\n                }\n                var container = range.commonAncestorContainer;\n                var selection = {\n                    start: brException(range.startContainer, range.startOffset),\n                    end: brException(range.endContainer, range.endOffset),\n                    collapsed: range.collapsed\n                };\n                // This has problems under Firefox.\n                // On Firefox with\n                // <p>Try me !</p>\n                // <ul>\n                // <li>line 1</li>\n                // <li>line 2</li>\n                // </ul>\n                // <p>line 3</p>\n                // <ul>\n                // <li>line 4</li>\n                // <li>line 5</li>\n                // </ul>\n                // <p>Hello textAngular</p>\n                // WITH the cursor after the 3 on line 3, it gets the commonAncestorContainer as:\n                // <TextNode textContent='line 3'>\n                // AND Chrome gets the commonAncestorContainer as:\n                // <p>line 3</p>\n                //\n                // Check if the container is a text node and return its parent if so\n                // unless this is the whole taTextElement.  If so we return the textNode\n                if (container.nodeType === 3) {\n                    if (container.parentNode.nodeName.toLowerCase() === 'div' &&\n                        /^taTextElement/.test(container.parentNode.id)) {\n                        // textNode where the parent is the whole <div>!!!\n                        //console.log('textNode ***************** container:', container);\n                    } else {\n                        container = container.parentNode;\n                    }\n                }\n                if (container.nodeName.toLowerCase() === 'div' &&\n                    /^taTextElement/.test(container.id)) {\n                    //console.log('*********taTextElement************');\n                    //console.log('commonAncestorContainer:', container);\n                    selection.start.element = container.childNodes[selection.start.offset];\n                    selection.end.element = container.childNodes[selection.end.offset];\n                    selection.container = container;\n                } else {\n                    if (container.parentNode === selection.start.element ||\n                        container.parentNode === selection.end.element) {\n                        selection.container = container.parentNode;\n                    } else {\n                        selection.container = container;\n                    }\n                }\n                //console.log('***selection container:', selection.container.nodeName, selection.start.offset, selection.container);\n                return selection;\n            },\n            // if we use the LEFT_ARROW and we are at the special place <span>&#65279;</span> we move the cursor over by one...\n            // Chrome and Firefox behave differently so so fix this for Firefox here.  No adjustment needed for Chrome.\n            updateLeftArrowKey: function(element) {\n                var range = rangy.getSelection().getRangeAt(0);\n                if (range && range.collapsed) {\n                    var _nodes = api.getFlattenedDom(range);\n                    if (!_nodes.findIndex) return;\n                    var _node = range.startContainer;\n                    var indexStartContainer = _nodes.findIndex(function(element, index){\n                        if (element.node===_node) return true;\n                        var _indexp = element.parents.indexOf(_node);\n                        return (_indexp !== -1);\n                    });\n                    var m;\n                    var nextNodeToRight;\n                    //console.log('indexStartContainer', indexStartContainer, _nodes.length, 'startContainer:', _node, _node === _nodes[indexStartContainer].node);\n                    _nodes.forEach(function (n, i) {\n                        //console.log(i, n.node);\n                        n.parents.forEach(function (nn, j){\n                            //console.log(i, j, nn);\n                        });\n                    });\n                    if (indexStartContainer+1 < _nodes.length) {\n                        // we need the node just after this startContainer\n                        // so we can check and see it this is a special place\n                        nextNodeToRight = _nodes[indexStartContainer+1].node;\n                        //console.log(nextNodeToRight, range.startContainer);\n                    }\n                    //console.log('updateLeftArrowKey', range.startOffset, range.startContainer.textContent);\n                    // this first section handles the case for Chrome browser\n                    // if the first character of the nextNode is a \\ufeff we know that we are just before the special span...\n                    // and so we most left by one character\n                    if (nextNodeToRight && nextNodeToRight.textContent) {\n                        m = /^\\ufeff([^\\ufeff]*)$/.exec(nextNodeToRight.textContent);\n                        if (m) {\n                            // we are before the special node with begins with a \\ufeff character\n                            //console.log('LEFT ...found it...', 'startOffset:', range.startOffset, m[0].length, m[1].length);\n                            // no need to change anything in this case\n                            return;\n                        }\n                    }\n                    var nextNodeToLeft;\n                    if (indexStartContainer > 0) {\n                        // we need the node just after this startContainer\n                        // so we can check and see it this is a special place\n                        nextNodeToLeft = _nodes[indexStartContainer-1].node;\n                        //console.log(nextNodeToLeft, nextNodeToLeft);\n                    }\n                    if (range.startOffset === 0 && nextNodeToLeft) {\n                        //console.log(nextNodeToLeft, range.startOffset, nextNodeToLeft.textContent);\n                        m = /^\\ufeff([^\\ufeff]*)$/.exec(nextNodeToLeft.textContent);\n                        if (m) {\n                            //console.log('LEFT &&&&&&&&&&&&&&&&&&&...found it...&&&&&&&&&&&', nextNodeToLeft, m[0].length, m[1].length);\n                            // move over to the left my one -- Firefox triggers this case\n                            api.setSelectionToElementEnd(nextNodeToLeft);\n                            return;\n                        }\n                    }\n                }\n                return;\n            },\n            // if we use the RIGHT_ARROW and we are at the special place <span>&#65279;</span> we move the cursor over by one...\n            updateRightArrowKey: function(element) {\n                // we do not need to make any adjustments here, so we ignore all this code\n                if (false) {\n                    var range = rangy.getSelection().getRangeAt(0);\n                    if (range && range.collapsed) {\n                        var _nodes = api.getFlattenedDom(range);\n                        if (!_nodes.findIndex) return;\n                        var _node = range.startContainer;\n                        var indexStartContainer = _nodes.findIndex(function (element, index) {\n                            if (element.node === _node) return true;\n                            var _indexp = element.parents.indexOf(_node);\n                            return (_indexp !== -1);\n                        });\n                        var _sel;\n                        var i;\n                        var m;\n\n                        // if the last character is a \\ufeff we know that we are just before the special span...\n                        // and so we most right by one character\n                        var indexFound = _nodes.findIndex(function (n, index) {\n                            if (n.textContent) {\n                                var m = /^\\ufeff([^\\ufeff]*)$/.exec(n.textContent);\n                                if (m) {\n                                    return true;\n                                } else {\n                                    return false;\n                                }\n                            } else {\n                                return false;\n                            }\n                        });\n                        if (indexFound === -1) {\n                            return;\n                        }\n                        //console.log(indexFound, range.startContainer, range.startOffset);\n                        _node = _nodes[indexStartContainer];\n                        //console.log('indexStartContainer', indexStartContainer);\n                        if (_node && _node.textContent) {\n                            m = /^\\ufeff([^\\ufeff]*)$/.exec(_node.textContent);\n                            if (m && range.startOffset - 1 === m[1].length) {\n                                //console.log('RIGHT found it...&&&&&&&&&&&', range.startOffset);\n                                // no need to make any adjustment\n                                return;\n                            }\n                        }\n                        //console.log(range.startOffset);\n                        if (_nodes && range.startOffset === 0) {\n                            indexStartContainer = _nodes.indexOf(range.startContainer);\n                            if (indexStartContainer !== -1 && indexStartContainer > 0) {\n                                _node = _nodes[indexStartContainer - 1];\n                                if (_node.textContent) {\n                                    m = /\\ufeff([^\\ufeff]*)$/.exec(_node.textContent);\n                                    if (m && true || range.startOffset === m[1].length + 1) {\n                                        //console.log('RIGHT &&&&&&&&&&&&&&&&&&&...found it...&&&&&&&&&&&', range.startOffset, m[1].length);\n                                        // no need to make any adjustment\n                                        return;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            getFlattenedDom: function(range) {\n                var parent = range.commonAncestorContainer.parentNode;\n                if (!parent) {\n                    return range.commonAncestorContainer.childNodes;\n                }\n                var nodes = Array.prototype.slice.call(parent.childNodes); // converts NodeList to Array\n                var indexStartContainer = nodes.indexOf(range.startContainer);\n                // make sure that we have a big enough set of nodes\n                if (indexStartContainer+1 < nodes.length && indexStartContainer > 0) {\n                    // we are good\n                    // we can go down one node or up one node\n                } else {\n                    if (parent.parentNode) {\n                        parent = parent.parentNode;\n                    }\n                }\n                // now walk the parent\n                nodes = [];\n                function addNodes(_set) {\n                    if (_set.node.childNodes.length) {\n                        var childNodes = Array.prototype.slice.call(_set.node.childNodes); // converts NodeList to Array\n                        childNodes.forEach(function(n) {\n                            var _t = _set.parents.slice();\n                            if (_t.slice(-1)[0]!==_set.node) {\n                                _t.push(_set.node);\n                            }\n                            addNodes({parents: _t, node: n});\n                        });\n                    } else {\n                        nodes.push({parents: _set.parents, node: _set.node});\n                    }\n                }\n                addNodes({parents: [parent], node: parent});\n                return nodes;\n            },\n            getOnlySelectedElements: function(){\n                var range = rangy.getSelection().getRangeAt(0);\n                var container = range.commonAncestorContainer;\n                // Node.TEXT_NODE === 3\n                // Node.ELEMENT_NODE === 1\n                // Node.COMMENT_NODE === 8\n                // Check if the container is a text node and return its parent if so\n                container = container.nodeType === 3 ? container.parentNode : container;\n                // get the nodes in the range that are ELEMENT_NODE and are children of the container\n                // in this range...\n                return range.getNodes([1], function(node){\n                    return node.parentNode === container;\n                });\n            },\n            // this includes the container element if all children are selected\n            getAllSelectedElements: function(){\n                var range = rangy.getSelection().getRangeAt(0);\n                var container = range.commonAncestorContainer;\n                // Node.TEXT_NODE === 3\n                // Node.ELEMENT_NODE === 1\n                // Node.COMMENT_NODE === 8\n                // Check if the container is a text node and return its parent if so\n                container = container.nodeType === 3 ? container.parentNode : container;\n                // get the nodes in the range that are ELEMENT_NODE and are children of the container\n                // in this range...\n                var selectedNodes = range.getNodes([1], function(node){\n                    return node.parentNode === container;\n                });\n                var innerHtml = container.innerHTML;\n                // remove the junk that rangy has put down\n                innerHtml = innerHtml.replace(/<span id=.selectionBoundary[^>]+>\\ufeff?<\\/span>/ig, '');\n                //console.log(innerHtml);\n                //console.log(range.toHtml());\n                //console.log(innerHtml === range.toHtml());\n                if (innerHtml === range.toHtml() &&\n                    // not the whole taTextElement\n                    (!(container.nodeName.toLowerCase() === 'div' &&  /^taTextElement/.test(container.id)))\n                ) {\n                    var arr = [];\n                    for(var i = selectedNodes.length; i--; arr.unshift(selectedNodes[i]));\n                    selectedNodes = arr;\n                    selectedNodes.push(container);\n                    //$log.debug(selectedNodes);\n                }\n                return selectedNodes;\n            },\n            // Some basic selection functions\n            getSelectionElement: function () {\n                var s = api.getSelection();\n                if (s) {\n                    return api.getSelection().container;\n                } else {\n                    return undefined;\n                }\n            },\n            setSelection: function(elStart, elEnd, start, end){\n                var range = rangy.createRange();\n\n                range.setStart(elStart, start);\n                range.setEnd(elEnd, end);\n\n                rangy.getSelection().setSingleRange(range);\n            },\n            setSelectionBeforeElement: function (el){\n                var range = rangy.createRange();\n\n                range.selectNode(el);\n                range.collapse(true);\n\n                rangy.getSelection().setSingleRange(range);\n            },\n            setSelectionAfterElement: function (el){\n                var range = rangy.createRange();\n\n                range.selectNode(el);\n                range.collapse(false);\n\n                rangy.getSelection().setSingleRange(range);\n            },\n            setSelectionToElementStart: function (el){\n                var range = rangy.createRange();\n\n                range.selectNodeContents(el);\n                range.collapse(true);\n\n                rangy.getSelection().setSingleRange(range);\n            },\n            setSelectionToElementEnd: function (el){\n                var range = rangy.createRange();\n\n                range.selectNodeContents(el);\n                range.collapse(false);\n                if(el.childNodes && el.childNodes[el.childNodes.length - 1] && el.childNodes[el.childNodes.length - 1].nodeName === 'br'){\n                    range.startOffset = range.endOffset = range.startOffset - 1;\n                }\n                rangy.getSelection().setSingleRange(range);\n            },\n            setStateShiftKey: function(bS) {\n                bShiftState = bS;\n            },\n            getStateShiftKey: function() {\n                return bShiftState;\n            },\n            // from http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div\n            // topNode is the contenteditable normally, all manipulation MUST be inside this.\n            insertHtml: function(html, topNode){\n                var parent, secondParent, _childI, nodes, i, lastNode, _tempFrag;\n                var element = angular.element(\"<div>\" + html + \"</div>\");\n                var range = rangy.getSelection().getRangeAt(0);\n                var frag = _document.createDocumentFragment();\n                var children = element[0].childNodes;\n                var isInline = true;\n\n                if(children.length > 0){\n                    // NOTE!! We need to do the following:\n                    // check for blockelements - if they exist then we have to split the current element in half (and all others up to the closest block element) and insert all children in-between.\n                    // If there are no block elements, or there is a mixture we need to create textNodes for the non wrapped text (we don't want them spans messing up the picture).\n                    nodes = [];\n                    for(_childI = 0; _childI < children.length; _childI++){\n                        var _cnode = children[_childI];\n                        if (_cnode.nodeName.toLowerCase() === 'p' &&\n                            _cnode.innerHTML.trim() === '') { // empty p element\n                            continue;\n                        }\n                        /****************\n                         *  allow any text to be inserted...\n                         if((   _cnode.nodeType === 3 &&\n                         _cnode.nodeValue === '\\ufeff'[0] &&\n                         _cnode.nodeValue.trim() === '') // empty no-space space element\n                         ) {\n                        // no change to isInline\n                        nodes.push(_cnode);\n                        continue;\n                    }\n                         if(_cnode.nodeType === 3 &&\n                         _cnode.nodeValue.trim() === '') { // empty text node\n                        continue;\n                    }\n                         *****************/\n                        isInline = isInline && !BLOCKELEMENTS.test(_cnode.nodeName);\n                        nodes.push(_cnode);\n                    }\n                    for(var _n = 0; _n < nodes.length; _n++) {\n                        lastNode = frag.appendChild(nodes[_n]);\n                    }\n                    if( !isInline &&\n                        range.collapsed &&\n                        /^(|<br(|\\/)>)$/i.test(range.startContainer.innerHTML) ) {\n                        range.selectNode(range.startContainer);\n                    }\n                }else{\n                    isInline = true;\n                    // paste text of some sort\n                    lastNode = frag = _document.createTextNode(html);\n                }\n\n                // Other Edge case - selected data spans multiple blocks.\n                if(isInline){\n                    range.deleteContents();\n                }else{ // not inline insert\n                    if(range.collapsed && range.startContainer !== topNode){\n                        if(range.startContainer.innerHTML && range.startContainer.innerHTML.match(/^<[^>]*>$/i)){\n                            // this log is to catch when innerHTML is something like `<img ...>`\n                            parent = range.startContainer;\n                            if(range.startOffset === 1){\n                                // before single tag\n                                range.setStartAfter(parent);\n                                range.setEndAfter(parent);\n                            }else{\n                                // after single tag\n                                range.setStartBefore(parent);\n                                range.setEndBefore(parent);\n                            }\n                        }else{\n                            // split element into 2 and insert block element in middle\n                            if(range.startContainer.nodeType === 3 && range.startContainer.parentNode !== topNode){ // if text node\n                                parent = range.startContainer.parentNode;\n                                secondParent = parent.cloneNode();\n                                // split the nodes into two lists - before and after, splitting the node with the selection into 2 text nodes.\n                                taDOM.splitNodes(parent.childNodes, parent, secondParent, range.startContainer, range.startOffset);\n\n                                // Escape out of the inline tags like b\n                                while(!VALIDELEMENTS.test(parent.nodeName)){\n                                    angular.element(parent).after(secondParent);\n                                    parent = parent.parentNode;\n                                    var _lastSecondParent = secondParent;\n                                    secondParent = parent.cloneNode();\n                                    // split the nodes into two lists - before and after, splitting the node with the selection into 2 text nodes.\n                                    taDOM.splitNodes(parent.childNodes, parent, secondParent, _lastSecondParent);\n                                }\n                            }else{\n                                parent = range.startContainer;\n                                secondParent = parent.cloneNode();\n                                taDOM.splitNodes(parent.childNodes, parent, secondParent, undefined, undefined, range.startOffset);\n                            }\n\n                            angular.element(parent).after(secondParent);\n                            // put cursor to end of inserted content\n                            //console.log('setStartAfter', parent);\n                            range.setStartAfter(parent);\n                            range.setEndAfter(parent);\n\n                            if(/^(|<br(|\\/)>)$/i.test(parent.innerHTML.trim())){\n                                range.setStartBefore(parent);\n                                range.setEndBefore(parent);\n                                angular.element(parent).remove();\n                            }\n                            if(/^(|<br(|\\/)>)$/i.test(secondParent.innerHTML.trim())) angular.element(secondParent).remove();\n                            if(parent.nodeName.toLowerCase() === 'li'){\n                                _tempFrag = _document.createDocumentFragment();\n                                for(i = 0; i < frag.childNodes.length; i++){\n                                    element = angular.element('<li>');\n                                    taDOM.transferChildNodes(frag.childNodes[i], element[0]);\n                                    taDOM.transferNodeAttributes(frag.childNodes[i], element[0]);\n                                    _tempFrag.appendChild(element[0]);\n                                }\n                                frag = _tempFrag;\n                                if(lastNode){\n                                    lastNode = frag.childNodes[frag.childNodes.length - 1];\n                                    lastNode = lastNode.childNodes[lastNode.childNodes.length - 1];\n                                }\n                            }\n                        }\n                    }else{\n                        range.deleteContents();\n                    }\n                }\n\n                range.insertNode(frag);\n                if(lastNode){\n                    api.setSelectionToElementEnd(lastNode);\n                }\n            }\n\n            /* NOT FUNCTIONAL YET\n             // under Firefox, we may have a selection that needs to be normalized\n             isSelectionContainerWhole_taTextElement: function (){\n             var range = rangy.getSelection().getRangeAt(0);\n             var container = range.commonAncestorContainer;\n             if (container.nodeName.toLowerCase() === 'div' &&\n             /^taTextElement/.test(container.id)) {\n             // container is the whole taTextElement\n             return true;\n             }\n             return false;\n             },\n             setNormalizedSelection: function (){\n             var range = rangy.getSelection().getRangeAt(0);\n             var container = range.commonAncestorContainer;\n             console.log(range);\n             console.log(container.childNodes);\n             if (range.collapsed) {\n             // we know what to do...\n             console.log(container.childNodes[range.startOffset]);\n             api.setSelectionToElementStart(container.childNodes[range.startOffset]);\n             }\n             },\n             */\n        };\n        return api;\n    }]).service('taDOM', function(){\n    var taDOM = {\n        // recursive function that returns an array of angular.elements that have the passed attribute set on them\n        getByAttribute: function(element, attribute){\n            var resultingElements = [];\n            var childNodes = element.children();\n            if(childNodes.length){\n                angular.forEach(childNodes, function(child){\n                    resultingElements = resultingElements.concat(taDOM.getByAttribute(angular.element(child), attribute));\n                });\n            }\n            if(element.attr(attribute) !== undefined) resultingElements.push(element);\n            return resultingElements;\n        },\n\n        transferChildNodes: function(source, target){\n            // clear out target\n            target.innerHTML = '';\n            while(source.childNodes.length > 0) target.appendChild(source.childNodes[0]);\n            return target;\n        },\n\n        splitNodes: function(nodes, target1, target2, splitNode, subSplitIndex, splitIndex){\n            if(!splitNode && isNaN(splitIndex)) throw new Error('taDOM.splitNodes requires a splitNode or splitIndex');\n            var startNodes = document.createDocumentFragment();\n            var endNodes = document.createDocumentFragment();\n            var index = 0;\n\n            while(nodes.length > 0 && (isNaN(splitIndex) || splitIndex !== index) && nodes[0] !== splitNode){\n                startNodes.appendChild(nodes[0]); // this removes from the nodes array (if proper childNodes object.\n                index++;\n            }\n\n            if(!isNaN(subSplitIndex) && subSplitIndex >= 0 && nodes[0]){\n                startNodes.appendChild(document.createTextNode(nodes[0].nodeValue.substring(0, subSplitIndex)));\n                nodes[0].nodeValue = nodes[0].nodeValue.substring(subSplitIndex);\n            }\n            while(nodes.length > 0) endNodes.appendChild(nodes[0]);\n\n            taDOM.transferChildNodes(startNodes, target1);\n            taDOM.transferChildNodes(endNodes, target2);\n        },\n\n        transferNodeAttributes: function(source, target){\n            for(var i = 0; i < source.attributes.length; i++) target.setAttribute(source.attributes[i].name, source.attributes[i].value);\n            return target;\n        }\n    };\n    return taDOM;\n});\n\nangular.module('textAngular.validators', [])\n    .directive('taMaxText', function(){\n        return {\n            restrict: 'A',\n            require: 'ngModel',\n            link: function(scope, elem, attrs, ctrl){\n                var max = parseInt(scope.$eval(attrs.taMaxText));\n                if (isNaN(max)){\n                    throw('Max text must be an integer');\n                }\n                attrs.$observe('taMaxText', function(value){\n                    max = parseInt(value);\n                    if (isNaN(max)){\n                        throw('Max text must be an integer');\n                    }\n                    if (ctrl.$dirty){\n                        ctrl.$validate();\n                    }\n                });\n                ctrl.$validators.taMaxText = function(viewValue){\n                    var source = angular.element('<div/>');\n                    source.html(viewValue);\n                    return source.text().length <= max;\n                };\n            }\n        };\n    }).directive('taMinText', function(){\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function(scope, elem, attrs, ctrl){\n            var min = parseInt(scope.$eval(attrs.taMinText));\n            if (isNaN(min)){\n                throw('Min text must be an integer');\n            }\n            attrs.$observe('taMinText', function(value){\n                min = parseInt(value);\n                if (isNaN(min)){\n                    throw('Min text must be an integer');\n                }\n                if (ctrl.$dirty){\n                    ctrl.$validate();\n                }\n            });\n            ctrl.$validators.taMinText = function(viewValue){\n                var source = angular.element('<div/>');\n                source.html(viewValue);\n                return !source.text().length || source.text().length >= min;\n            };\n        }\n    };\n});\nangular.module('textAngular.taBind', ['textAngular.factories', 'textAngular.DOM'])\n    .service('_taBlankTest', [function(){\n        return function(_blankVal){\n            // we radically restructure this code.\n            // what was here before was incredibly fragile.\n            // What we do now is to check that the html is non-blank visually\n            // which we check by looking at html->text\n            if(!_blankVal) return true;\n            // find first non-tag match - ie start of string or after tag that is not whitespace\n            // var t0 = performance.now();\n            // Takes a small fraction of a mSec to do this...\n            var _text_ = stripHtmlToText(_blankVal);\n            // var t1 = performance.now();\n            // console.log('Took', (t1 - t0).toFixed(4), 'milliseconds to generate:');\n            if (_text_=== '') {\n                // img generates a visible item so it is not blank!\n                if (/<img[^>]+>/.test(_blankVal)) {\n                    return false;\n                }\n                return true;\n            } else {\n                return false;\n            }\n        };\n    }])\n    .directive('taButton', [function(){\n        return {\n            link: function(scope, element, attrs){\n                element.attr('unselectable', 'on');\n                element.on('mousedown', function(e, eventData){\n                    /* istanbul ignore else: this is for catching the jqLite testing*/\n                    if(eventData) angular.extend(e, eventData);\n                    // this prevents focusout from firing on the editor when clicking toolbar buttons\n                    e.preventDefault();\n                    return false;\n                });\n            }\n        };\n    }])\n    .directive('taBind', [\n        'taSanitize', '$timeout', '$document', 'taFixChrome', 'taBrowserTag',\n        'taSelection', 'taSelectableElements', 'taApplyCustomRenderers', 'taOptions',\n        '_taBlankTest', '$parse', 'taDOM', 'textAngularManager',\n        function(\n            taSanitize, $timeout, $document, taFixChrome, taBrowserTag,\n            taSelection, taSelectableElements, taApplyCustomRenderers, taOptions,\n            _taBlankTest, $parse, taDOM, textAngularManager){\n            // Uses for this are textarea or input with ng-model and ta-bind='text'\n            // OR any non-form element with contenteditable=\"contenteditable\" ta-bind=\"html|text\" ng-model\n            return {\n                priority: 2, // So we override validators correctly\n                require: ['ngModel','?ngModelOptions'],\n                link: function(scope, element, attrs, controller){\n                    var ngModel = controller[0];\n                    var ngModelOptions = controller[1] || {};\n                    // the option to use taBind on an input or textarea is required as it will sanitize all input into it correctly.\n                    var _isContentEditable = element.attr('contenteditable') !== undefined && element.attr('contenteditable');\n                    var _isInputFriendly = _isContentEditable || element[0].tagName.toLowerCase() === 'textarea' || element[0].tagName.toLowerCase() === 'input';\n                    var _isReadonly = false;\n                    var _focussed = false;\n                    var _skipRender = false;\n                    var _disableSanitizer = attrs.taUnsafeSanitizer || taOptions.disableSanitizer;\n                    var _keepStyles = attrs.taKeepStyles || taOptions.keepStyles;\n                    var _lastKey;\n                    // see http://www.javascripter.net/faq/keycodes.htm for good information\n                    // NOTE Mute On|Off 173 (Opera MSIE Safari Chrome) 181 (Firefox)\n                    // BLOCKED_KEYS are special keys...\n                    // Tab, pause/break, CapsLock, Esc, Page Up, End, Home,\n                    // Left arrow, Up arrow, Right arrow, Down arrow, Insert, Delete,\n                    // f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12\n                    // NumLock, ScrollLock\n                    var BLOCKED_KEYS = /^(9|19|20|27|33|34|35|36|37|38|39|40|45|112|113|114|115|116|117|118|119|120|121|122|123|144|145)$/i;\n                    // UNDO_TRIGGER_KEYS - spaces, enter, delete, backspace, all punctuation\n                    // Backspace, Enter, Space, Delete, (; :) (Firefox), (= +) (Firefox),\n                    // Numpad +, Numpad -, (; :), (= +),\n                    // (, <), (- _), (. >), (/ ?), (` ~), ([ {), (\\ |), (] }), (' \")\n                    // NOTE - Firefox: 173 = (- _) -- adding this to UNDO_TRIGGER_KEYS\n                    var UNDO_TRIGGER_KEYS = /^(8|13|32|46|59|61|107|109|173|186|187|188|189|190|191|192|219|220|221|222)$/i;\n                    var _pasteHandler;\n\n                    // defaults to the paragraph element, but we need the line-break or it doesn't allow you to type into the empty element\n                    // non IE is '<p><br/></p>', ie is '<p></p>' as for once IE gets it correct...\n                    var _defaultVal, _defaultTest;\n\n                    var _CTRL_KEY = 0x0001;\n                    var _META_KEY = 0x0002;\n                    var _ALT_KEY = 0x0004;\n                    var _SHIFT_KEY = 0x0008;\n                    // KEYCODEs we use\n                    var _ENTER_KEYCODE = 13;\n                    var _SHIFT_KEYCODE = 16;\n                    var _TAB_KEYCODE = 9;\n                    var _LEFT_ARROW_KEYCODE = 37;\n                    var _RIGHT_ARROW_KEYCODE = 39;\n                    // map events to special keys...\n                    // mappings is an array of maps from events to specialKeys as declared in textAngularSetup\n                    var _keyMappings = [\n                        //\t\tctrl/command + z\n                        {\n                            specialKey: 'UndoKey',\n                            forbiddenModifiers: _ALT_KEY + _SHIFT_KEY,\n                            mustHaveModifiers: [_META_KEY + _CTRL_KEY],\n                            keyCode: 90\n                        },\n                        //\t\tctrl/command + shift + z\n                        {\n                            specialKey: 'RedoKey',\n                            forbiddenModifiers: _ALT_KEY,\n                            mustHaveModifiers: [_META_KEY + _CTRL_KEY, _SHIFT_KEY],\n                            keyCode: 90\n                        },\n                        //\t\tctrl/command + y\n                        {\n                            specialKey: 'RedoKey',\n                            forbiddenModifiers: _ALT_KEY + _SHIFT_KEY,\n                            mustHaveModifiers: [_META_KEY + _CTRL_KEY],\n                            keyCode: 89\n                        },\n                        //\t\tTabKey\n                        {\n                            specialKey: 'TabKey',\n                            forbiddenModifiers: _META_KEY + _SHIFT_KEY + _ALT_KEY + _CTRL_KEY,\n                            mustHaveModifiers: [],\n                            keyCode: _TAB_KEYCODE\n                        },\n                        //\t\tshift + TabKey\n                        {\n                            specialKey: 'ShiftTabKey',\n                            forbiddenModifiers: _META_KEY + _ALT_KEY + _CTRL_KEY,\n                            mustHaveModifiers: [_SHIFT_KEY],\n                            keyCode: _TAB_KEYCODE\n                        }\n                    ];\n                    function _mapKeys(event) {\n                        var specialKey;\n                        _keyMappings.forEach(function (map){\n                            if (map.keyCode === event.keyCode) {\n                                var netModifiers = (event.metaKey ? _META_KEY: 0) +\n                                    (event.ctrlKey ? _CTRL_KEY: 0) +\n                                    (event.shiftKey ? _SHIFT_KEY: 0) +\n                                    (event.altKey ? _ALT_KEY: 0);\n                                if (map.forbiddenModifiers & netModifiers) return;\n                                if (map.mustHaveModifiers.every(function (modifier) { return netModifiers & modifier; })){\n                                    specialKey = map.specialKey;\n                                }\n                            }\n                        });\n                        return specialKey;\n                    }\n\n                    // set the default to be a paragraph value\n                    if(attrs.taDefaultWrap === undefined) attrs.taDefaultWrap = 'p';\n                    /* istanbul ignore next: ie specific test */\n                    if(attrs.taDefaultWrap === ''){\n                        _defaultVal = '';\n                        _defaultTest = (_browserDetect.ie === undefined)? '<div><br></div>' : (_browserDetect.ie >= 11)? '<p><br></p>' : (_browserDetect.ie <= 8)? '<P>&nbsp;</P>' : '<p>&nbsp;</p>';\n                    }else{\n                        _defaultVal = (_browserDetect.ie === undefined || _browserDetect.ie >= 11)?\n                            (attrs.taDefaultWrap.toLowerCase() === 'br' ? '<BR><BR>' : '<' + attrs.taDefaultWrap + '><br></' + attrs.taDefaultWrap + '>') :\n                            (_browserDetect.ie <= 8)?\n                            '<' + attrs.taDefaultWrap.toUpperCase() + '></' + attrs.taDefaultWrap.toUpperCase() + '>' :\n                            '<' + attrs.taDefaultWrap + '></' + attrs.taDefaultWrap + '>';\n                        _defaultTest = (_browserDetect.ie === undefined || _browserDetect.ie >= 11)?\n                            (attrs.taDefaultWrap.toLowerCase() === 'br' ? '<br><br>' : '<' + attrs.taDefaultWrap + '><br></' + attrs.taDefaultWrap + '>') :\n                            (_browserDetect.ie <= 8)?\n                            '<' + attrs.taDefaultWrap.toUpperCase() + '>&nbsp;</' + attrs.taDefaultWrap.toUpperCase() + '>' :\n                            '<' + attrs.taDefaultWrap + '>&nbsp;</' + attrs.taDefaultWrap + '>';\n                    }\n\n                    /* istanbul ignore else */\n                    if(!ngModelOptions.$options) ngModelOptions.$options = {}; // ng-model-options support\n\n                    var _ensureContentWrapped = function(value) {\n                        if (_taBlankTest(value)) return value;\n                        var domTest = angular.element(\"<div>\" + value + \"</div>\");\n                        //console.log('domTest.children().length():', domTest.children().length);\n                        //console.log('_ensureContentWrapped', domTest.children());\n                        //console.log(value, attrs.taDefaultWrap);\n                        if (domTest.children().length === 0) {\n                            // if we have a <br> and the attrs.taDefaultWrap is a <p> we need to remove the <br>\n                            //value = value.replace(/<br>/i, '');\n                            value = \"<\" + attrs.taDefaultWrap + \">\" + value + \"</\" + attrs.taDefaultWrap + \">\";\n                        } else {\n                            var _children = domTest[0].childNodes;\n                            var i;\n                            var _foundBlockElement = false;\n                            for (i = 0; i < _children.length; i++) {\n                                if (_foundBlockElement = _children[i].nodeName.toLowerCase().match(BLOCKELEMENTS)) break;\n                            }\n                            if (!_foundBlockElement) {\n                                value = \"<\" + attrs.taDefaultWrap + \">\" + value + \"</\" + attrs.taDefaultWrap + \">\";\n                            }\n                            else{\n                                value = \"\";\n                                for(i = 0; i < _children.length; i++){\n                                    var node = _children[i];\n                                    var nodeName = node.nodeName.toLowerCase();\n                                    //console.log('node#:', i, 'name:', nodeName);\n                                    if(nodeName === '#comment') {\n                                        value += '<!--' + node.nodeValue + '-->';\n                                    } else if(nodeName === '#text') {\n                                        // determine if this is all whitespace, if so, we will leave it as it is.\n                                        // otherwise, we will wrap it as it is\n                                        var text = node.textContent;\n                                        if (!text.trim()) {\n                                            // just whitespace\n                                            value += text;\n                                        } else {\n                                            // not pure white space so wrap in <p>...</p> or whatever attrs.taDefaultWrap is set to.\n                                            value += \"<\" + attrs.taDefaultWrap + \">\" + text + \"</\" + attrs.taDefaultWrap + \">\";\n                                        }\n                                    } else if(!nodeName.match(BLOCKELEMENTS)){\n                                        /* istanbul ignore  next: Doesn't seem to trigger on tests */\n                                        var _subVal = (node.outerHTML || node.nodeValue);\n                                        /* istanbul ignore else: Doesn't seem to trigger on tests, is tested though */\n                                        if(_subVal.trim() !== '')\n                                            value += \"<\" + attrs.taDefaultWrap + \">\" + _subVal + \"</\" + attrs.taDefaultWrap + \">\";\n                                        else value += _subVal;\n                                    } else {\n                                        value += node.outerHTML;\n                                    }\n                                    //console.log(value);\n                                }\n                            }\n                        }\n                        //console.log(value);\n                        return value;\n                    };\n\n                    if(attrs.taPaste) {\n                        _pasteHandler = $parse(attrs.taPaste);\n                    }\n\n                    element.addClass('ta-bind');\n\n                    var _undoKeyupTimeout;\n\n                    scope['$undoManager' + (attrs.id || '')] = ngModel.$undoManager = {\n                        _stack: [],\n                        _index: 0,\n                        _max: 1000,\n                        push: function(value){\n                            if((typeof value === \"undefined\" || value === null) ||\n                                ((typeof this.current() !== \"undefined\" && this.current() !== null) && value === this.current())) return value;\n                            if(this._index < this._stack.length - 1){\n                                this._stack = this._stack.slice(0,this._index+1);\n                            }\n                            this._stack.push(value);\n                            if(_undoKeyupTimeout) $timeout.cancel(_undoKeyupTimeout);\n                            if(this._stack.length > this._max) this._stack.shift();\n                            this._index = this._stack.length - 1;\n                            return value;\n                        },\n                        undo: function(){\n                            return this.setToIndex(this._index-1);\n                        },\n                        redo: function(){\n                            return this.setToIndex(this._index+1);\n                        },\n                        setToIndex: function(index){\n                            if(index < 0 || index > this._stack.length - 1){\n                                return undefined;\n                            }\n                            this._index = index;\n                            return this.current();\n                        },\n                        current: function(){\n                            return this._stack[this._index];\n                        }\n                    };\n\n                    // in here we are undoing the converts used elsewhere to prevent the < > and & being displayed when they shouldn't in the code.\n                    var _compileHtml = function(){\n                        if(_isContentEditable) {\n                            return element[0].innerHTML;\n                        }\n                        if(_isInputFriendly) {\n                            return element.val();\n                        }\n                        throw ('textAngular Error: attempting to update non-editable taBind');\n                    };\n\n                    var selectorClickHandler = function(event){\n                        // emit the element-select event, pass the element\n                        scope.$emit('ta-element-select', this);\n                        event.preventDefault();\n                        return false;\n                    };\n\n                    //used for updating when inserting wrapped elements\n                    var _reApplyOnSelectorHandlers = scope['reApplyOnSelectorHandlers' + (attrs.id || '')] = function(){\n                        /* istanbul ignore else */\n                        if(!_isReadonly) angular.forEach(taSelectableElements, function(selector){\n                            // check we don't apply the handler twice\n                            element.find(selector)\n                                .off('click', selectorClickHandler)\n                                .on('click', selectorClickHandler);\n                        });\n                    };\n\n                    var _setViewValue = function(_val, triggerUndo, skipRender){\n                        _skipRender = skipRender || false;\n                        if(typeof triggerUndo === \"undefined\" || triggerUndo === null) triggerUndo = true && _isContentEditable; // if not contentEditable then the native undo/redo is fine\n                        if(typeof _val === \"undefined\" || _val === null) _val = _compileHtml();\n                        if(_taBlankTest(_val)){\n                            // this avoids us from tripping the ng-pristine flag if we click in and out with out typing\n                            if(ngModel.$viewValue !== '') ngModel.$setViewValue('');\n                            if(triggerUndo && ngModel.$undoManager.current() !== '') ngModel.$undoManager.push('');\n                        }else{\n                            _reApplyOnSelectorHandlers();\n                            if(ngModel.$viewValue !== _val){\n                                ngModel.$setViewValue(_val);\n                                if(triggerUndo) ngModel.$undoManager.push(_val);\n                            }\n                        }\n                        ngModel.$render();\n                    };\n\n                    var _setInnerHTML = function(newval){\n                        element[0].innerHTML = newval;\n                    };\n\n                    var _redoUndoTimeout;\n                    var _undo = scope['$undoTaBind' + (attrs.id || '')] = function(){\n                        /* istanbul ignore else: can't really test it due to all changes being ignored as well in readonly */\n                        if(!_isReadonly && _isContentEditable){\n                            var content = ngModel.$undoManager.undo();\n                            if(typeof content !== \"undefined\" && content !== null){\n                                _setInnerHTML(content);\n                                _setViewValue(content, false);\n                                if(_redoUndoTimeout) $timeout.cancel(_redoUndoTimeout);\n                                _redoUndoTimeout = $timeout(function(){\n                                    element[0].focus();\n                                    taSelection.setSelectionToElementEnd(element[0]);\n                                }, 1);\n                            }\n                        }\n                    };\n\n                    var _redo = scope['$redoTaBind' + (attrs.id || '')] = function(){\n                        /* istanbul ignore else: can't really test it due to all changes being ignored as well in readonly */\n                        if(!_isReadonly && _isContentEditable){\n                            var content = ngModel.$undoManager.redo();\n                            if(typeof content !== \"undefined\" && content !== null){\n                                _setInnerHTML(content);\n                                _setViewValue(content, false);\n                                /* istanbul ignore next */\n                                if(_redoUndoTimeout) $timeout.cancel(_redoUndoTimeout);\n                                _redoUndoTimeout = $timeout(function(){\n                                    element[0].focus();\n                                    taSelection.setSelectionToElementEnd(element[0]);\n                                }, 1);\n                            }\n                        }\n                    };\n\n                    //used for updating when inserting wrapped elements\n                    scope['updateTaBind' + (attrs.id || '')] = function(){\n                        if(!_isReadonly) _setViewValue(undefined, undefined, true);\n                    };\n\n                    // catch DOM XSS via taSanitize\n                    // Sanitizing both ways is identical\n                    var _sanitize = function(unsafe){\n                        return (ngModel.$oldViewValue = taSanitize(taFixChrome(unsafe, _keepStyles), ngModel.$oldViewValue, _disableSanitizer));\n                    };\n\n                    // trigger the validation calls\n                    if(element.attr('required')) ngModel.$validators.required = function(modelValue, viewValue) {\n                        return !_taBlankTest(modelValue || viewValue);\n                    };\n                    // parsers trigger from the above keyup function or any other time that the viewValue is updated and parses it for storage in the ngModel\n                    ngModel.$parsers.push(_sanitize);\n                    ngModel.$parsers.unshift(_ensureContentWrapped);\n                    // because textAngular is bi-directional (which is awesome) we need to also sanitize values going in from the server\n                    ngModel.$formatters.push(_sanitize);\n                    ngModel.$formatters.unshift(_ensureContentWrapped);\n                    ngModel.$formatters.unshift(function(value){\n                        return ngModel.$undoManager.push(value || '');\n                    });\n\n                    //this code is used to update the models when data is entered/deleted\n                    if(_isInputFriendly){\n                        scope.events = {};\n                        if(!_isContentEditable){\n                            // if a textarea or input just add in change and blur handlers, everything else is done by angulars input directive\n                            element.on('change blur', scope.events.change = scope.events.blur = function(){\n                                if(!_isReadonly) ngModel.$setViewValue(_compileHtml());\n                            });\n\n                            element.on('keydown', scope.events.keydown = function(event, eventData){\n                                /* istanbul ignore else: this is for catching the jqLite testing*/\n                                if(eventData) angular.extend(event, eventData);\n                                // Reference to http://stackoverflow.com/questions/6140632/how-to-handle-tab-in-textarea\n                                /* istanbul ignore else: otherwise normal functionality */\n                                if(event.keyCode === _TAB_KEYCODE){ // tab was pressed\n                                    // get caret position/selection\n                                    var start = this.selectionStart;\n                                    var end = this.selectionEnd;\n\n                                    var value = element.val();\n                                    if(event.shiftKey){\n                                        // find \\t\n                                        var _linebreak = value.lastIndexOf('\\n', start), _tab = value.lastIndexOf('\\t', start);\n                                        if(_tab !== -1 && _tab >= _linebreak){\n                                            // set textarea value to: text before caret + tab + text after caret\n                                            element.val(value.substring(0, _tab) + value.substring(_tab + 1));\n\n                                            // put caret at right position again (add one for the tab)\n                                            this.selectionStart = this.selectionEnd = start - 1;\n                                        }\n                                    }else{\n                                        // set textarea value to: text before caret + tab + text after caret\n                                        element.val(value.substring(0, start) + \"\\t\" + value.substring(end));\n\n                                        // put caret at right position again (add one for the tab)\n                                        this.selectionStart = this.selectionEnd = start + 1;\n                                    }\n                                    // prevent the focus lose\n                                    event.preventDefault();\n                                }\n                            });\n\n                            var _repeat = function(string, n){\n                                var result = '';\n                                for(var _n = 0; _n < n; _n++) result += string;\n                                return result;\n                            };\n\n                            // add a forEach function that will work on a NodeList, etc..\n                            var forEach = function (array, callback, scope) {\n                                for (var i= 0; i<array.length; i++) {\n                                    callback.call(scope, i, array[i]);\n                                }\n                            };\n\n                            // handle <ul> or <ol> nodes\n                            var recursiveListFormat = function(listNode, tablevel){\n                                var _html = '';\n                                var _subnodes = listNode.childNodes;\n                                tablevel++;\n                                // tab out and add the <ul> or <ol> html piece\n                                _html += _repeat('\\t', tablevel-1) + listNode.outerHTML.substring(0, 4);\n                                forEach(_subnodes, function (index, node) {\n                                    /* istanbul ignore next: browser catch */\n                                    var nodeName = node.nodeName.toLowerCase();\n                                    if (nodeName === '#comment') {\n                                        _html += '<!--' + node.nodeValue + '-->';\n                                        return;\n                                    }\n                                    if (nodeName === '#text') {\n                                        _html += node.textContent;\n                                        return;\n                                    }\n                                    /* istanbul ignore next: not tested, and this was original code -- so not wanting to possibly cause an issue, leaving it... */\n                                    if(!node.outerHTML) {\n                                        // no html to add\n                                        return;\n                                    }\n                                    if(nodeName === 'ul' || nodeName === 'ol') {\n                                        _html += '\\n' + recursiveListFormat(node, tablevel);\n                                    }\n                                    else {\n                                        // no reformatting within this subnode, so just do the tabing...\n                                        _html += '\\n' + _repeat('\\t', tablevel) + node.outerHTML;\n                                    }\n                                });\n                                // now add on the </ol> or </ul> piece\n                                _html += '\\n' + _repeat('\\t', tablevel-1) + listNode.outerHTML.substring(listNode.outerHTML.lastIndexOf('<'));\n                                return _html;\n                            };\n                            // handle formating of something like:\n                            // <ol><!--First comment-->\n                            //  <li>Test Line 1<!--comment test list 1--></li>\n                            //    <ul><!--comment ul-->\n                            //      <li>Nested Line 1</li>\n                            //        <!--comment between nested lines--><li>Nested Line 2</li>\n                            //    </ul>\n                            //  <li>Test Line 3</li>\n                            // </ol>\n                            ngModel.$formatters.unshift(function(htmlValue){\n                                // tabulate the HTML so it looks nicer\n                                //\n                                // first get a list of the nodes...\n                                // we do this by using the element parser...\n                                //\n                                // doing this -- which is simpiler -- breaks our tests...\n                                //var _nodes=angular.element(htmlValue);\n                                var _nodes = angular.element('<div>' + htmlValue + '</div>')[0].childNodes;\n                                if(_nodes.length > 0){\n                                    // do the reformatting of the layout...\n                                    htmlValue = '';\n                                    forEach(_nodes, function (index, node) {\n                                        var nodeName = node.nodeName.toLowerCase();\n                                        if (nodeName === '#comment') {\n                                            htmlValue += '<!--' + node.nodeValue + '-->';\n                                            return;\n                                        }\n                                        if (nodeName === '#text') {\n                                            htmlValue += node.textContent;\n                                            return;\n                                        }\n                                        /* istanbul ignore next: not tested, and this was original code -- so not wanting to possibly cause an issue, leaving it... */\n                                        if(!node.outerHTML)\n                                        {\n                                            // nothing to format!\n                                            return;\n                                        }\n                                        if(htmlValue.length > 0) {\n                                            // we aready have some content, so drop to a new line\n                                            htmlValue += '\\n';\n                                        }\n                                        if(nodeName === 'ul' || nodeName === 'ol') {\n                                            // okay a set of list stuff we want to reformat in a nested way\n                                            htmlValue += '' + recursiveListFormat(node, 0);\n                                        }\n                                        else {\n                                            // just use the original without any additional formating\n                                            htmlValue += '' + node.outerHTML;\n                                        }\n                                    });\n                                }\n                                return htmlValue;\n                            });\n                        }else{\n                            // all the code specific to contenteditable divs\n                            var _processingPaste = false;\n                            /* istanbul ignore next: phantom js cannot test this for some reason */\n                            var processpaste = function(text) {\n                                var _isOneNote = text!==undefined? text.match(/content=[\"']*OneNote.File/i): false;\n                                /* istanbul ignore else: don't care if nothing pasted */\n                                //console.log(text);\n                                if(text && text.trim().length){\n                                    // test paste from word/microsoft product\n                                    if(text.match(/class=[\"']*Mso(Normal|List)/i) || text.match(/content=[\"']*Word.Document/i) || text.match(/content=[\"']*OneNote.File/i)){\n                                        var textFragment = text.match(/<!--StartFragment-->([\\s\\S]*?)<!--EndFragment-->/i);\n                                        if(!textFragment) textFragment = text;\n                                        else textFragment = textFragment[1];\n                                        textFragment = textFragment.replace(/<o:p>[\\s\\S]*?<\\/o:p>/ig, '').replace(/class=([\"']|)MsoNormal([\"']|)/ig, '');\n                                        var dom = angular.element(\"<div>\" + textFragment + \"</div>\");\n                                        var targetDom = angular.element(\"<div></div>\");\n                                        var _list = {\n                                            element: null,\n                                            lastIndent: [],\n                                            lastLi: null,\n                                            isUl: false\n                                        };\n                                        _list.lastIndent.peek = function(){\n                                            var n = this.length;\n                                            if (n>0) return this[n-1];\n                                        };\n                                        var _resetList = function(isUl){\n                                            _list.isUl = isUl;\n                                            _list.element = angular.element(isUl ? \"<ul>\" : \"<ol>\");\n                                            _list.lastIndent = [];\n                                            _list.lastIndent.peek = function(){\n                                                var n = this.length;\n                                                if (n>0) return this[n-1];\n                                            };\n                                            _list.lastLevelMatch = null;\n                                        };\n                                        for(var i = 0; i <= dom[0].childNodes.length; i++){\n                                            if(!dom[0].childNodes[i] || dom[0].childNodes[i].nodeName === \"#text\"){\n                                                continue;\n                                            } else {\n                                                var tagName = dom[0].childNodes[i].tagName.toLowerCase();\n                                                if(tagName !== 'p' &&\n                                                    tagName !== 'ul' &&\n                                                    tagName !== 'h1' &&\n                                                    tagName !== 'h2' &&\n                                                    tagName !== 'h3' &&\n                                                    tagName !== 'h4' &&\n                                                    tagName !== 'h5' &&\n                                                    tagName !== 'h6' &&\n                                                    tagName !== 'table'){\n                                                    continue;\n                                                }\n                                            }\n                                            var el = angular.element(dom[0].childNodes[i]);\n                                            var _listMatch = (el.attr('class') || '').match(/MsoList(Bullet|Number|Paragraph)(CxSp(First|Middle|Last)|)/i);\n\n                                            if(_listMatch){\n                                                if(el[0].childNodes.length < 2 || el[0].childNodes[1].childNodes.length < 1){\n                                                    continue;\n                                                }\n                                                var isUl = _listMatch[1].toLowerCase() === 'bullet' || (_listMatch[1].toLowerCase() !== 'number' && !(/^[^0-9a-z<]*[0-9a-z]+[^0-9a-z<>]</i.test(el[0].childNodes[1].innerHTML) || /^[^0-9a-z<]*[0-9a-z]+[^0-9a-z<>]</i.test(el[0].childNodes[1].childNodes[0].innerHTML)));\n                                                var _indentMatch = (el.attr('style') || '').match(/margin-left:([\\-\\.0-9]*)/i);\n                                                var indent = parseFloat((_indentMatch)?_indentMatch[1]:0);\n                                                var _levelMatch = (el.attr('style') || '').match(/mso-list:l([0-9]+) level([0-9]+) lfo[0-9+]($|;)/i);\n                                                // prefers the mso-list syntax\n\n                                                if(_levelMatch && _levelMatch[2]) indent = parseInt(_levelMatch[2]);\n\n                                                if ((_levelMatch && (!_list.lastLevelMatch || _levelMatch[1] !== _list.lastLevelMatch[1])) || !_listMatch[3] || _listMatch[3].toLowerCase() === 'first' || (_list.lastIndent.peek() === null) || (_list.isUl !== isUl && _list.lastIndent.peek() === indent)) {\n                                                    _resetList(isUl);\n                                                    targetDom.append(_list.element);\n                                                } else if (_list.lastIndent.peek() != null && _list.lastIndent.peek() < indent){\n                                                    _list.element = angular.element(isUl ? '<ul>' : '<ol>');\n                                                    _list.lastLi.append(_list.element);\n                                                } else if (_list.lastIndent.peek() != null && _list.lastIndent.peek() > indent){\n                                                    while(_list.lastIndent.peek() != null && _list.lastIndent.peek() > indent){\n                                                        if(_list.element.parent()[0].tagName.toLowerCase() === 'li'){\n                                                            _list.element = _list.element.parent();\n                                                            continue;\n                                                        }else if(/[uo]l/i.test(_list.element.parent()[0].tagName.toLowerCase())){\n                                                            _list.element = _list.element.parent();\n                                                        }else{ // else it's it should be a sibling\n                                                            break;\n                                                        }\n                                                        _list.lastIndent.pop();\n                                                    }\n                                                    _list.isUl = _list.element[0].tagName.toLowerCase() === 'ul';\n                                                    if (isUl !== _list.isUl) {\n                                                        _resetList(isUl);\n                                                        targetDom.append(_list.element);\n                                                    }\n                                                }\n\n                                                _list.lastLevelMatch = _levelMatch;\n                                                if(indent !== _list.lastIndent.peek()) _list.lastIndent.push(indent);\n                                                _list.lastLi = angular.element('<li>');\n                                                _list.element.append(_list.lastLi);\n                                                _list.lastLi.html(el.html().replace(/<!(--|)\\[if !supportLists\\](--|)>[\\s\\S]*?<!(--|)\\[endif\\](--|)>/ig, ''));\n                                                el.remove();\n                                            }else{\n                                                _resetList(false);\n                                                targetDom.append(el);\n                                            }\n                                        }\n                                        var _unwrapElement = function(node){\n                                            node = angular.element(node);\n                                            for(var _n = node[0].childNodes.length - 1; _n >= 0; _n--) node.after(node[0].childNodes[_n]);\n                                            node.remove();\n                                        };\n\n                                        angular.forEach(targetDom.find('span'), function(node){\n                                            node.removeAttribute('lang');\n                                            if(node.attributes.length <= 0) _unwrapElement(node);\n                                        });\n                                        angular.forEach(targetDom.find('font'), _unwrapElement);\n\n                                        text = targetDom.html();\n                                        if(_isOneNote){\n                                            text = targetDom.html() || dom.html();\n                                        }\n                                        // LF characters instead of spaces in some spots and they are replaced by '/n', so we need to just swap them to spaces\n                                        text = text.replace(/\\n/g, ' ');\n                                    }else{\n                                        // remove unnecessary chrome insert\n                                        text = text.replace(/<(|\\/)meta[^>]*?>/ig, '');\n                                        if(text.match(/<[^>]*?(ta-bind)[^>]*?>/)){\n                                            // entire text-angular or ta-bind has been pasted, REMOVE AT ONCE!!\n                                            if(text.match(/<[^>]*?(text-angular)[^>]*?>/)){\n                                                var _el = angular.element('<div>' + text + '</div>');\n                                                _el.find('textarea').remove();\n                                                for(var _b = 0; _b < binds.length; _b++){\n                                                    var _target = binds[_b][0].parentNode.parentNode;\n                                                    for(var _c = 0; _c < binds[_b][0].childNodes.length; _c++){\n                                                        _target.parentNode.insertBefore(binds[_b][0].childNodes[_c], _target);\n                                                    }\n                                                    _target.parentNode.removeChild(_target);\n                                                }\n                                                text = _el.html().replace('<br class=\"Apple-interchange-newline\">', '');\n                                            }\n                                        }else if(text.match(/^<span/)){\n                                            // in case of pasting only a span - chrome paste, remove them. THis is just some wierd formatting\n                                            // if we remove the '<span class=\"Apple-converted-space\"> </span>' here we destroy the spacing\n                                            // on paste from even ourselves!\n                                            if (!text.match(/<span class=(\\\"Apple-converted-space\\\"|\\'Apple-converted-space\\')>.<\\/span>/ig)) {\n                                                text = text.replace(/<(|\\/)span[^>]*?>/ig, '');\n                                            }\n                                        }\n                                        // Webkit on Apple tags\n                                        text = text.replace(/<br class=\"Apple-interchange-newline\"[^>]*?>/ig, '').replace(/<span class=\"Apple-converted-space\">( |&nbsp;)<\\/span>/ig, '&nbsp;');\n                                    }\n\n                                    if (/<li(\\s.*)?>/i.test(text) && /(<ul(\\s.*)?>|<ol(\\s.*)?>).*<li(\\s.*)?>/i.test(text) === false) {\n                                        // insert missing parent of li element\n                                        text = text.replace(/<li(\\s.*)?>.*<\\/li(\\s.*)?>/i, '<ul>$&</ul>');\n                                    }\n\n                                    // parse whitespace from plaintext input, starting with preceding spaces that get stripped on paste\n                                    text = text.replace(/^[ |\\u00A0]+/gm, function (match) {\n                                        var result = '';\n                                        for (var i = 0; i < match.length; i++) {\n                                            result += '&nbsp;';\n                                        }\n                                        return result;\n                                    }).replace(/\\n|\\r\\n|\\r/g, '<br />').replace(/\\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;');\n\n                                    if(_pasteHandler) text = _pasteHandler(scope, {$html: text}) || text;\n\n                                    // turn span vertical-align:super into <sup></sup>\n                                    text = text.replace(/<span style=(\"|')([^<]*?)vertical-align\\s*:\\s*super;?([^>]*?)(\"|')>([^<]+?)<\\/span>/g, \"<sup style='$2$3'>$5</sup>\");\n\n                                    text = taSanitize(text, '', _disableSanitizer);\n                                    //console.log('DONE\\n', text);\n\n                                    taSelection.insertHtml(text, element[0]);\n                                    $timeout(function(){\n                                        ngModel.$setViewValue(_compileHtml());\n                                        _processingPaste = false;\n                                        element.removeClass('processing-paste');\n                                    }, 0);\n                                }else{\n                                    _processingPaste = false;\n                                    element.removeClass('processing-paste');\n                                }\n                            };\n\n                            element.on('paste', scope.events.paste = function(e, eventData){\n                                /* istanbul ignore else: this is for catching the jqLite testing*/\n                                if(eventData) angular.extend(e, eventData);\n                                if(_isReadonly || _processingPaste){\n                                    e.stopPropagation();\n                                    e.preventDefault();\n                                    return false;\n                                }\n\n                                // Code adapted from http://stackoverflow.com/questions/2176861/javascript-get-clipboard-data-on-paste-event-cross-browser/6804718#6804718\n                                _processingPaste = true;\n                                element.addClass('processing-paste');\n                                var pastedContent;\n                                var clipboardData = (e.originalEvent || e).clipboardData;\n                                /* istanbul ignore next: Handle legacy IE paste */\n                                if ( !clipboardData && window.clipboardData && window.clipboardData.getData ){\n                                    pastedContent = window.clipboardData.getData(\"Text\");\n                                    processpaste(pastedContent);\n                                    e.stopPropagation();\n                                    e.preventDefault();\n                                    return false;\n                                }\n                                if (clipboardData && clipboardData.getData && clipboardData.types.length > 0) {// Webkit - get data from clipboard, put into editdiv, cleanup, then cancel event\n                                    var _types = \"\";\n                                    for(var _t = 0; _t < clipboardData.types.length; _t++){\n                                        _types += \" \" + clipboardData.types[_t];\n                                    }\n                                    /* istanbul ignore next: browser tests */\n                                    if (/text\\/html/i.test(_types)) {\n                                        pastedContent = clipboardData.getData('text/html');\n                                    } else if (/text\\/plain/i.test(_types)) {\n                                        pastedContent = clipboardData.getData('text/plain');\n                                    }\n                                    processpaste(pastedContent);\n                                    e.stopPropagation();\n                                    e.preventDefault();\n                                    return false;\n                                } else {// Everything else - empty editdiv and allow browser to paste content into it, then cleanup\n                                    var _savedSelection = rangy.saveSelection(),\n                                        _tempDiv = angular.element('<div class=\"ta-hidden-input\" contenteditable=\"true\"></div>');\n                                    $document.find('body').append(_tempDiv);\n                                    _tempDiv[0].focus();\n                                    $timeout(function(){\n                                        // restore selection\n                                        rangy.restoreSelection(_savedSelection);\n                                        processpaste(_tempDiv[0].innerHTML);\n                                        element[0].focus();\n                                        _tempDiv.remove();\n                                    }, 0);\n                                }\n                            });\n                            element.on('cut', scope.events.cut = function(e){\n                                // timeout to next is needed as otherwise the paste/cut event has not finished actually changing the display\n                                if(!_isReadonly) $timeout(function(){\n                                    ngModel.$setViewValue(_compileHtml());\n                                }, 0);\n                                else e.preventDefault();\n                            });\n\n                            element.on('keydown', scope.events.keydown = function(event, eventData){\n                                /* istanbul ignore else: this is for catching the jqLite testing*/\n                                if(eventData) angular.extend(event, eventData);\n                                if (event.keyCode === _SHIFT_KEYCODE) {\n                                    taSelection.setStateShiftKey(true);\n                                } else {\n                                    taSelection.setStateShiftKey(false);\n                                }\n                                event.specialKey = _mapKeys(event);\n                                var userSpecialKey;\n                                /* istanbul ignore next: difficult to test */\n                                taOptions.keyMappings.forEach(function (mapping) {\n                                    if (event.specialKey === mapping.commandKeyCode) {\n                                        // taOptions has remapped this binding... so\n                                        // we disable our own\n                                        event.specialKey = undefined;\n                                    }\n                                    if (mapping.testForKey(event)) {\n                                        userSpecialKey = mapping.commandKeyCode;\n                                    }\n                                    if ((mapping.commandKeyCode === 'UndoKey') || (mapping.commandKeyCode === 'RedoKey')) {\n                                        // this is necessary to fully stop the propagation.\n                                        if (!mapping.enablePropagation) {\n                                            event.preventDefault();\n                                        }\n                                    }\n                                });\n                                /* istanbul ignore next: difficult to test */\n                                if (typeof userSpecialKey !== 'undefined') {\n                                    event.specialKey = userSpecialKey;\n                                }\n                                /* istanbul ignore next: difficult to test as can't seem to select */\n                                if ((typeof event.specialKey !== 'undefined') && (\n                                        event.specialKey !== 'UndoKey' || event.specialKey !== 'RedoKey'\n                                    )) {\n                                    event.preventDefault();\n                                    textAngularManager.sendKeyCommand(scope, event);\n                                }\n                                /* istanbul ignore else: readonly check */\n                                if(!_isReadonly){\n                                    if (event.specialKey==='UndoKey') {\n                                        _undo();\n                                        event.preventDefault();\n                                    }\n                                    if (event.specialKey==='RedoKey') {\n                                        _redo();\n                                        event.preventDefault();\n                                    }\n                                    /* istanbul ignore next: difficult to test as can't seem to select */\n                                    if(event.keyCode === _ENTER_KEYCODE && !event.shiftKey && !event.ctrlKey && !event.metaKey && !event.altKey)\n                                    {\n                                        var contains = function(a, obj) {\n                                            for (var i = 0; i < a.length; i++) {\n                                                if (a[i] === obj) {\n                                                    return true;\n                                                }\n                                            }\n                                            return false;\n                                        };\n                                        var $selection;\n                                        var selection = taSelection.getSelectionElement();\n                                        // shifted to nodeName here from tagName since it is more widely supported see: http://stackoverflow.com/questions/4878484/difference-between-tagname-and-nodename\n                                        if(!selection.nodeName.match(VALIDELEMENTS)) return;\n                                        var _new = angular.element(_defaultVal);\n                                        // if we are in the last element of a blockquote, or ul or ol and the element is blank\n                                        // we need to pull the element outside of the said type\n                                        var moveOutsideElements = ['blockquote', 'ul', 'ol'];\n                                        if (contains(moveOutsideElements, selection.parentNode.tagName.toLowerCase())) {\n                                            if (/^<br(|\\/)>$/i.test(selection.innerHTML.trim()) && !selection.nextSibling) {\n                                                // if last element is blank, pull element outside.\n                                                $selection = angular.element(selection);\n                                                var _parent = $selection.parent();\n                                                _parent.after(_new);\n                                                $selection.remove();\n                                                if (_parent.children().length === 0) _parent.remove();\n                                                taSelection.setSelectionToElementStart(_new[0]);\n                                                event.preventDefault();\n                                            }\n                                            if (/^<[^>]+><br(|\\/)><\\/[^>]+>$/i.test(selection.innerHTML.trim())) {\n                                                $selection = angular.element(selection);\n                                                $selection.after(_new);\n                                                $selection.remove();\n                                                taSelection.setSelectionToElementStart(_new[0]);\n                                                event.preventDefault();\n                                            }\n                                        }\n                                    }\n                                }\n                            });\n                            var _keyupTimeout;\n                            element.on('keyup', scope.events.keyup = function(event, eventData){\n                                /* istanbul ignore else: this is for catching the jqLite testing*/\n                                if(eventData) angular.extend(event, eventData);\n                                taSelection.setStateShiftKey(false);\t// clear the ShiftKey state\n                                /* istanbul ignore next: FF specific bug fix */\n                                if (event.keyCode === _TAB_KEYCODE) {\n                                    var _selection = taSelection.getSelection();\n                                    if(_selection.start.element === element[0] && element.children().length) taSelection.setSelectionToElementStart(element.children()[0]);\n                                    return;\n                                }\n                                // we do this here during the 'keyup' so that the browser has already moved the slection by one character...\n                                if (event.keyCode === _LEFT_ARROW_KEYCODE && !event.shiftKey) {\n                                    taSelection.updateLeftArrowKey(element);\n                                }\n                                // we do this here during the 'keyup' so that the browser has already moved the slection by one character...\n                                if (event.keyCode === _RIGHT_ARROW_KEYCODE && !event.shiftKey) {\n                                    taSelection.updateRightArrowKey(element);\n                                }\n                                if(_undoKeyupTimeout) $timeout.cancel(_undoKeyupTimeout);\n                                if(!_isReadonly && !BLOCKED_KEYS.test(event.keyCode)){\n                                    /* istanbul ignore next: Ignore any _ENTER_KEYCODE that has ctrlKey, metaKey or alKey */\n                                    if (event.keyCode === _ENTER_KEYCODE && (event.ctrlKey || event.metaKey || event.altKey)) {\n                                        // we ignore any ENTER_\tKEYCODE that is anything but plain or a shift one...\n                                    } else {\n                                        // if enter - insert new taDefaultWrap, if shift+enter insert <br/>\n                                        if(_defaultVal !== '' && _defaultVal !== '<BR><BR>' && event.keyCode === _ENTER_KEYCODE && !event.ctrlKey && !event.metaKey && !event.altKey){\n                                            var selection = taSelection.getSelectionElement();\n                                            while(!selection.nodeName.match(VALIDELEMENTS) && selection !== element[0]){\n                                                selection = selection.parentNode;\n                                            }\n                                            if(!event.shiftKey){\n                                                // new paragraph, br should be caught correctly\n                                                // shifted to nodeName here from tagName since it is more widely supported see: http://stackoverflow.com/questions/4878484/difference-between-tagname-and-nodename\n                                                //console.log('Enter', selection.nodeName, attrs.taDefaultWrap, selection.innerHTML.trim());\n                                                if(selection.tagName.toLowerCase() !==\n                                                    attrs.taDefaultWrap &&\n                                                    selection.nodeName.toLowerCase() !== 'li' &&\n                                                    (selection.innerHTML.trim() === '' || selection.innerHTML.trim() === '<br>')\n                                                ) {\n                                                    // Chrome starts with a <div><br></div> after an EnterKey\n                                                    // so we replace this with the _defaultVal\n                                                    var _new = angular.element(_defaultVal);\n                                                    angular.element(selection).replaceWith(_new);\n                                                    taSelection.setSelectionToElementStart(_new[0]);\n                                                }\n                                            } else {\n                                                // shift + Enter\n                                                var tagName = selection.tagName.toLowerCase();\n                                                //console.log('Shift+Enter', selection.tagName, attrs.taDefaultWrap, selection.innerHTML.trim());\n                                                // For an LI: We see: LI p ....<br><br>\n                                                // For a P: We see: P p ....<br><br>\n                                                // on Safari, the browser ignores the Shift+Enter and acts just as an Enter Key\n                                                // For an LI: We see: LI p <br>\n                                                // For a P: We see: P p <br>\n                                                if((tagName === attrs.taDefaultWrap ||\n                                                    tagName === 'li' ||\n                                                    tagName === 'pre' ||\n                                                    tagName === 'div') &&\n                                                    !/.+<br><br>/.test(selection.innerHTML.trim())) {\n                                                    var ps = selection.previousSibling;\n                                                    //console.log('wrong....', ps);\n                                                    // we need to remove this selection and fix the previousSibling up...\n                                                    if (ps) {\n                                                        ps.innerHTML = ps.innerHTML + '<br><br>';\n                                                        angular.element(selection).remove();\n                                                        taSelection.setSelectionToElementEnd(ps);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        var val = _compileHtml();\n                                        if(_defaultVal !== '' && (val.trim() === '' || val.trim() === '<br>')){\n                                            _setInnerHTML(_defaultVal);\n                                            taSelection.setSelectionToElementStart(element.children()[0]);\n                                        }else if(val.substring(0, 1) !== '<' && attrs.taDefaultWrap !== ''){\n                                            /* we no longer do this, since there can be comments here and white space\n                                             var _savedSelection = rangy.saveSelection();\n                                             val = _compileHtml();\n                                             val = \"<\" + attrs.taDefaultWrap + \">\" + val + \"</\" + attrs.taDefaultWrap + \">\";\n                                             _setInnerHTML(val);\n                                             rangy.restoreSelection(_savedSelection);\n                                             */\n                                        }\n                                        var triggerUndo = _lastKey !== event.keyCode && UNDO_TRIGGER_KEYS.test(event.keyCode);\n                                        if(_keyupTimeout) $timeout.cancel(_keyupTimeout);\n                                        _keyupTimeout = $timeout(function() {\n                                            _setViewValue(val, triggerUndo, true);\n                                        }, ngModelOptions.$options.debounce || 400);\n                                        if(!triggerUndo) _undoKeyupTimeout = $timeout(function(){ ngModel.$undoManager.push(val); }, 250);\n                                        _lastKey = event.keyCode;\n                                    }\n                                }\n                            });\n\n                            // when there is a change from a spelling correction in the browser, the only\n                            // change that is seen is a 'input' and the $watch('html') sees nothing... So\n                            // we added this element.on('input') to catch this change and call the _setViewValue()\n                            // so the ngModel is updated and all works as it should.\n                            var _inputTimeout;\n                            element.on('input', function() {\n                                if (_compileHtml() !== ngModel.$viewValue) {\n                                    // we wait a time now to allow the natural $watch('html') to handle this change\n                                    // and then after a 1 second delay, if there is still a difference we will do the\n                                    // _setViewValue() call.\n                                    /* istanbul ignore if: can't test */\n                                    if(_inputTimeout) $timeout.cancel(_inputTimeout);\n                                    /* istanbul ignore next: cant' test? */\n                                    _inputTimeout = $timeout(function() {\n                                        var _savedSelection = rangy.saveSelection();\n                                        var _val = _compileHtml();\n                                        if (_val !== ngModel.$viewValue) {\n                                            //console.log('_setViewValue');\n                                            //console.log('old:', ngModel.$viewValue);\n                                            //console.log('new:', _val);\n                                            _setViewValue(_val, true);\n                                        }\n                                        // if the savedSelection marker is gone at this point, we cannot restore the selection!!!\n                                        //console.log('rangy.restoreSelection', ngModel.$viewValue.length, _savedSelection);\n                                        if (ngModel.$viewValue.length !== 0) {\n                                            rangy.restoreSelection(_savedSelection);\n                                        }\n                                    }, 1000);\n                                }\n                            });\n\n                            element.on('blur', scope.events.blur = function(){\n                                _focussed = false;\n                                /* istanbul ignore else: if readonly don't update model */\n                                if(!_isReadonly){\n                                    _setViewValue(undefined, undefined, true);\n                                }else{\n                                    _skipRender = true; // don't redo the whole thing, just check the placeholder logic\n                                    ngModel.$render();\n                                }\n                            });\n\n                            // Placeholders not supported on ie 8 and below\n                            if(attrs.placeholder && (_browserDetect.ie > 8 || _browserDetect.ie === undefined)){\n                                var rule;\n                                if(attrs.id) rule = addCSSRule('#' + attrs.id + '.placeholder-text:before', 'content: \"' + attrs.placeholder + '\"');\n                                else throw('textAngular Error: An unique ID is required for placeholders to work');\n\n                                scope.$on('$destroy', function(){\n                                    removeCSSRule(rule);\n                                });\n                            }\n\n                            element.on('focus', scope.events.focus = function(){\n                                _focussed = true;\n                                element.removeClass('placeholder-text');\n                                _reApplyOnSelectorHandlers();\n                            });\n\n                            element.on('mouseup', scope.events.mouseup = function(){\n                                var _selection = taSelection.getSelection();\n                                if(_selection && _selection.start.element === element[0] && element.children().length) taSelection.setSelectionToElementStart(element.children()[0]);\n                            });\n\n                            // prevent propagation on mousedown in editor, see #206\n                            element.on('mousedown', scope.events.mousedown = function(event, eventData){\n                                /* istanbul ignore else: this is for catching the jqLite testing*/\n                                if(eventData) angular.extend(event, eventData);\n                                event.stopPropagation();\n                            });\n                        }\n                    }\n\n                    var fileDropHandler = function(event, eventData){\n                        /* istanbul ignore else: this is for catching the jqLite testing*/\n                        if(eventData) angular.extend(event, eventData);\n                        // emit the drop event, pass the element, preventing should be done elsewhere\n                        if(!dropFired && !_isReadonly){\n                            dropFired = true;\n                            var dataTransfer;\n                            if(event.originalEvent) dataTransfer = event.originalEvent.dataTransfer;\n                            else dataTransfer = event.dataTransfer;\n                            scope.$emit('ta-drop-event', this, event, dataTransfer);\n                            $timeout(function(){\n                                dropFired = false;\n                                _setViewValue(undefined, undefined, true);\n                            }, 100);\n                        }\n                    };\n\n                    var _renderTimeout;\n                    var _renderInProgress = false;\n                    // changes to the model variable from outside the html/text inputs\n                    ngModel.$render = function(){\n                        /* istanbul ignore if: Catches rogue renders, hard to replicate in tests */\n                        if(_renderInProgress) return;\n                        else _renderInProgress = true;\n                        // catch model being null or undefined\n                        var val = ngModel.$viewValue || '';\n                        // if the editor isn't focused it needs to be updated, otherwise it's receiving user input\n                        if(!_skipRender){\n                            /* istanbul ignore else: in other cases we don't care */\n                            if(_isContentEditable && _focussed){\n                                // update while focussed\n                                element.removeClass('placeholder-text');\n                                /* istanbul ignore next: don't know how to test this */\n                                if(_renderTimeout) $timeout.cancel(_renderTimeout);\n                                _renderTimeout = $timeout(function(){\n                                    /* istanbul ignore if: Can't be bothered testing this... */\n                                    if(!_focussed){\n                                        element[0].focus();\n                                        taSelection.setSelectionToElementEnd(element.children()[element.children().length - 1]);\n                                    }\n                                    _renderTimeout = undefined;\n                                }, 1);\n                            }\n                            if(_isContentEditable){\n                                // WYSIWYG Mode\n                                if(attrs.placeholder){\n                                    if(val === ''){\n                                        // blank\n                                        _setInnerHTML(_defaultVal);\n                                    }else{\n                                        // not-blank\n                                        _setInnerHTML(val);\n                                    }\n                                }else{\n                                    _setInnerHTML((val === '') ? _defaultVal : val);\n                                }\n                                // if in WYSIWYG and readOnly we kill the use of links by clicking\n                                if(!_isReadonly){\n                                    _reApplyOnSelectorHandlers();\n                                    element.on('drop', fileDropHandler);\n                                }else{\n                                    element.off('drop', fileDropHandler);\n                                }\n                            }else if(element[0].tagName.toLowerCase() !== 'textarea' && element[0].tagName.toLowerCase() !== 'input'){\n                                // make sure the end user can SEE the html code as a display. This is a read-only display element\n                                _setInnerHTML(taApplyCustomRenderers(val));\n                            }else{\n                                // only for input and textarea inputs\n                                element.val(val);\n                            }\n                        }\n                        if(_isContentEditable && attrs.placeholder){\n                            if(val === ''){\n                                if(_focussed) element.removeClass('placeholder-text');\n                                else element.addClass('placeholder-text');\n                            }else{\n                                element.removeClass('placeholder-text');\n                            }\n                        }\n                        _renderInProgress = _skipRender = false;\n                    };\n\n                    if(attrs.taReadonly){\n                        //set initial value\n                        _isReadonly = scope.$eval(attrs.taReadonly);\n                        if(_isReadonly){\n                            element.addClass('ta-readonly');\n                            // we changed to readOnly mode (taReadonly='true')\n                            if(element[0].tagName.toLowerCase() === 'textarea' || element[0].tagName.toLowerCase() === 'input'){\n                                element.attr('disabled', 'disabled');\n                            }\n                            if(element.attr('contenteditable') !== undefined && element.attr('contenteditable')){\n                                element.removeAttr('contenteditable');\n                            }\n                        }else{\n                            element.removeClass('ta-readonly');\n                            // we changed to NOT readOnly mode (taReadonly='false')\n                            if(element[0].tagName.toLowerCase() === 'textarea' || element[0].tagName.toLowerCase() === 'input'){\n                                element.removeAttr('disabled');\n                            }else if(_isContentEditable){\n                                element.attr('contenteditable', 'true');\n                            }\n                        }\n                        // taReadonly only has an effect if the taBind element is an input or textarea or has contenteditable='true' on it.\n                        // Otherwise it is readonly by default\n                        scope.$watch(attrs.taReadonly, function(newVal, oldVal){\n                            if(oldVal === newVal) return;\n                            if(newVal){\n                                element.addClass('ta-readonly');\n                                // we changed to readOnly mode (taReadonly='true')\n                                if(element[0].tagName.toLowerCase() === 'textarea' || element[0].tagName.toLowerCase() === 'input'){\n                                    element.attr('disabled', 'disabled');\n                                }\n                                if(element.attr('contenteditable') !== undefined && element.attr('contenteditable')){\n                                    element.removeAttr('contenteditable');\n                                }\n                                // turn ON selector click handlers\n                                angular.forEach(taSelectableElements, function(selector){\n                                    element.find(selector).on('click', selectorClickHandler);\n                                });\n                                element.off('drop', fileDropHandler);\n                            }else{\n                                element.removeClass('ta-readonly');\n                                // we changed to NOT readOnly mode (taReadonly='false')\n                                if(element[0].tagName.toLowerCase() === 'textarea' || element[0].tagName.toLowerCase() === 'input'){\n                                    element.removeAttr('disabled');\n                                }else if(_isContentEditable){\n                                    element.attr('contenteditable', 'true');\n                                }\n                                // remove the selector click handlers\n                                angular.forEach(taSelectableElements, function(selector){\n                                    element.find(selector).off('click', selectorClickHandler);\n                                });\n                                element.on('drop', fileDropHandler);\n                            }\n                            _isReadonly = newVal;\n                        });\n                    }\n\n                    // Initialise the selectableElements\n                    // if in WYSIWYG and readOnly we kill the use of links by clicking\n                    if(_isContentEditable && !_isReadonly){\n                        angular.forEach(taSelectableElements, function(selector){\n                            element.find(selector).on('click', selectorClickHandler);\n                        });\n                        element.on('drop', fileDropHandler);\n                    }\n                }\n            };\n        }]);\n\n// this global var is used to prevent multiple fires of the drop event. Needs to be global to the textAngular file.\nvar dropFired = false;\nvar textAngular = angular.module(\"textAngular\", ['ngSanitize', 'textAngularSetup', 'textAngular.factories', 'textAngular.DOM', 'textAngular.validators', 'textAngular.taBind']); //This makes ngSanitize required\n\ntextAngular.config([function(){\n    // clear taTools variable. Just catches testing and any other time that this config may run multiple times...\n    angular.forEach(taTools, function(value, key){ delete taTools[key];\t});\n}]);\n\ntextAngular.directive(\"textAngular\", [\n    '$compile', '$timeout', 'taOptions', 'taSelection', 'taExecCommand',\n    'textAngularManager', '$document', '$animate', '$log', '$q', '$parse',\n    function($compile, $timeout, taOptions, taSelection, taExecCommand,\n             textAngularManager, $document, $animate, $log, $q, $parse){\n        return {\n            require: '?ngModel',\n            scope: {},\n            restrict: \"EA\",\n            priority: 2, // So we override validators correctly\n            link: function(scope, element, attrs, ngModel){\n                // all these vars should not be accessable outside this directive\n                var _keydown, _keyup, _keypress, _mouseup, _focusin, _focusout,\n                    _originalContents, _editorFunctions,\n                    _serial = (attrs.serial) ? attrs.serial : Math.floor(Math.random() * 10000000000000000),\n                    _taExecCommand, _resizeMouseDown, _updateSelectedStylesTimeout;\n                var _resizeTimeout;\n\n                scope._name = (attrs.name) ? attrs.name : 'textAngularEditor' + _serial;\n\n                var oneEvent = function(_element, event, action){\n                    $timeout(function(){\n                        _element.one(event, action);\n                    }, 100);\n                };\n                _taExecCommand = taExecCommand(attrs.taDefaultWrap);\n                // get the settings from the defaults and add our specific functions that need to be on the scope\n                angular.extend(scope, angular.copy(taOptions), {\n                    // wraps the selection in the provided tag / execCommand function. Should only be called in WYSIWYG mode.\n                    wrapSelection: function(command, opt, isSelectableElementTool){\n                        // we restore the saved selection that was saved when focus was lost\n                        /* NOT FUNCTIONAL YET */\n                        /* textAngularManager.restoreFocusSelection(scope._name, scope); */\n                        if(command.toLowerCase() === \"undo\"){\n                            scope['$undoTaBindtaTextElement' + _serial]();\n                        }else if(command.toLowerCase() === \"redo\"){\n                            scope['$redoTaBindtaTextElement' + _serial]();\n                        }else{\n                            // catch errors like FF erroring when you try to force an undo with nothing done\n                            _taExecCommand(command, false, opt, scope.defaultTagAttributes);\n                            if(isSelectableElementTool){\n                                // re-apply the selectable tool events\n                                scope['reApplyOnSelectorHandlerstaTextElement' + _serial]();\n                            }\n                            // refocus on the shown display element, this fixes a display bug when using :focus styles to outline the box.\n                            // You still have focus on the text/html input it just doesn't display up\n                            scope.displayElements.text[0].focus();\n                        }\n                    },\n                    showHtml: scope.$eval(attrs.taShowHtml) || false\n                });\n                // setup the options from the optional attributes\n                if(attrs.taFocussedClass)\t\t\tscope.classes.focussed = attrs.taFocussedClass;\n                if(attrs.taTextEditorClass)\t\t\tscope.classes.textEditor = attrs.taTextEditorClass;\n                if(attrs.taHtmlEditorClass)\t\t\tscope.classes.htmlEditor = attrs.taHtmlEditorClass;\n                if(attrs.taDefaultTagAttributes){\n                    try\t{\n                        //\tTODO: This should use angular.merge to enhance functionality once angular 1.4 is required\n                        angular.extend(scope.defaultTagAttributes, angular.fromJson(attrs.taDefaultTagAttributes));\n                    } catch (error) {\n                        $log.error(error);\n                    }\n                }\n                // optional setup functions\n                if(attrs.taTextEditorSetup)\t\t\tscope.setup.textEditorSetup = scope.$parent.$eval(attrs.taTextEditorSetup);\n                if(attrs.taHtmlEditorSetup)\t\t\tscope.setup.htmlEditorSetup = scope.$parent.$eval(attrs.taHtmlEditorSetup);\n                // optional fileDropHandler function\n                if(attrs.taFileDrop)\t\t\t\tscope.fileDropHandler = scope.$parent.$eval(attrs.taFileDrop);\n                else\t\t\t\t\t\t\t\tscope.fileDropHandler = scope.defaultFileDropHandler;\n\n                _originalContents = element[0].innerHTML;\n                // clear the original content\n                element[0].innerHTML = '';\n\n                // Setup the HTML elements as variable references for use later\n                scope.displayElements = {\n                    // we still need the hidden input even with a textarea as the textarea may have invalid/old input in it,\n                    // wheras the input will ALLWAYS have the correct value.\n                    forminput: angular.element(\"<input type='hidden' tabindex='-1' style='display: none;'>\"),\n                    html: angular.element(\"<textarea></textarea>\"),\n                    text: angular.element(\"<div></div>\"),\n                    // other toolbased elements\n                    scrollWindow: angular.element(\"<div class='ta-scroll-window'></div>\"),\n                    popover: angular.element('<div class=\"popover fade bottom\" style=\"max-width: none; width: 305px;\"></div>'),\n                    popoverArrow: angular.element('<div class=\"arrow\"></div>'),\n                    popoverContainer: angular.element('<div class=\"popover-content\"></div>'),\n                    resize: {\n                        overlay: angular.element('<div class=\"ta-resizer-handle-overlay\"></div>'),\n                        background: angular.element('<div class=\"ta-resizer-handle-background\"></div>'),\n                        anchors: [\n                            angular.element('<div class=\"ta-resizer-handle-corner ta-resizer-handle-corner-tl\"></div>'),\n                            angular.element('<div class=\"ta-resizer-handle-corner ta-resizer-handle-corner-tr\"></div>'),\n                            angular.element('<div class=\"ta-resizer-handle-corner ta-resizer-handle-corner-bl\"></div>'),\n                            angular.element('<div class=\"ta-resizer-handle-corner ta-resizer-handle-corner-br\"></div>')\n                        ],\n                        info: angular.element('<div class=\"ta-resizer-handle-info\"></div>')\n                    }\n                };\n\n                // Setup the popover\n                scope.displayElements.popover.append(scope.displayElements.popoverArrow);\n                scope.displayElements.popover.append(scope.displayElements.popoverContainer);\n                scope.displayElements.scrollWindow.append(scope.displayElements.popover);\n\n                scope.displayElements.popover.on('mousedown', function(e, eventData){\n                    /* istanbul ignore else: this is for catching the jqLite testing*/\n                    if(eventData) angular.extend(e, eventData);\n                    // this prevents focusout from firing on the editor when clicking anything in the popover\n                    e.preventDefault();\n                    return false;\n                });\n\n                /* istanbul ignore next: popover resize and scroll events handled */\n                scope.handlePopoverEvents = function() {\n                    if (scope.displayElements.popover.css('display')==='block') {\n                        if(_resizeTimeout) $timeout.cancel(_resizeTimeout);\n                        _resizeTimeout = $timeout(function() {\n                            //console.log('resize', scope.displayElements.popover.css('display'));\n                            scope.reflowPopover(scope.resizeElement);\n                            scope.reflowResizeOverlay(scope.resizeElement);\n                        }, 100);\n                    }\n                };\n\n                /* istanbul ignore next: browser resize check */\n                angular.element(window).on('resize', scope.handlePopoverEvents);\n\n                /* istanbul ignore next: browser scroll check */\n                angular.element(window).on('scroll', scope.handlePopoverEvents);\n\n                // we want to know if a given node has a scrollbar!\n                // credit to lotif on http://stackoverflow.com/questions/4880381/check-whether-html-element-has-scrollbars\n                var isScrollable = function(node) {\n                    var cs;\n                    var _notScrollable = {\n                        vertical: false,\n                        horizontal: false,\n                    };\n                    try {\n                        cs = window.getComputedStyle(node);\n                        if (cs === null) {\n                            return _notScrollable;\n                        }\n                    } catch (e) {\n                        /* istanbul ignore next: error handler */\n                        return _notScrollable;\n                    }\n                    var overflowY = cs['overflow-y'];\n                    var overflowX = cs['overflow-x'];\n                    return {\n                        vertical: (overflowY === 'scroll' || overflowY === 'auto') &&\n                        /* istanbul ignore next: not tested */\n                        node.scrollHeight > node.clientHeight,\n                        horizontal: (overflowX === 'scroll' || overflowX === 'auto') &&\n                        /* istanbul ignore next: not tested */\n                        node.scrollWidth > node.clientWidth,\n                    };\n                };\n\n                // getScrollTop\n                //\n                // we structure this so that it can climb the parents of the _el and when it finds\n                // one with scrollbars, it adds an EventListener, so that no matter how the\n                // DOM is structured in the user APP, if there is a scrollbar not as part of the\n                // ta-scroll-window, we will still capture the 'scroll' events...\n                // and handle the scroll event properly and do the resize, etc.\n                //\n                scope.getScrollTop = function (_el, bAddListener) {\n                    var scrollTop = _el.scrollTop;\n                    if (typeof scrollTop === 'undefined') {\n                        scrollTop = 0;\n                    }\n                    /* istanbul ignore next: triggered only if has scrollbar */\n                    if (bAddListener && isScrollable(_el).vertical) {\n                        // remove element eventListener\n                        _el.removeEventListener('scroll', scope._scrollListener, false);\n                        _el.addEventListener('scroll', scope._scrollListener, false);\n                    }\n                    /* istanbul ignore next: triggered only if has scrollbar and scrolled */\n                    if (scrollTop !== 0) {\n                        return { node:_el.nodeName, top:scrollTop };\n                    }\n                    /* istanbul ignore else: catches only if no scroll */\n                    if (_el.parentNode) {\n                        return scope.getScrollTop(_el.parentNode, bAddListener);\n                    } else {\n                        return { node:'<none>', top:0 };\n                    }\n                };\n\n                // define the popover display and hide functions\n                scope.showPopover = function(_el){\n                    scope.getScrollTop(scope.displayElements.scrollWindow[0], true);\n                    scope.displayElements.popover.css('display', 'block');\n                    // we must use a $timeout here, or the css change to the\n                    // displayElements.resize.overlay will not take!!!\n                    // WHY???\n                    $timeout(function() {\n                        scope.displayElements.resize.overlay.css('display', 'block');\n                    });\n                    scope.resizeElement = _el;\n                    scope.reflowPopover(_el);\n                    $animate.addClass(scope.displayElements.popover, 'in');\n                    oneEvent($document.find('body'), 'click keyup', function(){scope.hidePopover();});\n                };\n\n                /* istanbul ignore next: browser scroll event handler */\n                scope._scrollListener = function (e, eventData){\n                    scope.handlePopoverEvents();\n                };\n\n                scope.reflowPopover = function(_el){\n                    var scrollTop = scope.getScrollTop(scope.displayElements.scrollWindow[0], false);\n                    var spaceAboveImage = _el[0].offsetTop-scrollTop.top;\n                    //var spaceBelowImage = scope.displayElements.text[0].offsetHeight - _el[0].offsetHeight - spaceAboveImage;\n                    //console.log(spaceAboveImage, spaceBelowImage);\n\n                    /* istanbul ignore if: catches only if near bottom of editor */\n                    if(spaceAboveImage < 51) {\n                        scope.displayElements.popover.css('top', _el[0].offsetTop + _el[0].offsetHeight + scope.displayElements.scrollWindow[0].scrollTop + 'px');\n                        scope.displayElements.popover.removeClass('top').addClass('bottom');\n                    } else {\n                        scope.displayElements.popover.css('top', _el[0].offsetTop - 54 + scope.displayElements.scrollWindow[0].scrollTop + 'px');\n                        scope.displayElements.popover.removeClass('bottom').addClass('top');\n                    }\n                    var _maxLeft = scope.displayElements.text[0].offsetWidth - scope.displayElements.popover[0].offsetWidth;\n                    var _targetLeft = _el[0].offsetLeft + (_el[0].offsetWidth / 2.0) - (scope.displayElements.popover[0].offsetWidth / 2.0);\n                    var _rleft = Math.max(0, Math.min(_maxLeft, _targetLeft));\n                    var _marginLeft = (Math.min(_targetLeft, (Math.max(0, _targetLeft - _maxLeft))) - 11);\n                    _rleft += window.scrollX;\n                    _marginLeft -= window.scrollX;\n                    scope.displayElements.popover.css('left', _rleft + 'px');\n                    scope.displayElements.popoverArrow.css('margin-left', _marginLeft + 'px');\n                };\n                scope.hidePopover = function(){\n                    scope.displayElements.popover.css('display', 'none');\n                    scope.displayElements.popoverContainer.attr('style', '');\n                    scope.displayElements.popoverContainer.attr('class', 'popover-content');\n                    scope.displayElements.popover.removeClass('in');\n                    scope.displayElements.resize.overlay.css('display', 'none');\n                };\n\n                // setup the resize overlay\n                scope.displayElements.resize.overlay.append(scope.displayElements.resize.background);\n                angular.forEach(scope.displayElements.resize.anchors, function(anchor){ scope.displayElements.resize.overlay.append(anchor);});\n                scope.displayElements.resize.overlay.append(scope.displayElements.resize.info);\n                scope.displayElements.scrollWindow.append(scope.displayElements.resize.overlay);\n\n                // A click event on the resize.background will now shift the focus to the editor\n                /* istanbul ignore next: click on the resize.background to focus back to editor */\n                scope.displayElements.resize.background.on('click', function(e) {\n                    scope.displayElements.text[0].focus();\n                });\n\n                // define the display and hide events\n                scope.reflowResizeOverlay = function(_el){\n                    _el = angular.element(_el)[0];\n                    scope.displayElements.resize.overlay.css({\n                        'display': 'block',\n                        'left': _el.offsetLeft - 5 + 'px',\n                        'top': _el.offsetTop - 5 + 'px',\n                        'width': _el.offsetWidth + 10 + 'px',\n                        'height': _el.offsetHeight + 10 + 'px'\n                    });\n                    scope.displayElements.resize.info.text(_el.offsetWidth + ' x ' + _el.offsetHeight);\n                };\n                /* istanbul ignore next: pretty sure phantomjs won't test this */\n                scope.showResizeOverlay = function(_el){\n                    var _body = $document.find('body');\n                    _resizeMouseDown = function(event){\n                        var startPosition = {\n                            width: parseInt(_el.attr('width')),\n                            height: parseInt(_el.attr('height')),\n                            x: event.clientX,\n                            y: event.clientY\n                        };\n                        if(startPosition.width === undefined || isNaN(startPosition.width)) startPosition.width = _el[0].offsetWidth;\n                        if(startPosition.height === undefined || isNaN(startPosition.height)) startPosition.height = _el[0].offsetHeight;\n                        scope.hidePopover();\n                        var ratio = startPosition.height / startPosition.width;\n                        var mousemove = function(event){\n                            // calculate new size\n                            var pos = {\n                                x: Math.max(0, startPosition.width + (event.clientX - startPosition.x)),\n                                y: Math.max(0, startPosition.height + (event.clientY - startPosition.y))\n                            };\n\n                            // DEFAULT: the aspect ratio is not locked unless the Shift key is pressed.\n                            //\n                            // attribute: ta-resize-force-aspect-ratio -- locks resize into maintaing the aspect ratio\n                            var bForceAspectRatio = (attrs.taResizeForceAspectRatio !== undefined);\n                            // attribute: ta-resize-maintain-aspect-ratio=true causes the space ratio to remain locked\n                            // unless the Shift key is pressed\n                            var bFlipKeyBinding = attrs.taResizeMaintainAspectRatio;\n                            var bKeepRatio =  bForceAspectRatio || (bFlipKeyBinding && !event.shiftKey);\n                            if(bKeepRatio) {\n                                var newRatio = pos.y / pos.x;\n                                pos.x = ratio > newRatio ? pos.x : pos.y / ratio;\n                                pos.y = ratio > newRatio ? pos.x * ratio : pos.y;\n                            }\n                            var el = angular.element(_el);\n                            function roundedMaxVal(val) {\n                                return Math.round(Math.max(0, val));\n                            }\n                            el.css('height', roundedMaxVal(pos.y) + 'px');\n                            el.css('width', roundedMaxVal(pos.x) + 'px');\n\n                            // reflow the popover tooltip\n                            scope.reflowResizeOverlay(_el);\n                        };\n                        _body.on('mousemove', mousemove);\n                        oneEvent(_body, 'mouseup', function(event){\n                            event.preventDefault();\n                            event.stopPropagation();\n                            _body.off('mousemove', mousemove);\n                            // at this point, we need to force the model to update! since the css has changed!\n                            // this fixes bug: #862 - we now hide the popover -- as this seems more consitent.\n                            // there are still issues under firefox, the window does not repaint. -- not sure\n                            // how best to resolve this, but clicking anywhere works.\n                            scope.$apply(function (){\n                                scope.hidePopover();\n                                scope.updateTaBindtaTextElement();\n                            }, 100);\n                        });\n                        event.stopPropagation();\n                        event.preventDefault();\n                    };\n\n                    scope.displayElements.resize.anchors[3].off('mousedown');\n                    scope.displayElements.resize.anchors[3].on('mousedown', _resizeMouseDown);\n\n                    scope.reflowResizeOverlay(_el);\n                    oneEvent(_body, 'click', function(){scope.hideResizeOverlay();});\n                };\n                /* istanbul ignore next: pretty sure phantomjs won't test this */\n                scope.hideResizeOverlay = function(){\n                    scope.displayElements.resize.anchors[3].off('mousedown', _resizeMouseDown);\n                    scope.displayElements.resize.overlay.css('display', 'none');\n                };\n\n                // allow for insertion of custom directives on the textarea and div\n                scope.setup.htmlEditorSetup(scope.displayElements.html);\n                scope.setup.textEditorSetup(scope.displayElements.text);\n                scope.displayElements.html.attr({\n                    'id': 'taHtmlElement' + _serial,\n                    'ng-show': 'showHtml',\n                    'ta-bind': 'ta-bind',\n                    'ng-model': 'html',\n                    'ng-model-options': element.attr('ng-model-options')\n                });\n                scope.displayElements.text.attr({\n                    'id': 'taTextElement' + _serial,\n                    'contentEditable': 'true',\n                    'ta-bind': 'ta-bind',\n                    'ng-model': 'html',\n                    'ng-model-options': element.attr('ng-model-options')\n                });\n                scope.displayElements.scrollWindow.attr({'ng-hide': 'showHtml'});\n                if(attrs.taDefaultWrap) {\n                    // taDefaultWrap is only applied to the text and not the html view\n                    scope.displayElements.text.attr('ta-default-wrap', attrs.taDefaultWrap);\n                }\n\n                if(attrs.taUnsafeSanitizer){\n                    scope.displayElements.text.attr('ta-unsafe-sanitizer', attrs.taUnsafeSanitizer);\n                    scope.displayElements.html.attr('ta-unsafe-sanitizer', attrs.taUnsafeSanitizer);\n                }\n\n                if(attrs.taKeepStyles){\n                    scope.displayElements.text.attr('ta-keep-styles', attrs.taKeepStyles);\n                    scope.displayElements.html.attr('ta-keep-styles', attrs.taKeepStyles);\n                }\n\n                // add the main elements to the origional element\n                scope.displayElements.scrollWindow.append(scope.displayElements.text);\n                element.append(scope.displayElements.scrollWindow);\n                element.append(scope.displayElements.html);\n\n                scope.displayElements.forminput.attr('name', scope._name);\n                element.append(scope.displayElements.forminput);\n\n                if(attrs.tabindex){\n                    element.removeAttr('tabindex');\n                    scope.displayElements.text.attr('tabindex', attrs.tabindex);\n                    scope.displayElements.html.attr('tabindex', attrs.tabindex);\n                }\n\n                if (attrs.placeholder) {\n                    scope.displayElements.text.attr('placeholder', attrs.placeholder);\n                    scope.displayElements.html.attr('placeholder', attrs.placeholder);\n                }\n\n                if(attrs.taDisabled){\n                    scope.displayElements.text.attr('ta-readonly', 'disabled');\n                    scope.displayElements.html.attr('ta-readonly', 'disabled');\n                    scope.disabled = scope.$parent.$eval(attrs.taDisabled);\n                    scope.$parent.$watch(attrs.taDisabled, function(newVal){\n                        scope.disabled = newVal;\n                        if(scope.disabled){\n                            element.addClass(scope.classes.disabled);\n                        }else{\n                            element.removeClass(scope.classes.disabled);\n                        }\n                    });\n                }\n\n                if(attrs.taPaste){\n                    scope._pasteHandler = function(_html){\n                        return $parse(attrs.taPaste)(scope.$parent, {$html: _html});\n                    };\n                    scope.displayElements.text.attr('ta-paste', '_pasteHandler($html)');\n                }\n\n                // compile the scope with the text and html elements only - if we do this with the main element it causes a compile loop\n                $compile(scope.displayElements.scrollWindow)(scope);\n                $compile(scope.displayElements.html)(scope);\n\n                scope.updateTaBindtaTextElement = scope['updateTaBindtaTextElement' + _serial];\n                scope.updateTaBindtaHtmlElement = scope['updateTaBindtaHtmlElement' + _serial];\n\n                // add the classes manually last\n                element.addClass(\"ta-root\");\n                scope.displayElements.scrollWindow.addClass(\"ta-text ta-editor \" + scope.classes.textEditor);\n                scope.displayElements.html.addClass(\"ta-html ta-editor \" + scope.classes.htmlEditor);\n\n                var testAndSet = function(choice, beforeState) {\n                    /* istanbul ignore next: this is only here because of a bug in rangy where rangy.saveSelection() has cleared the state */\n                    if (beforeState !== $document[0].queryCommandState(choice)) {\n                        $document[0].execCommand(choice, false, null);\n                    }\n                };\n                // used in the toolbar actions\n                scope._actionRunning = false;\n                var _savedSelection = false;\n                scope.startAction = function(){\n                    var _beforeStateBold = false;\n                    var _beforeStateItalic = false;\n                    var _beforeStateUnderline = false;\n                    var _beforeStateStrikethough = false;\n                    scope._actionRunning = true;\n                    _beforeStateBold = $document[0].queryCommandState('bold');\n                    _beforeStateItalic = $document[0].queryCommandState('italic');\n                    _beforeStateUnderline = $document[0].queryCommandState('underline');\n                    _beforeStateStrikethough = $document[0].queryCommandState('strikeThrough');\n                    //console.log('B', _beforeStateBold, 'I', _beforeStateItalic, '_', _beforeStateUnderline, 'S', _beforeStateStrikethough);\n                    // if rangy library is loaded return a function to reload the current selection\n                    _savedSelection = rangy.saveSelection();\n                    // rangy.saveSelection() clear the state of bold, italic, underline, strikethrough\n                    // so we reset them here....!!!\n                    // this fixes bugs #423, #1129, #1105, #693 which are actually rangy bugs!\n                    testAndSet('bold', _beforeStateBold);\n                    testAndSet('italic', _beforeStateItalic);\n                    testAndSet('underline', _beforeStateUnderline);\n                    testAndSet('strikeThrough', _beforeStateStrikethough);\n                    //console.log('B', $document[0].queryCommandState('bold'), 'I', $document[0].queryCommandState('italic'), '_', $document[0].queryCommandState('underline'), 'S', $document[0].queryCommandState('strikeThrough') );\n                    return function(){\n                        if(_savedSelection) rangy.restoreSelection(_savedSelection);\n                        // perhaps if we restore the selections here, we would do better overall???\n                        // BUT what we do above does well in 90% of the cases...\n                    };\n                };\n                scope.endAction = function(){\n                    scope._actionRunning = false;\n                    if(_savedSelection){\n                        if(scope.showHtml){\n                            scope.displayElements.html[0].focus();\n                        }else{\n                            scope.displayElements.text[0].focus();\n                        }\n                        // rangy.restoreSelection(_savedSelection);\n                        rangy.removeMarkers(_savedSelection);\n                    }\n                    _savedSelection = false;\n                    scope.updateSelectedStyles();\n                    // only update if in text or WYSIWYG mode\n                    if(!scope.showHtml) scope['updateTaBindtaTextElement' + _serial]();\n                };\n\n                // note that focusout > focusin is called everytime we click a button - except bad support: http://www.quirksmode.org/dom/events/blurfocus.html\n                // cascades to displayElements.text and displayElements.html automatically.\n                _focusin = function(e){\n                    scope.focussed = true;\n                    element.addClass(scope.classes.focussed);\n                    /*******  NOT FUNCTIONAL YET\n                     if (e.target.id === 'taTextElement' + _serial) {\n                        console.log('_focusin taTextElement');\n                        // we only do this if NOT focussed\n                        textAngularManager.restoreFocusSelection(scope._name);\n                    }\n                     *******/\n                    _editorFunctions.focus();\n                    element.triggerHandler('focus');\n                    // we call editorScope.updateSelectedStyles() here because we want the toolbar to be focussed\n                    // as soon as we have focus.  Otherwise this only happens on mousedown or keydown etc...\n                    /* istanbul ignore else: don't run if already running */\n                    if(scope.updateSelectedStyles && !scope._bUpdateSelectedStyles){\n                        // we don't set editorScope._bUpdateSelectedStyles here, because we do not want the\n                        // updateSelectedStyles() to run twice which it will do after 200 msec if we have\n                        // set editorScope._bUpdateSelectedStyles\n                        //\n                        // WOW, normally I would do a scope.$apply here, but this causes ERRORs when doing tests!\n                        $timeout(function () {\n                            scope.updateSelectedStyles();\n                        }, 0);\n                    }\n                };\n                scope.displayElements.html.on('focus', _focusin);\n                scope.displayElements.text.on('focus', _focusin);\n                _focusout = function(e){\n                    /****************** NOT FUNCTIONAL YET\n                     try {\n                        var _s = rangy.getSelection();\n                        if (_s) {\n                            // we save the selection when we loose focus so that if do a wrapSelection, the\n                            // apropriate selection in the editor is restored before action.\n                            var _savedFocusRange = rangy.saveRange(_s.getRangeAt(0));\n                            textAngularManager.saveFocusSelection(scope._name, _savedFocusRange);\n                        }\n                    } catch(error) { }\n                     *****************/\n                    // if we are NOT runnig an action and have NOT focussed again on the text etc then fire the blur events\n                    if(!scope._actionRunning &&\n                        $document[0].activeElement !== scope.displayElements.html[0] &&\n                        $document[0].activeElement !== scope.displayElements.text[0])\n                    {\n                        element.removeClass(scope.classes.focussed);\n                        _editorFunctions.unfocus();\n                        // to prevent multiple apply error defer to next seems to work.\n                        $timeout(function(){\n                            scope._bUpdateSelectedStyles = false;\n                            element.triggerHandler('blur');\n                            scope.focussed = false;\n                        }, 0);\n                    }\n                    e.preventDefault();\n                    return false;\n                };\n                scope.displayElements.html.on('blur', _focusout);\n                scope.displayElements.text.on('blur', _focusout);\n\n                scope.displayElements.text.on('paste', function(event){\n                    element.triggerHandler('paste', event);\n                });\n\n                // Setup the default toolbar tools, this way allows the user to add new tools like plugins.\n                // This is on the editor for future proofing if we find a better way to do this.\n                scope.queryFormatBlockState = function(command){\n                    // $document[0].queryCommandValue('formatBlock') errors in Firefox if we call this when focussed on the textarea\n                    return !scope.showHtml && command.toLowerCase() === $document[0].queryCommandValue('formatBlock').toLowerCase();\n                };\n                scope.queryCommandState = function(command){\n                    // $document[0].queryCommandValue('formatBlock') errors in Firefox if we call this when focussed on the textarea\n                    return (!scope.showHtml) ? $document[0].queryCommandState(command) : '';\n                };\n                scope.switchView = function(){\n                    scope.showHtml = !scope.showHtml;\n                    $animate.enabled(false, scope.displayElements.html);\n                    $animate.enabled(false, scope.displayElements.text);\n                    //Show the HTML view\n                    /* istanbul ignore next: ngModel exists check */\n                    /* THIS is not the correct thing to do, here....\n                     The ngModel is correct, but it is not formatted as the user as done it...\n                     var _model;\n                     if (ngModel) {\n                     _model = ngModel.$viewValue;\n                     } else {\n                     _model = scope.html;\n                     }\n                     var _html = scope.displayElements.html[0].value;\n                     if (getDomFromHtml(_html).childElementCount !== getDomFromHtml(_model).childElementCount) {\n                     // the model and the html do not agree\n                     // they can get out of sync and when they do, we correct that here...\n                     scope.displayElements.html.val(_model);\n                     }\n                     */\n                    if(scope.showHtml){\n                        //defer until the element is visible\n                        $timeout(function(){\n                            $animate.enabled(true, scope.displayElements.html);\n                            $animate.enabled(true, scope.displayElements.text);\n                            // [0] dereferences the DOM object from the angular.element\n                            return scope.displayElements.html[0].focus();\n                        }, 100);\n                    }else{\n                        //Show the WYSIWYG view\n                        //defer until the element is visible\n                        $timeout(function(){\n                            $animate.enabled(true, scope.displayElements.html);\n                            $animate.enabled(true, scope.displayElements.text);\n                            // [0] dereferences the DOM object from the angular.element\n                            return scope.displayElements.text[0].focus();\n                        }, 100);\n                    }\n                };\n\n                // changes to the model variable from outside the html/text inputs\n                // if no ngModel, then the only input is from inside text-angular\n                if(attrs.ngModel){\n                    var _firstRun = true;\n                    ngModel.$render = function(){\n                        if(_firstRun){\n                            // we need this firstRun to set the originalContents otherwise it gets overrided by the setting of ngModel to undefined from NaN\n                            _firstRun = false;\n                            // if view value is null or undefined initially and there was original content, set to the original content\n                            var _initialValue = scope.$parent.$eval(attrs.ngModel);\n                            if((_initialValue === undefined || _initialValue === null) && (_originalContents && _originalContents !== '')){\n                                // on passing through to taBind it will be sanitised\n                                ngModel.$setViewValue(_originalContents);\n                            }\n                        }\n                        scope.displayElements.forminput.val(ngModel.$viewValue);\n                        // if the editors aren't focused they need to be updated, otherwise they are doing the updating\n                        scope.html = ngModel.$viewValue || '';\n                    };\n                    // trigger the validation calls\n                    if(element.attr('required')) ngModel.$validators.required = function(modelValue, viewValue) {\n                        var value = modelValue || viewValue;\n                        return !(!value || value.trim() === '');\n                    };\n                }else{\n                    // if no ngModel then update from the contents of the origional html.\n                    scope.displayElements.forminput.val(_originalContents);\n                    scope.html = _originalContents;\n                }\n\n                // changes from taBind back up to here\n                scope.$watch('html', function(newValue, oldValue){\n                    if(newValue !== oldValue){\n                        if(attrs.ngModel && ngModel.$viewValue !== newValue) {\n                            ngModel.$setViewValue(newValue);\n                        }\n                        scope.displayElements.forminput.val(newValue);\n                    }\n                });\n\n                if(attrs.taTargetToolbars) {\n                    _editorFunctions = textAngularManager.registerEditor(scope._name, scope, attrs.taTargetToolbars.split(','));\n                }\n                else{\n                    var _toolbar = angular.element('<div text-angular-toolbar name=\"textAngularToolbar' + _serial + '\">');\n                    // passthrough init of toolbar options\n                    if(attrs.taToolbar)\t\t\t\t\t\t_toolbar.attr('ta-toolbar', attrs.taToolbar);\n                    if(attrs.taToolbarClass)\t\t\t\t_toolbar.attr('ta-toolbar-class', attrs.taToolbarClass);\n                    if(attrs.taToolbarGroupClass)\t\t\t_toolbar.attr('ta-toolbar-group-class', attrs.taToolbarGroupClass);\n                    if(attrs.taToolbarButtonClass)\t\t\t_toolbar.attr('ta-toolbar-button-class', attrs.taToolbarButtonClass);\n                    if(attrs.taToolbarActiveButtonClass)\t_toolbar.attr('ta-toolbar-active-button-class', attrs.taToolbarActiveButtonClass);\n                    if(attrs.taFocussedClass)\t\t\t\t_toolbar.attr('ta-focussed-class', attrs.taFocussedClass);\n\n                    element.prepend(_toolbar);\n                    $compile(_toolbar)(scope.$parent);\n                    _editorFunctions = textAngularManager.registerEditor(scope._name, scope, ['textAngularToolbar' + _serial]);\n                }\n\n                scope.$on('$destroy', function(){\n                    textAngularManager.unregisterEditor(scope._name);\n                    angular.element(window).off('blur');\n                    angular.element(window).off('resize', scope.handlePopoverEvents);\n                    angular.element(window).off('scroll', scope.handlePopoverEvents);\n                });\n\n                // catch element select event and pass to toolbar tools\n                scope.$on('ta-element-select', function(event, element){\n                    if(_editorFunctions.triggerElementSelect(event, element)){\n                        scope['reApplyOnSelectorHandlerstaTextElement' + _serial]();\n                    }\n                });\n\n                /******************* no working fully\n                 var distanceFromPoint = function (px, py, x, y) {\n                    return Math.sqrt((px-x)*(px-x)+(py-y)*(py-y));\n                };\n                 // because each object is a rectangle and we have a single point,\n                 // we need to give priority if the point is inside the rectangle\n                 var getPositionDistance = function(el, x, y) {\n                    var range = document.createRange();\n                    range.selectNode(el);\n                    var rect = range.getBoundingClientRect();\n                    console.log(el, rect);\n                    range.detach();\n                    var bcr = rect;\n                    // top left\n                    var d1 = distanceFromPoint(bcr.left, bcr.top, x, y);\n                    // bottom left\n                    var d2 = distanceFromPoint(bcr.left, bcr.bottom, x, y);\n                    // top right\n                    var d3 = distanceFromPoint(bcr.right, bcr.top, x, y);\n                    // bottom right\n                    var d4 = distanceFromPoint(bcr.right, bcr.bottom, x, y);\n                    return Math.min(d1, d2, d3, d4);\n                };\n                 var findClosest = function(el, minElement, maxDistance, x, y) {\n                    var _d=0;\n                    for (var i = 0; i < el.childNodes.length; i++) {\n                        var _n = el.childNodes[i];\n                        if (!_n.childNodes.length) {\n                            _d = getPositionDistance(_n, x, y);\n                            //console.log(_n, _n.childNodes, _d);\n                            if (_d < maxDistance) {\n                                maxDistance = _d;\n                                minElement = _n;\n                            }\n                        }\n                        var res = findClosest(_n, minElement, maxDistance, x, y);\n                        if (res.max < maxDistance) {\n                            maxDistance = res.max;\n                            minElement = res.min;\n                        }\n                    }\n                    return { max: maxDistance, min: minElement };\n                };\n                 var getClosestElement = function (el, x, y) {\n                    return findClosest(el, null, 12341234124, x, y);\n                };\n                 ****************/\n\n                scope.$on('ta-drop-event', function(event, element, dropEvent, dataTransfer){\n                    if(dataTransfer && dataTransfer.files && dataTransfer.files.length > 0){\n                        scope.displayElements.text[0].focus();\n                        // we must set the location of the drop!\n                        //console.log(dropEvent.clientX, dropEvent.clientY, dropEvent.target);\n                        taSelection.setSelectionToElementEnd(dropEvent.target);\n                        angular.forEach(dataTransfer.files, function(file){\n                            // taking advantage of boolean execution, if the fileDropHandler returns true, nothing else after it is executed\n                            // If it is false then execute the defaultFileDropHandler if the fileDropHandler is NOT the default one\n                            // Once one of these has been executed wrap the result as a promise, if undefined or variable update the taBind, else we should wait for the promise\n                            try{\n                                $q.when(scope.fileDropHandler(file, scope.wrapSelection) ||\n                                    (scope.fileDropHandler !== scope.defaultFileDropHandler &&\n                                    $q.when(scope.defaultFileDropHandler(file, scope.wrapSelection)))).then(function(){\n                                    scope['updateTaBindtaTextElement' + _serial]();\n                                });\n                            }catch(error){\n                                $log.error(error);\n                            }\n                        });\n                        dropEvent.preventDefault();\n                        dropEvent.stopPropagation();\n                        /* istanbul ignore else, the updates if moved text */\n                    }else{\n                        $timeout(function(){\n                            scope['updateTaBindtaTextElement' + _serial]();\n                        }, 0);\n                    }\n                });\n\n                // the following is for applying the active states to the tools that support it\n                scope._bUpdateSelectedStyles = false;\n                /* istanbul ignore next: browser window/tab leave check */\n                angular.element(window).on('blur', function(){\n                    scope._bUpdateSelectedStyles = false;\n                    scope.focussed = false;\n                });\n                // loop through all the tools polling their activeState function if it exists\n                scope.updateSelectedStyles = function(){\n                    var _selection;\n                    /* istanbul ignore next: This check is to ensure multiple timeouts don't exist */\n                    if(_updateSelectedStylesTimeout) $timeout.cancel(_updateSelectedStylesTimeout);\n                    // test if the common element ISN'T the root ta-text node\n                    if((_selection = taSelection.getSelectionElement()) !== undefined && _selection.parentNode !== scope.displayElements.text[0]){\n                        _editorFunctions.updateSelectedStyles(angular.element(_selection));\n                    }else _editorFunctions.updateSelectedStyles();\n                    // used to update the active state when a key is held down, ie the left arrow\n                    /* istanbul ignore else: browser only check */\n                    if(scope._bUpdateSelectedStyles) _updateSelectedStylesTimeout = $timeout(scope.updateSelectedStyles, 200);\n                };\n                // start updating on keydown\n                _keydown = function(){\n                    /* istanbul ignore next: ie catch */\n                    if(!scope.focussed){\n                        scope._bUpdateSelectedStyles = false;\n                        return;\n                    }\n                    /* istanbul ignore else: don't run if already running */\n                    if(!scope._bUpdateSelectedStyles){\n                        scope._bUpdateSelectedStyles = true;\n                        scope.$apply(function(){\n                            scope.updateSelectedStyles();\n                        });\n                    }\n                };\n                scope.displayElements.html.on('keydown', _keydown);\n                scope.displayElements.text.on('keydown', _keydown);\n                // stop updating on key up and update the display/model\n                _keyup = function(){\n                    scope._bUpdateSelectedStyles = false;\n                };\n                scope.displayElements.html.on('keyup', _keyup);\n                scope.displayElements.text.on('keyup', _keyup);\n                // stop updating on key up and update the display/model\n                _keypress = function(event, eventData){\n                    // bug fix for Firefox.  If we are selecting a <a> already, any characters will\n                    // be added within the <a> which is bad!\n                    /* istanbul ignore next: don't see how to test this... */\n                    if (taSelection.getSelection) {\n                        var _selection = taSelection.getSelection();\n                        // in a weird case (can't reproduce) taSelection.getSelectionElement() can be undefined!!\n                        // this comes from range.commonAncestorContainer;\n                        // so I check for this here which fixes the error case\n                        if (taSelection.getSelectionElement() && taSelection.getSelectionElement().nodeName.toLowerCase() === 'a') {\n                            // check and see if we are at the edge of the <a>\n                            if (_selection.start.element.nodeType === 3 &&\n                                _selection.start.element.textContent.length === _selection.end.offset) {\n                                // we are at the end of the <a>!!!\n                                // so move the selection to after the <a>!!\n                                taSelection.setSelectionAfterElement(taSelection.getSelectionElement());\n                            }\n                            if (_selection.start.element.nodeType === 3 &&\n                                _selection.start.offset === 0) {\n                                // we are at the start of the <a>!!!\n                                // so move the selection before the <a>!!\n                                taSelection.setSelectionBeforeElement(taSelection.getSelectionElement());\n                            }\n                        }\n                    }\n                    /* istanbul ignore else: this is for catching the jqLite testing*/\n                    if(eventData) angular.extend(event, eventData);\n                    scope.$apply(function(){\n                        if(_editorFunctions.sendKeyCommand(event)){\n                            /* istanbul ignore else: don't run if already running */\n                            if(!scope._bUpdateSelectedStyles){\n                                scope.updateSelectedStyles();\n                            }\n                            event.preventDefault();\n                            return false;\n                        }\n                    });\n                };\n                scope.displayElements.html.on('keypress', _keypress);\n                scope.displayElements.text.on('keypress', _keypress);\n                // update the toolbar active states when we click somewhere in the text/html boxed\n                _mouseup = function(){\n                    // ensure only one execution of updateSelectedStyles()\n                    scope._bUpdateSelectedStyles = false;\n                    // for some reason, unless we do a $timeout here, after a _mouseup when the line is\n                    // highlighted, and instead use a scope.$apply(function(){ scope.updateSelectedStyles(); });\n                    // doesn't work properly, so we replaced this with:\n                    /* istanbul ignore next: not tested  */\n                    $timeout(function() { scope.updateSelectedStyles(); }, 0);\n                };\n                scope.displayElements.html.on('mouseup', _mouseup);\n                scope.displayElements.text.on('mouseup', _mouseup);\n            }\n        };\n    }\n]);\ntextAngular.service('textAngularManager', ['taToolExecuteAction', 'taTools', 'taRegisterTool', '$interval', '$rootScope', '$log',\n    function(taToolExecuteAction, taTools, taRegisterTool, $interval, $rootScope, $log){\n        // this service is used to manage all textAngular editors and toolbars.\n        // All publicly published functions that modify/need to access the toolbar or editor scopes should be in here\n        // these contain references to all the editors and toolbars that have been initialised in this app\n        var toolbars = {}, editors = {};\n        // we touch the time any change occurs through register of an editor or tool so that we\n        // in the future will fire and event to trigger an updateSelection\n        var timeRecentModification = 0;\n        var updateStyles = function(selectedElement){\n            angular.forEach(editors, function(editor) {\n                editor.editorFunctions.updateSelectedStyles(selectedElement);\n            });\n        };\n        var triggerInterval = 50;\n        var triggerIntervalTimer;\n        var setupTriggerUpdateStyles = function() {\n            timeRecentModification = Date.now();\n            /* istanbul ignore next: setup a one time updateStyles() */\n            triggerIntervalTimer = $interval(function() {\n                updateStyles();\n                triggerIntervalTimer = undefined;\n            }, triggerInterval, 1); // only trigger once\n        };\n        /* istanbul ignore next: make sure clean up on destroy */\n        $rootScope.$on('destroy', function() {\n            if (triggerIntervalTimer) {\n                $interval.cancel(triggerIntervalTimer);\n                triggerIntervalTimer = undefined;\n            }\n        });\n        var touchModification = function() {\n            if (Math.abs(Date.now() - timeRecentModification) > triggerInterval) {\n                // we have already triggered the updateStyles a long time back... so setup it again...\n                setupTriggerUpdateStyles();\n            }\n        };\n        // when we focus into a toolbar, we need to set the TOOLBAR's $parent to be the toolbars it's linked to.\n        // We also need to set the tools to be updated to be the toolbars...\n        return {\n            // register an editor and the toolbars that it is affected by\n            registerEditor: function(editorName, editorScope, targetToolbars){\n                // NOTE: name === editorScope._name\n                // targetToolbars is an [] of 'toolbar name's\n                // targetToolbars are optional, we don't require a toolbar to function\n                if(!editorName || editorName === '') throw('textAngular Error: An editor requires a name');\n                if(!editorScope) throw('textAngular Error: An editor requires a scope');\n                if(editors[editorName]) throw('textAngular Error: An Editor with name \"' + editorName + '\" already exists');\n                editors[editorName] = {\n                    scope: editorScope,\n                    toolbars: targetToolbars,\n                    // toolbarScopes used by this editor\n                    toolbarScopes: [],\n                    _registerToolbarScope: function(toolbarScope){\n                        // add to the list late\n                        if(this.toolbars.indexOf(toolbarScope.name) >= 0) {\n                            // if this toolbarScope is being used by this editor we add it as one of the scopes\n                            this.toolbarScopes.push(toolbarScope);\n                        }\n                    },\n                    // this is a suite of functions the editor should use to update all it's linked toolbars\n                    editorFunctions: {\n                        disable: function(){\n                            // disable all linked toolbars\n                            angular.forEach(editors[editorName].toolbarScopes, function(toolbarScope){\n                                toolbarScope.disabled = true;\n                            });\n                        },\n                        enable: function(){\n                            // enable all linked toolbars\n                            angular.forEach(editors[editorName].toolbarScopes, function(toolbarScope){\n                                toolbarScope.disabled = false;\n                            });\n                        },\n                        focus: function(){\n                            // this should be called when the editor is focussed\n                            angular.forEach(editors[editorName].toolbarScopes, function(toolbarScope){\n                                toolbarScope._parent = editorScope;\n                                toolbarScope.disabled = false;\n                                toolbarScope.focussed = true;\n                            });\n                            editorScope.focussed = true;\n                        },\n                        unfocus: function(){\n                            // this should be called when the editor becomes unfocussed\n                            angular.forEach(editors[editorName].toolbarScopes, function(toolbarScope){\n                                toolbarScope.disabled = true;\n                                toolbarScope.focussed = false;\n                            });\n                            editorScope.focussed = false;\n                        },\n                        updateSelectedStyles: function(selectedElement){\n                            // update the active state of all buttons on liked toolbars\n                            angular.forEach(editors[editorName].toolbarScopes, function(toolbarScope){\n                                angular.forEach(toolbarScope.tools, function(toolScope){\n                                    if(toolScope.activeState){\n                                        toolbarScope._parent = editorScope;\n                                        // selectedElement may be undefined if nothing selected\n                                        toolScope.active = toolScope.activeState(selectedElement);\n                                    }\n                                });\n                            });\n                        },\n                        sendKeyCommand: function(event){\n                            // we return true if we applied an action, false otherwise\n                            var result = false;\n                            if(event.ctrlKey || event.metaKey || event.specialKey) angular.forEach(taTools, function(tool, name){\n                                if(tool.commandKeyCode && (tool.commandKeyCode === event.which || tool.commandKeyCode === event.specialKey)){\n                                    for(var _t = 0; _t < editors[editorName].toolbarScopes.length; _t++){\n                                        if(editors[editorName].toolbarScopes[_t].tools[name] !== undefined){\n                                            taToolExecuteAction.call(editors[editorName].toolbarScopes[_t].tools[name], editorScope);\n                                            result = true;\n                                            break;\n                                        }\n                                    }\n                                }\n                            });\n                            return result;\n                        },\n                        triggerElementSelect: function(event, element){\n                            // search through the taTools to see if a match for the tag is made.\n                            // if there is, see if the tool is on a registered toolbar and not disabled.\n                            // NOTE: This can trigger on MULTIPLE tools simultaneously.\n                            var elementHasAttrs = function(_element, attrs){\n                                var result = true;\n                                for(var i = 0; i < attrs.length; i++) result = result && _element.attr(attrs[i]);\n                                return result;\n                            };\n                            var workerTools = [];\n                            var unfilteredTools = {};\n                            var result = false;\n                            element = angular.element(element);\n                            // get all valid tools by element name, keep track if one matches the\n                            var onlyWithAttrsFilter = false;\n                            angular.forEach(taTools, function(tool, name){\n                                if(\n                                    tool.onElementSelect &&\n                                    tool.onElementSelect.element &&\n                                    tool.onElementSelect.element.toLowerCase() === element[0].tagName.toLowerCase() &&\n                                    (!tool.onElementSelect.filter || tool.onElementSelect.filter(element))\n                                ){\n                                    // this should only end up true if the element matches the only attributes\n                                    onlyWithAttrsFilter = onlyWithAttrsFilter ||\n                                        (angular.isArray(tool.onElementSelect.onlyWithAttrs) && elementHasAttrs(element, tool.onElementSelect.onlyWithAttrs));\n                                    if(!tool.onElementSelect.onlyWithAttrs || elementHasAttrs(element, tool.onElementSelect.onlyWithAttrs)) unfilteredTools[name] = tool;\n                                }\n                            });\n                            // if we matched attributes to filter on, then filter, else continue\n                            if(onlyWithAttrsFilter){\n                                angular.forEach(unfilteredTools, function(tool, name){\n                                    if(tool.onElementSelect.onlyWithAttrs && elementHasAttrs(element, tool.onElementSelect.onlyWithAttrs)) workerTools.push({'name': name, 'tool': tool});\n                                });\n                                // sort most specific (most attrs to find) first\n                                workerTools.sort(function(a,b){\n                                    return b.tool.onElementSelect.onlyWithAttrs.length - a.tool.onElementSelect.onlyWithAttrs.length;\n                                });\n                            }else{\n                                angular.forEach(unfilteredTools, function(tool, name){\n                                    workerTools.push({'name': name, 'tool': tool});\n                                });\n                            }\n                            // Run the actions on the first visible filtered tool only\n                            if(workerTools.length > 0){\n                                for(var _i = 0; _i < workerTools.length; _i++){\n                                    var tool = workerTools[_i].tool;\n                                    var name = workerTools[_i].name;\n                                    for(var _t = 0; _t < editors[editorName].toolbarScopes.length; _t++){\n                                        if(editors[editorName].toolbarScopes[_t].tools[name] !== undefined){\n                                            tool.onElementSelect.action.call(editors[editorName].toolbarScopes[_t].tools[name], event, element, editorScope);\n                                            result = true;\n                                            break;\n                                        }\n                                    }\n                                    if(result) break;\n                                }\n                            }\n                            return result;\n                        }\n                    }\n                };\n                angular.forEach(targetToolbars, function(_name){\n                    if(toolbars[_name]) {\n                        editors[editorName].toolbarScopes.push(toolbars[_name]);\n                    }\n                    // if it doesn't exist it may not have been compiled yet and it will be added later\n                });\n                touchModification();\n                return editors[editorName].editorFunctions;\n            },\n            // retrieve editor by name, largely used by testing suites only\n            retrieveEditor: function(name){\n                return editors[name];\n            },\n            unregisterEditor: function(name){\n                delete editors[name];\n                touchModification();\n            },\n            // registers a toolbar such that it can be linked to editors\n            registerToolbar: function(toolbarScope){\n                if(!toolbarScope) throw('textAngular Error: A toolbar requires a scope');\n                if(!toolbarScope.name || toolbarScope.name === '') throw('textAngular Error: A toolbar requires a name');\n                if(toolbars[toolbarScope.name]) throw('textAngular Error: A toolbar with name \"' + toolbarScope.name + '\" already exists');\n                toolbars[toolbarScope.name] = toolbarScope;\n                // walk all the editors and connect this toolbarScope to the editors.... if we need to.  This way, it does\n                // not matter if we register the editors after the toolbars or not\n                // Note the editor will ignore this toolbarScope if it is not connected to it...\n                angular.forEach(editors, function(_editor){\n                    _editor._registerToolbarScope(toolbarScope);\n                });\n                touchModification();\n            },\n            // retrieve toolbar by name, largely used by testing suites only\n            retrieveToolbar: function(name){\n                return toolbars[name];\n            },\n            // retrieve toolbars by editor name, largely used by testing suites only\n            retrieveToolbarsViaEditor: function(name){\n                var result = [], _this = this;\n                angular.forEach(this.retrieveEditor(name).toolbars, function(name){\n                    result.push(_this.retrieveToolbar(name));\n                });\n                return result;\n            },\n            unregisterToolbar: function(name){\n                delete toolbars[name];\n                touchModification();\n            },\n            // functions for updating the toolbar buttons display\n            updateToolsDisplay: function(newTaTools){\n                // pass a partial struct of the taTools, this allows us to update the tools on the fly, will not change the defaults.\n                var _this = this;\n                angular.forEach(newTaTools, function(_newTool, key){\n                    _this.updateToolDisplay(key, _newTool);\n                });\n            },\n            // this function resets all toolbars to their default tool definitions\n            resetToolsDisplay: function(){\n                var _this = this;\n                angular.forEach(taTools, function(_newTool, key){\n                    _this.resetToolDisplay(key);\n                });\n                touchModification();\n            },\n            // update a tool on all toolbars\n            updateToolDisplay: function(toolKey, _newTool){\n                var _this = this;\n                angular.forEach(toolbars, function(toolbarScope, toolbarKey){\n                    _this.updateToolbarToolDisplay(toolbarKey, toolKey, _newTool);\n                });\n                touchModification();\n            },\n            // resets a tool to the default/starting state on all toolbars\n            resetToolDisplay: function(toolKey){\n                var _this = this;\n                angular.forEach(toolbars, function(toolbarScope, toolbarKey){\n                    _this.resetToolbarToolDisplay(toolbarKey, toolKey);\n                });\n                touchModification();\n            },\n            // update a tool on a specific toolbar\n            updateToolbarToolDisplay: function(toolbarKey, toolKey, _newTool){\n                if(toolbars[toolbarKey]) toolbars[toolbarKey].updateToolDisplay(toolKey, _newTool);\n                else throw('textAngular Error: No Toolbar with name \"' + toolbarKey + '\" exists');\n            },\n            // reset a tool on a specific toolbar to it's default starting value\n            resetToolbarToolDisplay: function(toolbarKey, toolKey){\n                if(toolbars[toolbarKey]) toolbars[toolbarKey].updateToolDisplay(toolKey, taTools[toolKey], true);\n                else throw('textAngular Error: No Toolbar with name \"' + toolbarKey + '\" exists');\n            },\n            // removes a tool from all toolbars and it's definition\n            removeTool: function(toolKey){\n                delete taTools[toolKey];\n                angular.forEach(toolbars, function(toolbarScope){\n                    delete toolbarScope.tools[toolKey];\n                    for(var i = 0; i < toolbarScope.toolbar.length; i++){\n                        var toolbarIndex;\n                        for(var j = 0; j < toolbarScope.toolbar[i].length; j++){\n                            if(toolbarScope.toolbar[i][j] === toolKey){\n                                toolbarIndex = {\n                                    group: i,\n                                    index: j\n                                };\n                                break;\n                            }\n                            if(toolbarIndex !== undefined) break;\n                        }\n                        if(toolbarIndex !== undefined){\n                            toolbarScope.toolbar[toolbarIndex.group].slice(toolbarIndex.index, 1);\n                            toolbarScope._$element.children().eq(toolbarIndex.group).children().eq(toolbarIndex.index).remove();\n                        }\n                    }\n                });\n                touchModification();\n            },\n            // toolkey, toolDefinition are required. If group is not specified will pick the last group, if index isnt defined will append to group\n            addTool: function(toolKey, toolDefinition, group, index){\n                taRegisterTool(toolKey, toolDefinition);\n                angular.forEach(toolbars, function(toolbarScope){\n                    toolbarScope.addTool(toolKey, toolDefinition, group, index);\n                });\n                touchModification();\n            },\n            // adds a Tool but only to one toolbar not all\n            addToolToToolbar: function(toolKey, toolDefinition, toolbarKey, group, index){\n                taRegisterTool(toolKey, toolDefinition);\n                toolbars[toolbarKey].addTool(toolKey, toolDefinition, group, index);\n                touchModification();\n            },\n            // this is used when externally the html of an editor has been changed and textAngular needs to be notified to update the model.\n            // this will call a $digest if not already happening\n            refreshEditor: function(name){\n                if(editors[name]){\n                    editors[name].scope.updateTaBindtaTextElement();\n                    /* istanbul ignore else: phase catch */\n                    if(!editors[name].scope.$$phase) editors[name].scope.$digest();\n                }else throw('textAngular Error: No Editor with name \"' + name + '\" exists');\n                touchModification();\n            },\n            // this is used by taBind to send a key command in response to a special key event\n            sendKeyCommand: function(scope, event){\n                var _editor = editors[scope._name];\n                /* istanbul ignore else: if nothing to do, do nothing */\n                if (_editor && _editor.editorFunctions.sendKeyCommand(event)) {\n                    /* istanbul ignore else: don't run if already running */\n                    if(!scope._bUpdateSelectedStyles){\n                        scope.updateSelectedStyles();\n                    }\n                    event.preventDefault();\n                    return false;\n                }\n            },\n            //\n            // When a toolbar and tools are created, it isn't until there is a key event or mouse event\n            // that the updateSelectedStyles() is called behind the scenes.\n            // This function forces an update through the existing editors to help the application make sure\n            // the inital state is correct.\n            //\n            updateStyles: updateStyles,\n            // return the current version of textAngular in use to the user\n            getVersion: function () { return textAngularVersion; },\n            // for testing\n            getToolbarScopes: function () {\n                var tmp=[];\n                angular.forEach(editors, function (_editor) {\n                    tmp = tmp.concat(_editor.toolbarScopes);\n                });\n                return tmp;\n            }\n            /********************** not functional yet\n             // save the selection ('range') for the given editor\n             saveFocusSelection: function (name, range) {\n            editors[name].savedFocusRange = range;\n        },\n             // restore the saved selection from when the focus was lost\n             restoreFocusSelection: function(name, scope) {\n            // we only do this if NOT focussed and saved...\n            if (editors[name].savedFocusRange && !scope.focussed) {\n                try {\n                    var _r = rangy.restoreRange(editors[name].savedFocusRange);\n                    var _sel = rangy.getSelection();\n                    _sel.addRange(_r);\n                } catch(e) {}\n            }\n        }\n             *************/\n        };\n    }]);\ntextAngular.directive('textAngularToolbar', [\n    '$compile', 'textAngularManager', 'taOptions', 'taTools', 'taToolExecuteAction', '$window',\n    function($compile, textAngularManager, taOptions, taTools, taToolExecuteAction, $window){\n        return {\n            scope: {\n                name: '@' // a name IS required\n            },\n            restrict: \"EA\",\n            link: function(scope, element, attrs){\n                if(!scope.name || scope.name === '') throw('textAngular Error: A toolbar requires a name');\n                angular.extend(scope, angular.copy(taOptions));\n                if(attrs.taToolbar)\t\t\t\t\t\tscope.toolbar = scope.$parent.$eval(attrs.taToolbar);\n                if(attrs.taToolbarClass)\t\t\t\tscope.classes.toolbar = attrs.taToolbarClass;\n                if(attrs.taToolbarGroupClass)\t\t\tscope.classes.toolbarGroup = attrs.taToolbarGroupClass;\n                if(attrs.taToolbarButtonClass)\t\t\tscope.classes.toolbarButton = attrs.taToolbarButtonClass;\n                if(attrs.taToolbarActiveButtonClass)\tscope.classes.toolbarButtonActive = attrs.taToolbarActiveButtonClass;\n                if(attrs.taFocussedClass)\t\t\t\tscope.classes.focussed = attrs.taFocussedClass;\n\n                scope.disabled = true;\n                scope.focussed = false;\n                scope._$element = element;\n                element[0].innerHTML = '';\n                element.addClass(\"ta-toolbar \" + scope.classes.toolbar);\n\n                scope.$watch('focussed', function(){\n                    if(scope.focussed) element.addClass(scope.classes.focussed);\n                    else element.removeClass(scope.classes.focussed);\n                });\n\n                var setupToolElement = function(toolDefinition, toolScope){\n                    var toolElement;\n                    if(toolDefinition && toolDefinition.display){\n                        toolElement = angular.element(toolDefinition.display);\n                    }\n                    else toolElement = angular.element(\"<button type='button'>\");\n\n                    if(toolDefinition && toolDefinition[\"class\"]) toolElement.addClass(toolDefinition[\"class\"]);\n                    else toolElement.addClass(scope.classes.toolbarButton);\n\n                    toolElement.attr('name', toolScope.name);\n                    // important to not take focus from the main text/html entry\n                    toolElement.attr('ta-button', 'ta-button');\n                    toolElement.attr('ng-disabled', 'isDisabled()');\n                    toolElement.attr('tabindex', '-1');\n                    toolElement.attr('ng-click', 'executeAction()');\n                    toolElement.attr('ng-class', 'displayActiveToolClass(active)');\n\n                    if (toolDefinition && toolDefinition.tooltiptext) {\n                        toolElement.attr('title', toolDefinition.tooltiptext);\n                    }\n                    if(toolDefinition && !toolDefinition.display && !toolScope._display){\n                        // first clear out the current contents if any\n                        toolElement[0].innerHTML = '';\n                        // add the buttonText\n                        if(toolDefinition.buttontext) toolElement[0].innerHTML = toolDefinition.buttontext;\n                        // add the icon to the front of the button if there is content\n                        if(toolDefinition.iconclass){\n                            var icon = angular.element('<i>'), content = toolElement[0].innerHTML;\n                            icon.addClass(toolDefinition.iconclass);\n                            toolElement[0].innerHTML = '';\n                            toolElement.append(icon);\n                            if(content && content !== '') toolElement.append('&nbsp;' + content);\n                        }\n                    }\n\n                    toolScope._lastToolDefinition = angular.copy(toolDefinition);\n\n                    return $compile(toolElement)(toolScope);\n                };\n\n                // Keep a reference for updating the active states later\n                scope.tools = {};\n                // create the tools in the toolbar\n                // default functions and values to prevent errors in testing and on init\n                scope._parent = {\n                    disabled: true,\n                    showHtml: false,\n                    queryFormatBlockState: function(){ return false; },\n                    queryCommandState: function(){ return false; }\n                };\n                var defaultChildScope = {\n                    $window: $window,\n                    $editor: function(){\n                        // dynamically gets the editor as it is set\n                        return scope._parent;\n                    },\n                    isDisabled: function(){\n                        // view selection button is always enabled since it doesn not depend on a selction!\n                        if (this.name === 'html' && scope._parent.startAction) {\n                            return false;\n                        }\n                        // to set your own disabled logic set a function or boolean on the tool called 'disabled'\n                        return ( // this bracket is important as without it it just returns the first bracket and ignores the rest\n                            // when the button's disabled function/value evaluates to true\n                            (typeof this.$eval('disabled') !== 'function' && this.$eval('disabled')) || this.$eval('disabled()') ||\n                            // all buttons except the HTML Switch button should be disabled in the showHtml (RAW html) mode\n                            (this.name !== 'html' && this.$editor().showHtml) ||\n                            // if the toolbar is disabled\n                            this.$parent.disabled ||\n                            // if the current editor is disabled\n                            this.$editor().disabled\n                        );\n                    },\n                    displayActiveToolClass: function(active){\n                        return (active)? scope.classes.toolbarButtonActive : '';\n                    },\n                    executeAction: taToolExecuteAction\n                };\n\n                angular.forEach(scope.toolbar, function(group){\n                    // setup the toolbar group\n                    var groupElement = angular.element(\"<div>\");\n                    groupElement.addClass(scope.classes.toolbarGroup);\n                    angular.forEach(group, function(tool){\n                        // init and add the tools to the group\n                        // a tool name (key name from taTools struct)\n                        //creates a child scope of the main angularText scope and then extends the childScope with the functions of this particular tool\n                        // reference to the scope and element kept\n                        scope.tools[tool] = angular.extend(scope.$new(true), taTools[tool], defaultChildScope, {name: tool});\n                        scope.tools[tool].$element = setupToolElement(taTools[tool], scope.tools[tool]);\n                        // append the tool compiled with the childScope to the group element\n                        groupElement.append(scope.tools[tool].$element);\n                    });\n                    // append the group to the toolbar\n                    element.append(groupElement);\n                });\n\n                // update a tool\n                // if a value is set to null, remove from the display\n                // when forceNew is set to true it will ignore all previous settings, used to reset to taTools definition\n                // to reset to defaults pass in taTools[key] as _newTool and forceNew as true, ie `updateToolDisplay(key, taTools[key], true);`\n                scope.updateToolDisplay = function(key, _newTool, forceNew){\n                    var toolInstance = scope.tools[key];\n                    if(toolInstance){\n                        // get the last toolDefinition, then override with the new definition\n                        if(toolInstance._lastToolDefinition && !forceNew) _newTool = angular.extend({}, toolInstance._lastToolDefinition, _newTool);\n                        if(_newTool.buttontext === null && _newTool.iconclass === null && _newTool.display === null)\n                            throw('textAngular Error: Tool Definition for updating \"' + key + '\" does not have a valid display/iconclass/buttontext value');\n\n                        // if tool is defined on this toolbar, update/redo the tool\n                        if(_newTool.buttontext === null){\n                            delete _newTool.buttontext;\n                        }\n                        if(_newTool.iconclass === null){\n                            delete _newTool.iconclass;\n                        }\n                        if(_newTool.display === null){\n                            delete _newTool.display;\n                        }\n\n                        var toolElement = setupToolElement(_newTool, toolInstance);\n                        toolInstance.$element.replaceWith(toolElement);\n                        toolInstance.$element = toolElement;\n                    }\n                };\n\n                // we assume here that all values passed are valid and correct\n                scope.addTool = function(key, _newTool, groupIndex, index){\n                    scope.tools[key] = angular.extend(scope.$new(true), taTools[key], defaultChildScope, {name: key});\n                    scope.tools[key].$element = setupToolElement(taTools[key], scope.tools[key]);\n                    var group;\n                    if(groupIndex === undefined) groupIndex = scope.toolbar.length - 1;\n                    group = angular.element(element.children()[groupIndex]);\n\n                    if(index === undefined){\n                        group.append(scope.tools[key].$element);\n                        scope.toolbar[groupIndex][scope.toolbar[groupIndex].length - 1] = key;\n                    }else{\n                        group.children().eq(index).after(scope.tools[key].$element);\n                        scope.toolbar[groupIndex][index] = key;\n                    }\n                };\n\n                textAngularManager.registerToolbar(scope);\n\n                scope.$on('$destroy', function(){\n                    textAngularManager.unregisterToolbar(scope.name);\n                });\n            }\n        };\n    }\n]);\ntextAngular.directive('textAngularVersion', ['textAngularManager',\n    function(textAngularManager) {\n        var version = textAngularManager.getVersion();\n        return {\n            restrict: \"EA\",\n            link: function (scope, element, attrs) {\n                element.html(version);\n            }\n        };\n    }\n]);","\n// tests against the current jqLite/jquery implementation if this can be an element\nfunction validElementString(string){\n    try{\n        return angular.element(string).length !== 0;\n    }catch(any){\n        return false;\n    }\n}\n// setup the global contstant functions for setting up the toolbar\n\n// all tool definitions\nvar taTools = {};\n/*\n A tool definition is an object with the following key/value parameters:\n action: [function(deferred, restoreSelection)]\n a function that is executed on clicking on the button - this will allways be executed using ng-click and will\n overwrite any ng-click value in the display attribute.\n The function is passed a deferred object ($q.defer()), if this is wanted to be used `return false;` from the action and\n manually call `deferred.resolve();` elsewhere to notify the editor that the action has finished.\n restoreSelection is only defined if the rangy library is included and it can be called as `restoreSelection()` to restore the users\n selection in the WYSIWYG editor.\n display: [string]?\n Optional, an HTML element to be displayed as the button. The `scope` of the button is the tool definition object with some additional functions\n If set this will cause buttontext and iconclass to be ignored\n class: [string]?\n Optional, if set will override the taOptions.classes.toolbarButton class.\n buttontext: [string]?\n if this is defined it will replace the contents of the element contained in the `display` element\n iconclass: [string]?\n if this is defined an icon (<i>) will be appended to the `display` element with this string as it's class\n tooltiptext: [string]?\n Optional, a plain text description of the action, used for the title attribute of the action button in the toolbar by default.\n activestate: [function(commonElement)]?\n this function is called on every caret movement, if it returns true then the class taOptions.classes.toolbarButtonActive\n will be applied to the `display` element, else the class will be removed\n disabled: [function()]?\n if this function returns true then the tool will have the class taOptions.classes.disabled applied to it, else it will be removed\n Other functions available on the scope are:\n name: [string]\n the name of the tool, this is the first parameter passed into taRegisterTool\n isDisabled: [function()]\n returns true if the tool is disabled, false if it isn't\n displayActiveToolClass: [function(boolean)]\n returns true if the tool is 'active' in the currently focussed toolbar\n onElementSelect: [Object]\n This object contains the following key/value pairs and is used to trigger the ta-element-select event\n element: [String]\n an element name, will only trigger the onElementSelect action if the tagName of the element matches this string\n filter: [function(element)]?\n an optional filter that returns a boolean, if true it will trigger the onElementSelect.\n action: [function(event, element, editorScope)]\n the action that should be executed if the onElementSelect function runs\n */\n// name and toolDefinition to add into the tools available to be added on the toolbar\nfunction registerTextAngularTool(name, toolDefinition){\n    if(!name || name === '' || taTools.hasOwnProperty(name)) throw('textAngular Error: A unique name is required for a Tool Definition');\n    if(\n        (toolDefinition.display && (toolDefinition.display === '' || !validElementString(toolDefinition.display))) ||\n        (!toolDefinition.display && !toolDefinition.buttontext && !toolDefinition.iconclass)\n    )\n        throw('textAngular Error: Tool Definition for \"' + name + '\" does not have a valid display/iconclass/buttontext value');\n    taTools[name] = toolDefinition;\n}\n\nangular.module('textAngularSetup', [])\n    .constant('taRegisterTool', registerTextAngularTool)\n    .value('taTools', taTools)\n    // Here we set up the global display defaults, to set your own use a angular $provider#decorator.\n    .value('taOptions',  {\n        //////////////////////////////////////////////////////////////////////////////////////\n        // forceTextAngularSanitize\n        // set false to allow the textAngular-sanitize provider to be replaced\n        // with angular-sanitize or a custom provider.\n        forceTextAngularSanitize: true,\n        ///////////////////////////////////////////////////////////////////////////////////////\n        // keyMappings\n        // allow customizable keyMappings for specialized key boards or languages\n        //\n        // keyMappings provides key mappings that are attached to a given commandKeyCode.\n        // To modify a specific keyboard binding, simply provide function which returns true\n        // for the event you wish to map to.\n        // Or to disable a specific keyboard binding, provide a function which returns false.\n        // Note: 'RedoKey' and 'UndoKey' are internally bound to the redo and undo functionality.\n        // At present, the following commandKeyCodes are in use:\n        // 98, 'TabKey', 'ShiftTabKey', 105, 117, 'UndoKey', 'RedoKey'\n        //\n        // To map to an new commandKeyCode, add a new key mapping such as:\n        // {commandKeyCode: 'CustomKey', testForKey: function (event) {\n        //  if (event.keyCode=57 && event.ctrlKey && !event.shiftKey && !event.altKey) return true;\n        // } }\n        // to the keyMappings. This example maps ctrl+9 to 'CustomKey'\n        // Then where taRegisterTool(...) is called, add a commandKeyCode: 'CustomKey' and your\n        // tool will be bound to ctrl+9.\n        //\n        // To disble one of the already bound commandKeyCodes such as 'RedoKey' or 'UndoKey' add:\n        // {commandKeyCode: 'RedoKey', testForKey: function (event) { return false; } },\n        // {commandKeyCode: 'UndoKey', testForKey: function (event) { return false; } },\n        // to disable them.\n        //\n        keyMappings : [],\n        toolbar: [\n            ['bold', 'italics', 'underline', 'strikeThrough', 'ul', 'ol', 'redo', 'undo', 'clear'],\n            ['insertLink', 'wordcount', 'charcount']\n        ],\n        classes: {\n            focussed: \"focussed\",\n            toolbar: \"btn-toolbar\",\n            toolbarGroup: \"btn-group\",\n            toolbarButton: \"btn btn-default\",\n            toolbarButtonActive: \"active\",\n            disabled: \"disabled\",\n            textEditor: 'form-control',\n            htmlEditor: 'form-control'\n        },\n        defaultTagAttributes : {\n            a: {target:\"\"}\n        },\n        setup: {\n            // wysiwyg mode\n            textEditorSetup: function($element){ /* Do some processing here */ },\n            // raw html\n            htmlEditorSetup: function($element){ /* Do some processing here */ }\n        },\n        defaultFileDropHandler:\n        /* istanbul ignore next: untestable image processing */\n            function(file, insertAction){\n                var reader = new FileReader();\n                if(file.type.substring(0, 5) === 'image'){\n                    reader.onload = function() {\n                        if(reader.result !== '') insertAction('insertImage', reader.result, true);\n                    };\n\n                    reader.readAsDataURL(file);\n                    // NOTE: For async procedures return a promise and resolve it when the editor should update the model.\n                    return true;\n                }\n                return false;\n            }\n    })\n\n    // This is the element selector string that is used to catch click events within a taBind, prevents the default and $emits a 'ta-element-select' event\n    // these are individually used in an angular.element().find() call. What can go here depends on whether you have full jQuery loaded or just jQLite with angularjs.\n    // div is only used as div.ta-insert-video caught in filter.\n    .value('taSelectableElements', ['a','img'])\n\n    // This is an array of objects with the following options:\n    //\t\t\t\tselector: <string> a jqLite or jQuery selector string\n    //\t\t\t\tcustomAttribute: <string> an attribute to search for\n    //\t\t\t\trenderLogic: <function(element)>\n    // Both or one of selector and customAttribute must be defined.\n    .value('taCustomRenderers', [\n        {\n            // Parse back out: '<div class=\"ta-insert-video\" ta-insert-video src=\"' + urlLink + '\" allowfullscreen=\"true\" width=\"300\" frameborder=\"0\" height=\"250\"></div>'\n            // To correct video element. For now only support youtube\n            selector: 'img',\n            customAttribute: 'ta-insert-video',\n            renderLogic: function(element){\n                var iframe = angular.element('<iframe></iframe>');\n                var attributes = element.prop(\"attributes\");\n                // loop through element attributes and apply them on iframe\n                angular.forEach(attributes, function(attr) {\n                    iframe.attr(attr.name, attr.value);\n                });\n                iframe.attr('src', iframe.attr('ta-insert-video'));\n                element.replaceWith(iframe);\n            }\n        }\n    ])\n\n    .value('taTranslations', {\n        // moved to sub-elements\n        //toggleHTML: \"Toggle HTML\",\n        //insertImage: \"Please enter a image URL to insert\",\n        //insertLink: \"Please enter a URL to insert\",\n        //insertVideo: \"Please enter a youtube URL to embed\",\n        html: {\n            tooltip: 'Toggle html / Rich Text'\n        },\n        // tooltip for heading - might be worth splitting\n        heading: {\n            tooltip: 'Heading '\n        },\n        p: {\n            tooltip: 'Paragraph'\n        },\n        pre: {\n            tooltip: 'Preformatted text'\n        },\n        ul: {\n            tooltip: 'Unordered List'\n        },\n        ol: {\n            tooltip: 'Ordered List'\n        },\n        quote: {\n            tooltip: 'Quote/unquote selection or paragraph'\n        },\n        undo: {\n            tooltip: 'Undo'\n        },\n        redo: {\n            tooltip: 'Redo'\n        },\n        bold: {\n            tooltip: 'Bold'\n        },\n        italic: {\n            tooltip: 'Italic'\n        },\n        underline: {\n            tooltip: 'Underline'\n        },\n        strikeThrough:{\n            tooltip: 'Strikethrough'\n        },\n        justifyLeft: {\n            tooltip: 'Align text left'\n        },\n        justifyRight: {\n            tooltip: 'Align text right'\n        },\n        justifyFull: {\n            tooltip: 'Justify text'\n        },\n        justifyCenter: {\n            tooltip: 'Center'\n        },\n        indent: {\n            tooltip: 'Increase indent'\n        },\n        outdent: {\n            tooltip: 'Decrease indent'\n        },\n        clear: {\n            tooltip: 'Clear formatting'\n        },\n        insertImage: {\n            dialogPrompt: 'Please enter an image URL to insert',\n            tooltip: 'Insert image',\n            hotkey: 'the - possibly language dependent hotkey ... for some future implementation'\n        },\n        insertVideo: {\n            tooltip: 'Insert video',\n            dialogPrompt: 'Please enter a youtube URL to embed'\n        },\n        insertLink: {\n            tooltip: 'Insert / edit link',\n            dialogPrompt: \"Please enter a URL to insert\"\n        },\n        editLink: {\n            reLinkButton: {\n                tooltip: \"Relink\"\n            },\n            unLinkButton: {\n                tooltip: \"Unlink\"\n            },\n            targetToggle: {\n                buttontext: \"Open in New Window\"\n            }\n        },\n        wordcount: {\n            tooltip: 'Display words Count'\n        },\n        charcount: {\n            tooltip: 'Display characters Count'\n        }\n    })\n    .factory('taToolFunctions', ['$window','taTranslations', function($window, taTranslations) {\n        return {\n            imgOnSelectAction: function(event, $element, editorScope){\n                // setup the editor toolbar\n                // Credit to the work at http://hackerwins.github.io/summernote/ for this editbar logic/display\n                var finishEdit = function(){\n                    editorScope.updateTaBindtaTextElement();\n                    editorScope.hidePopover();\n                };\n                event.preventDefault();\n                editorScope.displayElements.popover.css('width', '375px');\n                var container = editorScope.displayElements.popoverContainer;\n                container.empty();\n                var buttonGroup = angular.element('<div class=\"btn-group\" style=\"padding-right: 6px;\">');\n                var fullButton = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\">100% </button>');\n                fullButton.on('click', function(event){\n                    event.preventDefault();\n                    $element.css({\n                        'width': '100%',\n                        'height': ''\n                    });\n                    finishEdit();\n                });\n                var halfButton = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\">50% </button>');\n                halfButton.on('click', function(event){\n                    event.preventDefault();\n                    $element.css({\n                        'width': '50%',\n                        'height': ''\n                    });\n                    finishEdit();\n                });\n                var quartButton = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\">25% </button>');\n                quartButton.on('click', function(event){\n                    event.preventDefault();\n                    $element.css({\n                        'width': '25%',\n                        'height': ''\n                    });\n                    finishEdit();\n                });\n                var resetButton = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\">Reset</button>');\n                resetButton.on('click', function(event){\n                    event.preventDefault();\n                    $element.css({\n                        width: '',\n                        height: ''\n                    });\n                    finishEdit();\n                });\n                buttonGroup.append(fullButton);\n                buttonGroup.append(halfButton);\n                buttonGroup.append(quartButton);\n                buttonGroup.append(resetButton);\n                container.append(buttonGroup);\n\n                buttonGroup = angular.element('<div class=\"btn-group\" style=\"padding-right: 6px;\">');\n                var floatLeft = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\"><i class=\"fa fa-align-left\"></i></button>');\n                floatLeft.on('click', function(event){\n                    event.preventDefault();\n                    // webkit\n                    $element.css('float', 'left');\n                    // firefox\n                    $element.css('cssFloat', 'left');\n                    // IE < 8\n                    $element.css('styleFloat', 'left');\n                    finishEdit();\n                });\n                var floatRight = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\"><i class=\"fa fa-align-right\"></i></button>');\n                floatRight.on('click', function(event){\n                    event.preventDefault();\n                    // webkit\n                    $element.css('float', 'right');\n                    // firefox\n                    $element.css('cssFloat', 'right');\n                    // IE < 8\n                    $element.css('styleFloat', 'right');\n                    finishEdit();\n                });\n                var floatNone = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\"><i class=\"fa fa-align-justify\"></i></button>');\n                floatNone.on('click', function(event){\n                    event.preventDefault();\n                    // webkit\n                    $element.css('float', '');\n                    // firefox\n                    $element.css('cssFloat', '');\n                    // IE < 8\n                    $element.css('styleFloat', '');\n                    finishEdit();\n                });\n                buttonGroup.append(floatLeft);\n                buttonGroup.append(floatNone);\n                buttonGroup.append(floatRight);\n                container.append(buttonGroup);\n\n                buttonGroup = angular.element('<div class=\"btn-group\">');\n                var remove = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\"><i class=\"fa fa-trash-o\"></i></button>');\n                remove.on('click', function(event){\n                    event.preventDefault();\n                    $element.remove();\n                    finishEdit();\n                });\n                buttonGroup.append(remove);\n                container.append(buttonGroup);\n\n                editorScope.showPopover($element);\n                editorScope.showResizeOverlay($element);\n            },\n            aOnSelectAction: function(event, $element, editorScope){\n                // setup the editor toolbar\n                // Credit to the work at http://hackerwins.github.io/summernote/ for this editbar logic\n                event.preventDefault();\n                editorScope.displayElements.popover.css('width', '436px');\n                var container = editorScope.displayElements.popoverContainer;\n                container.empty();\n                container.css('line-height', '28px');\n                var link = angular.element('<a href=\"' + $element.attr('href') + '\" target=\"_blank\">' + $element.attr('href') + '</a>');\n                link.css({\n                    'display': 'inline-block',\n                    'max-width': '200px',\n                    'overflow': 'hidden',\n                    'text-overflow': 'ellipsis',\n                    'white-space': 'nowrap',\n                    'vertical-align': 'middle'\n                });\n                container.append(link);\n                var buttonGroup = angular.element('<div class=\"btn-group pull-right\">');\n                var reLinkButton = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" tabindex=\"-1\" unselectable=\"on\" title=\"' + taTranslations.editLink.reLinkButton.tooltip + '\"><i class=\"fa fa-edit icon-edit\"></i></button>');\n                reLinkButton.on('click', function(event){\n                    event.preventDefault();\n                    var urlLink = $window.prompt(taTranslations.insertLink.dialogPrompt, $element.attr('href'));\n                    if(urlLink && urlLink !== '' && urlLink !== 'http://'){\n                        $element.attr('href', urlLink);\n                        editorScope.updateTaBindtaTextElement();\n                    }\n                    editorScope.hidePopover();\n                });\n                buttonGroup.append(reLinkButton);\n                var unLinkButton = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" tabindex=\"-1\" unselectable=\"on\" title=\"' + taTranslations.editLink.unLinkButton.tooltip + '\"><i class=\"fa fa-unlink icon-unlink\"></i></button>');\n                // directly before this click event is fired a digest is fired off whereby the reference to $element is orphaned off\n                unLinkButton.on('click', function(event){\n                    event.preventDefault();\n                    $element.replaceWith($element.contents());\n                    editorScope.updateTaBindtaTextElement();\n                    editorScope.hidePopover();\n                });\n                buttonGroup.append(unLinkButton);\n                var targetToggle = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" tabindex=\"-1\" unselectable=\"on\">' + taTranslations.editLink.targetToggle.buttontext + '</button>');\n                if($element.attr('target') === '_blank'){\n                    targetToggle.addClass('active');\n                }\n                targetToggle.on('click', function(event){\n                    event.preventDefault();\n                    $element.attr('target', ($element.attr('target') === '_blank') ? '' : '_blank');\n                    targetToggle.toggleClass('active');\n                    editorScope.updateTaBindtaTextElement();\n                });\n                buttonGroup.append(targetToggle);\n                container.append(buttonGroup);\n                editorScope.showPopover($element);\n            },\n            extractYoutubeVideoId: function(url) {\n                var re = /(?:youtube(?:-nocookie)?\\.com\\/(?:[^\\/\\n\\s]+\\/\\S+\\/|(?:v|e(?:mbed)?)\\/|\\S*?[?&]v=)|youtu\\.be\\/)([a-zA-Z0-9_-]{11})/i;\n                var match = url.match(re);\n                return (match && match[1]) || null;\n            }\n        };\n    }])\n    .run(['taRegisterTool', '$window', 'taTranslations', 'taSelection', 'taToolFunctions', '$sanitize', 'taOptions', '$log',\n        function(taRegisterTool, $window, taTranslations, taSelection, taToolFunctions, $sanitize, taOptions, $log){\n            // test for the version of $sanitize that is in use\n            // You can disable this check by setting taOptions.textAngularSanitize == false\n            var gv = {}; $sanitize('', gv);\n            /* istanbul ignore next, throws error */\n            if ((taOptions.forceTextAngularSanitize===true) && (gv.version !== 'taSanitize')) {\n                throw angular.$$minErr('textAngular')(\"textAngularSetup\", \"The textAngular-sanitize provider has been replaced by another -- have you included angular-sanitize by mistake?\");\n            }\n            taRegisterTool(\"html\", {\n                iconclass: 'fa fa-code',\n                tooltiptext: taTranslations.html.tooltip,\n                action: function(){\n                    this.$editor().switchView();\n                },\n                activeState: function(){\n                    return this.$editor().showHtml;\n                }\n            });\n            // add the Header tools\n            // convenience functions so that the loop works correctly\n            var _retActiveStateFunction = function(q){\n                return function(){ return this.$editor().queryFormatBlockState(q); };\n            };\n            var headerAction = function(){\n                return this.$editor().wrapSelection(\"formatBlock\", \"<\" + this.name.toUpperCase() +\">\");\n            };\n            angular.forEach(['h1','h2','h3','h4','h5','h6'], function(h){\n                taRegisterTool(h.toLowerCase(), {\n                    buttontext: h.toUpperCase(),\n                    tooltiptext: taTranslations.heading.tooltip + h.charAt(1),\n                    action: headerAction,\n                    activeState: _retActiveStateFunction(h.toLowerCase())\n                });\n            });\n            taRegisterTool('p', {\n                buttontext: 'P',\n                tooltiptext: taTranslations.p.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"formatBlock\", \"<P>\");\n                },\n                activeState: function(){ return this.$editor().queryFormatBlockState('p'); }\n            });\n            // key: pre -> taTranslations[key].tooltip, taTranslations[key].buttontext\n            taRegisterTool('pre', {\n                buttontext: 'pre',\n                tooltiptext: taTranslations.pre.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"formatBlock\", \"<PRE>\");\n                },\n                activeState: function(){ return this.$editor().queryFormatBlockState('pre'); }\n            });\n            taRegisterTool('ul', {\n                iconclass: 'fa fa-list-ul',\n                tooltiptext: taTranslations.ul.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"insertUnorderedList\", null);\n                },\n                activeState: function(){ return this.$editor().queryCommandState('insertUnorderedList'); }\n            });\n            taRegisterTool('ol', {\n                iconclass: 'fa fa-list-ol',\n                tooltiptext: taTranslations.ol.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"insertOrderedList\", null);\n                },\n                activeState: function(){ return this.$editor().queryCommandState('insertOrderedList'); }\n            });\n            taRegisterTool('quote', {\n                iconclass: 'fa fa-quote-right',\n                tooltiptext: taTranslations.quote.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"formatBlock\", \"<BLOCKQUOTE>\");\n                },\n                activeState: function(){ return this.$editor().queryFormatBlockState('blockquote'); }\n            });\n            taRegisterTool('undo', {\n                iconclass: 'fa fa-undo',\n                tooltiptext: taTranslations.undo.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"undo\", null);\n                }\n            });\n            taRegisterTool('redo', {\n                iconclass: 'fa fa-repeat',\n                tooltiptext: taTranslations.redo.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"redo\", null);\n                }\n            });\n            taRegisterTool('bold', {\n                iconclass: 'fa fa-bold',\n                tooltiptext: taTranslations.bold.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"bold\", null);\n                },\n                activeState: function(){\n                    return this.$editor().queryCommandState('bold');\n                },\n                commandKeyCode: 98\n            });\n            taRegisterTool('justifyLeft', {\n                iconclass: 'fa fa-align-left',\n                tooltiptext: taTranslations.justifyLeft.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"justifyLeft\", null);\n                },\n                activeState: function(commonElement){\n                    /* istanbul ignore next: */\n                    if (commonElement && commonElement.nodeName === '#document') return false;\n                    var result = false;\n                    if (commonElement) {\n                        // commonELement.css('text-align') can throw an error 'Cannot read property 'defaultView' of null' in rare conditions\n                        // so we do try catch here...\n                        try {\n                            result =\n                                commonElement.css('text-align') === 'left' ||\n                                commonElement.attr('align') === 'left' ||\n                                (\n                                    commonElement.css('text-align') !== 'right' &&\n                                    commonElement.css('text-align') !== 'center' &&\n                                    commonElement.css('text-align') !== 'justify' && !this.$editor().queryCommandState('justifyRight') && !this.$editor().queryCommandState('justifyCenter')\n                                ) && !this.$editor().queryCommandState('justifyFull');\n                        } catch(e) {\n                            /* istanbul ignore next: error handler */\n                            //console.log(e);\n                            result = false;\n                        }\n                    }\n                    result = result || this.$editor().queryCommandState('justifyLeft');\n                    return result;\n                }\n            });\n            taRegisterTool('justifyRight', {\n                iconclass: 'fa fa-align-right',\n                tooltiptext: taTranslations.justifyRight.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"justifyRight\", null);\n                },\n                activeState: function(commonElement){\n                    /* istanbul ignore next: */\n                    if (commonElement && commonElement.nodeName === '#document') return false;\n                    var result = false;\n                    if(commonElement) {\n                        // commonELement.css('text-align') can throw an error 'Cannot read property 'defaultView' of null' in rare conditions\n                        // so we do try catch here...\n                        try {\n                            result = commonElement.css('text-align') === 'right';\n                        } catch(e) {\n                            /* istanbul ignore next: error handler */\n                            //console.log(e);\n                            result = false;\n                        }\n                    }\n                    result = result || this.$editor().queryCommandState('justifyRight');\n                    return result;\n                }\n            });\n            taRegisterTool('justifyFull', {\n                iconclass: 'fa fa-align-justify',\n                tooltiptext: taTranslations.justifyFull.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"justifyFull\", null);\n                },\n                activeState: function(commonElement){\n                    var result = false;\n                    if(commonElement) {\n                        // commonELement.css('text-align') can throw an error 'Cannot read property 'defaultView' of null' in rare conditions\n                        // so we do try catch here...\n                        try {\n                            result = commonElement.css('text-align') === 'justify';\n                        } catch(e) {\n                            /* istanbul ignore next: error handler */\n                            //console.log(e);\n                            result = false;\n                        }\n                    }\n                    result = result || this.$editor().queryCommandState('justifyFull');\n                    return result;\n                }\n            });\n            taRegisterTool('justifyCenter', {\n                iconclass: 'fa fa-align-center',\n                tooltiptext: taTranslations.justifyCenter.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"justifyCenter\", null);\n                },\n                activeState: function(commonElement){\n                    /* istanbul ignore next: */\n                    if (commonElement && commonElement.nodeName === '#document') return false;\n                    var result = false;\n                    if(commonElement) {\n                        // commonELement.css('text-align') can throw an error 'Cannot read property 'defaultView' of null' in rare conditions\n                        // so we do try catch here...\n                        try {\n                            result = commonElement.css('text-align') === 'center';\n                        } catch(e) {\n                            /* istanbul ignore next: error handler */\n                            //console.log(e);\n                            result = false;\n                        }\n\n                    }\n                    result = result || this.$editor().queryCommandState('justifyCenter');\n                    return result;\n                }\n            });\n            taRegisterTool('indent', {\n                iconclass: 'fa fa-indent',\n                tooltiptext: taTranslations.indent.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"indent\", null);\n                },\n                activeState: function(){\n                    return this.$editor().queryFormatBlockState('blockquote');\n                },\n                commandKeyCode: 'TabKey'\n            });\n            taRegisterTool('outdent', {\n                iconclass: 'fa fa-outdent',\n                tooltiptext: taTranslations.outdent.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"outdent\", null);\n                },\n                activeState: function(){\n                    return false;\n                },\n                commandKeyCode: 'ShiftTabKey'\n            });\n            taRegisterTool('italics', {\n                iconclass: 'fa fa-italic',\n                tooltiptext: taTranslations.italic.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"italic\", null);\n                },\n                activeState: function(){\n                    return this.$editor().queryCommandState('italic');\n                },\n                commandKeyCode: 105\n            });\n            taRegisterTool('underline', {\n                iconclass: 'fa fa-underline',\n                tooltiptext: taTranslations.underline.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"underline\", null);\n                },\n                activeState: function(){\n                    return this.$editor().queryCommandState('underline');\n                },\n                commandKeyCode: 117\n            });\n            taRegisterTool('strikeThrough', {\n                iconclass: 'fa fa-strikethrough',\n                tooltiptext: taTranslations.strikeThrough.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"strikeThrough\", null);\n                },\n                activeState: function(){\n                    return document.queryCommandState('strikeThrough');\n                }\n            });\n            taRegisterTool('clear', {\n                iconclass: 'fa fa-ban',\n                tooltiptext: taTranslations.clear.tooltip,\n                action: function(deferred, restoreSelection){\n                    var i, selectedElements, elementsSeen;\n\n                    this.$editor().wrapSelection(\"removeFormat\", null);\n                    var possibleNodes = angular.element(taSelection.getSelectionElement());\n                    selectedElements = taSelection.getAllSelectedElements();\n                    //$log.log('selectedElements:', selectedElements);\n                    // remove lists\n                    var removeListElements = function(list, pe){\n                        list = angular.element(list);\n                        var prevElement = pe;\n                        if (!pe) {\n                            prevElement = list;\n                        }\n                        angular.forEach(list.children(), function(liElem){\n                            if (liElem.tagName.toLowerCase() === 'ul' ||\n                                liElem.tagName.toLowerCase() === 'ol') {\n                                prevElement = removeListElements(liElem, prevElement);\n                            } else {\n                                var newElem = angular.element('<p></p>');\n                                newElem.html(angular.element(liElem).html());\n                                prevElement.after(newElem);\n                                prevElement = newElem;\n                            }\n                        });\n                        list.remove();\n                        return prevElement;\n                    };\n\n                    angular.forEach(selectedElements, function(element) {\n                        if (element.nodeName.toLowerCase() === 'ul' ||\n                            element.nodeName.toLowerCase() === 'ol') {\n                            //console.log('removeListElements', element);\n                            removeListElements(element);\n                        }\n                    });\n\n                    angular.forEach(possibleNodes.find(\"ul\"), removeListElements);\n                    angular.forEach(possibleNodes.find(\"ol\"), removeListElements);\n\n                    // clear out all class attributes. These do not seem to be cleared via removeFormat\n                    var $editor = this.$editor();\n                    var recursiveRemoveClass = function(node){\n                        node = angular.element(node);\n                        /* istanbul ignore next: this is not triggered in tests any longer since we now never select the whole displayELement */\n                        if(node[0] !== $editor.displayElements.text[0]) {\n                            node.removeAttr('class');\n                        }\n                        angular.forEach(node.children(), recursiveRemoveClass);\n                    };\n                    angular.forEach(possibleNodes, recursiveRemoveClass);\n                    // check if in list. If not in list then use formatBlock option\n                    if(possibleNodes[0] && possibleNodes[0].tagName.toLowerCase() !== 'li' &&\n                        possibleNodes[0].tagName.toLowerCase() !== 'ol' &&\n                        possibleNodes[0].tagName.toLowerCase() !== 'ul' &&\n                        possibleNodes[0].getAttribute(\"contenteditable\") !== \"true\") {\n                        this.$editor().wrapSelection(\"formatBlock\", \"default\");\n                    }\n                    restoreSelection();\n                }\n            });\n\n            /* jshint -W099 */\n            /****************************\n             //  we don't use this code - since the previous way CLEAR is expected to work does not clear partially selected <li>\n\n             var removeListElement = function(listE){\n                console.log(listE);\n                var _list = listE.parentNode.childNodes;\n                console.log('_list', _list);\n                var _preLis = [], _postLis = [], _found = false;\n                for (i = 0; i < _list.length; i++) {\n                    if (_list[i] === listE) {\n                        _found = true;\n                    } else if (!_found) _preLis.push(_list[i]);\n                    else _postLis.push(_list[i]);\n                }\n                var _parent = angular.element(listE.parentNode);\n                var newElem = angular.element('<p></p>');\n                newElem.html(angular.element(listE).html());\n                if (_preLis.length === 0 || _postLis.length === 0) {\n                    if (_postLis.length === 0) _parent.after(newElem);\n                    else _parent[0].parentNode.insertBefore(newElem[0], _parent[0]);\n\n                    if (_preLis.length === 0 && _postLis.length === 0) _parent.remove();\n                    else angular.element(listE).remove();\n                } else {\n                    var _firstList = angular.element('<' + _parent[0].tagName + '></' + _parent[0].tagName + '>');\n                    var _secondList = angular.element('<' + _parent[0].tagName + '></' + _parent[0].tagName + '>');\n                    for (i = 0; i < _preLis.length; i++) _firstList.append(angular.element(_preLis[i]));\n                    for (i = 0; i < _postLis.length; i++) _secondList.append(angular.element(_postLis[i]));\n                    _parent.after(_secondList);\n                    _parent.after(newElem);\n                    _parent.after(_firstList);\n                    _parent.remove();\n                }\n                taSelection.setSelectionToElementEnd(newElem[0]);\n            };\n\n             elementsSeen = [];\n             if (selectedElements.length !==0) console.log(selectedElements);\n             angular.forEach(selectedElements, function (element) {\n                if (elementsSeen.indexOf(element) !== -1 || elementsSeen.indexOf(element.parentElement) !== -1) {\n                    return;\n                }\n                elementsSeen.push(element);\n                if (element.nodeName.toLowerCase() === 'li') {\n                    console.log('removeListElement', element);\n                    removeListElement(element);\n                }\n                else if (element.parentElement && element.parentElement.nodeName.toLowerCase() === 'li') {\n                    console.log('removeListElement', element.parentElement);\n                    elementsSeen.push(element.parentElement);\n                    removeListElement(element.parentElement);\n                }\n            });\n             **********************/\n\n            /**********************\n             if(possibleNodes[0].tagName.toLowerCase() === 'li'){\n                var _list = possibleNodes[0].parentNode.childNodes;\n                var _preLis = [], _postLis = [], _found = false;\n                for(i = 0; i < _list.length; i++){\n                    if(_list[i] === possibleNodes[0]){\n                        _found = true;\n                    }else if(!_found) _preLis.push(_list[i]);\n                    else _postLis.push(_list[i]);\n                }\n                var _parent = angular.element(possibleNodes[0].parentNode);\n                var newElem = angular.element('<p></p>');\n                newElem.html(angular.element(possibleNodes[0]).html());\n                if(_preLis.length === 0 || _postLis.length === 0){\n                    if(_postLis.length === 0) _parent.after(newElem);\n                    else _parent[0].parentNode.insertBefore(newElem[0], _parent[0]);\n\n                    if(_preLis.length === 0 && _postLis.length === 0) _parent.remove();\n                    else angular.element(possibleNodes[0]).remove();\n                }else{\n                    var _firstList = angular.element('<'+_parent[0].tagName+'></'+_parent[0].tagName+'>');\n                    var _secondList = angular.element('<'+_parent[0].tagName+'></'+_parent[0].tagName+'>');\n                    for(i = 0; i < _preLis.length; i++) _firstList.append(angular.element(_preLis[i]));\n                    for(i = 0; i < _postLis.length; i++) _secondList.append(angular.element(_postLis[i]));\n                    _parent.after(_secondList);\n                    _parent.after(newElem);\n                    _parent.after(_firstList);\n                    _parent.remove();\n                }\n                taSelection.setSelectionToElementEnd(newElem[0]);\n            }\n             *******************/\n\n\n            /* istanbul ignore next: if it's javascript don't worry - though probably should show some kind of error message */\n            var blockJavascript = function (link) {\n                if (link.toLowerCase().indexOf('javascript')!==-1) {\n                    return true;\n                }\n                return false;\n            };\n\n            taRegisterTool('insertImage', {\n                iconclass: 'fa fa-picture-o',\n                tooltiptext: taTranslations.insertImage.tooltip,\n                action: function(){\n                    var imageLink;\n                    imageLink = $window.prompt(taTranslations.insertImage.dialogPrompt, 'http://');\n                    if(imageLink && imageLink !== '' && imageLink !== 'http://'){\n                        /* istanbul ignore next: don't know how to test this... since it needs a dialogPrompt */\n                        // block javascript here\n                        if (!blockJavascript(imageLink)) {\n                            if (taSelection.getSelectionElement().tagName && taSelection.getSelectionElement().tagName.toLowerCase() === 'a') {\n                                // due to differences in implementation between FireFox and Chrome, we must move the\n                                // insertion point past the <a> element, otherwise FireFox inserts inside the <a>\n                                // With this change, both FireFox and Chrome behave the same way!\n                                taSelection.setSelectionAfterElement(taSelection.getSelectionElement());\n                            }\n                            // In the past we used the simple statement:\n                            //return this.$editor().wrapSelection('insertImage', imageLink, true);\n                            //\n                            // However on Firefox only, when the content is empty this is a problem\n                            // See Issue #1201\n                            // Investigation reveals that Firefox only inserts a <p> only!!!!\n                            // So now we use insertHTML here and all is fine.\n                            // NOTE: this is what 'insertImage' is supposed to do anyway!\n                            var embed = '<img src=\"' + imageLink + '\">';\n                            return this.$editor().wrapSelection('insertHTML', embed, true);\n                        }\n                    }\n                },\n                onElementSelect: {\n                    element: 'img',\n                    action: taToolFunctions.imgOnSelectAction\n                }\n            });\n            taRegisterTool('insertVideo', {\n                iconclass: 'fa fa-youtube-play',\n                tooltiptext: taTranslations.insertVideo.tooltip,\n                action: function(){\n                    var urlPrompt;\n                    urlPrompt = $window.prompt(taTranslations.insertVideo.dialogPrompt, 'https://');\n                    // block javascript here\n                    /* istanbul ignore else: if it's javascript don't worry - though probably should show some kind of error message */\n                    if (!blockJavascript(urlPrompt)) {\n\n                        if (urlPrompt && urlPrompt !== '' && urlPrompt !== 'https://') {\n\n                            videoId = taToolFunctions.extractYoutubeVideoId(urlPrompt);\n\n                            /* istanbul ignore else: if it's invalid don't worry - though probably should show some kind of error message */\n                            if (videoId) {\n                                // create the embed link\n                                var urlLink = \"https://www.youtube.com/embed/\" + videoId;\n                                // create the HTML\n                                // for all options see: http://stackoverflow.com/questions/2068344/how-do-i-get-a-youtube-video-thumbnail-from-the-youtube-api\n                                // maxresdefault.jpg seems to be undefined on some.\n                                var embed = '<img class=\"ta-insert-video\" src=\"https://img.youtube.com/vi/' + videoId + '/hqdefault.jpg\" ta-insert-video=\"' + urlLink + '\" contenteditable=\"false\" allowfullscreen=\"true\" frameborder=\"0\" />';\n                                /* istanbul ignore next: don't know how to test this... since it needs a dialogPrompt */\n                                if (taSelection.getSelectionElement().tagName && taSelection.getSelectionElement().tagName.toLowerCase() === 'a') {\n                                    // due to differences in implementation between FireFox and Chrome, we must move the\n                                    // insertion point past the <a> element, otherwise FireFox inserts inside the <a>\n                                    // With this change, both FireFox and Chrome behave the same way!\n                                    taSelection.setSelectionAfterElement(taSelection.getSelectionElement());\n                                }\n                                // insert\n                                return this.$editor().wrapSelection('insertHTML', embed, true);\n                            }\n                        }\n                    }\n                },\n                onElementSelect: {\n                    element: 'img',\n                    onlyWithAttrs: ['ta-insert-video'],\n                    action: taToolFunctions.imgOnSelectAction\n                }\n            });\n            taRegisterTool('insertLink', {\n                tooltiptext: taTranslations.insertLink.tooltip,\n                iconclass: 'fa fa-link',\n                action: function(){\n                    var urlLink;\n                    // if this link has already been set, we need to just edit the existing link\n                    /* istanbul ignore if: we do not test this */\n                    if (taSelection.getSelectionElement().tagName && taSelection.getSelectionElement().tagName.toLowerCase() === 'a') {\n                        urlLink = $window.prompt(taTranslations.insertLink.dialogPrompt, taSelection.getSelectionElement().href);\n                    } else {\n                        urlLink = $window.prompt(taTranslations.insertLink.dialogPrompt, 'http://');\n                    }\n                    if(urlLink && urlLink !== '' && urlLink !== 'http://'){\n                        // block javascript here\n                        /* istanbul ignore else: if it's javascript don't worry - though probably should show some kind of error message */\n                        if (!blockJavascript(urlLink)) {\n                            return this.$editor().wrapSelection('createLink', urlLink, true);\n                        }\n                    }\n                },\n                activeState: function(commonElement){\n                    if(commonElement) return commonElement[0].tagName === 'A';\n                    return false;\n                },\n                onElementSelect: {\n                    element: 'a',\n                    action: taToolFunctions.aOnSelectAction\n                }\n            });\n            taRegisterTool('wordcount', {\n                display: '<div id=\"toolbarWC\" style=\"display:block; min-width:100px;\">Words: <span ng-bind=\"wordcount\"></span></div>',\n                disabled: true,\n                wordcount: 0,\n                activeState: function(){ // this fires on keyup\n                    var textElement = this.$editor().displayElements.text;\n                    /* istanbul ignore next: will default to '' when undefined */\n                    var workingHTML = textElement[0].innerHTML || '';\n                    var noOfWords = 0;\n\n                    /* istanbul ignore if: will default to '' when undefined */\n                    if (workingHTML.replace(/\\s*<[^>]*?>\\s*/g, '') !== '') {\n                        if (workingHTML.trim() !== '') {\n                            noOfWords = workingHTML.replace(/<\\/?(b|i|em|strong|span|u|strikethrough|a|img|small|sub|sup|label)( [^>*?])?>/gi, '') // remove inline tags without adding spaces\n                                .replace(/(<[^>]*?>\\s*<[^>]*?>)/ig, ' ') // replace adjacent tags with possible space between with a space\n                                .replace(/(<[^>]*?>)/ig, '') // remove any singular tags\n                                .replace(/\\s+/ig, ' ') // condense spacing\n                                .match(/\\S+/g).length; // count remaining non-space strings\n                        }\n                    }\n\n                    //Set current scope\n                    this.wordcount = noOfWords;\n                    //Set editor scope\n                    this.$editor().wordcount = noOfWords;\n\n                    return false;\n                }\n            });\n            taRegisterTool('charcount', {\n                display: '<div id=\"toolbarCC\" style=\"display:block; min-width:120px;\">Characters: <span ng-bind=\"charcount\"></span></div>',\n                disabled: true,\n                charcount: 0,\n                activeState: function(){ // this fires on keyup\n                    var textElement = this.$editor().displayElements.text;\n                    var sourceText = textElement[0].innerText || textElement[0].textContent; // to cover the non-jquery use case.\n\n                    // Caculate number of chars\n                    var noOfChars = sourceText.replace(/(\\r\\n|\\n|\\r)/gm,\"\").replace(/^\\s+/g,' ').replace(/\\s+$/g, ' ').length;\n                    //Set current scope\n                    this.charcount = noOfChars;\n                    //Set editor scope\n                    this.$editor().charcount = noOfChars;\n                    return false;\n                }\n            });\n        }]);","(function() {\n  'use strict';\n\n  angular.module('toastr', [])\n    .factory('toastr', toastr);\n\n  toastr.$inject = ['$animate', '$injector', '$rootScope', '$sce', 'toastrConfig', '$q'];\n\n  function toastr($animate, $injector, $rootScope, $sce, toastrConfig, $q) {\n    var container;\n    var index = 0;\n    var toasts = [];\n\n    var previousToastMessage = '';\n    var openToasts = {};\n\n    var containerDefer = $q.defer();\n\n    var toast = {\n      active: active,\n      clear: clear,\n      error: error,\n      info: info,\n      remove: remove,\n      success: success,\n      warning: warning,\n      refreshTimer: refreshTimer\n    };\n\n    return toast;\n\n    /* Public API */\n    function active() {\n      return toasts.length;\n    }\n\n    function clear(toast) {\n      // Bit of a hack, I will remove this soon with a BC\n      if (arguments.length === 1 && !toast) { return; }\n\n      if (toast) {\n        remove(toast.toastId);\n      } else {\n        for (var i = 0; i < toasts.length; i++) {\n          remove(toasts[i].toastId);\n        }\n      }\n    }\n\n    function error(message, title, optionsOverride) {\n      var type = _getOptions().iconClasses.error;\n      return _buildNotification(type, message, title, optionsOverride);\n    }\n\n    function info(message, title, optionsOverride) {\n      var type = _getOptions().iconClasses.info;\n      return _buildNotification(type, message, title, optionsOverride);\n    }\n\n    function success(message, title, optionsOverride) {\n      var type = _getOptions().iconClasses.success;\n      return _buildNotification(type, message, title, optionsOverride);\n    }\n\n    function warning(message, title, optionsOverride) {\n      var type = _getOptions().iconClasses.warning;\n      return _buildNotification(type, message, title, optionsOverride);\n    }\n\n    function refreshTimer(toast, newTime) {\n      if (toast && toast.isOpened && toasts.indexOf(toast) >= 0) {\n          toast.scope.refreshTimer(newTime);\n      }\n    }\n\n    function remove(toastId, wasClicked) {\n      var toast = findToast(toastId);\n\n      if (toast && ! toast.deleting) { // Avoid clicking when fading out\n        toast.deleting = true;\n        toast.isOpened = false;\n        $animate.leave(toast.el).then(function() {\n          if (toast.scope.options.onHidden) {\n            toast.scope.options.onHidden(!!wasClicked, toast);\n          }\n          toast.scope.$destroy();\n          var index = toasts.indexOf(toast);\n          delete openToasts[toast.scope.message];\n          toasts.splice(index, 1);\n          var maxOpened = toastrConfig.maxOpened;\n          if (maxOpened && toasts.length >= maxOpened) {\n            toasts[maxOpened - 1].open.resolve();\n          }\n          if (lastToast()) {\n            container.remove();\n            container = null;\n            containerDefer = $q.defer();\n          }\n        });\n      }\n\n      function findToast(toastId) {\n        for (var i = 0; i < toasts.length; i++) {\n          if (toasts[i].toastId === toastId) {\n            return toasts[i];\n          }\n        }\n      }\n\n      function lastToast() {\n        return !toasts.length;\n      }\n    }\n\n    /* Internal functions */\n    function _buildNotification(type, message, title, optionsOverride) {\n      if (angular.isObject(title)) {\n        optionsOverride = title;\n        title = null;\n      }\n\n      return _notify({\n        iconClass: type,\n        message: message,\n        optionsOverride: optionsOverride,\n        title: title\n      });\n    }\n\n    function _getOptions() {\n      return angular.extend({}, toastrConfig);\n    }\n\n    function _createOrGetContainer(options) {\n      if(container) { return containerDefer.promise; }\n\n      container = angular.element('<div></div>');\n      container.attr('id', options.containerId);\n      container.addClass(options.positionClass);\n      container.css({'pointer-events': 'auto'});\n\n      var target = angular.element(document.querySelector(options.target));\n\n      if ( ! target || ! target.length) {\n        throw 'Target for toasts doesn\\'t exist';\n      }\n\n      $animate.enter(container, target).then(function() {\n        containerDefer.resolve();\n      });\n\n      return containerDefer.promise;\n    }\n\n    function _notify(map) {\n      var options = _getOptions();\n\n      if (shouldExit()) { return; }\n\n      var newToast = createToast();\n\n      toasts.push(newToast);\n\n      if (ifMaxOpenedAndAutoDismiss()) {\n        var oldToasts = toasts.slice(0, (toasts.length - options.maxOpened));\n        for (var i = 0, len = oldToasts.length; i < len; i++) {\n          remove(oldToasts[i].toastId);\n        }\n      }\n\n      if (maxOpenedNotReached()) {\n        newToast.open.resolve();\n      }\n\n      newToast.open.promise.then(function() {\n        _createOrGetContainer(options).then(function() {\n          newToast.isOpened = true;\n          if (options.newestOnTop) {\n            $animate.enter(newToast.el, container).then(function() {\n              newToast.scope.init();\n            });\n          } else {\n            var sibling = container[0].lastChild ? angular.element(container[0].lastChild) : null;\n            $animate.enter(newToast.el, container, sibling).then(function() {\n              newToast.scope.init();\n            });\n          }\n        });\n      });\n\n      return newToast;\n\n      function ifMaxOpenedAndAutoDismiss() {\n        return options.autoDismiss && options.maxOpened && toasts.length > options.maxOpened;\n      }\n\n      function createScope(toast, map, options) {\n        if (options.allowHtml) {\n          toast.scope.allowHtml = true;\n          toast.scope.title = $sce.trustAsHtml(map.title);\n          toast.scope.message = $sce.trustAsHtml(map.message);\n        } else {\n          toast.scope.title = map.title;\n          toast.scope.message = map.message;\n        }\n\n        toast.scope.toastType = toast.iconClass;\n        toast.scope.toastId = toast.toastId;\n        toast.scope.extraData = options.extraData;\n\n        toast.scope.options = {\n          extendedTimeOut: options.extendedTimeOut,\n          messageClass: options.messageClass,\n          onHidden: options.onHidden,\n          onShown: generateEvent('onShown'),\n          onTap: generateEvent('onTap'),\n          progressBar: options.progressBar,\n          tapToDismiss: options.tapToDismiss,\n          timeOut: options.timeOut,\n          titleClass: options.titleClass,\n          toastClass: options.toastClass\n        };\n\n        if (options.closeButton) {\n          toast.scope.options.closeHtml = options.closeHtml;\n        }\n\n        function generateEvent(event) {\n          if (options[event]) {\n            return function() {\n              options[event](toast);\n            };\n          }\n        }\n      }\n\n      function createToast() {\n        var newToast = {\n          toastId: index++,\n          isOpened: false,\n          scope: $rootScope.$new(),\n          open: $q.defer()\n        };\n        newToast.iconClass = map.iconClass;\n        if (map.optionsOverride) {\n          angular.extend(options, cleanOptionsOverride(map.optionsOverride));\n          newToast.iconClass = map.optionsOverride.iconClass || newToast.iconClass;\n        }\n\n        createScope(newToast, map, options);\n\n        newToast.el = createToastEl(newToast.scope);\n\n        return newToast;\n\n        function cleanOptionsOverride(options) {\n          var badOptions = ['containerId', 'iconClasses', 'maxOpened', 'newestOnTop',\n                            'positionClass', 'preventDuplicates', 'preventOpenDuplicates', 'templates'];\n          for (var i = 0, l = badOptions.length; i < l; i++) {\n            delete options[badOptions[i]];\n          }\n\n          return options;\n        }\n      }\n\n      function createToastEl(scope) {\n        var angularDomEl = angular.element('<div toast></div>'),\n          $compile = $injector.get('$compile');\n        return $compile(angularDomEl)(scope);\n      }\n\n      function maxOpenedNotReached() {\n        return options.maxOpened && toasts.length <= options.maxOpened || !options.maxOpened;\n      }\n\n      function shouldExit() {\n        var isDuplicateOfLast = options.preventDuplicates && map.message === previousToastMessage;\n        var isDuplicateOpen = options.preventOpenDuplicates && openToasts[map.message];\n\n        if (isDuplicateOfLast || isDuplicateOpen) {\n          return true;\n        }\n\n        previousToastMessage = map.message;\n        openToasts[map.message] = true;\n\n        return false;\n      }\n    }\n  }\n}());\n\n(function() {\n  'use strict';\n\n  angular.module('toastr')\n    .constant('toastrConfig', {\n      allowHtml: false,\n      autoDismiss: false,\n      closeButton: false,\n      closeHtml: '<button>&times;</button>',\n      containerId: 'toast-container',\n      extendedTimeOut: 1000,\n      iconClasses: {\n        error: 'toast-error',\n        info: 'toast-info',\n        success: 'toast-success',\n        warning: 'toast-warning'\n      },\n      maxOpened: 0,\n      messageClass: 'toast-message',\n      newestOnTop: true,\n      onHidden: null,\n      onShown: null,\n      onTap: null,\n      positionClass: 'toast-top-right',\n      preventDuplicates: false,\n      preventOpenDuplicates: false,\n      progressBar: false,\n      tapToDismiss: true,\n      target: 'body',\n      templates: {\n        toast: 'directives/toast/toast.html',\n        progressbar: 'directives/progressbar/progressbar.html'\n      },\n      timeOut: 5000,\n      titleClass: 'toast-title',\n      toastClass: 'toast'\n    });\n}());\n\n(function() {\n  'use strict';\n\n  angular.module('toastr')\n    .directive('progressBar', progressBar);\n\n  progressBar.$inject = ['toastrConfig'];\n\n  function progressBar(toastrConfig) {\n    return {\n      require: '^toast',\n      templateUrl: function() {\n        return toastrConfig.templates.progressbar;\n      },\n      link: linkFunction\n    };\n\n    function linkFunction(scope, element, attrs, toastCtrl) {\n      var intervalId, currentTimeOut, hideTime;\n\n      toastCtrl.progressBar = scope;\n\n      scope.start = function(duration) {\n        if (intervalId) {\n          clearInterval(intervalId);\n        }\n\n        currentTimeOut = parseFloat(duration);\n        hideTime = new Date().getTime() + currentTimeOut;\n        intervalId = setInterval(updateProgress, 10);\n      };\n\n      scope.stop = function() {\n        if (intervalId) {\n          clearInterval(intervalId);\n        }\n      };\n\n      function updateProgress() {\n        var percentage = ((hideTime - (new Date().getTime())) / currentTimeOut) * 100;\n        element.css('width', percentage + '%');\n      }\n\n      scope.$on('$destroy', function() {\n        // Failsafe stop\n        clearInterval(intervalId);\n      });\n    }\n  }\n}());\n\n(function() {\n  'use strict';\n\n  angular.module('toastr')\n    .controller('ToastController', ToastController);\n\n  function ToastController() {\n    this.progressBar = null;\n\n    this.startProgressBar = function(duration) {\n      if (this.progressBar) {\n        this.progressBar.start(duration);\n      }\n    };\n\n    this.stopProgressBar = function() {\n      if (this.progressBar) {\n        this.progressBar.stop();\n      }\n    };\n  }\n}());\n\n(function() {\n  'use strict';\n\n  angular.module('toastr')\n    .directive('toast', toast);\n\n  toast.$inject = ['$injector', '$interval', 'toastrConfig', 'toastr'];\n\n  function toast($injector, $interval, toastrConfig, toastr) {\n    return {\n      templateUrl: function() {\n        return toastrConfig.templates.toast;\n      },\n      controller: 'ToastController',\n      link: toastLinkFunction\n    };\n\n    function toastLinkFunction(scope, element, attrs, toastCtrl) {\n      var timeout;\n\n      scope.toastClass = scope.options.toastClass;\n      scope.titleClass = scope.options.titleClass;\n      scope.messageClass = scope.options.messageClass;\n      scope.progressBar = scope.options.progressBar;\n\n      if (wantsCloseButton()) {\n        var button = angular.element(scope.options.closeHtml),\n          $compile = $injector.get('$compile');\n        button.addClass('toast-close-button');\n        button.attr('ng-click', 'close(true, $event)');\n        $compile(button)(scope);\n        element.children().prepend(button);\n      }\n\n      scope.init = function() {\n        if (scope.options.timeOut) {\n          timeout = createTimeout(scope.options.timeOut);\n        }\n        if (scope.options.onShown) {\n          scope.options.onShown();\n        }\n      };\n\n      element.on('mouseenter', function() {\n        hideAndStopProgressBar();\n        if (timeout) {\n          $interval.cancel(timeout);\n        }\n      });\n\n      scope.tapToast = function () {\n        if (angular.isFunction(scope.options.onTap)) {\n          scope.options.onTap();\n        }\n        if (scope.options.tapToDismiss) {\n          scope.close(true);\n        }\n      };\n\n      scope.close = function (wasClicked, $event) {\n        if ($event && angular.isFunction($event.stopPropagation)) {\n          $event.stopPropagation();\n        }\n        toastr.remove(scope.toastId, wasClicked);\n      };\n      \n      scope.refreshTimer = function(newTime) {\n        if (timeout) {\n          $interval.cancel(timeout);\n          timeout = createTimeout(newTime || scope.options.timeOut);\n        }\n      };\n\n      element.on('mouseleave', function() {\n        if (scope.options.timeOut === 0 && scope.options.extendedTimeOut === 0) { return; }\n        scope.$apply(function() {\n          scope.progressBar = scope.options.progressBar;\n        });\n        timeout = createTimeout(scope.options.extendedTimeOut);\n      });\n\n      function createTimeout(time) {\n        toastCtrl.startProgressBar(time);\n        return $interval(function() {\n          toastCtrl.stopProgressBar();\n          toastr.remove(scope.toastId);\n        }, time, 1);\n      }\n\n      function hideAndStopProgressBar() {\n        scope.progressBar = false;\n        toastCtrl.stopProgressBar();\n      }\n\n      function wantsCloseButton() {\n        return scope.options.closeHtml;\n      }\n    }\n  }\n}());\n\nangular.module(\"toastr\").run([\"$templateCache\", function($templateCache) {$templateCache.put(\"directives/progressbar/progressbar.html\",\"<div class=\\\"toast-progress\\\"></div>\\n\");\n$templateCache.put(\"directives/toast/toast.html\",\"<div class=\\\"{{toastClass}} {{toastType}}\\\" ng-click=\\\"tapToast()\\\">\\n  <div ng-switch on=\\\"allowHtml\\\">\\n    <div ng-switch-default ng-if=\\\"title\\\" class=\\\"{{titleClass}}\\\" aria-label=\\\"{{title}}\\\">{{title}}</div>\\n    <div ng-switch-default class=\\\"{{messageClass}}\\\" aria-label=\\\"{{message}}\\\">{{message}}</div>\\n    <div ng-switch-when=\\\"true\\\" ng-if=\\\"title\\\" class=\\\"{{titleClass}}\\\" ng-bind-html=\\\"title\\\"></div>\\n    <div ng-switch-when=\\\"true\\\" class=\\\"{{messageClass}}\\\" ng-bind-html=\\\"message\\\"></div>\\n  </div>\\n  <progress-bar ng-if=\\\"progressBar\\\"></progress-bar>\\n</div>\\n\");}]);","/*\n * angular-tooltips\n * 1.1.10\n *\n * Angular.js tooltips module.\n * http://720kb.github.io/angular-tooltips\n *\n * MIT license\n * Wed Jan 25 2017\n */\n/*global angular,window*/\n(function withAngular(angular, window) {\n  'use strict';\n\n  var directiveName = 'tooltips'\n  , resizeObserver = (function resizeObserver() {\n\n    var callbacks = []\n      , lastTime = 0\n      , runCallbacks = function runCallbacks(currentTime) {\n\n        if (currentTime - lastTime >= 15) {\n\n          callbacks.forEach(function iterator(callback) {\n\n            callback();\n          });\n          lastTime = currentTime;\n        } else {\n\n          window.console.log('Skipped!');\n        }\n      }\n      , resizeTimeout\n      , resize = function resize() {\n        window.clearTimeout(resizeTimeout);\n        resizeTimeout = window.setTimeout(function onResizeTimeout() {\n          window.requestAnimationFrame(runCallbacks);\n        }, 500);\n      }\n      , addCallback = function addCallback(callback) {\n\n        if (callback) {\n\n          callbacks.push(callback);\n        }\n      };\n\n    return {\n      'add': function add(callback) {\n\n        if (!callbacks.length) {\n\n          window.addEventListener('resize', resize);\n        }\n        addCallback(callback);\n      },\n      'remove': function remove() {\n        if (!callbacks.length) {\n          window.clearTimeout(resizeTimeout);\n          window.removeEventListener('resize', resize);\n        }\n      }\n    };\n  }())\n  , getAttributesToAdd = function getAttributesToAdd(element) {\n    var attributesToAdd = {};\n\n    element.removeAttr(directiveName);\n    if (element.attr('tooltip-template') !== undefined) {\n\n      attributesToAdd['tooltip-template'] = element.attr('tooltip-template');\n      element.removeAttr('tooltip-template');\n    }\n\n    if (element.attr('tooltip-template-url') !== undefined) {\n\n      attributesToAdd['tooltip-template-url'] = element.attr('tooltip-template-url');\n      element.removeAttr('tooltip-template-url');\n    }\n\n    if (element.attr('tooltip-template-url-cache') !== undefined) {\n\n      attributesToAdd['tooltip-template-url-cache'] = element.attr('tooltip-template-url-cache');\n      element.removeAttr('tooltip-template-url-cache');\n    }\n\n    if (element.attr('tooltip-controller') !== undefined) {\n\n      attributesToAdd['tooltip-controller'] = element.attr('tooltip-controller');\n      element.removeAttr('tooltip-controller');\n    }\n\n    if (element.attr('tooltip-side') !== undefined) {\n\n      attributesToAdd['tooltip-side'] = element.attr('tooltip-side');\n      element.removeAttr('tooltip-side');\n    }\n\n    if (element.attr('tooltip-show-trigger') !== undefined) {\n\n      attributesToAdd['tooltip-show-trigger'] = element.attr('tooltip-show-trigger');\n      element.removeAttr('tooltip-show-trigger');\n    }\n\n    if (element.attr('tooltip-hide-trigger') !== undefined) {\n\n      attributesToAdd['tooltip-hide-trigger'] = element.attr('tooltip-hide-trigger');\n      element.removeAttr('tooltip-hide-trigger');\n    }\n\n    if (element.attr('tooltip-smart') !== undefined) {\n\n      attributesToAdd['tooltip-smart'] = element.attr('tooltip-smart');\n      element.removeAttr('tooltip-smart');\n    }\n\n    if (element.attr('tooltip-class') !== undefined) {\n\n      attributesToAdd['tooltip-class'] = element.attr('tooltip-class');\n      element.removeAttr('tooltip-class');\n    }\n\n    if (element.attr('tooltip-close-button') !== undefined) {\n\n      attributesToAdd['tooltip-close-button'] = element.attr('tooltip-close-button');\n      element.removeAttr('tooltip-close-button');\n    }\n\n    if (element.attr('tooltip-size') !== undefined) {\n\n      attributesToAdd['tooltip-size'] = element.attr('tooltip-size');\n      element.removeAttr('tooltip-size');\n    }\n\n    if (element.attr('tooltip-speed') !== undefined) {\n\n      attributesToAdd['tooltip-speed'] = element.attr('tooltip-speed');\n      element.removeAttr('tooltip-speed');\n    }\n\n    return attributesToAdd;\n  }\n  , getStyle = function getStyle(anElement) {\n\n    if (window.getComputedStyle) {\n\n      return window.getComputedStyle(anElement, '');\n    } else if (anElement.currentStyle) {\n\n      return anElement.currentStyle;\n    }\n  }\n  , getAppendedTip = function getAppendedTip(theTooltipElement) {\n    var tipsInBody = window.document.querySelectorAll('._exradicated-tooltip')\n      , aTipInBody\n      , tipsInBodyIndex = 0\n      , tipsInBodyLength = tipsInBody.length\n      , angularizedElement;\n\n    for (; tipsInBodyIndex < tipsInBodyLength; tipsInBodyIndex += 1) {\n\n      aTipInBody = tipsInBody.item(tipsInBodyIndex);\n      if (aTipInBody) {\n\n        angularizedElement = angular.element(aTipInBody);\n        if (angularizedElement.data('_tooltip-parent') &&\n          angularizedElement.data('_tooltip-parent') === theTooltipElement) {\n\n          return angularizedElement;\n        }\n      }\n    }\n  }\n  , removeAppendedTip = function removeAppendedTip(theTooltipElement) {\n    var tipElement = getAppendedTip(theTooltipElement);\n\n    if (tipElement) {\n\n      tipElement.remove();\n    }\n  }\n  , isOutOfPage = function isOutOfPage(theTipElement) {\n\n    if (theTipElement) {\n      var squarePosition = theTipElement[0].getBoundingClientRect();\n\n      if (squarePosition.top < 0 ||\n        squarePosition.top > window.document.body.offsetHeight ||\n        squarePosition.left < 0 ||\n        squarePosition.left > window.document.body.offsetWidth ||\n        squarePosition.bottom < 0 ||\n        squarePosition.bottom > window.document.body.offsetHeight ||\n        squarePosition.right < 0 ||\n        squarePosition.right > window.document.body.offsetWidth) {\n\n        theTipElement.css({\n          'top': '',\n          'left': '',\n          'bottom': '',\n          'right': ''\n        });\n        return true;\n      }\n\n      return false;\n    }\n\n    throw new Error('You must provide a position');\n  }\n  , tooltipConfigurationProvider = function tooltipConfigurationProvider() {\n\n    var tooltipConfiguration = {\n      'side': 'top',\n      'showTrigger': 'mouseenter',\n      'hideTrigger': 'mouseleave',\n      'class': '',\n      'smart': false,\n      'closeButton': false,\n      'size': '',\n      'speed': 'steady',\n      'tooltipTemplateUrlCache': false\n    };\n\n    return {\n      'configure': function configure(configuration) {\n        var configurationKeys = Object.keys(tooltipConfiguration)\n          , configurationIndex = 0\n          , aConfigurationKey;\n\n        if (configuration) {\n\n          for (; configurationIndex < configurationKeys.length; configurationIndex += 1) {\n\n            aConfigurationKey = configurationKeys[configurationIndex];\n            if (aConfigurationKey &&\n              configuration[aConfigurationKey]) {\n\n              tooltipConfiguration[aConfigurationKey] = configuration[aConfigurationKey];\n            }\n          }\n        }\n      },\n      '$get': /*@ngInject*/ function instantiateProvider() {\n\n        return tooltipConfiguration;\n      }\n    };\n  }\n  , tooltipDirective = /*@ngInject*/ ['$log', '$http', '$compile', '$timeout', '$controller', '$injector', 'tooltipsConf', '$templateCache', function tooltipDirective($log, $http, $compile, $timeout, $controller, $injector, tooltipsConf, $templateCache) {\n\n    var linkingFunction = function linkingFunction($scope, $element, $attrs, $controllerDirective, $transcludeFunc) {\n\n      if ($attrs.tooltipTemplate &&\n        $attrs.tooltipTemplateUrl) {\n\n        throw new Error('You can not define tooltip-template and tooltip-template-url together');\n      }\n\n      if (!($attrs.tooltipTemplateUrl || $attrs.tooltipTemplate) &&\n        $attrs.tooltipController) {\n\n        throw new Error('You can not have a controller without a template or templateUrl defined');\n      }\n\n      var oldTooltipSide = '_' + tooltipsConf.side\n        , oldTooltipShowTrigger = tooltipsConf.showTrigger\n        , oldTooltipHideTrigger = tooltipsConf.hideTrigger\n        , oldTooltipClass\n        , oldSize = tooltipsConf.size\n        , oldSpeed = '_' + tooltipsConf.speed;\n\n      $attrs.tooltipSide = $attrs.tooltipSide || tooltipsConf.side;\n      $attrs.tooltipShowTrigger = $attrs.tooltipShowTrigger || tooltipsConf.showTrigger;\n      $attrs.tooltipHideTrigger = $attrs.tooltipHideTrigger || tooltipsConf.hideTrigger;\n      $attrs.tooltipClass = $attrs.tooltipClass || tooltipsConf.class;\n      $attrs.tooltipSmart = $attrs.tooltipSmart === 'true' || tooltipsConf.smart;\n      $attrs.tooltipCloseButton = $attrs.tooltipCloseButton || tooltipsConf.closeButton.toString();\n      $attrs.tooltipSize = $attrs.tooltipSize || tooltipsConf.size;\n      $attrs.tooltipSpeed = $attrs.tooltipSpeed || tooltipsConf.speed;\n      $attrs.tooltipAppendToBody = $attrs.tooltipAppendToBody === 'true';\n\n      $transcludeFunc($scope, function onTransclusionDone(element, scope) {\n        var attributes = getAttributesToAdd(element)\n          , tooltipElement = angular.element(window.document.createElement('tooltip'))\n          , tipContElement = angular.element(window.document.createElement('tip-cont'))\n          , tipElement = angular.element(window.document.createElement('tip'))\n          , tipTipElement = angular.element(window.document.createElement('tip-tip'))\n          , closeButtonElement = angular.element(window.document.createElement('span'))\n          , tipArrowElement = angular.element(window.document.createElement('tip-arrow'))\n          , whenActivateMultilineCalculation = function whenActivateMultilineCalculation() {\n\n            return tipContElement.html();\n          }\n          , calculateIfMultiLine = function calculateIfMultiLine(newValue) {\n\n            if (newValue !== undefined &&\n              tipContElement[0].getClientRects().length > 1) {\n\n              tooltipElement.addClass('_multiline');\n            } else {\n\n              tooltipElement.removeClass('_multiline');\n            }\n          }\n          , onTooltipShow = function onTooltipShow(event) {\n\n            tipElement.addClass('_hidden');\n            if ($attrs.tooltipSmart) {\n\n              switch ($attrs.tooltipSide) {\n                case 'top': {\n\n                  if (isOutOfPage(tipElement)) {\n\n                    tooltipElement.removeClass('_top');\n                    tooltipElement.addClass('_left');\n                    if (isOutOfPage(tipElement)) {\n\n                      tooltipElement.removeClass('_left');\n                      tooltipElement.addClass('_bottom');\n                      if (isOutOfPage(tipElement)) {\n\n                        tooltipElement.removeClass('_bottom');\n                        tooltipElement.addClass('_right');\n                        if (isOutOfPage(tipElement)) {\n\n                          tooltipElement.removeClass('_right');\n                          tooltipElement.addClass('_top');\n                        }\n                      }\n                    }\n                  }\n                  break;\n                }\n\n                case 'left': {\n\n                  if (isOutOfPage(tipElement)) {\n\n                    tooltipElement.removeClass('_left');\n                    tooltipElement.addClass('_bottom');\n                    if (isOutOfPage(tipElement)) {\n\n                      tooltipElement.removeClass('_bottom');\n                      tooltipElement.addClass('_right');\n                      if (isOutOfPage(tipElement)) {\n\n                        tooltipElement.removeClass('_right');\n                        tooltipElement.addClass('_top');\n                        if (isOutOfPage(tipElement)) {\n\n                          tooltipElement.removeClass('_top');\n                          tooltipElement.addClass('_left');\n                        }\n                      }\n                    }\n                  }\n                  break;\n                }\n\n                case 'bottom': {\n\n                  if (isOutOfPage(tipElement)) {\n\n                    tooltipElement.removeClass('_bottom');\n                    tooltipElement.addClass('_left');\n                    if (isOutOfPage(tipElement)) {\n\n                      tooltipElement.removeClass('_left');\n                      tooltipElement.addClass('_top');\n                      if (isOutOfPage(tipElement)) {\n\n                        tooltipElement.removeClass('_top');\n                        tooltipElement.addClass('_right');\n                        if (isOutOfPage(tipElement)) {\n\n                          tooltipElement.removeClass('_right');\n                          tooltipElement.addClass('_bottom');\n                        }\n                      }\n                    }\n                  }\n                  break;\n                }\n\n                case 'right': {\n\n                  if (isOutOfPage(tipElement)) {\n\n                    tooltipElement.removeClass('_right');\n                    tooltipElement.addClass('_top');\n                    if (isOutOfPage(tipElement)) {\n\n                      tooltipElement.removeClass('_top');\n                      tooltipElement.addClass('_left');\n                      if (isOutOfPage(tipElement)) {\n\n                        tooltipElement.removeClass('_left');\n                        tooltipElement.addClass('_bottom');\n                        if (isOutOfPage(tipElement)) {\n\n                          tooltipElement.removeClass('_bottom');\n                          tooltipElement.addClass('_right');\n                        }\n                      }\n                    }\n                  }\n                  break;\n                }\n                default: {\n\n                  throw new Error('Position not supported');\n                }\n              }\n            }\n\n            if ($attrs.tooltipAppendToBody) {\n\n              var tipTipElementStyle = getStyle(tipTipElement[0])\n                , tipArrowElementStyle = getStyle(tipArrowElement[0])\n                , tipElementStyle = getStyle(tipElement[0])\n                , tipElementBoundingClientRect = tipElement[0].getBoundingClientRect()\n                , exradicatedTipElement = angular.copy(tipElement)\n                , tipTipStyleIndex = 0\n                , tipTipStyleLength = tipTipElementStyle.length\n                , tipArrowStyleIndex = 0\n                , tipArrowStyleLength = tipArrowElementStyle.length\n                , tipStyleIndex = 0\n                , tipStyleLength = tipElementStyle.length\n                , aStyleKey\n                , tipTipCssToSet = {}\n                , tipCssToSet = {}\n                , tipArrowCssToSet = {}\n                , paddingTopValue\n                , paddingBottomValue\n                , paddingLeftValue\n                , paddingRightValue;\n\n              tipElement.removeClass('_hidden');\n              exradicatedTipElement.removeClass('_hidden');\n              exradicatedTipElement.data('_tooltip-parent', tooltipElement);\n              removeAppendedTip(tooltipElement);\n\n              for (; tipTipStyleIndex < tipTipStyleLength; tipTipStyleIndex += 1) {\n\n                aStyleKey = tipTipElementStyle[tipTipStyleIndex];\n                if (aStyleKey &&\n                  tipTipElementStyle.getPropertyValue(aStyleKey)) {\n\n                  tipTipCssToSet[aStyleKey] = tipTipElementStyle.getPropertyValue(aStyleKey);\n                }\n              }\n\n              for (; tipArrowStyleIndex < tipArrowStyleLength; tipArrowStyleIndex += 1) {\n\n                aStyleKey = tipArrowElementStyle[tipArrowStyleIndex];\n                if (aStyleKey &&\n                  tipArrowElementStyle.getPropertyValue(aStyleKey)) {\n\n                  tipArrowCssToSet[aStyleKey] = tipArrowElementStyle.getPropertyValue(aStyleKey);\n                }\n              }\n\n              for (; tipStyleIndex < tipStyleLength; tipStyleIndex += 1) {\n\n                aStyleKey = tipElementStyle[tipStyleIndex];\n                if (aStyleKey &&\n                    aStyleKey !== 'position' &&\n                    aStyleKey !== 'display' &&\n                    aStyleKey !== 'opacity' &&\n                    aStyleKey !== 'z-index' &&\n                    aStyleKey !== 'bottom' &&\n                    aStyleKey !== 'height' &&\n                    aStyleKey !== 'left' &&\n                    aStyleKey !== 'right' &&\n                    aStyleKey !== 'top' &&\n                    aStyleKey !== 'width' &&\n                  tipElementStyle.getPropertyValue(aStyleKey)) {\n\n                  tipCssToSet[aStyleKey] = tipElementStyle.getPropertyValue(aStyleKey);\n                }\n              }\n              paddingTopValue = window.parseInt(tipElementStyle.getPropertyValue('padding-top'), 10);\n              paddingBottomValue = window.parseInt(tipElementStyle.getPropertyValue('padding-bottom'), 10);\n              paddingLeftValue = window.parseInt(tipElementStyle.getPropertyValue('padding-left'), 10);\n              paddingRightValue = window.parseInt(tipElementStyle.getPropertyValue('padding-right'), 10);\n\n              tipCssToSet.top = tipElementBoundingClientRect.top + window.pageYOffset + 'px';\n              tipCssToSet.left = tipElementBoundingClientRect.left + window.pageXOffset + 'px';\n              tipCssToSet.height = tipElementBoundingClientRect.height - (paddingTopValue + paddingBottomValue) + 'px';\n              tipCssToSet.width = tipElementBoundingClientRect.width - (paddingLeftValue + paddingRightValue) + 'px';\n\n              exradicatedTipElement.css(tipCssToSet);\n\n              exradicatedTipElement.children().css(tipTipCssToSet);\n              exradicatedTipElement.children().next().css(tipArrowCssToSet);\n              if (event &&\n                $attrs.tooltipHidden !== 'true') {\n\n                exradicatedTipElement.addClass('_exradicated-tooltip');\n                angular.element(window.document.body).append(exradicatedTipElement);\n              }\n            } else {\n\n              tipElement.removeClass('_hidden');\n              if (event &&\n                $attrs.tooltipHidden !== 'true') {\n\n                tooltipElement.addClass('active');\n              }\n            }\n          }\n          , onTooltipHide = function onTooltipHide() {\n\n            if ($attrs.tooltipAppendToBody) {\n\n              removeAppendedTip(tooltipElement);\n            } else {\n\n              tooltipElement.removeClass('active');\n            }\n          }\n          , registerOnScrollFrom = function registerOnScrollFrom(theElement) {\n            var parentElement = theElement.parent()\n              , timer;\n\n            if (theElement[0] &&\n              (theElement[0].scrollHeight > theElement[0].clientHeight ||\n              theElement[0].scrollWidth > theElement[0].clientWidth)) {\n\n              theElement.on('scroll', function onScroll() {\n                var that = this;\n\n                if (timer) {\n\n                  $timeout.cancel(timer);\n                }\n\n                timer = $timeout(function doLater() {\n\n                  var theTipElement = getAppendedTip(tooltipElement)\n                    , tooltipBoundingRect = tooltipElement[0].getBoundingClientRect()\n                    , thatBoundingRect = that.getBoundingClientRect();\n\n                  if (tooltipBoundingRect.top < thatBoundingRect.top ||\n                    tooltipBoundingRect.bottom > thatBoundingRect.bottom ||\n                    tooltipBoundingRect.left < thatBoundingRect.left ||\n                    tooltipBoundingRect.right > thatBoundingRect.right) {\n\n                    removeAppendedTip(tooltipElement);\n                  } else if (theTipElement) {\n\n                    onTooltipShow(true);\n                  }\n                });\n              });\n            }\n\n            if (parentElement &&\n              parentElement.length) {\n\n              registerOnScrollFrom(parentElement);\n            }\n          }\n          , onTooltipTemplateChange = function onTooltipTemplateChange(newValue) {\n            if (newValue) {\n              tooltipElement.removeClass('_force-hidden'); //see lines below, this forces to hide tooltip when is empty\n              tipTipElement.empty();\n              tipTipElement.append(closeButtonElement);\n              tipTipElement.append(newValue);\n              $timeout(function doLaterShow() {\n\n                onTooltipShow();\n              });\n            } else {\n              //hide tooltip because is empty\n              tipTipElement.empty();\n              tooltipElement.addClass('_force-hidden'); //force to be hidden if empty\n            }\n          }\n          , onTooltipTemplateUrlChange = function onTooltipTemplateUrlChange(newValue) {\n            if (newValue && !$attrs.tooltipTemplateUrlCache) {\n\n              $http.get(newValue).then(function onResponse(response) {\n\n                if (response &&\n                  response.data) {\n\n                  tooltipElement.removeClass('_force-hidden'); //see lines below, this forces to hide tooltip when is empty\n                  tipTipElement.empty();\n                  tipTipElement.append(closeButtonElement);\n                  tipTipElement.append($compile(response.data)(scope));\n                  $timeout(function doLater() {\n\n                    onTooltipShow();\n                  });\n                }\n              });\n            } else {\n              //hide tooltip because is empty\n              tipTipElement.empty();\n              tooltipElement.addClass('_force-hidden'); //force to be hidden if empty\n            }\n          }\n          , onTooltipTemplateUrlCacheChange = function onTooltipTemplateUrlCacheChange(newValue) {\n            if (newValue && $attrs.tooltipTemplateUrl) {\n\n              var template = $templateCache.get($attrs.tooltipTemplateUrl);\n\n              if (typeof template !== 'undefined') {\n\n                tooltipElement.removeClass('_force-hidden'); //see lines below, this forces to hide tooltip when is empty\n                tipTipElement.empty();\n                tipTipElement.append(closeButtonElement);\n                tipTipElement.append($compile(template)(scope));\n                $timeout(function doLater() {\n                  onTooltipShow();\n                });\n              }\n            } else {\n              //hide tooltip because is empty\n              tipTipElement.empty();\n              tooltipElement.addClass('_force-hidden'); //force to be hidden if empty\n            }\n          }\n          , onTooltipSideChange = function onTooltipSideChange(newValue) {\n\n            if (newValue) {\n\n              if (oldTooltipSide) {\n\n                tooltipElement.removeAttr('_' + oldTooltipSide);\n              }\n              tooltipElement.addClass('_' + newValue);\n              oldTooltipSide = newValue;\n            }\n          }\n          , onTooltipShowTrigger = function onTooltipShowTrigger(newValue) {\n\n            if (newValue) {\n\n              if (oldTooltipShowTrigger) {\n\n                tooltipElement.off(oldTooltipShowTrigger);\n              }\n              tooltipElement.on(newValue, onTooltipShow);\n              oldTooltipShowTrigger = newValue;\n            }\n          }\n          , onTooltipHideTrigger = function onTooltipHideTrigger(newValue) {\n\n            if (newValue) {\n\n              if (oldTooltipHideTrigger) {\n\n                tooltipElement.off(oldTooltipHideTrigger);\n              }\n              tooltipElement.on(newValue, onTooltipHide);\n              oldTooltipHideTrigger = newValue;\n            }\n          }\n          , onTooltipClassChange = function onTooltipClassChange(newValue) {\n\n            if (newValue) {\n\n              if (oldTooltipClass) {\n\n                tipElement.removeClass(oldTooltipClass);\n              }\n              tipElement.addClass(newValue);\n              oldTooltipClass = newValue;\n            }\n          }\n          , onTooltipSmartChange = function onTooltipSmartChange() {\n\n            if (typeof $attrs.tooltipSmart !== 'boolean') {\n\n              $attrs.tooltipSmart = $attrs.tooltipSmart === 'true';\n            }\n          }\n          , onTooltipCloseButtonChange = function onTooltipCloseButtonChange(newValue) {\n            var enableButton = newValue === 'true';\n\n            if (enableButton) {\n\n              closeButtonElement.on('click', onTooltipHide);\n              closeButtonElement.css('display', 'block');\n            } else {\n\n              closeButtonElement.off('click');\n              closeButtonElement.css('display', 'none');\n            }\n          }\n          , onTooltipTemplateControllerChange = function onTooltipTemplateControllerChange(newValue) {\n\n            if (newValue) {\n\n              var tipController = $controller(newValue, {\n                  '$scope': scope\n                })\n                , newScope = scope.$new(false, scope)\n                , indexOfAs = newValue.indexOf('as')\n                , controllerName;\n\n              if (indexOfAs >= 0) {\n\n                controllerName = newValue.substr(indexOfAs + 3);\n                newScope[controllerName] = tipController;\n              } else {\n\n                angular.extend(newScope, tipController);\n              }\n\n              tipTipElement.replaceWith($compile(tipTipElement)(newScope));\n              /*eslint-disable no-use-before-define*/\n              unregisterOnTooltipControllerChange();\n              /*eslint-enable no-use-before-define*/\n            }\n          }\n          , onTooltipSizeChange = function onTooltipSizeChange(newValue) {\n\n            if (newValue) {\n\n              if (oldSize) {\n\n                tipTipElement.removeClass('_' + oldSize);\n              }\n              tipTipElement.addClass('_' + newValue);\n              oldSize = newValue;\n            }\n          }\n          , onTooltipSpeedChange = function onTooltipSpeedChange(newValue) {\n\n            if (newValue) {\n\n              if (oldSpeed) {\n\n                tooltipElement.removeClass('_' + oldSpeed);\n              }\n              tooltipElement.addClass('_' + newValue);\n              oldSpeed = newValue;\n            }\n          }\n          , unregisterOnTooltipTemplateChange = $attrs.$observe('tooltipTemplate', onTooltipTemplateChange)\n          , unregisterOnTooltipTemplateUrlChange = $attrs.$observe('tooltipTemplateUrl', onTooltipTemplateUrlChange)\n          , unregisterOnTooltipTemplateUrlCacheChange = $attrs.$observe('tooltipTemplateUrlCache', onTooltipTemplateUrlCacheChange)\n          , unregisterOnTooltipSideChangeObserver = $attrs.$observe('tooltipSide', onTooltipSideChange)\n          , unregisterOnTooltipShowTrigger = $attrs.$observe('tooltipShowTrigger', onTooltipShowTrigger)\n          , unregisterOnTooltipHideTrigger = $attrs.$observe('tooltipHideTrigger', onTooltipHideTrigger)\n          , unregisterOnTooltipClassChange = $attrs.$observe('tooltipClass', onTooltipClassChange)\n          , unregisterOnTooltipSmartChange = $attrs.$observe('tooltipSmart', onTooltipSmartChange)\n          , unregisterOnTooltipCloseButtonChange = $attrs.$observe('tooltipCloseButton', onTooltipCloseButtonChange)\n          , unregisterOnTooltipControllerChange = $attrs.$observe('tooltipController', onTooltipTemplateControllerChange)\n          , unregisterOnTooltipSizeChange = $attrs.$observe('tooltipSize', onTooltipSizeChange)\n          , unregisterOnTooltipSpeedChange = $attrs.$observe('tooltipSpeed', onTooltipSpeedChange)\n          , unregisterTipContentChangeWatcher = scope.$watch(whenActivateMultilineCalculation, calculateIfMultiLine);\n\n        closeButtonElement.addClass('close-button');\n        closeButtonElement.html('&times;');\n\n        tipElement.addClass('_hidden');\n\n        tipTipElement.append(closeButtonElement);\n        tipTipElement.append($attrs.tooltipTemplate);\n\n        tipElement.append(tipTipElement);\n        tipElement.append(tipArrowElement);\n\n        tipContElement.append(element);\n\n        tooltipElement.attr(attributes);\n        tooltipElement.addClass('tooltips');\n\n        tooltipElement.append(tipContElement);\n        tooltipElement.append(tipElement);\n        $element.after(tooltipElement);\n\n        if ($attrs.tooltipAppendToBody) {\n\n          resizeObserver.add(function onResize() {\n\n            registerOnScrollFrom(tooltipElement);\n          });\n          registerOnScrollFrom(tooltipElement);\n        }\n\n        resizeObserver.add(function registerResize() {\n\n          calculateIfMultiLine();\n          onTooltipShow();\n        });\n\n        $timeout(function doLater() {\n\n          onTooltipShow();\n          tipElement.removeClass('_hidden');\n          tooltipElement.addClass('_ready');\n        });\n\n        scope.$on('$destroy', function unregisterListeners() {\n\n          unregisterOnTooltipTemplateChange();\n          unregisterOnTooltipTemplateUrlChange();\n          unregisterOnTooltipTemplateUrlCacheChange();\n          unregisterOnTooltipSideChangeObserver();\n          unregisterOnTooltipShowTrigger();\n          unregisterOnTooltipHideTrigger();\n          unregisterOnTooltipClassChange();\n          unregisterOnTooltipSmartChange();\n          unregisterOnTooltipCloseButtonChange();\n          unregisterOnTooltipSizeChange();\n          unregisterOnTooltipSpeedChange();\n          unregisterTipContentChangeWatcher();\n          resizeObserver.remove();\n          element.off($attrs.tooltipShowTrigger + ' ' + $attrs.tooltipHideTrigger);\n        });\n      });\n    };\n\n    return {\n      'restrict': 'A',\n      'transclude': 'element',\n      'priority': 1,\n      'terminal': true,\n      'link': linkingFunction\n    };\n  }];\n\n  angular.module('720kb.tooltips', [])\n  .provider(directiveName + 'Conf', tooltipConfigurationProvider)\n  .directive(directiveName, tooltipDirective);\n}(angular, window));\n","/*!\n * ui-select\n * http://github.com/angular-ui/ui-select\n * Version: 0.19.3 - 2016-08-17T06:16:41.345Z\n * License: MIT\n */\n\n\n(function () {\n\"use strict\";\nvar KEY = {\n    TAB: 9,\n    ENTER: 13,\n    ESC: 27,\n    SPACE: 32,\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n    SHIFT: 16,\n    CTRL: 17,\n    ALT: 18,\n    PAGE_UP: 33,\n    PAGE_DOWN: 34,\n    HOME: 36,\n    END: 35,\n    BACKSPACE: 8,\n    DELETE: 46,\n    COMMAND: 91,\n\n    MAP: { 91 : \"COMMAND\", 8 : \"BACKSPACE\" , 9 : \"TAB\" , 13 : \"ENTER\" , 16 : \"SHIFT\" , 17 : \"CTRL\" , 18 : \"ALT\" , 19 : \"PAUSEBREAK\" , 20 : \"CAPSLOCK\" , 27 : \"ESC\" , 32 : \"SPACE\" , 33 : \"PAGE_UP\", 34 : \"PAGE_DOWN\" , 35 : \"END\" , 36 : \"HOME\" , 37 : \"LEFT\" , 38 : \"UP\" , 39 : \"RIGHT\" , 40 : \"DOWN\" , 43 : \"+\" , 44 : \"PRINTSCREEN\" , 45 : \"INSERT\" , 46 : \"DELETE\", 48 : \"0\" , 49 : \"1\" , 50 : \"2\" , 51 : \"3\" , 52 : \"4\" , 53 : \"5\" , 54 : \"6\" , 55 : \"7\" , 56 : \"8\" , 57 : \"9\" , 59 : \";\", 61 : \"=\" , 65 : \"A\" , 66 : \"B\" , 67 : \"C\" , 68 : \"D\" , 69 : \"E\" , 70 : \"F\" , 71 : \"G\" , 72 : \"H\" , 73 : \"I\" , 74 : \"J\" , 75 : \"K\" , 76 : \"L\", 77 : \"M\" , 78 : \"N\" , 79 : \"O\" , 80 : \"P\" , 81 : \"Q\" , 82 : \"R\" , 83 : \"S\" , 84 : \"T\" , 85 : \"U\" , 86 : \"V\" , 87 : \"W\" , 88 : \"X\" , 89 : \"Y\" , 90 : \"Z\", 96 : \"0\" , 97 : \"1\" , 98 : \"2\" , 99 : \"3\" , 100 : \"4\" , 101 : \"5\" , 102 : \"6\" , 103 : \"7\" , 104 : \"8\" , 105 : \"9\", 106 : \"*\" , 107 : \"+\" , 109 : \"-\" , 110 : \".\" , 111 : \"/\", 112 : \"F1\" , 113 : \"F2\" , 114 : \"F3\" , 115 : \"F4\" , 116 : \"F5\" , 117 : \"F6\" , 118 : \"F7\" , 119 : \"F8\" , 120 : \"F9\" , 121 : \"F10\" , 122 : \"F11\" , 123 : \"F12\", 144 : \"NUMLOCK\" , 145 : \"SCROLLLOCK\" , 186 : \";\" , 187 : \"=\" , 188 : \",\" , 189 : \"-\" , 190 : \".\" , 191 : \"/\" , 192 : \"`\" , 219 : \"[\" , 220 : \"\\\\\" , 221 : \"]\" , 222 : \"'\"\n    },\n\n    isControl: function (e) {\n        var k = e.which;\n        switch (k) {\n        case KEY.COMMAND:\n        case KEY.SHIFT:\n        case KEY.CTRL:\n        case KEY.ALT:\n            return true;\n        }\n\n        if (e.metaKey || e.ctrlKey || e.altKey) return true;\n\n        return false;\n    },\n    isFunctionKey: function (k) {\n        k = k.which ? k.which : k;\n        return k >= 112 && k <= 123;\n    },\n    isVerticalMovement: function (k){\n      return ~[KEY.UP, KEY.DOWN].indexOf(k);\n    },\n    isHorizontalMovement: function (k){\n      return ~[KEY.LEFT,KEY.RIGHT,KEY.BACKSPACE,KEY.DELETE].indexOf(k);\n    },\n    toSeparator: function (k) {\n      var sep = {ENTER:\"\\n\",TAB:\"\\t\",SPACE:\" \"}[k];\n      if (sep) return sep;\n      // return undefined for special keys other than enter, tab or space.\n      // no way to use them to cut strings.\n      return KEY[k] ? undefined : k;\n    }\n  };\n\n/**\n * Add querySelectorAll() to jqLite.\n *\n * jqLite find() is limited to lookups by tag name.\n * TODO This will change with future versions of AngularJS, to be removed when this happens\n *\n * See jqLite.find - why not use querySelectorAll? https://github.com/angular/angular.js/issues/3586\n * See feat(jqLite): use querySelectorAll instead of getElementsByTagName in jqLite.find https://github.com/angular/angular.js/pull/3598\n */\nif (angular.element.prototype.querySelectorAll === undefined) {\n  angular.element.prototype.querySelectorAll = function(selector) {\n    return angular.element(this[0].querySelectorAll(selector));\n  };\n}\n\n/**\n * Add closest() to jqLite.\n */\nif (angular.element.prototype.closest === undefined) {\n  angular.element.prototype.closest = function( selector) {\n    var elem = this[0];\n    var matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector;\n\n    while (elem) {\n      if (matchesSelector.bind(elem)(selector)) {\n        return elem;\n      } else {\n        elem = elem.parentElement;\n      }\n    }\n    return false;\n  };\n}\n\nvar latestId = 0;\n\nvar uis = angular.module('ui.select', [])\n\n.constant('uiSelectConfig', {\n  theme: 'bootstrap',\n  searchEnabled: true,\n  sortable: false,\n  placeholder: '', // Empty by default, like HTML tag <select>\n  refreshDelay: 1000, // In milliseconds\n  closeOnSelect: true,\n  skipFocusser: false,\n  dropdownPosition: 'auto',\n  removeSelected: true,\n  resetSearchInput: true,\n  generateId: function() {\n    return latestId++;\n  },\n  appendToBody: false\n})\n\n// See Rename minErr and make it accessible from outside https://github.com/angular/angular.js/issues/6913\n.service('uiSelectMinErr', function() {\n  var minErr = angular.$$minErr('ui.select');\n  return function() {\n    var error = minErr.apply(this, arguments);\n    var message = error.message.replace(new RegExp('\\nhttp://errors.angularjs.org/.*'), '');\n    return new Error(message);\n  };\n})\n\n// Recreates old behavior of ng-transclude. Used internally.\n.directive('uisTranscludeAppend', function () {\n  return {\n    link: function (scope, element, attrs, ctrl, transclude) {\n        transclude(scope, function (clone) {\n          element.append(clone);\n        });\n      }\n    };\n})\n\n/**\n * Highlights text that matches $select.search.\n *\n * Taken from AngularUI Bootstrap Typeahead\n * See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L340\n */\n.filter('highlight', function() {\n  function escapeRegexp(queryToEscape) {\n    return ('' + queryToEscape).replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n  }\n\n  return function(matchItem, query) {\n    return query && matchItem ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<span class=\"ui-select-highlight\">$&</span>') : matchItem;\n  };\n})\n\n/**\n * A read-only equivalent of jQuery's offset function: http://api.jquery.com/offset/\n *\n * Taken from AngularUI Bootstrap Position:\n * See https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js#L70\n */\n.factory('uisOffset',\n  ['$document', '$window',\n  function ($document, $window) {\n\n  return function(element) {\n    var boundingClientRect = element[0].getBoundingClientRect();\n    return {\n      width: boundingClientRect.width || element.prop('offsetWidth'),\n      height: boundingClientRect.height || element.prop('offsetHeight'),\n      top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n      left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n    };\n  };\n}]);\n\nuis.directive('uiSelectChoices',\n  ['uiSelectConfig', 'uisRepeatParser', 'uiSelectMinErr', '$compile', '$window',\n  function(uiSelectConfig, RepeatParser, uiSelectMinErr, $compile, $window) {\n\n  return {\n    restrict: 'EA',\n    require: '^uiSelect',\n    replace: true,\n    transclude: true,\n    templateUrl: function(tElement) {\n      // Needed so the uiSelect can detect the transcluded content\n      tElement.addClass('ui-select-choices');\n\n      // Gets theme attribute from parent (ui-select)\n      var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;\n      return theme + '/choices.tpl.html';\n    },\n\n    compile: function(tElement, tAttrs) {\n\n      if (!tAttrs.repeat) throw uiSelectMinErr('repeat', \"Expected 'repeat' expression.\");\n\n      // var repeat = RepeatParser.parse(attrs.repeat);\n      var groupByExp = tAttrs.groupBy;\n      var groupFilterExp = tAttrs.groupFilter;\n\n      if (groupByExp) {\n        var groups = tElement.querySelectorAll('.ui-select-choices-group');\n        if (groups.length !== 1) throw uiSelectMinErr('rows', \"Expected 1 .ui-select-choices-group but got '{0}'.\", groups.length);\n        groups.attr('ng-repeat', RepeatParser.getGroupNgRepeatExpression());\n      }\n\n      var parserResult = RepeatParser.parse(tAttrs.repeat);\n\n      var choices = tElement.querySelectorAll('.ui-select-choices-row');\n      if (choices.length !== 1) {\n        throw uiSelectMinErr('rows', \"Expected 1 .ui-select-choices-row but got '{0}'.\", choices.length);\n      }\n\n      choices.attr('ng-repeat', parserResult.repeatExpression(groupByExp))\n             .attr('ng-if', '$select.open'); //Prevent unnecessary watches when dropdown is closed\n\n\n      var rowsInner = tElement.querySelectorAll('.ui-select-choices-row-inner');\n      if (rowsInner.length !== 1) {\n        throw uiSelectMinErr('rows', \"Expected 1 .ui-select-choices-row-inner but got '{0}'.\", rowsInner.length);\n      }\n      rowsInner.attr('uis-transclude-append', ''); //Adding uisTranscludeAppend directive to row element after choices element has ngRepeat\n\n      // If IE8 then need to target rowsInner to apply the ng-click attr as choices will not capture the event.\n      var clickTarget = $window.document.addEventListener ? choices : rowsInner;\n      clickTarget.attr('ng-click', '$select.select(' + parserResult.itemName + ',$select.skipFocusser,$event)');\n\n      return function link(scope, element, attrs, $select) {\n\n\n        $select.parseRepeatAttr(attrs.repeat, groupByExp, groupFilterExp); //Result ready at $select.parserResult\n\n        $select.disableChoiceExpression = attrs.uiDisableChoice;\n        $select.onHighlightCallback = attrs.onHighlight;\n\n        $select.dropdownPosition = attrs.position ? attrs.position.toLowerCase() : uiSelectConfig.dropdownPosition;\n\n        scope.$on('$destroy', function() {\n          choices.remove();\n        });\n\n        scope.$watch('$select.search', function(newValue) {\n          if(newValue && !$select.open && $select.multiple) $select.activate(false, true);\n          $select.activeIndex = $select.tagging.isActivated ? -1 : 0;\n          if (!attrs.minimumInputLength || $select.search.length >= attrs.minimumInputLength) {\n            $select.refresh(attrs.refresh);\n          } else {\n            $select.items = [];\n          }\n        });\n\n        attrs.$observe('refreshDelay', function() {\n          // $eval() is needed otherwise we get a string instead of a number\n          var refreshDelay = scope.$eval(attrs.refreshDelay);\n          $select.refreshDelay = refreshDelay !== undefined ? refreshDelay : uiSelectConfig.refreshDelay;\n        });\n      };\n    }\n  };\n}]);\n\n/**\n * Contains ui-select \"intelligence\".\n *\n * The goal is to limit dependency on the DOM whenever possible and\n * put as much logic in the controller (instead of the link functions) as possible so it can be easily tested.\n */\nuis.controller('uiSelectCtrl',\n  ['$scope', '$element', '$timeout', '$filter', '$$uisDebounce', 'uisRepeatParser', 'uiSelectMinErr', 'uiSelectConfig', '$parse', '$injector', '$window',\n  function($scope, $element, $timeout, $filter, $$uisDebounce, RepeatParser, uiSelectMinErr, uiSelectConfig, $parse, $injector, $window) {\n\n  var ctrl = this;\n\n  var EMPTY_SEARCH = '';\n\n  ctrl.placeholder = uiSelectConfig.placeholder;\n  ctrl.searchEnabled = uiSelectConfig.searchEnabled;\n  ctrl.sortable = uiSelectConfig.sortable;\n  ctrl.refreshDelay = uiSelectConfig.refreshDelay;\n  ctrl.paste = uiSelectConfig.paste;\n  ctrl.resetSearchInput = uiSelectConfig.resetSearchInput;\n\n  ctrl.removeSelected = uiSelectConfig.removeSelected; //If selected item(s) should be removed from dropdown list\n  ctrl.closeOnSelect = true; //Initialized inside uiSelect directive link function\n  ctrl.skipFocusser = false; //Set to true to avoid returning focus to ctrl when item is selected\n  ctrl.search = EMPTY_SEARCH;\n\n  ctrl.activeIndex = 0; //Dropdown of choices\n  ctrl.items = []; //All available choices\n\n  ctrl.open = false;\n  ctrl.focus = false;\n  ctrl.disabled = false;\n  ctrl.selected = undefined;\n\n  ctrl.dropdownPosition = 'auto';\n\n  ctrl.focusser = undefined; //Reference to input element used to handle focus events\n  ctrl.multiple = undefined; // Initialized inside uiSelect directive link function\n  ctrl.disableChoiceExpression = undefined; // Initialized inside uiSelectChoices directive link function\n  ctrl.tagging = {isActivated: false, fct: undefined};\n  ctrl.taggingTokens = {isActivated: false, tokens: undefined};\n  ctrl.lockChoiceExpression = undefined; // Initialized inside uiSelectMatch directive link function\n  ctrl.clickTriggeredSelect = false;\n  ctrl.$filter = $filter;\n  ctrl.$element = $element;\n\n  // Use $injector to check for $animate and store a reference to it\n  ctrl.$animate = (function () {\n    try {\n      return $injector.get('$animate');\n    } catch (err) {\n      // $animate does not exist\n      return null;\n    }\n  })();\n\n  ctrl.searchInput = $element.querySelectorAll('input.ui-select-search');\n  if (ctrl.searchInput.length !== 1) {\n    throw uiSelectMinErr('searchInput', \"Expected 1 input.ui-select-search but got '{0}'.\", ctrl.searchInput.length);\n  }\n\n  ctrl.isEmpty = function() {\n    return angular.isUndefined(ctrl.selected) || ctrl.selected === null || ctrl.selected === '' || (ctrl.multiple && ctrl.selected.length === 0);\n  };\n\n  function _findIndex(collection, predicate, thisArg){\n    if (collection.findIndex){\n      return collection.findIndex(predicate, thisArg);\n    } else {\n      var list = Object(collection);\n      var length = list.length >>> 0;\n      var value;\n\n      for (var i = 0; i < length; i++) {\n        value = list[i];\n        if (predicate.call(thisArg, value, i, list)) {\n          return i;\n        }\n      }\n      return -1;\n    }\n  }\n\n  // Most of the time the user does not want to empty the search input when in typeahead mode\n  function _resetSearchInput() {\n    if (ctrl.resetSearchInput) {\n      ctrl.search = EMPTY_SEARCH;\n      //reset activeIndex\n      if (ctrl.selected && ctrl.items.length && !ctrl.multiple) {\n        ctrl.activeIndex = _findIndex(ctrl.items, function(item){\n          return angular.equals(this, item);\n        }, ctrl.selected);\n      }\n    }\n  }\n\n    function _groupsFilter(groups, groupNames) {\n      var i, j, result = [];\n      for(i = 0; i < groupNames.length ;i++){\n        for(j = 0; j < groups.length ;j++){\n          if(groups[j].name == [groupNames[i]]){\n            result.push(groups[j]);\n          }\n        }\n      }\n      return result;\n    }\n\n  // When the user clicks on ui-select, displays the dropdown list\n  ctrl.activate = function(initSearchValue, avoidReset) {\n    if (!ctrl.disabled  && !ctrl.open) {\n      if(!avoidReset) _resetSearchInput();\n\n      $scope.$broadcast('uis:activate');\n\n      ctrl.open = true;\n\n      ctrl.activeIndex = ctrl.activeIndex >= ctrl.items.length ? 0 : ctrl.activeIndex;\n\n      // ensure that the index is set to zero for tagging variants\n      // that where first option is auto-selected\n      if ( ctrl.activeIndex === -1 && ctrl.taggingLabel !== false ) {\n        ctrl.activeIndex = 0;\n      }\n\n      var container = $element.querySelectorAll('.ui-select-choices-content');\n      var searchInput = $element.querySelectorAll('.ui-select-search');\n      if (ctrl.$animate && ctrl.$animate.on && ctrl.$animate.enabled(container[0])) {\n        var animateHandler = function(elem, phase) {\n          if (phase === 'start' && ctrl.items.length === 0) {\n            // Only focus input after the animation has finished\n            ctrl.$animate.off('removeClass', searchInput[0], animateHandler);\n            $timeout(function () {\n              ctrl.focusSearchInput(initSearchValue);\n            });\n          } else if (phase === 'close') {\n            // Only focus input after the animation has finished\n            ctrl.$animate.off('enter', container[0], animateHandler);\n            $timeout(function () {\n              ctrl.focusSearchInput(initSearchValue);\n            });\n          }\n        };\n\n        if (ctrl.items.length > 0) {\n          ctrl.$animate.on('enter', container[0], animateHandler);\n        } else {\n          ctrl.$animate.on('removeClass', searchInput[0], animateHandler);\n        }\n      } else {\n        $timeout(function () {\n          ctrl.focusSearchInput(initSearchValue);\n          if(!ctrl.tagging.isActivated && ctrl.items.length > 1) {\n            _ensureHighlightVisible();\n          }\n        });\n      }\n    }\n    else if (ctrl.open && !ctrl.searchEnabled) {\n      // Close the selection if we don't have search enabled, and we click on the select again\n      ctrl.close();\n    }\n  };\n\n  ctrl.focusSearchInput = function (initSearchValue) {\n    ctrl.search = initSearchValue || ctrl.search;\n    ctrl.searchInput[0].focus();\n  };\n\n  ctrl.findGroupByName = function(name) {\n    return ctrl.groups && ctrl.groups.filter(function(group) {\n      return group.name === name;\n    })[0];\n  };\n\n  ctrl.parseRepeatAttr = function(repeatAttr, groupByExp, groupFilterExp) {\n    function updateGroups(items) {\n      var groupFn = $scope.$eval(groupByExp);\n      ctrl.groups = [];\n      angular.forEach(items, function(item) {\n        var groupName = angular.isFunction(groupFn) ? groupFn(item) : item[groupFn];\n        var group = ctrl.findGroupByName(groupName);\n        if(group) {\n          group.items.push(item);\n        }\n        else {\n          ctrl.groups.push({name: groupName, items: [item]});\n        }\n      });\n      if(groupFilterExp){\n        var groupFilterFn = $scope.$eval(groupFilterExp);\n        if( angular.isFunction(groupFilterFn)){\n          ctrl.groups = groupFilterFn(ctrl.groups);\n        } else if(angular.isArray(groupFilterFn)){\n          ctrl.groups = _groupsFilter(ctrl.groups, groupFilterFn);\n        }\n      }\n      ctrl.items = [];\n      ctrl.groups.forEach(function(group) {\n        ctrl.items = ctrl.items.concat(group.items);\n      });\n    }\n\n    function setPlainItems(items) {\n      ctrl.items = items;\n    }\n\n    ctrl.setItemsFn = groupByExp ? updateGroups : setPlainItems;\n\n    ctrl.parserResult = RepeatParser.parse(repeatAttr);\n\n    ctrl.isGrouped = !!groupByExp;\n    ctrl.itemProperty = ctrl.parserResult.itemName;\n\n    //If collection is an Object, convert it to Array\n\n    var originalSource = ctrl.parserResult.source;\n\n    //When an object is used as source, we better create an array and use it as 'source'\n    var createArrayFromObject = function(){\n      var origSrc = originalSource($scope);\n      $scope.$uisSource = Object.keys(origSrc).map(function(v){\n        var result = {};\n        result[ctrl.parserResult.keyName] = v;\n        result.value = origSrc[v];\n        return result;\n      });\n    };\n\n    if (ctrl.parserResult.keyName){ // Check for (key,value) syntax\n      createArrayFromObject();\n      ctrl.parserResult.source = $parse('$uisSource' + ctrl.parserResult.filters);\n      $scope.$watch(originalSource, function(newVal, oldVal){\n        if (newVal !== oldVal) createArrayFromObject();\n      }, true);\n    }\n\n    ctrl.refreshItems = function (data){\n      data = data || ctrl.parserResult.source($scope);\n      var selectedItems = ctrl.selected;\n      //TODO should implement for single mode removeSelected\n      if (ctrl.isEmpty() || (angular.isArray(selectedItems) && !selectedItems.length) || !ctrl.multiple || !ctrl.removeSelected) {\n        ctrl.setItemsFn(data);\n      }else{\n        if ( data !== undefined && data !== null ) {\n          var filteredItems = data.filter(function(i) {\n            return angular.isArray(selectedItems) ? selectedItems.every(function(selectedItem) {\n              return !angular.equals(i, selectedItem);\n            }) : !angular.equals(i, selectedItems);\n          });\n          ctrl.setItemsFn(filteredItems);\n        }\n      }\n      if (ctrl.dropdownPosition === 'auto' || ctrl.dropdownPosition === 'up'){\n        $scope.calculateDropdownPos();\n      }\n\n      $scope.$broadcast('uis:refresh');\n    };\n\n    // See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L259\n    $scope.$watchCollection(ctrl.parserResult.source, function(items) {\n      if (items === undefined || items === null) {\n        // If the user specifies undefined or null => reset the collection\n        // Special case: items can be undefined if the user did not initialized the collection on the scope\n        // i.e $scope.addresses = [] is missing\n        ctrl.items = [];\n      } else {\n        if (!angular.isArray(items)) {\n          throw uiSelectMinErr('items', \"Expected an array but got '{0}'.\", items);\n        } else {\n          //Remove already selected items (ex: while searching)\n          //TODO Should add a test\n          ctrl.refreshItems(items);\n\n          //update the view value with fresh data from items, if there is a valid model value\n          if(angular.isDefined(ctrl.ngModel.$modelValue)) {\n            ctrl.ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters\n          }\n        }\n      }\n    });\n\n  };\n\n  var _refreshDelayPromise;\n\n  /**\n   * Typeahead mode: lets the user refresh the collection using his own function.\n   *\n   * See Expose $select.search for external / remote filtering https://github.com/angular-ui/ui-select/pull/31\n   */\n  ctrl.refresh = function(refreshAttr) {\n    if (refreshAttr !== undefined) {\n\n      // Debounce\n      // See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L155\n      // FYI AngularStrap typeahead does not have debouncing: https://github.com/mgcrea/angular-strap/blob/v2.0.0-rc.4/src/typeahead/typeahead.js#L177\n      if (_refreshDelayPromise) {\n        $timeout.cancel(_refreshDelayPromise);\n      }\n      _refreshDelayPromise = $timeout(function() {\n        $scope.$eval(refreshAttr);\n      }, ctrl.refreshDelay);\n    }\n  };\n\n  ctrl.isActive = function(itemScope) {\n    if ( !ctrl.open ) {\n      return false;\n    }\n    var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);\n    var isActive =  itemIndex == ctrl.activeIndex;\n\n    if ( !isActive || itemIndex < 0 ) {\n      return false;\n    }\n\n    if (isActive && !angular.isUndefined(ctrl.onHighlightCallback)) {\n      itemScope.$eval(ctrl.onHighlightCallback);\n    }\n\n    return isActive;\n  };\n\n  var _isItemSelected = function (item) {\n    return (ctrl.selected && angular.isArray(ctrl.selected) &&\n        ctrl.selected.filter(function (selection) { return angular.equals(selection, item); }).length > 0);\n  };\n\n  var disabledItems = [];\n\n  function _updateItemDisabled(item, isDisabled) {\n    var disabledItemIndex = disabledItems.indexOf(item);\n    if (isDisabled && disabledItemIndex === -1) {\n      disabledItems.push(item);\n    }\n\n    if (!isDisabled && disabledItemIndex > -1) {\n      disabledItems.splice(disabledItemIndex, 1);\n    }\n  }\n\n  function _isItemDisabled(item) {\n    return disabledItems.indexOf(item) > -1;\n  }\n\n  ctrl.isDisabled = function(itemScope) {\n\n    if (!ctrl.open) return;\n\n    var item = itemScope[ctrl.itemProperty];\n    var itemIndex = ctrl.items.indexOf(item);\n    var isDisabled = false;\n\n    if (itemIndex >= 0 && (angular.isDefined(ctrl.disableChoiceExpression) || ctrl.multiple)) {\n\n      if (item.isTag) return false;\n\n      if (ctrl.multiple) {\n        isDisabled = _isItemSelected(item);\n      }\n\n      if (!isDisabled && angular.isDefined(ctrl.disableChoiceExpression)) {\n        isDisabled = !!(itemScope.$eval(ctrl.disableChoiceExpression));\n      }\n\n      _updateItemDisabled(item, isDisabled);\n    }\n\n    return isDisabled;\n  };\n\n\n  // When the user selects an item with ENTER or clicks the dropdown\n  ctrl.select = function(item, skipFocusser, $event) {\n    if (item === undefined || !_isItemDisabled(item)) {\n\n      if ( ! ctrl.items && ! ctrl.search && ! ctrl.tagging.isActivated) return;\n\n      if (!item || !_isItemDisabled(item)) {\n        // if click is made on existing item, prevent from tagging, ctrl.search does not matter\n        ctrl.clickTriggeredSelect = false;\n        if($event && $event.type === 'click' && item)\n          ctrl.clickTriggeredSelect = true;\n\n        if(ctrl.tagging.isActivated && ctrl.clickTriggeredSelect === false) {\n          // if taggingLabel is disabled and item is undefined we pull from ctrl.search\n          if ( ctrl.taggingLabel === false ) {\n            if ( ctrl.activeIndex < 0 ) {\n              if (item === undefined) {\n                item = ctrl.tagging.fct !== undefined ? ctrl.tagging.fct(ctrl.search) : ctrl.search;\n              }\n              if (!item || angular.equals( ctrl.items[0], item ) ) {\n                return;\n              }\n            } else {\n              // keyboard nav happened first, user selected from dropdown\n              item = ctrl.items[ctrl.activeIndex];\n            }\n          } else {\n            // tagging always operates at index zero, taggingLabel === false pushes\n            // the ctrl.search value without having it injected\n            if ( ctrl.activeIndex === 0 ) {\n              // ctrl.tagging pushes items to ctrl.items, so we only have empty val\n              // for `item` if it is a detected duplicate\n              if ( item === undefined ) return;\n\n              // create new item on the fly if we don't already have one;\n              // use tagging function if we have one\n              if ( ctrl.tagging.fct !== undefined && typeof item === 'string' ) {\n                item = ctrl.tagging.fct(item);\n                if (!item) return;\n              // if item type is 'string', apply the tagging label\n              } else if ( typeof item === 'string' ) {\n                // trim the trailing space\n                item = item.replace(ctrl.taggingLabel,'').trim();\n              }\n            }\n          }\n          // search ctrl.selected for dupes potentially caused by tagging and return early if found\n          if (_isItemSelected(item)) {\n            ctrl.close(skipFocusser);\n            return;\n          }\n        }\n        _resetSearchInput();\n        $scope.$broadcast('uis:select', item);\n\n        var locals = {};\n        locals[ctrl.parserResult.itemName] = item;\n\n        $timeout(function(){\n          ctrl.onSelectCallback($scope, {\n            $item: item,\n            $model: ctrl.parserResult.modelMapper($scope, locals)\n          });\n        });\n\n        if (ctrl.closeOnSelect) {\n          ctrl.close(skipFocusser);\n        }\n      }\n    }\n  };\n\n  // Closes the dropdown\n  ctrl.close = function(skipFocusser) {\n    if (!ctrl.open) return;\n    if (ctrl.ngModel && ctrl.ngModel.$setTouched) ctrl.ngModel.$setTouched();\n    ctrl.open = false;\n    _resetSearchInput();\n    $scope.$broadcast('uis:close', skipFocusser);\n\n  };\n\n  ctrl.setFocus = function(){\n    if (!ctrl.focus) ctrl.focusInput[0].focus();\n  };\n\n  ctrl.clear = function($event) {\n    ctrl.select(undefined);\n    $event.stopPropagation();\n    $timeout(function() {\n      ctrl.focusser[0].focus();\n    }, 0, false);\n  };\n\n  // Toggle dropdown\n  ctrl.toggle = function(e) {\n    if (ctrl.open) {\n      ctrl.close();\n      e.preventDefault();\n      e.stopPropagation();\n    } else {\n      ctrl.activate();\n    }\n  };\n\n  // Set default function for locked choices - avoids unnecessary\n  // logic if functionality is not being used\n  ctrl.isLocked = function () {\n    return false;\n  };\n\n  $scope.$watch(function () {\n    return angular.isDefined(ctrl.lockChoiceExpression) && ctrl.lockChoiceExpression !== \"\";\n  }, _initaliseLockedChoices);\n\n  function _initaliseLockedChoices(doInitalise) {\n    if(!doInitalise) return;\n\n    var lockedItems = [];\n\n    function _updateItemLocked(item, isLocked) {\n      var lockedItemIndex = lockedItems.indexOf(item);\n      if (isLocked && lockedItemIndex === -1) {\n        lockedItems.push(item);\n        }\n\n      if (!isLocked && lockedItemIndex > -1) {\n        lockedItems.splice(lockedItemIndex, 0);\n      }\n    }\n\n    function _isItemlocked(item) {\n      return lockedItems.indexOf(item) > -1;\n    }\n\n    ctrl.isLocked = function (itemScope, itemIndex) {\n      var isLocked = false,\n          item = ctrl.selected[itemIndex];\n\n      if(item) {\n        if (itemScope) {\n          isLocked = !!(itemScope.$eval(ctrl.lockChoiceExpression));\n          _updateItemLocked(item, isLocked);\n        } else {\n          isLocked = _isItemlocked(item);\n        }\n      }\n\n      return isLocked;\n    };\n  }\n\n\n  var sizeWatch = null;\n  var updaterScheduled = false;\n  ctrl.sizeSearchInput = function() {\n\n    var input = ctrl.searchInput[0],\n        container = ctrl.searchInput.parent().parent()[0],\n        calculateContainerWidth = function() {\n          // Return the container width only if the search input is visible\n          return container.clientWidth * !!input.offsetParent;\n        },\n        updateIfVisible = function(containerWidth) {\n          if (containerWidth === 0) {\n            return false;\n          }\n          var inputWidth = containerWidth - input.offsetLeft - 10;\n          if (inputWidth < 50) inputWidth = containerWidth;\n          ctrl.searchInput.css('width', inputWidth+'px');\n          return true;\n        };\n\n    ctrl.searchInput.css('width', '10px');\n    $timeout(function() { //Give tags time to render correctly\n      if (sizeWatch === null && !updateIfVisible(calculateContainerWidth())) {\n        sizeWatch = $scope.$watch(function() {\n          if (!updaterScheduled) {\n            updaterScheduled = true;\n            $scope.$$postDigest(function() {\n              updaterScheduled = false;\n              if (updateIfVisible(calculateContainerWidth())) {\n                sizeWatch();\n                sizeWatch = null;\n              }\n            });\n          }\n        }, angular.noop);\n      }\n    });\n  };\n\n  function _handleDropDownSelection(key) {\n    var processed = true;\n    switch (key) {\n      case KEY.DOWN:\n        if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode\n        else if (ctrl.activeIndex < ctrl.items.length - 1) { ctrl.activeIndex++; }\n        break;\n      case KEY.UP:\n        if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode\n        else if (ctrl.activeIndex > 0 || (ctrl.search.length === 0 && ctrl.tagging.isActivated && ctrl.activeIndex > -1)) { ctrl.activeIndex--; }\n        break;\n      case KEY.TAB:\n        if (!ctrl.multiple || ctrl.open) ctrl.select(ctrl.items[ctrl.activeIndex], true);\n        break;\n      case KEY.ENTER:\n        if(ctrl.open && (ctrl.tagging.isActivated || ctrl.activeIndex >= 0)){\n          ctrl.select(ctrl.items[ctrl.activeIndex], ctrl.skipFocusser); // Make sure at least one dropdown item is highlighted before adding if not in tagging mode\n        } else {\n          ctrl.activate(false, true); //In case its the search input in 'multiple' mode\n        }\n        break;\n      case KEY.ESC:\n        ctrl.close();\n        break;\n      default:\n        processed = false;\n    }\n    return processed;\n  }\n\n  // Bind to keyboard shortcuts\n  ctrl.searchInput.on('keydown', function(e) {\n\n    var key = e.which;\n\n    if (~[KEY.ENTER,KEY.ESC].indexOf(key)){\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    // if(~[KEY.ESC,KEY.TAB].indexOf(key)){\n    //   //TODO: SEGURO?\n    //   ctrl.close();\n    // }\n\n    $scope.$apply(function() {\n\n      var tagged = false;\n\n      if (ctrl.items.length > 0 || ctrl.tagging.isActivated) {\n        if(!_handleDropDownSelection(key) && !ctrl.searchEnabled) {\n          e.preventDefault();\n          e.stopPropagation();\n        }\n        if ( ctrl.taggingTokens.isActivated ) {\n          for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {\n            if ( ctrl.taggingTokens.tokens[i] === KEY.MAP[e.keyCode] ) {\n              // make sure there is a new value to push via tagging\n              if ( ctrl.search.length > 0 ) {\n                tagged = true;\n              }\n            }\n          }\n          if ( tagged ) {\n            $timeout(function() {\n              ctrl.searchInput.triggerHandler('tagged');\n              var newItem = ctrl.search.replace(KEY.MAP[e.keyCode],'').trim();\n              if ( ctrl.tagging.fct ) {\n                newItem = ctrl.tagging.fct( newItem );\n              }\n              if (newItem) ctrl.select(newItem, true);\n            });\n          }\n        }\n      }\n\n    });\n\n    if(KEY.isVerticalMovement(key) && ctrl.items.length > 0){\n      _ensureHighlightVisible();\n    }\n\n    if (key === KEY.ENTER || key === KEY.ESC) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n  });\n\n  ctrl.searchInput.on('paste', function (e) {\n    var data;\n\n    if (window.clipboardData && window.clipboardData.getData) { // IE\n      data = window.clipboardData.getData('Text');\n    } else {\n      data = (e.originalEvent || e).clipboardData.getData('text/plain');\n    }\n\n    // Prepend the current input field text to the paste buffer.\n    data = ctrl.search + data;\n\n    if (data && data.length > 0) {\n      // If tagging try to split by tokens and add items\n      if (ctrl.taggingTokens.isActivated) {\n        var items = [];\n        for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {  // split by first token that is contained in data\n          var separator = KEY.toSeparator(ctrl.taggingTokens.tokens[i]) || ctrl.taggingTokens.tokens[i];\n          if (data.indexOf(separator) > -1) {\n            items = data.split(separator);\n            break;  // only split by one token\n          }\n        }\n        if (items.length === 0) {\n          items = [data];\n        }\n        var oldsearch = ctrl.search;\n        angular.forEach(items, function (item) {\n          var newItem = ctrl.tagging.fct ? ctrl.tagging.fct(item) : item;\n          if (newItem) {\n            ctrl.select(newItem, true);\n          }\n        });\n        ctrl.search = oldsearch || EMPTY_SEARCH;\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (ctrl.paste) {\n        ctrl.paste(data);\n        ctrl.search = EMPTY_SEARCH;\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  });\n\n  ctrl.searchInput.on('tagged', function() {\n    $timeout(function() {\n      _resetSearchInput();\n    });\n  });\n\n  // See https://github.com/ivaynberg/select2/blob/3.4.6/select2.js#L1431\n  function _ensureHighlightVisible() {\n    var container = $element.querySelectorAll('.ui-select-choices-content');\n    var choices = container.querySelectorAll('.ui-select-choices-row');\n    if (choices.length < 1) {\n      throw uiSelectMinErr('choices', \"Expected multiple .ui-select-choices-row but got '{0}'.\", choices.length);\n    }\n\n    if (ctrl.activeIndex < 0) {\n      return;\n    }\n\n    var highlighted = choices[ctrl.activeIndex];\n    var posY = highlighted.offsetTop + highlighted.clientHeight - container[0].scrollTop;\n    var height = container[0].offsetHeight;\n\n    if (posY > height) {\n      container[0].scrollTop += posY - height;\n    } else if (posY < highlighted.clientHeight) {\n      if (ctrl.isGrouped && ctrl.activeIndex === 0)\n        container[0].scrollTop = 0; //To make group header visible when going all the way up\n      else\n        container[0].scrollTop -= highlighted.clientHeight - posY;\n    }\n  }\n\n  var onResize = $$uisDebounce(function() {\n    ctrl.sizeSearchInput();\n  }, 50);\n\n  angular.element($window).bind('resize', onResize);\n\n  $scope.$on('$destroy', function() {\n    ctrl.searchInput.off('keyup keydown tagged blur paste');\n    angular.element($window).off('resize', onResize);\n  });\n}]);\n\nuis.directive('uiSelect',\n  ['$document', 'uiSelectConfig', 'uiSelectMinErr', 'uisOffset', '$compile', '$parse', '$timeout',\n  function($document, uiSelectConfig, uiSelectMinErr, uisOffset, $compile, $parse, $timeout) {\n\n  return {\n    restrict: 'EA',\n    templateUrl: function(tElement, tAttrs) {\n      var theme = tAttrs.theme || uiSelectConfig.theme;\n      return theme + (angular.isDefined(tAttrs.multiple) ? '/select-multiple.tpl.html' : '/select.tpl.html');\n    },\n    replace: true,\n    transclude: true,\n    require: ['uiSelect', '^ngModel'],\n    scope: true,\n\n    controller: 'uiSelectCtrl',\n    controllerAs: '$select',\n    compile: function(tElement, tAttrs) {\n\n      // Allow setting ngClass on uiSelect\n      var match = /{(.*)}\\s*{(.*)}/.exec(tAttrs.ngClass);\n      if(match) {\n        var combined = '{'+ match[1] +', '+ match[2] +'}';\n        tAttrs.ngClass = combined;\n        tElement.attr('ng-class', combined);\n      }\n\n      //Multiple or Single depending if multiple attribute presence\n      if (angular.isDefined(tAttrs.multiple))\n        tElement.append('<ui-select-multiple/>').removeAttr('multiple');\n      else\n        tElement.append('<ui-select-single/>');\n\n      if (tAttrs.inputId)\n        tElement.querySelectorAll('input.ui-select-search')[0].id = tAttrs.inputId;\n\n      return function(scope, element, attrs, ctrls, transcludeFn) {\n\n        var $select = ctrls[0];\n        var ngModel = ctrls[1];\n\n        $select.generatedId = uiSelectConfig.generateId();\n        $select.baseTitle = attrs.title || 'Select box';\n        $select.focusserTitle = $select.baseTitle + ' focus';\n        $select.focusserId = 'focusser-' + $select.generatedId;\n\n        $select.closeOnSelect = function() {\n          if (angular.isDefined(attrs.closeOnSelect)) {\n            return $parse(attrs.closeOnSelect)();\n          } else {\n            return uiSelectConfig.closeOnSelect;\n          }\n        }();\n\n        scope.$watch('skipFocusser', function() {\n            var skipFocusser = scope.$eval(attrs.skipFocusser);\n            $select.skipFocusser = skipFocusser !== undefined ? skipFocusser : uiSelectConfig.skipFocusser;\n        });\n\n        $select.onSelectCallback = $parse(attrs.onSelect);\n        $select.onRemoveCallback = $parse(attrs.onRemove);\n\n        //Set reference to ngModel from uiSelectCtrl\n        $select.ngModel = ngModel;\n\n        $select.choiceGrouped = function(group){\n          return $select.isGrouped && group && group.name;\n        };\n\n        if(attrs.tabindex){\n          attrs.$observe('tabindex', function(value) {\n            $select.focusInput.attr('tabindex', value);\n            element.removeAttr('tabindex');\n          });\n        }\n\n        scope.$watch(function () { return scope.$eval(attrs.searchEnabled); }, function(newVal) {\n          $select.searchEnabled = newVal !== undefined ? newVal : uiSelectConfig.searchEnabled;\n        });\n\n        scope.$watch('sortable', function() {\n            var sortable = scope.$eval(attrs.sortable);\n            $select.sortable = sortable !== undefined ? sortable : uiSelectConfig.sortable;\n        });\n\n        attrs.$observe('limit', function() {\n          //Limit the number of selections allowed\n          $select.limit = (angular.isDefined(attrs.limit)) ? parseInt(attrs.limit, 10) : undefined;\n        });\n\n        scope.$watch('removeSelected', function() {\n            var removeSelected = scope.$eval(attrs.removeSelected);\n            $select.removeSelected = removeSelected !== undefined ? removeSelected : uiSelectConfig.removeSelected;\n        });\n\n        attrs.$observe('disabled', function() {\n          // No need to use $eval() (thanks to ng-disabled) since we already get a boolean instead of a string\n          $select.disabled = attrs.disabled !== undefined ? attrs.disabled : false;\n        });\n\n        attrs.$observe('resetSearchInput', function() {\n          // $eval() is needed otherwise we get a string instead of a boolean\n          var resetSearchInput = scope.$eval(attrs.resetSearchInput);\n          $select.resetSearchInput = resetSearchInput !== undefined ? resetSearchInput : true;\n        });\n\n        attrs.$observe('paste', function() {\n          $select.paste = scope.$eval(attrs.paste);\n        });\n\n        attrs.$observe('tagging', function() {\n          if(attrs.tagging !== undefined)\n          {\n            // $eval() is needed otherwise we get a string instead of a boolean\n            var taggingEval = scope.$eval(attrs.tagging);\n            $select.tagging = {isActivated: true, fct: taggingEval !== true ? taggingEval : undefined};\n          }\n          else\n          {\n            $select.tagging = {isActivated: false, fct: undefined};\n          }\n        });\n\n        attrs.$observe('taggingLabel', function() {\n          if(attrs.tagging !== undefined )\n          {\n            // check eval for FALSE, in this case, we disable the labels\n            // associated with tagging\n            if ( attrs.taggingLabel === 'false' ) {\n              $select.taggingLabel = false;\n            }\n            else\n            {\n              $select.taggingLabel = attrs.taggingLabel !== undefined ? attrs.taggingLabel : '(new)';\n            }\n          }\n        });\n\n        attrs.$observe('taggingTokens', function() {\n          if (attrs.tagging !== undefined) {\n            var tokens = attrs.taggingTokens !== undefined ? attrs.taggingTokens.split('|') : [',','ENTER'];\n            $select.taggingTokens = {isActivated: true, tokens: tokens };\n          }\n        });\n\n        //Automatically gets focus when loaded\n        if (angular.isDefined(attrs.autofocus)){\n          $timeout(function(){\n            $select.setFocus();\n          });\n        }\n\n        //Gets focus based on scope event name (e.g. focus-on='SomeEventName')\n        if (angular.isDefined(attrs.focusOn)){\n          scope.$on(attrs.focusOn, function() {\n              $timeout(function(){\n                $select.setFocus();\n              });\n          });\n        }\n\n        function onDocumentClick(e) {\n          if (!$select.open) return; //Skip it if dropdown is close\n\n          var contains = false;\n\n          if (window.jQuery) {\n            // Firefox 3.6 does not support element.contains()\n            // See Node.contains https://developer.mozilla.org/en-US/docs/Web/API/Node.contains\n            contains = window.jQuery.contains(element[0], e.target);\n          } else {\n            contains = element[0].contains(e.target);\n          }\n\n          if (!contains && !$select.clickTriggeredSelect) {\n            var skipFocusser;\n            if (!$select.skipFocusser) {\n              //Will lose focus only with certain targets\n              var focusableControls = ['input','button','textarea','select'];\n              var targetController = angular.element(e.target).controller('uiSelect'); //To check if target is other ui-select\n              skipFocusser = targetController && targetController !== $select; //To check if target is other ui-select\n              if (!skipFocusser) skipFocusser =  ~focusableControls.indexOf(e.target.tagName.toLowerCase()); //Check if target is input, button or textarea\n            } else {\n              skipFocusser = true;\n            }\n            $select.close(skipFocusser);\n            scope.$digest();\n          }\n          $select.clickTriggeredSelect = false;\n        }\n\n        // See Click everywhere but here event http://stackoverflow.com/questions/12931369\n        $document.on('click', onDocumentClick);\n\n        scope.$on('$destroy', function() {\n          $document.off('click', onDocumentClick);\n        });\n\n        // Move transcluded elements to their correct position in main template\n        transcludeFn(scope, function(clone) {\n          // See Transclude in AngularJS http://blog.omkarpatil.com/2012/11/transclude-in-angularjs.html\n\n          // One day jqLite will be replaced by jQuery and we will be able to write:\n          // var transcludedElement = clone.filter('.my-class')\n          // instead of creating a hackish DOM element:\n          var transcluded = angular.element('<div>').append(clone);\n\n          var transcludedMatch = transcluded.querySelectorAll('.ui-select-match');\n          transcludedMatch.removeAttr('ui-select-match'); //To avoid loop in case directive as attr\n          transcludedMatch.removeAttr('data-ui-select-match'); // Properly handle HTML5 data-attributes\n          if (transcludedMatch.length !== 1) {\n            throw uiSelectMinErr('transcluded', \"Expected 1 .ui-select-match but got '{0}'.\", transcludedMatch.length);\n          }\n          element.querySelectorAll('.ui-select-match').replaceWith(transcludedMatch);\n\n          var transcludedChoices = transcluded.querySelectorAll('.ui-select-choices');\n          transcludedChoices.removeAttr('ui-select-choices'); //To avoid loop in case directive as attr\n          transcludedChoices.removeAttr('data-ui-select-choices'); // Properly handle HTML5 data-attributes\n          if (transcludedChoices.length !== 1) {\n            throw uiSelectMinErr('transcluded', \"Expected 1 .ui-select-choices but got '{0}'.\", transcludedChoices.length);\n          }\n          element.querySelectorAll('.ui-select-choices').replaceWith(transcludedChoices);\n\n          var transcludedNoChoice = transcluded.querySelectorAll('.ui-select-no-choice');\n          transcludedNoChoice.removeAttr('ui-select-no-choice'); //To avoid loop in case directive as attr\n          transcludedNoChoice.removeAttr('data-ui-select-no-choice'); // Properly handle HTML5 data-attributes\n          if (transcludedNoChoice.length == 1) {\n            element.querySelectorAll('.ui-select-no-choice').replaceWith(transcludedNoChoice);\n          }\n        });\n\n        // Support for appending the select field to the body when its open\n        var appendToBody = scope.$eval(attrs.appendToBody);\n        if (appendToBody !== undefined ? appendToBody : uiSelectConfig.appendToBody) {\n          scope.$watch('$select.open', function(isOpen) {\n            if (isOpen) {\n              positionDropdown();\n            } else {\n              resetDropdown();\n            }\n          });\n\n          // Move the dropdown back to its original location when the scope is destroyed. Otherwise\n          // it might stick around when the user routes away or the select field is otherwise removed\n          scope.$on('$destroy', function() {\n            resetDropdown();\n          });\n        }\n\n        // Hold on to a reference to the .ui-select-container element for appendToBody support\n        var placeholder = null,\n            originalWidth = '';\n\n        function positionDropdown() {\n          // Remember the absolute position of the element\n          var offset = uisOffset(element);\n\n          // Clone the element into a placeholder element to take its original place in the DOM\n          placeholder = angular.element('<div class=\"ui-select-placeholder\"></div>');\n          placeholder[0].style.width = offset.width + 'px';\n          placeholder[0].style.height = offset.height + 'px';\n          element.after(placeholder);\n\n          // Remember the original value of the element width inline style, so it can be restored\n          // when the dropdown is closed\n          originalWidth = element[0].style.width;\n\n          // Now move the actual dropdown element to the end of the body\n          $document.find('body').append(element);\n\n          element[0].style.position = 'absolute';\n          element[0].style.left = offset.left + 'px';\n          element[0].style.top = offset.top + 'px';\n          element[0].style.width = offset.width + 'px';\n        }\n\n        function resetDropdown() {\n          if (placeholder === null) {\n            // The dropdown has not actually been display yet, so there's nothing to reset\n            return;\n          }\n\n          // Move the dropdown element back to its original location in the DOM\n          placeholder.replaceWith(element);\n          placeholder = null;\n\n          element[0].style.position = '';\n          element[0].style.left = '';\n          element[0].style.top = '';\n          element[0].style.width = originalWidth;\n\n          // Set focus back on to the moved element\n          $select.setFocus();\n        }\n\n        // Hold on to a reference to the .ui-select-dropdown element for direction support.\n        var dropdown = null,\n            directionUpClassName = 'direction-up';\n\n        // Support changing the direction of the dropdown if there isn't enough space to render it.\n        scope.$watch('$select.open', function() {\n\n          if ($select.dropdownPosition === 'auto' || $select.dropdownPosition === 'up'){\n            scope.calculateDropdownPos();\n          }\n\n        });\n\n        var setDropdownPosUp = function(offset, offsetDropdown){\n\n          offset = offset || uisOffset(element);\n          offsetDropdown = offsetDropdown || uisOffset(dropdown);\n\n          dropdown[0].style.position = 'absolute';\n          dropdown[0].style.top = (offsetDropdown.height * -1) + 'px';\n          element.addClass(directionUpClassName);\n\n        };\n\n        var setDropdownPosDown = function(offset, offsetDropdown){\n\n          element.removeClass(directionUpClassName);\n\n          offset = offset || uisOffset(element);\n          offsetDropdown = offsetDropdown || uisOffset(dropdown);\n\n          dropdown[0].style.position = '';\n          dropdown[0].style.top = '';\n\n        };\n\n        var calculateDropdownPosAfterAnimation = function() {\n          // Delay positioning the dropdown until all choices have been added so its height is correct.\n          $timeout(function() {\n            if ($select.dropdownPosition === 'up') {\n              //Go UP\n              setDropdownPosUp();\n            } else {\n              //AUTO\n              element.removeClass(directionUpClassName);\n\n              var offset = uisOffset(element);\n              var offsetDropdown = uisOffset(dropdown);\n\n              //https://code.google.com/p/chromium/issues/detail?id=342307#c4\n              var scrollTop = $document[0].documentElement.scrollTop || $document[0].body.scrollTop; //To make it cross browser (blink, webkit, IE, Firefox).\n\n              // Determine if the direction of the dropdown needs to be changed.\n              if (offset.top + offset.height + offsetDropdown.height > scrollTop + $document[0].documentElement.clientHeight) {\n                //Go UP\n                setDropdownPosUp(offset, offsetDropdown);\n              }else{\n                //Go DOWN\n                setDropdownPosDown(offset, offsetDropdown);\n              }\n            }\n\n            // Display the dropdown once it has been positioned.\n            dropdown[0].style.opacity = 1;\n          });\n        };\n\n        var opened = false;\n\n        scope.calculateDropdownPos = function() {\n          if ($select.open) {\n            dropdown = angular.element(element).querySelectorAll('.ui-select-dropdown');\n\n            if (dropdown.length === 0) {\n              return;\n            }\n\n           // Hide the dropdown so there is no flicker until $timeout is done executing.\n           if ($select.search === '' && !opened) {\n              dropdown[0].style.opacity = 0;\n              opened = true;\n           }\n\n            if (!uisOffset(dropdown).height && $select.$animate && $select.$animate.on && $select.$animate.enabled(dropdown)) {\n              var needsCalculated = true;\n\n              $select.$animate.on('enter', dropdown, function (elem, phase) {\n                if (phase === 'close' && needsCalculated) {\n                  calculateDropdownPosAfterAnimation();\n                  needsCalculated = false;\n                }\n              });\n            } else {\n              calculateDropdownPosAfterAnimation();\n            }\n          } else {\n            if (dropdown === null || dropdown.length === 0) {\n              return;\n            }\n\n            // Reset the position of the dropdown.\n            dropdown[0].style.opacity = 0;\n            dropdown[0].style.position = '';\n            dropdown[0].style.top = '';\n            element.removeClass(directionUpClassName);\n          }\n        };\n      };\n    }\n  };\n}]);\n\nuis.directive('uiSelectMatch', ['uiSelectConfig', function(uiSelectConfig) {\n  return {\n    restrict: 'EA',\n    require: '^uiSelect',\n    replace: true,\n    transclude: true,\n    templateUrl: function(tElement) {\n      // Needed so the uiSelect can detect the transcluded content\n      tElement.addClass('ui-select-match');\n\n      var parent = tElement.parent();\n      // Gets theme attribute from parent (ui-select)\n      var theme = getAttribute(parent, 'theme') || uiSelectConfig.theme;\n      var multi = angular.isDefined(getAttribute(parent, 'multiple'));\n\n      return theme + (multi ? '/match-multiple.tpl.html' : '/match.tpl.html');\n    },\n    link: function(scope, element, attrs, $select) {\n      $select.lockChoiceExpression = attrs.uiLockChoice;\n      attrs.$observe('placeholder', function(placeholder) {\n        $select.placeholder = placeholder !== undefined ? placeholder : uiSelectConfig.placeholder;\n      });\n\n      function setAllowClear(allow) {\n        $select.allowClear = (angular.isDefined(allow)) ? (allow === '') ? true : (allow.toLowerCase() === 'true') : false;\n      }\n\n      attrs.$observe('allowClear', setAllowClear);\n      setAllowClear(attrs.allowClear);\n\n      if($select.multiple){\n        $select.sizeSearchInput();\n      }\n\n    }\n  };\n\n  function getAttribute(elem, attribute) {\n    if (elem[0].hasAttribute(attribute))\n      return elem.attr(attribute);\n\n    if (elem[0].hasAttribute('data-' + attribute))\n      return elem.attr('data-' + attribute);\n\n    if (elem[0].hasAttribute('x-' + attribute))\n      return elem.attr('x-' + attribute);\n  }\n}]);\n\nuis.directive('uiSelectMultiple', ['uiSelectMinErr','$timeout', function(uiSelectMinErr, $timeout) {\n  return {\n    restrict: 'EA',\n    require: ['^uiSelect', '^ngModel'],\n\n    controller: ['$scope','$timeout', function($scope, $timeout){\n\n      var ctrl = this,\n          $select = $scope.$select,\n          ngModel;\n\n      if (angular.isUndefined($select.selected))\n        $select.selected = [];\n\n      //Wait for link fn to inject it\n      $scope.$evalAsync(function(){ ngModel = $scope.ngModel; });\n\n      ctrl.activeMatchIndex = -1;\n\n      ctrl.updateModel = function(){\n        ngModel.$setViewValue(Date.now()); //Set timestamp as a unique string to force changes\n        ctrl.refreshComponent();\n      };\n\n      ctrl.refreshComponent = function(){\n        //Remove already selected items\n        //e.g. When user clicks on a selection, the selected array changes and\n        //the dropdown should remove that item\n        if($select.refreshItems){\n          $select.refreshItems();\n        }\n        if($select.sizeSearchInput){\n          $select.sizeSearchInput();\n        }\n      };\n\n      // Remove item from multiple select\n      ctrl.removeChoice = function(index){\n\n        // if the choice is locked, don't remove it\n        if($select.isLocked(null, index)) return false;\n\n        var removedChoice = $select.selected[index];\n\n        var locals = {};\n        locals[$select.parserResult.itemName] = removedChoice;\n\n        $select.selected.splice(index, 1);\n        ctrl.activeMatchIndex = -1;\n        $select.sizeSearchInput();\n\n        // Give some time for scope propagation.\n        $timeout(function(){\n          $select.onRemoveCallback($scope, {\n            $item: removedChoice,\n            $model: $select.parserResult.modelMapper($scope, locals)\n          });\n        });\n\n        ctrl.updateModel();\n\n        return true;\n      };\n\n      ctrl.getPlaceholder = function(){\n        //Refactor single?\n        if($select.selected && $select.selected.length) return;\n        return $select.placeholder;\n      };\n\n\n    }],\n    controllerAs: '$selectMultiple',\n\n    link: function(scope, element, attrs, ctrls) {\n\n      var $select = ctrls[0];\n      var ngModel = scope.ngModel = ctrls[1];\n      var $selectMultiple = scope.$selectMultiple;\n\n      //$select.selected = raw selected objects (ignoring any property binding)\n\n      $select.multiple = true;\n\n      //Input that will handle focus\n      $select.focusInput = $select.searchInput;\n\n      //Properly check for empty if set to multiple\n      ngModel.$isEmpty = function(value) {\n        return !value || value.length === 0;\n      };\n\n      //From view --> model\n      ngModel.$parsers.unshift(function () {\n        var locals = {},\n            result,\n            resultMultiple = [];\n        for (var j = $select.selected.length - 1; j >= 0; j--) {\n          locals = {};\n          locals[$select.parserResult.itemName] = $select.selected[j];\n          result = $select.parserResult.modelMapper(scope, locals);\n          resultMultiple.unshift(result);\n        }\n        return resultMultiple;\n      });\n\n      // From model --> view\n      ngModel.$formatters.unshift(function (inputValue) {\n        var data = $select.parserResult && $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search\n            locals = {},\n            result;\n        if (!data) return inputValue;\n        var resultMultiple = [];\n        var checkFnMultiple = function(list, value){\n          if (!list || !list.length) return;\n          for (var p = list.length - 1; p >= 0; p--) {\n            locals[$select.parserResult.itemName] = list[p];\n            result = $select.parserResult.modelMapper(scope, locals);\n            if($select.parserResult.trackByExp){\n                var propsItemNameMatches = /(\\w*)\\./.exec($select.parserResult.trackByExp);\n                var matches = /\\.([^\\s]+)/.exec($select.parserResult.trackByExp);\n                if(propsItemNameMatches && propsItemNameMatches.length > 0 && propsItemNameMatches[1] == $select.parserResult.itemName){\n                  if(matches && matches.length>0 && result[matches[1]] == value[matches[1]]){\n                      resultMultiple.unshift(list[p]);\n                      return true;\n                  }\n                }\n            }\n            if (angular.equals(result,value)){\n              resultMultiple.unshift(list[p]);\n              return true;\n            }\n          }\n          return false;\n        };\n        if (!inputValue) return resultMultiple; //If ngModel was undefined\n        for (var k = inputValue.length - 1; k >= 0; k--) {\n          //Check model array of currently selected items\n          if (!checkFnMultiple($select.selected, inputValue[k])){\n            //Check model array of all items available\n            if (!checkFnMultiple(data, inputValue[k])){\n              //If not found on previous lists, just add it directly to resultMultiple\n              resultMultiple.unshift(inputValue[k]);\n            }\n          }\n        }\n        return resultMultiple;\n      });\n\n      //Watch for external model changes\n      scope.$watchCollection(function(){ return ngModel.$modelValue; }, function(newValue, oldValue) {\n        if (oldValue != newValue){\n          //update the view value with fresh data from items, if there is a valid model value\n          if(angular.isDefined(ngModel.$modelValue)) {\n            ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters\n          }\n          $selectMultiple.refreshComponent();\n        }\n      });\n\n      ngModel.$render = function() {\n        // Make sure that model value is array\n        if(!angular.isArray(ngModel.$viewValue)){\n          // Have tolerance for null or undefined values\n          if(angular.isUndefined(ngModel.$viewValue) || ngModel.$viewValue === null){\n            ngModel.$viewValue = [];\n          } else {\n            throw uiSelectMinErr('multiarr', \"Expected model value to be array but got '{0}'\", ngModel.$viewValue);\n          }\n        }\n        $select.selected = ngModel.$viewValue;\n        $selectMultiple.refreshComponent();\n        scope.$evalAsync(); //To force $digest\n      };\n\n      scope.$on('uis:select', function (event, item) {\n        if($select.selected.length >= $select.limit) {\n          return;\n        }\n        $select.selected.push(item);\n        $selectMultiple.updateModel();\n      });\n\n      scope.$on('uis:activate', function () {\n        $selectMultiple.activeMatchIndex = -1;\n      });\n\n      scope.$watch('$select.disabled', function(newValue, oldValue) {\n        // As the search input field may now become visible, it may be necessary to recompute its size\n        if (oldValue && !newValue) $select.sizeSearchInput();\n      });\n\n      $select.searchInput.on('keydown', function(e) {\n        var key = e.which;\n        scope.$apply(function() {\n          var processed = false;\n          // var tagged = false; //Checkme\n          if(KEY.isHorizontalMovement(key)){\n            processed = _handleMatchSelection(key);\n          }\n          if (processed  && key != KEY.TAB) {\n            //TODO Check si el tab selecciona aun correctamente\n            //Crear test\n            e.preventDefault();\n            e.stopPropagation();\n          }\n        });\n      });\n      function _getCaretPosition(el) {\n        if(angular.isNumber(el.selectionStart)) return el.selectionStart;\n        // selectionStart is not supported in IE8 and we don't want hacky workarounds so we compromise\n        else return el.value.length;\n      }\n      // Handles selected options in \"multiple\" mode\n      function _handleMatchSelection(key){\n        var caretPosition = _getCaretPosition($select.searchInput[0]),\n            length = $select.selected.length,\n            // none  = -1,\n            first = 0,\n            last  = length-1,\n            curr  = $selectMultiple.activeMatchIndex,\n            next  = $selectMultiple.activeMatchIndex+1,\n            prev  = $selectMultiple.activeMatchIndex-1,\n            newIndex = curr;\n\n        if(caretPosition > 0 || ($select.search.length && key == KEY.RIGHT)) return false;\n\n        $select.close();\n\n        function getNewActiveMatchIndex(){\n          switch(key){\n            case KEY.LEFT:\n              // Select previous/first item\n              if(~$selectMultiple.activeMatchIndex) return prev;\n              // Select last item\n              else return last;\n              break;\n            case KEY.RIGHT:\n              // Open drop-down\n              if(!~$selectMultiple.activeMatchIndex || curr === last){\n                $select.activate();\n                return false;\n              }\n              // Select next/last item\n              else return next;\n              break;\n            case KEY.BACKSPACE:\n              // Remove selected item and select previous/first\n              if(~$selectMultiple.activeMatchIndex){\n                if($selectMultiple.removeChoice(curr)) {\n                  return prev;\n                } else {\n                  return curr;\n                }\n\n              } else {\n                // If nothing yet selected, select last item\n                return last;\n              }\n              break;\n            case KEY.DELETE:\n              // Remove selected item and select next item\n              if(~$selectMultiple.activeMatchIndex){\n                $selectMultiple.removeChoice($selectMultiple.activeMatchIndex);\n                return curr;\n              }\n              else return false;\n          }\n        }\n\n        newIndex = getNewActiveMatchIndex();\n\n        if(!$select.selected.length || newIndex === false) $selectMultiple.activeMatchIndex = -1;\n        else $selectMultiple.activeMatchIndex = Math.min(last,Math.max(first,newIndex));\n\n        return true;\n      }\n\n      $select.searchInput.on('keyup', function(e) {\n\n        if ( ! KEY.isVerticalMovement(e.which) ) {\n          scope.$evalAsync( function () {\n            $select.activeIndex = $select.taggingLabel === false ? -1 : 0;\n          });\n        }\n        // Push a \"create new\" item into array if there is a search string\n        if ( $select.tagging.isActivated && $select.search.length > 0 ) {\n\n          // return early with these keys\n          if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || KEY.isVerticalMovement(e.which) ) {\n            return;\n          }\n          // always reset the activeIndex to the first item when tagging\n          $select.activeIndex = $select.taggingLabel === false ? -1 : 0;\n          // taggingLabel === false bypasses all of this\n          if ($select.taggingLabel === false) return;\n\n          var items = angular.copy( $select.items );\n          var stashArr = angular.copy( $select.items );\n          var newItem;\n          var item;\n          var hasTag = false;\n          var dupeIndex = -1;\n          var tagItems;\n          var tagItem;\n\n          // case for object tagging via transform `$select.tagging.fct` function\n          if ( $select.tagging.fct !== undefined) {\n            tagItems = $select.$filter('filter')(items,{'isTag': true});\n            if ( tagItems.length > 0 ) {\n              tagItem = tagItems[0];\n            }\n            // remove the first element, if it has the `isTag` prop we generate a new one with each keyup, shaving the previous\n            if ( items.length > 0 && tagItem ) {\n              hasTag = true;\n              items = items.slice(1,items.length);\n              stashArr = stashArr.slice(1,stashArr.length);\n            }\n            newItem = $select.tagging.fct($select.search);\n            // verify the new tag doesn't match the value of a possible selection choice or an already selected item.\n            if (\n              stashArr.some(function (origItem) {\n                 return angular.equals(origItem, newItem);\n              }) ||\n              $select.selected.some(function (origItem) {\n                return angular.equals(origItem, newItem);\n              })\n            ) {\n              scope.$evalAsync(function () {\n                $select.activeIndex = 0;\n                $select.items = items;\n              });\n              return;\n            }\n            if (newItem) newItem.isTag = true;\n          // handle newItem string and stripping dupes in tagging string context\n          } else {\n            // find any tagging items already in the $select.items array and store them\n            tagItems = $select.$filter('filter')(items,function (item) {\n              return item.match($select.taggingLabel);\n            });\n            if ( tagItems.length > 0 ) {\n              tagItem = tagItems[0];\n            }\n            item = items[0];\n            // remove existing tag item if found (should only ever be one tag item)\n            if ( item !== undefined && items.length > 0 && tagItem ) {\n              hasTag = true;\n              items = items.slice(1,items.length);\n              stashArr = stashArr.slice(1,stashArr.length);\n            }\n            newItem = $select.search+' '+$select.taggingLabel;\n            if ( _findApproxDupe($select.selected, $select.search) > -1 ) {\n              return;\n            }\n            // verify the the tag doesn't match the value of an existing item from\n            // the searched data set or the items already selected\n            if ( _findCaseInsensitiveDupe(stashArr.concat($select.selected)) ) {\n              // if there is a tag from prev iteration, strip it / queue the change\n              // and return early\n              if ( hasTag ) {\n                items = stashArr;\n                scope.$evalAsync( function () {\n                  $select.activeIndex = 0;\n                  $select.items = items;\n                });\n              }\n              return;\n            }\n            if ( _findCaseInsensitiveDupe(stashArr) ) {\n              // if there is a tag from prev iteration, strip it\n              if ( hasTag ) {\n                $select.items = stashArr.slice(1,stashArr.length);\n              }\n              return;\n            }\n          }\n          if ( hasTag ) dupeIndex = _findApproxDupe($select.selected, newItem);\n          // dupe found, shave the first item\n          if ( dupeIndex > -1 ) {\n            items = items.slice(dupeIndex+1,items.length-1);\n          } else {\n            items = [];\n            if (newItem) items.push(newItem);\n            items = items.concat(stashArr);\n          }\n          scope.$evalAsync( function () {\n            $select.activeIndex = 0;\n            $select.items = items;\n\n            if ($select.isGrouped) {\n              // update item references in groups, so that indexOf will work after angular.copy\n              var itemsWithoutTag = newItem ? items.slice(1) : items;\n              $select.setItemsFn(itemsWithoutTag);\n              if (newItem) {\n                // add tag item as a new group\n                $select.items.unshift(newItem);\n                $select.groups.unshift({name: '', items: [newItem], tagging: true});\n              }\n            }\n          });\n        }\n      });\n      function _findCaseInsensitiveDupe(arr) {\n        if ( arr === undefined || $select.search === undefined ) {\n          return false;\n        }\n        var hasDupe = arr.filter( function (origItem) {\n          if ( $select.search.toUpperCase() === undefined || origItem === undefined ) {\n            return false;\n          }\n          return origItem.toUpperCase() === $select.search.toUpperCase();\n        }).length > 0;\n\n        return hasDupe;\n      }\n      function _findApproxDupe(haystack, needle) {\n        var dupeIndex = -1;\n        if(angular.isArray(haystack)) {\n          var tempArr = angular.copy(haystack);\n          for (var i = 0; i <tempArr.length; i++) {\n            // handle the simple string version of tagging\n            if ( $select.tagging.fct === undefined ) {\n              // search the array for the match\n              if ( tempArr[i]+' '+$select.taggingLabel === needle ) {\n              dupeIndex = i;\n              }\n            // handle the object tagging implementation\n            } else {\n              var mockObj = tempArr[i];\n              if (angular.isObject(mockObj)) {\n                mockObj.isTag = true;\n              }\n              if ( angular.equals(mockObj, needle) ) {\n                dupeIndex = i;\n              }\n            }\n          }\n        }\n        return dupeIndex;\n      }\n\n      $select.searchInput.on('blur', function() {\n        $timeout(function() {\n          $selectMultiple.activeMatchIndex = -1;\n        });\n      });\n\n    }\n  };\n}]);\n\nuis.directive('uiSelectNoChoice',\n    ['uiSelectConfig', function (uiSelectConfig) {\n        return {\n            restrict: 'EA',\n            require: '^uiSelect',\n            replace: true,\n            transclude: true,\n            templateUrl: function (tElement) {\n                // Needed so the uiSelect can detect the transcluded content\n                tElement.addClass('ui-select-no-choice');\n\n                // Gets theme attribute from parent (ui-select)\n                var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;\n                return theme + '/no-choice.tpl.html';\n            }\n        };\n    }]);\n\nuis.directive('uiSelectSingle', ['$timeout','$compile', function($timeout, $compile) {\n  return {\n    restrict: 'EA',\n    require: ['^uiSelect', '^ngModel'],\n    link: function(scope, element, attrs, ctrls) {\n\n      var $select = ctrls[0];\n      var ngModel = ctrls[1];\n\n      //From view --> model\n      ngModel.$parsers.unshift(function (inputValue) {\n        var locals = {},\n            result;\n        locals[$select.parserResult.itemName] = inputValue;\n        result = $select.parserResult.modelMapper(scope, locals);\n        return result;\n      });\n\n      //From model --> view\n      ngModel.$formatters.unshift(function (inputValue) {\n        var data = $select.parserResult && $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search\n            locals = {},\n            result;\n        if (data){\n          var checkFnSingle = function(d){\n            locals[$select.parserResult.itemName] = d;\n            result = $select.parserResult.modelMapper(scope, locals);\n            return result === inputValue;\n          };\n          //If possible pass same object stored in $select.selected\n          if ($select.selected && checkFnSingle($select.selected)) {\n            return $select.selected;\n          }\n          for (var i = data.length - 1; i >= 0; i--) {\n            if (checkFnSingle(data[i])) return data[i];\n          }\n        }\n        return inputValue;\n      });\n\n      //Update viewValue if model change\n      scope.$watch('$select.selected', function(newValue) {\n        if (ngModel.$viewValue !== newValue) {\n          ngModel.$setViewValue(newValue);\n        }\n      });\n\n      ngModel.$render = function() {\n        $select.selected = ngModel.$viewValue;\n      };\n\n      scope.$on('uis:select', function (event, item) {\n        $select.selected = item;\n      });\n\n      scope.$on('uis:close', function (event, skipFocusser) {\n        $timeout(function(){\n          $select.focusser.prop('disabled', false);\n          if (!skipFocusser) $select.focusser[0].focus();\n        },0,false);\n      });\n\n      scope.$on('uis:activate', function () {\n        focusser.prop('disabled', true); //Will reactivate it on .close()\n      });\n\n      //Idea from: https://github.com/ivaynberg/select2/blob/79b5bf6db918d7560bdd959109b7bcfb47edaf43/select2.js#L1954\n      var focusser = angular.element(\"<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' id='{{ $select.focusserId }}' aria-label='{{ $select.focusserTitle }}' aria-haspopup='true' role='button' />\");\n      $compile(focusser)(scope);\n      $select.focusser = focusser;\n\n      //Input that will handle focus\n      $select.focusInput = focusser;\n\n      element.parent().append(focusser);\n      focusser.bind(\"focus\", function(){\n        scope.$evalAsync(function(){\n          $select.focus = true;\n        });\n      });\n      focusser.bind(\"blur\", function(){\n        scope.$evalAsync(function(){\n          $select.focus = false;\n        });\n      });\n      focusser.bind(\"keydown\", function(e){\n\n        if (e.which === KEY.BACKSPACE) {\n          e.preventDefault();\n          e.stopPropagation();\n          $select.select(undefined);\n          scope.$apply();\n          return;\n        }\n\n        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {\n          return;\n        }\n\n        if (e.which == KEY.DOWN  || e.which == KEY.UP || e.which == KEY.ENTER || e.which == KEY.SPACE){\n          e.preventDefault();\n          e.stopPropagation();\n          $select.activate();\n        }\n\n        scope.$digest();\n      });\n\n      focusser.bind(\"keyup input\", function(e){\n\n        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || e.which == KEY.ENTER || e.which === KEY.BACKSPACE) {\n          return;\n        }\n\n        $select.activate(focusser.val()); //User pressed some regular key, so we pass it to the search input\n        focusser.val('');\n        scope.$digest();\n\n      });\n\n\n    }\n  };\n}]);\n\n// Make multiple matches sortable\nuis.directive('uiSelectSort', ['$timeout', 'uiSelectConfig', 'uiSelectMinErr', function($timeout, uiSelectConfig, uiSelectMinErr) {\n  return {\n    require: ['^^uiSelect', '^ngModel'],\n    link: function(scope, element, attrs, ctrls) {\n      if (scope[attrs.uiSelectSort] === null) {\n        throw uiSelectMinErr('sort', 'Expected a list to sort');\n      }\n\n      var $select = ctrls[0];\n      var $ngModel = ctrls[1];\n\n      var options = angular.extend({\n          axis: 'horizontal'\n        },\n        scope.$eval(attrs.uiSelectSortOptions));\n\n      var axis = options.axis;\n      var draggingClassName = 'dragging';\n      var droppingClassName = 'dropping';\n      var droppingBeforeClassName = 'dropping-before';\n      var droppingAfterClassName = 'dropping-after';\n\n      scope.$watch(function(){\n        return $select.sortable;\n      }, function(newValue){\n        if (newValue) {\n          element.attr('draggable', true);\n        } else {\n          element.removeAttr('draggable');\n        }\n      });\n\n      element.on('dragstart', function(event) {\n        element.addClass(draggingClassName);\n\n        (event.dataTransfer || event.originalEvent.dataTransfer).setData('text', scope.$index.toString());\n      });\n\n      element.on('dragend', function() {\n        removeClass(draggingClassName);\n      });\n\n      var move = function(from, to) {\n        /*jshint validthis: true */\n        this.splice(to, 0, this.splice(from, 1)[0]);\n      };\n\n      var removeClass = function(className) {\n        angular.forEach($select.$element.querySelectorAll('.' + className), function(el){\n          angular.element(el).removeClass(className);\n        });\n      };\n\n      var dragOverHandler = function(event) {\n        event.preventDefault();\n\n        var offset = axis === 'vertical' ? event.offsetY || event.layerY || (event.originalEvent ? event.originalEvent.offsetY : 0) : event.offsetX || event.layerX || (event.originalEvent ? event.originalEvent.offsetX : 0);\n\n        if (offset < (this[axis === 'vertical' ? 'offsetHeight' : 'offsetWidth'] / 2)) {\n          removeClass(droppingAfterClassName);\n          element.addClass(droppingBeforeClassName);\n\n        } else {\n          removeClass(droppingBeforeClassName);\n          element.addClass(droppingAfterClassName);\n        }\n      };\n\n      var dropTimeout;\n\n      var dropHandler = function(event) {\n        event.preventDefault();\n\n        var droppedItemIndex = parseInt((event.dataTransfer || event.originalEvent.dataTransfer).getData('text'), 10);\n\n        // prevent event firing multiple times in firefox\n        $timeout.cancel(dropTimeout);\n        dropTimeout = $timeout(function() {\n          _dropHandler(droppedItemIndex);\n        }, 20);\n      };\n\n      var _dropHandler = function(droppedItemIndex) {\n        var theList = scope.$eval(attrs.uiSelectSort);\n        var itemToMove = theList[droppedItemIndex];\n        var newIndex = null;\n\n        if (element.hasClass(droppingBeforeClassName)) {\n          if (droppedItemIndex < scope.$index) {\n            newIndex = scope.$index - 1;\n          } else {\n            newIndex = scope.$index;\n          }\n        } else {\n          if (droppedItemIndex < scope.$index) {\n            newIndex = scope.$index;\n          } else {\n            newIndex = scope.$index + 1;\n          }\n        }\n\n        move.apply(theList, [droppedItemIndex, newIndex]);\n\n        $ngModel.$setViewValue(Date.now());\n\n        scope.$apply(function() {\n          scope.$emit('uiSelectSort:change', {\n            array: theList,\n            item: itemToMove,\n            from: droppedItemIndex,\n            to: newIndex\n          });\n        });\n\n        removeClass(droppingClassName);\n        removeClass(droppingBeforeClassName);\n        removeClass(droppingAfterClassName);\n\n        element.off('drop', dropHandler);\n      };\n\n      element.on('dragenter', function() {\n        if (element.hasClass(draggingClassName)) {\n          return;\n        }\n\n        element.addClass(droppingClassName);\n\n        element.on('dragover', dragOverHandler);\n        element.on('drop', dropHandler);\n      });\n\n      element.on('dragleave', function(event) {\n        if (event.target != element) {\n          return;\n        }\n\n        removeClass(droppingClassName);\n        removeClass(droppingBeforeClassName);\n        removeClass(droppingAfterClassName);\n\n        element.off('dragover', dragOverHandler);\n        element.off('drop', dropHandler);\n      });\n    }\n  };\n}]);\n\n/**\n * Debounces functions\n *\n * Taken from UI Bootstrap $$debounce source code\n * See https://github.com/angular-ui/bootstrap/blob/master/src/debounce/debounce.js\n *\n */\nuis.factory('$$uisDebounce', ['$timeout', function($timeout) {\n  return function(callback, debounceTime) {\n    var timeoutPromise;\n\n    return function() {\n      var self = this;\n      var args = Array.prototype.slice.call(arguments);\n      if (timeoutPromise) {\n        $timeout.cancel(timeoutPromise);\n      }\n\n      timeoutPromise = $timeout(function() {\n        callback.apply(self, args);\n      }, debounceTime);\n    };\n  };\n}]);\n\nuis.directive('uisOpenClose', ['$parse', '$timeout', function ($parse, $timeout) {\n  return {\n    restrict: 'A',\n    require: 'uiSelect',\n    link: function (scope, element, attrs, $select) {\n      $select.onOpenCloseCallback = $parse(attrs.uisOpenClose);\n\n      scope.$watch('$select.open', function (isOpen, previousState) {\n        if (isOpen !== previousState) {\n          $timeout(function () {\n            $select.onOpenCloseCallback(scope, {\n              isOpen: isOpen\n            });\n          });\n        }\n      });\n    }\n  };\n}]);\n\n/**\n * Parses \"repeat\" attribute.\n *\n * Taken from AngularJS ngRepeat source code\n * See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L211\n *\n * Original discussion about parsing \"repeat\" attribute instead of fully relying on ng-repeat:\n * https://github.com/angular-ui/ui-select/commit/5dd63ad#commitcomment-5504697\n */\n\nuis.service('uisRepeatParser', ['uiSelectMinErr','$parse', function(uiSelectMinErr, $parse) {\n  var self = this;\n\n  /**\n   * Example:\n   * expression = \"address in addresses | filter: {street: $select.search} track by $index\"\n   * itemName = \"address\",\n   * source = \"addresses | filter: {street: $select.search}\",\n   * trackByExp = \"$index\",\n   */\n  self.parse = function(expression) {\n\n\n    var match;\n    //var isObjectCollection = /\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)/.test(expression);\n    // If an array is used as collection\n\n    // if (isObjectCollection){\n    // 000000000000000000000000000000111111111000000000000000222222222222220033333333333333333333330000444444444444444444000000000000000055555555555000000000000000000000066666666600000000\n    match = expression.match(/^\\s*(?:([\\s\\S]+?)\\s+as\\s+)?(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(\\s*[\\s\\S]+?)?(?:\\s+track\\s+by\\s+([\\s\\S]+?))?\\s*$/);\n\n    // 1 Alias\n    // 2 Item\n    // 3 Key on (key,value)\n    // 4 Value on (key,value)\n    // 5 Source expression (including filters)\n    // 6 Track by\n\n    if (!match) {\n      throw uiSelectMinErr('iexp', \"Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.\",\n              expression);\n    }\n\n    var source = match[5],\n        filters = '';\n\n    // When using (key,value) ui-select requires filters to be extracted, since the object\n    // is converted to an array for $select.items\n    // (in which case the filters need to be reapplied)\n    if (match[3]) {\n      // Remove any enclosing parenthesis\n      source = match[5].replace(/(^\\()|(\\)$)/g, '');\n      // match all after | but not after ||\n      var filterMatch = match[5].match(/^\\s*(?:[\\s\\S]+?)(?:[^\\|]|\\|\\|)+([\\s\\S]*)\\s*$/);\n      if(filterMatch && filterMatch[1].trim()) {\n        filters = filterMatch[1];\n        source = source.replace(filters, '');\n      }\n    }\n\n    return {\n      itemName: match[4] || match[2], // (lhs) Left-hand side,\n      keyName: match[3], //for (key, value) syntax\n      source: $parse(source),\n      filters: filters,\n      trackByExp: match[6],\n      modelMapper: $parse(match[1] || match[4] || match[2]),\n      repeatExpression: function (grouped) {\n        var expression = this.itemName + ' in ' + (grouped ? '$group.items' : '$select.items');\n        if (this.trackByExp) {\n          expression += ' track by ' + this.trackByExp;\n        }\n        return expression;\n      }\n    };\n\n  };\n\n  self.getGroupNgRepeatExpression = function() {\n    return '$group in $select.groups track by $group.name';\n  };\n\n}]);\n\n}());\nangular.module(\"ui.select\").run([\"$templateCache\", function($templateCache) {$templateCache.put(\"bootstrap/choices.tpl.html\",\"<ul class=\\\"ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu\\\" role=\\\"listbox\\\" ng-display=\\\"$select.open && $select.items.length > 0\\\"><li class=\\\"ui-select-choices-group\\\" id=\\\"ui-select-choices-{{ $select.generatedId }}\\\"><div class=\\\"divider\\\" ng-display=\\\"$select.isGrouped && $index > 0\\\"></div><div ng-display=\\\"$select.isGrouped\\\" class=\\\"ui-select-choices-group-label dropdown-header\\\" ng-bind=\\\"$group.name\\\"></div><div ng-attr-id=\\\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\\\" class=\\\"ui-select-choices-row\\\" ng-class=\\\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\\\" role=\\\"option\\\"><span class=\\\"ui-select-choices-row-inner\\\"></span></div></li></ul>\");\n$templateCache.put(\"bootstrap/match-multiple.tpl.html\",\"<span class=\\\"ui-select-match\\\"><span ng-repeat=\\\"$item in $select.selected track by $index\\\"><span class=\\\"ui-select-match-item btn btn-default btn-xs\\\" tabindex=\\\"-1\\\" type=\\\"button\\\" ng-disabled=\\\"$select.disabled\\\" ng-click=\\\"$selectMultiple.activeMatchIndex = $index;\\\" ng-class=\\\"{\\'btn-primary\\':$selectMultiple.activeMatchIndex === $index, \\'select-locked\\':$select.isLocked(this, $index)}\\\" ui-select-sort=\\\"$select.selected\\\"><span class=\\\"close ui-select-match-close\\\" ng-hide=\\\"$select.disabled\\\" ng-click=\\\"$selectMultiple.removeChoice($index)\\\">&nbsp;&times;</span> <span uis-transclude-append=\\\"\\\"></span></span></span></span>\");\n$templateCache.put(\"bootstrap/match.tpl.html\",\"<div class=\\\"ui-select-match\\\" ng-hide=\\\"$select.open && $select.searchEnabled\\\" ng-disabled=\\\"$select.disabled\\\" ng-class=\\\"{\\'btn-default-focus\\':$select.focus}\\\"><span tabindex=\\\"-1\\\" class=\\\"btn btn-default form-control ui-select-toggle\\\" aria-label=\\\"{{ $select.baseTitle }} activate\\\" ng-disabled=\\\"$select.disabled\\\" ng-click=\\\"$select.activate()\\\" style=\\\"outline: 0;\\\"><span ng-display=\\\"$select.isEmpty()\\\" class=\\\"ui-select-placeholder text-muted\\\">{{$select.placeholder}}</span> <span ng-hide=\\\"$select.isEmpty()\\\" class=\\\"ui-select-match-text pull-left\\\" ng-class=\\\"{\\'ui-select-allow-clear\\': $select.allowClear && !$select.isEmpty()}\\\" ng-transclude=\\\"\\\"></span> <i class=\\\"caret pull-right\\\" ng-click=\\\"$select.toggle($event)\\\"></i> <a ng-display=\\\"$select.allowClear && !$select.isEmpty() && ($select.disabled !== true)\\\" aria-label=\\\"{{ $select.baseTitle }} clear\\\" style=\\\"margin-right: 10px\\\" ng-click=\\\"$select.clear($event)\\\" class=\\\"btn btn-xs btn-link pull-right\\\"><i class=\\\"glyphicon glyphicon-remove\\\" aria-hidden=\\\"true\\\"></i></a></span></div>\");\n$templateCache.put(\"bootstrap/no-choice.tpl.html\",\"<ul class=\\\"ui-select-no-choice dropdown-menu\\\" ng-show=\\\"$select.items.length == 0\\\"><li ng-transclude=\\\"\\\"></li></ul>\");\n$templateCache.put(\"bootstrap/select-multiple.tpl.html\",\"<div class=\\\"ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control\\\" ng-class=\\\"{open: $select.open}\\\"><div><div class=\\\"ui-select-match\\\"></div><input type=\\\"search\\\" autocomplete=\\\"off\\\" autocorrect=\\\"off\\\" autocapitalize=\\\"off\\\" spellcheck=\\\"false\\\" class=\\\"ui-select-search input-xs\\\" placeholder=\\\"{{$selectMultiple.getPlaceholder()}}\\\" ng-disabled=\\\"$select.disabled\\\" ng-click=\\\"$select.activate()\\\" ng-model=\\\"$select.search\\\" role=\\\"combobox\\\" aria-label=\\\"{{ $select.baseTitle }}\\\" ondrop=\\\"return false;\\\"></div><div class=\\\"ui-select-choices\\\"></div><div class=\\\"ui-select-no-choice\\\"></div></div>\");\n$templateCache.put(\"bootstrap/select.tpl.html\",\"<div class=\\\"ui-select-container ui-select-bootstrap dropdown\\\" ng-class=\\\"{open: $select.open}\\\"><div class=\\\"ui-select-match\\\"></div><input type=\\\"search\\\" autocomplete=\\\"off\\\" tabindex=\\\"-1\\\" aria-expanded=\\\"true\\\" aria-label=\\\"{{ $select.baseTitle }}\\\" aria-owns=\\\"ui-select-choices-{{ $select.generatedId }}\\\" aria-activedescendant=\\\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\\\" class=\\\"form-control ui-select-search\\\" ng-class=\\\"{ \\'ui-select-search-hidden\\' : !$select.searchEnabled }\\\" placeholder=\\\"{{$select.placeholder}}\\\" ng-model=\\\"$select.search\\\" ng-show=\\\"$select.open\\\"><div class=\\\"ui-select-choices\\\"></div><div class=\\\"ui-select-no-choice\\\"></div></div>\");\n$templateCache.put(\"select2/choices.tpl.html\",\"<ul tabindex=\\\"-1\\\" class=\\\"ui-select-choices ui-select-choices-content select2-results\\\"><li class=\\\"ui-select-choices-group\\\" ng-class=\\\"{\\'select2-result-with-children\\': $select.choiceGrouped($group) }\\\"><div ng-show=\\\"$select.choiceGrouped($group)\\\" class=\\\"ui-select-choices-group-label select2-result-label\\\" ng-bind=\\\"$group.name\\\"></div><ul role=\\\"listbox\\\" id=\\\"ui-select-choices-{{ $select.generatedId }}\\\" ng-class=\\\"{\\'select2-result-sub\\': $select.choiceGrouped($group), \\'select2-result-single\\': !$select.choiceGrouped($group) }\\\"><li role=\\\"option\\\" ng-attr-id=\\\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\\\" class=\\\"ui-select-choices-row\\\" ng-class=\\\"{\\'select2-highlighted\\': $select.isActive(this), \\'select2-disabled\\': $select.isDisabled(this)}\\\"><div class=\\\"select2-result-label ui-select-choices-row-inner\\\"></div></li></ul></li></ul>\");\n$templateCache.put(\"select2/match-multiple.tpl.html\",\"<span class=\\\"ui-select-match\\\"><li class=\\\"ui-select-match-item select2-search-choice\\\" ng-repeat=\\\"$item in $select.selected track by $index\\\" ng-class=\\\"{\\'select2-search-choice-focus\\':$selectMultiple.activeMatchIndex === $index, \\'select2-locked\\':$select.isLocked(this, $index)}\\\" ui-select-sort=\\\"$select.selected\\\"><span uis-transclude-append=\\\"\\\"></span> <a href=\\\"javascript:;\\\" class=\\\"ui-select-match-close select2-search-choice-close\\\" ng-click=\\\"$selectMultiple.removeChoice($index)\\\" tabindex=\\\"-1\\\"></a></li></span>\");\n$templateCache.put(\"select2/match.tpl.html\",\"<a class=\\\"select2-choice ui-select-match\\\" ng-class=\\\"{\\'select2-default\\': $select.isEmpty()}\\\" ng-click=\\\"$select.toggle($event)\\\" aria-label=\\\"{{ $select.baseTitle }} select\\\"><span ng-show=\\\"$select.isEmpty()\\\" class=\\\"select2-chosen\\\">{{$select.placeholder}}</span> <span ng-hide=\\\"$select.isEmpty()\\\" class=\\\"select2-chosen\\\" ng-transclude=\\\"\\\"></span> <abbr ng-if=\\\"$select.allowClear && !$select.isEmpty()\\\" class=\\\"select2-search-choice-close\\\" ng-click=\\\"$select.clear($event)\\\"></abbr> <span class=\\\"select2-arrow ui-select-toggle\\\"><b></b></span></a>\");\n$templateCache.put(\"select2/no-choice.tpl.html\",\"<div class=\\\"ui-select-no-choice dropdown\\\" ng-show=\\\"$select.items.length == 0\\\"><div class=\\\"dropdown-content\\\"><div data-selectable=\\\"\\\" ng-transclude=\\\"\\\"></div></div></div>\");\n$templateCache.put(\"select2/select-multiple.tpl.html\",\"<div class=\\\"ui-select-container ui-select-multiple select2 select2-container select2-container-multi\\\" ng-class=\\\"{\\'select2-container-active select2-dropdown-open open\\': $select.open, \\'select2-container-disabled\\': $select.disabled}\\\"><ul class=\\\"select2-choices\\\"><span class=\\\"ui-select-match\\\"></span><li class=\\\"select2-search-field\\\"><input type=\\\"search\\\" autocomplete=\\\"off\\\" autocorrect=\\\"off\\\" autocapitalize=\\\"off\\\" spellcheck=\\\"false\\\" role=\\\"combobox\\\" aria-expanded=\\\"true\\\" aria-owns=\\\"ui-select-choices-{{ $select.generatedId }}\\\" aria-label=\\\"{{ $select.baseTitle }}\\\" aria-activedescendant=\\\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\\\" class=\\\"select2-input ui-select-search\\\" placeholder=\\\"{{$selectMultiple.getPlaceholder()}}\\\" ng-disabled=\\\"$select.disabled\\\" ng-hide=\\\"$select.disabled\\\" ng-model=\\\"$select.search\\\" ng-click=\\\"$select.activate()\\\" style=\\\"width: 34px;\\\" ondrop=\\\"return false;\\\"></li></ul><div class=\\\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\\\" ng-class=\\\"{\\'select2-display-none\\': !$select.open || $select.items.length === 0}\\\"><div class=\\\"ui-select-choices\\\"></div></div></div>\");\n$templateCache.put(\"select2/select.tpl.html\",\"<div class=\\\"ui-select-container select2 select2-container\\\" ng-class=\\\"{\\'select2-container-active select2-dropdown-open open\\': $select.open, \\'select2-container-disabled\\': $select.disabled, \\'select2-container-active\\': $select.focus, \\'select2-allowclear\\': $select.allowClear && !$select.isEmpty()}\\\"><div class=\\\"ui-select-match\\\"></div><div class=\\\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\\\" ng-class=\\\"{\\'select2-display-none\\': !$select.open}\\\"><div class=\\\"search-container\\\" ng-class=\\\"{\\'ui-select-search-hidden\\':!$select.searchEnabled, \\'select2-search\\':$select.searchEnabled}\\\"><input type=\\\"search\\\" autocomplete=\\\"off\\\" autocorrect=\\\"off\\\" autocapitalize=\\\"off\\\" spellcheck=\\\"false\\\" role=\\\"combobox\\\" aria-expanded=\\\"true\\\" aria-owns=\\\"ui-select-choices-{{ $select.generatedId }}\\\" aria-label=\\\"{{ $select.baseTitle }}\\\" aria-activedescendant=\\\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\\\" class=\\\"ui-select-search select2-input\\\" ng-model=\\\"$select.search\\\"></div><div class=\\\"ui-select-choices\\\"></div><div class=\\\"ui-select-no-choice\\\"></div></div></div>\");\n$templateCache.put(\"selectize/choices.tpl.html\",\"<div ng-display=\\\"$select.open\\\" class=\\\"ui-select-choices ui-select-dropdown selectize-dropdown single\\\"><div class=\\\"ui-select-choices-content selectize-dropdown-content\\\"><div class=\\\"ui-select-choices-group optgroup\\\" role=\\\"listbox\\\"><div ng-display=\\\"$select.isGrouped\\\" class=\\\"ui-select-choices-group-label optgroup-header\\\" ng-bind=\\\"$group.name\\\"></div><div role=\\\"option\\\" class=\\\"ui-select-choices-row\\\" ng-class=\\\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\\\"><div class=\\\"option ui-select-choices-row-inner\\\" data-selectable=\\\"\\\"></div></div></div></div></div>\");\n$templateCache.put(\"selectize/match.tpl.html\",\"<div ng-hide=\\\"$select.searchEnabled && ($select.open || $select.isEmpty())\\\" class=\\\"ui-select-match\\\"><span ng-show=\\\"!$select.searchEnabled && ($select.isEmpty() || $select.open)\\\" class=\\\"ui-select-placeholder text-muted\\\">{{$select.placeholder}}</span> <span ng-hide=\\\"$select.isEmpty() || $select.open\\\" ng-transclude=\\\"\\\"></span></div>\");\n$templateCache.put(\"selectize/no-choice.tpl.html\",\"<div class=\\\"ui-select-no-choice selectize-dropdown\\\" ng-show=\\\"$select.items.length == 0\\\"><div class=\\\"selectize-dropdown-content\\\"><div data-selectable=\\\"\\\" ng-transclude=\\\"\\\"></div></div></div>\");\n$templateCache.put(\"selectize/select.tpl.html\",\"<div class=\\\"ui-select-container selectize-control single\\\" ng-class=\\\"{\\'open\\': $select.open}\\\"><div class=\\\"selectize-input\\\" ng-class=\\\"{\\'focus\\': $select.open, \\'disabled\\': $select.disabled, \\'selectize-focus\\' : $select.focus}\\\" ng-click=\\\"$select.open && !$select.searchEnabled ? $select.toggle($event) : $select.activate()\\\"><div class=\\\"ui-select-match\\\"></div><input type=\\\"search\\\" autocomplete=\\\"off\\\" tabindex=\\\"-1\\\" class=\\\"ui-select-search ui-select-toggle\\\" ng-class=\\\"{\\'ui-select-search-hidden\\':!$select.searchEnabled}\\\" ng-click=\\\"$select.toggle($event)\\\" placeholder=\\\"{{$select.placeholder}}\\\" ng-model=\\\"$select.search\\\" ng-hide=\\\"!$select.isEmpty() && !$select.open\\\" ng-disabled=\\\"$select.disabled\\\" aria-label=\\\"{{ $select.baseTitle }}\\\"></div><div class=\\\"ui-select-choices\\\"></div><div class=\\\"ui-select-no-choice\\\"></div></div>\");}]);\n","(function() {\n  angular\n    .module('validation.rule', ['validation'])\n    .config(['$validationProvider', function($validationProvider) {\n      var expression = {\n        required: function(value) {\n          return !!value;\n        },\n        url: /((([A-Za-z]{3,9}:(?:\\/\\/)?)(?:[-;:&=\\+\\$,\\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=\\+\\$,\\w]+@)[A-Za-z0-9.-]+)((?:\\/[\\+~%\\/.\\w-_]*)?\\??(?:[-\\+=&;%@.\\w_]*)#?(?:[\\w]*))?)/,\n        email: /^([\\w-\\.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([\\w-]+\\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\\]?)$/,\n        number: /^\\d+$/,\n        minlength: function(value, scope, element, attrs, param) {\n          return value && value.length >= param;\n        },\n        maxlength: function(value, scope, element, attrs, param) {\n          return !value || value.length <= param;\n        }\n      };\n\n      var defaultMsg = {\n        required: {\n          error: 'This field is required',\n          success: ''\n        },\n        url: {\n          error: 'This is not a valid URL',\n          success: ''\n        },\n        email: {\n          error: 'This is not a valid email address',\n          success: ''\n        },\n        number: {\n          error: 'This field must be numeric',\n          success: ''\n        },\n        minlength: {\n          error: 'This field is nog long enough',\n          success: ''\n        },\n        maxlength: {\n          error: 'This field is too long',\n          success: ''\n        }\n      };\n      $validationProvider.setExpression(expression).setDefaultMsg(defaultMsg);\n    }]);\n}).call(this);\n","angular.module('validation', ['validation.provider', 'validation.directive']);\nangular.module('validation.provider', []);\nangular.module('validation.directive', ['validation.provider']);\n\n(function() {\n    angular\n        .module('validation.provider')\n        .provider('$validation', Provider);\n\n    function Provider() {\n        var $injector;\n        var $scope;\n        var $http;\n        var $q;\n        var $timeout;\n        var _this = this;\n\n        /**\n         * Setup the provider\n         * @param injector\n         */\n        var setup = function(injector) {\n            $injector = injector;\n            $scope = $injector.get('$rootScope');\n            $http = $injector.get('$http');\n            $q = $injector.get('$q');\n            $timeout = $injector.get('$timeout');\n        };\n\n        /**\n         * Define validation type RegExp\n         * @type {{}}\n         */\n        var expression = {};\n\n        /**\n         * default valid method\n         * @type {{}}\n         */\n        var validMethod = null;\n\n        /**\n         * default error, success message\n         * @type {{}}\n         */\n        var defaultMsg = {};\n\n        /**\n         * Allow user to set a custom Expression, do remember set the default message using setDefaultMsg\n         * @param obj\n         * @returns {*}\n         */\n        this.setExpression = function(obj) {\n            angular.extend(expression, obj);\n            return _this;\n        };\n\n        /**\n         * Get the Expression\n         * @param exprs\n         * @returns {*}\n         */\n        this.getExpression = function(exprs) {\n            return expression[exprs];\n        };\n\n        /**\n         * Allow user to set default message\n         * @param obj\n         * @returns {*}\n         */\n        this.setDefaultMsg = function(obj) {\n            angular.extend(defaultMsg, obj);\n            return _this;\n        };\n\n        /**\n         * Get the Default Message\n         * @param msg\n         * @returns {*}\n         */\n        this.getDefaultMsg = function(msg) {\n            return defaultMsg[msg];\n        };\n\n        /**\n         * allow user to set the global valid method\n         * @param v\n         * @returns {*}\n         */\n        this.setValidMethod = function(v) {\n            validMethod = v;\n        };\n\n        /**\n         * Get the valid method\n         * @returns {*}\n         */\n        this.getValidMethod = function() {\n            return validMethod;\n        };\n\n        /**\n         * Override the errorHTML function\n         * @param func\n         * @returns {*}\n         */\n        this.setErrorHTML = function(func) {\n            if (func.constructor !== Function) {\n                return;\n            }\n            _this.getErrorHTML = func;\n            return _this;\n        };\n\n        /**\n         * Invalid message HTML, here's the default\n         * @param message\n         * @returns {string}\n         */\n        this.getErrorHTML = function(message) {\n            return '<p class=\"validation-invalid\">' + message + '</p>';\n        };\n\n        /**\n         * Override the successHTML function\n         * @param func\n         * @returns {*}\n         */\n        this.setSuccessHTML = function(func) {\n            if (func.constructor !== Function) {\n                return;\n            }\n            _this.getSuccessHTML = func;\n            return _this;\n        };\n\n        /**\n         * Valid message HTML, here's the default\n         * @param message\n         * @returns {string}\n         */\n        this.getSuccessHTML = function(message) {\n            return '<p class=\"validation-valid\">' + message + '</p>';\n        };\n\n        /**\n         * Whether show the validation success message\n         * You can easily change this to false in your config\n         * example: $validationProvider.showSuccessMessage = false;\n         * @type {boolean}\n         */\n        this.showSuccessMessage = true;\n\n        /**\n         * Whether show the validation error message\n         * You can easily change this to false in your config\n         * example: $validationProvider.showErrorMessage = false;\n         * @type {boolean}\n         */\n        this.showErrorMessage = true;\n\n        /**\n         * Check form valid, return true\n         * checkValid(Form): Check the specific form(Form) valid from angular `$valid`\n         * @param form\n         * @returns {boolean}\n         */\n        this.checkValid = function(form) {\n            return !!(form && form.$valid);\n        };\n\n        /**\n         * Validate the form when click submit, when `validMethod = submit`\n         * @param form\n         * @returns {promise|*}\n         */\n        this.validate = function(form) {\n            var deferred = $q.defer();\n            var idx = 0;\n\n            if (form === undefined) {\n                console.error('This is not a regular Form name scope');\n                deferred.reject('This is not a regular Form name scope');\n                return deferred.promise;\n            }\n\n            if (form.validationId) { // single\n                $scope.$broadcast(form.$name + 'submit-' + form.validationId, idx++);\n            } else if (form.constructor === Array) { // multiple\n                for (var k in form) {\n                    $scope.$broadcast(form[k].$name + 'submit-' + form[k].validationId, idx++);\n                }\n            } else {\n                for (var i in form) { // whole scope\n                    if (i[0] !== '$' && form[i].hasOwnProperty('$dirty')) {\n                        $scope.$broadcast(i + 'submit-' + form[i].validationId, idx++);\n                    }\n                }\n            }\n\n            deferred.promise.success = function(fn) {\n                deferred.promise.then(function(value) {\n                    fn(value);\n                });\n                return deferred.promise;\n            };\n\n            deferred.promise.error = function(fn) {\n                deferred.promise.then(null, function(value) {\n                    fn(value);\n                });\n                return deferred.promise;\n            };\n\n            $timeout(function() {\n                if (_this.checkValid(form)) {\n                    deferred.resolve('success');\n                } else {\n                    deferred.reject('error');\n                }\n            });\n\n            return deferred.promise;\n        };\n\n        /**\n         * Do this function if validation valid\n         * @param element\n         */\n        this.validCallback = null;\n\n        /**\n         * Do this function if validation invalid\n         * @param element\n         */\n        this.invalidCallback = null;\n\n        /**\n         * Do this function when reset is performed\n         * @param element\n         */\n        this.resetCallback = null;\n\n        /**\n         * reset the specific form\n         * @param form\n         */\n        this.reset = function(form) {\n            if (form === undefined) {\n                console.error('This is not a regular Form name scope');\n                return;\n            }\n\n            if (form.validationId) {\n                $scope.$broadcast(form.$name + 'reset-' + form.validationId);\n            } else if (form.constructor === Array) {\n                for (var k in form) {\n                    $scope.$broadcast(form[k].$name + 'reset-' + form[k].validationId);\n                }\n            } else {\n                for (var i in form) {\n                    if (i[0] !== '$' && form[i].hasOwnProperty('$dirty')) {\n                        $scope.$broadcast(i + 'reset-' + form[i].validationId);\n                    }\n                }\n            }\n        };\n\n        /**\n         * Add Message Element in config phase\n         * When you need custom your messageElement\n         * NODE: this funtion & and `message-id` attribute, have similar purpose.\n         * This function will help you add your `messageElement` automatically instead of pre-defined.\n         * @param element\n         */\n        this.addMsgElement = function(element) {\n            return element.after('<span></span>');\n        };\n\n        /**\n         * Add Message Element in config phase\n         * When you need custom your messageElement\n         * NODE: this funtion & and `message-id` attribute, have similar purpose.\n         * This function will help you add your `messageElement` automatically instead of pre-defined.\n         * @param element\n         */\n        this.getMsgElement = function(element) {\n            return element.next();\n        };\n\n        /**\n         * $get\n         * @returns {{setErrorHTML: *, getErrorHTML: Function, setSuccessHTML: *, getSuccessHTML: Function, setExpression: *, getExpression: Function, setDefaultMsg: *, getDefaultMsg: Function, checkValid: Function, validate: Function, reset: Function}}\n         */\n        this.$get = ['$injector', function($injector) {\n            setup($injector);\n            return {\n                setValidMethod: this.setValidMethod,\n                getValidMethod: this.getValidMethod,\n                setErrorHTML: this.setErrorHTML,\n                getErrorHTML: this.getErrorHTML,\n                setSuccessHTML: this.setSuccessHTML,\n                getSuccessHTML: this.getSuccessHTML,\n                setExpression: this.setExpression,\n                getExpression: this.getExpression,\n                setDefaultMsg: this.setDefaultMsg,\n                getDefaultMsg: this.getDefaultMsg,\n                showSuccessMessage: this.showSuccessMessage,\n                showErrorMessage: this.showErrorMessage,\n                checkValid: this.checkValid,\n                validate: this.validate,\n                validCallback: this.validCallback,\n                invalidCallback: this.invalidCallback,\n                resetCallback: this.resetCallback,\n                reset: this.reset,\n                addMsgElement: this.addMsgElement,\n                getMsgElement: this.getMsgElement\n            };\n        }];\n    }\n}).call(this);\n\n(function() {\n    angular\n        .module('validation.directive')\n        .directive('validationReset', Reset);\n\n    function Reset($injector) {\n        var $validationProvider = $injector.get('$validation');\n        var $timeout = $injector.get('$timeout');\n        var $parse = $injector.get('$parse');\n        return {\n            link: function postLink(scope, element, attrs) {\n                var form = $parse(attrs.validationReset)(scope);\n                $timeout(function() {\n                    element.on('click', function(e) {\n                        e.preventDefault();\n                        $validationProvider.reset(form);\n                    });\n                });\n            }\n        };\n    }\n    Reset.$inject = ['$injector'];\n}).call(this);\n\n(function() {\n    angular\n        .module('validation.directive')\n        .directive('validationSubmit', Submit);\n\n    function Submit($injector) {\n        var $validationProvider = $injector.get('$validation');\n        var $timeout = $injector.get('$timeout');\n        var $parse = $injector.get('$parse');\n        return {\n            priority: 1, // execute before ng-click (0)\n            require: '?ngClick',\n            link: function postLink(scope, element, attrs) {\n                var form = $parse(attrs.validationSubmit)(scope);\n                $timeout(function() {\n                    // Disable ng-click event propagation\n                    element.off('click');\n                    element.on('click', function(e) {\n                        e.preventDefault();\n                        $validationProvider.validate(form)\n                            .success(function() {\n                                $parse(attrs.ngClick)(scope);\n                            });\n                    });\n                });\n            }\n        };\n    }\n    Submit.$inject = ['$injector'];\n}).call(this);\n\n(function() {\n    angular\n        .module('validation.directive')\n        .directive('validator', Validator);\n\n    function Validator($injector) {\n        var $validationProvider = $injector.get('$validation');\n        var $q = $injector.get('$q');\n        var $timeout = $injector.get('$timeout');\n        var $compile = $injector.get('$compile');\n        var $parse = $injector.get('$parse');\n        var groups = {};\n\n        /**\n         * Do this function if validation valid\n         * @param element\n         * @param validMessage\n         * @param validation\n         * @param callback\n         * @param ctrl\n         * @returns {}\n         */\n        var validFunc = function(element, validMessage, validation, scope, ctrl, attrs, param) {\n            var messageToShow = validMessage || $validationProvider.getDefaultMsg(validation).success;\n            var validCallback = $parse(attrs.validCallback);\n            var messageId = attrs.messageId;\n            var validationGroup = attrs.validationGroup;\n            var messageElem;\n\n            if (messageId || validationGroup) messageElem = angular.element(document.querySelector('#' + (messageId || validationGroup)));\n            else messageElem = $validationProvider.getMsgElement(element);\n\n            if (element.attr('no-validation-message')) {\n                messageElem.css('display', 'none');\n            } else if ($validationProvider.showSuccessMessage && messageToShow) {\n                messageToShow = angular.isFunction(messageToShow) ? messageToShow(element, attrs, param) : messageToShow;\n\n                messageElem.html('').append($compile($validationProvider.getSuccessHTML(messageToShow, element, attrs))(scope));\n                messageElem.css('display', '');\n            } else {\n                messageElem.css('display', 'none');\n            }\n\n            ctrl.$setValidity(ctrl.$name, true);\n            validCallback(scope, {\n                message: messageToShow\n            });\n            if ($validationProvider.validCallback) $validationProvider.validCallback(element);\n\n            return true;\n        };\n\n\n        /**\n         * Do this function if validation invalid\n         * @param element\n         * @param validMessage\n         * @param validation\n         * @param callback\n         * @param ctrl\n         * @returns {}\n         */\n        var invalidFunc = function(element, validMessage, validation, scope, ctrl, attrs, param) {\n            var messageToShow = validMessage || $validationProvider.getDefaultMsg(validation).error;\n            var invalidCallback = $parse(attrs.invalidCallback);\n            var messageId = attrs.messageId;\n            var validationGroup = attrs.validationGroup;\n            var messageElem;\n\n            if (messageId || validationGroup) messageElem = angular.element(document.querySelector('#' + (messageId || validationGroup)));\n            else messageElem = $validationProvider.getMsgElement(element);\n\n            if (element.attr('no-validation-message')) {\n                messageElem.css('display', 'none');\n            } else if ($validationProvider.showErrorMessage && messageToShow) {\n                messageToShow = angular.isFunction(messageToShow) ? messageToShow(element, attrs, param) : messageToShow;\n\n                messageElem.html('').append($compile($validationProvider.getErrorHTML(messageToShow, element, attrs))(scope));\n                messageElem.css('display', '');\n            } else {\n                messageElem.css('display', 'none');\n            }\n\n            ctrl.$setValidity(ctrl.$name, false);\n            invalidCallback(scope, {\n                message: messageToShow\n            });\n            if ($validationProvider.invalidCallback) $validationProvider.invalidCallback(element);\n\n            return false;\n        };\n\n        /**\n         * Verify whether there is one of the elements inside the group valid.\n         * If so, it returns true, otherwise, it returns false\n         *\n         * @param validationGroup\n         * @return {boolean}\n         */\n        var checkValidationGroup = function(validationGroup) {\n            var group = groups[validationGroup];\n\n            return Object.keys(group).some(function(key) {\n                return group[key];\n            });\n        };\n\n        /**\n         * Set validity to all elements inside the given group\n         *\n         * @param scope\n         * @param groupName\n         * @param validity\n         */\n        function setValidationGroup(scope, validationGroup, validity) {\n            var validationGroupElems = document.querySelectorAll('*[validation-group=' + validationGroup + ']');\n\n            // Loop through all elements inside the group\n            for (var i = 0, len = validationGroupElems.length; i < len; i++) {\n                var elem = validationGroupElems[i];\n                var formName = elem.form.name;\n                var elemName = elem.name;\n                scope[formName][elemName].$setValidity(elemName, validity);\n            }\n        }\n\n        /**\n         * collect elements for focus\n         * @type {Object}\n         ***private variable\n         */\n        var focusElements = {};\n\n        /**\n         * Get Validation Result Object\n         * @param data\n         * @returns {\n     *    result: Boolean, // is success or error\n     *    message: String  // tips\n     * }\n         */\n        function getResultObj(data) {\n            var res = {};\n            if (data && data.length > 0) {\n                res = data[0];\n                if (!angular.isObject(res)) {\n                    res = {\n                        result: res,\n                        message: ''\n                    };\n                }\n            } else {\n                res = {\n                    result: false,\n                    message: ''\n                };\n            }\n            return res;\n        }\n\n        /**\n         * Check Validation with Function or RegExp\n         * @param scope\n         * @param element\n         * @param attrs\n         * @param ctrl\n         * @param validation\n         * @param value\n         * @returns {}\n         */\n        var checkValidation = function(scope, element, attrs, ctrl, validation, value) {\n            var validators = validation.slice(0);\n            var validatorExpr = validators[0].trim();\n            var paramIndex = validatorExpr.indexOf('=');\n            var validator = paramIndex === -1 ? validatorExpr : validatorExpr.substr(0, paramIndex);\n            var validatorParam = paramIndex === -1 ? null : validatorExpr.substr(paramIndex + 1);\n            var leftValidation = validators.slice(1);\n            var successMessage = validator + 'SuccessMessage';\n            var errorMessage = validator + 'ErrorMessage';\n            var expression = $validationProvider.getExpression(validator);\n            var validationGroup = attrs.validationGroup;\n            var valid = {\n                success: function(message) {\n                    validFunc(element, message || attrs[successMessage], validator, scope, ctrl, attrs, validatorParam);\n                    if (leftValidation.length) {\n                        return checkValidation(scope, element, attrs, ctrl, leftValidation, value);\n                    } else {\n                        return true;\n                    }\n                },\n                error: function(message) {\n                    return invalidFunc(element, message || attrs[errorMessage], validator, scope, ctrl, attrs, validatorParam);\n                }\n            };\n\n            if (expression === undefined) {\n                console.error('You are using undefined validator \"%s\"', validator);\n                if (leftValidation.length) return checkValidation(scope, element, attrs, ctrl, leftValidation, value);\n                else return;\n            }\n            // Check with Function\n            if (expression.constructor === Function) {\n                return $q.all([$validationProvider.getExpression(validator)(value, scope, element, attrs, validatorParam)])\n                    .then(function(data) {\n                        var resultObj = getResultObj(data);\n                        var message = resultObj.message;\n                        if (resultObj.result) {\n                            if (validationGroup) {\n                                groups[validationGroup][ctrl.$name] = true;\n                                setValidationGroup(scope, validationGroup, true);\n                            }\n                            return valid.success(message);\n                        } else if (validationGroup) {\n                            groups[validationGroup][ctrl.$name] = false;\n\n                            // Whenever the element is invalid, we'll check whether one of the elements inside the its group valid or not.\n                            // If there is a valid element, its invalid message won't be shown, Otherwise, shows its invalid message.\n                            if (checkValidationGroup(validationGroup)) {\n                                setValidationGroup(scope, validationGroup, true);\n                            } else {\n                                setValidationGroup(scope, validationGroup, false);\n                                return valid.error(message);\n                            }\n                        } else return valid.error(message);\n                    }, function() {\n                        return valid.error();\n                    });\n            }\n\n            // Check with RegExp\n            else if (expression.constructor === RegExp) {\n                // Only apply the test if the value is neither undefined or null\n                if (value !== undefined && value !== null) {\n                    if ($validationProvider.getExpression(validator).test(value)) {\n                        if (validationGroup) {\n                            groups[validationGroup][ctrl.$name] = true;\n                            setValidationGroup(scope, validationGroup, true);\n                        }\n                        return valid.success();\n                    } else if (validationGroup) {\n                        groups[validationGroup][ctrl.$name] = false;\n\n                        // Whenever the element is invalid, we'll check whether one of the elements inside the its group valid or not.\n                        // If there is a valid element, its invalid message won't be shown, Otherwise, shows its invalid message.\n                        if (checkValidationGroup(validationGroup)) {\n                            setValidationGroup(scope, validationGroup, true);\n                        } else {\n                            setValidationGroup(scope, validationGroup, false);\n                            return valid.error();\n                        }\n                    } else return valid.error();\n                }\n            } else return valid.error();\n        };\n\n        /**\n         * generate unique guid\n         */\n        var s4 = function() {\n            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n        };\n        var guid = function() {\n            return (s4() + s4() + s4() + s4());\n        };\n\n\n        return {\n            restrict: 'A',\n            require: 'ngModel',\n            link: function(scope, element, attrs, ctrl) {\n                /**\n                 * All attributes\n                 */\n                var useViewValue = attrs.useViewValue !== 'false';\n                var validator = attrs.validator;\n                var messageId = attrs.messageId;\n                var validationGroup = attrs.validationGroup;\n                var validMethod = attrs.validMethod;\n                var ngModel = attrs.ngModel;\n\n                /**\n                 * watch\n                 * @type {watch}\n                 *\n                 * Use to collect scope.$watch method\n                 *\n                 * use watch() to destroy the $watch method\n                 */\n                var watch = function() {};\n\n                /**\n                 * validator\n                 * @type {Array}\n                 *\n                 * Convert user input String to Array\n                 */\n                var validation = validator.split(',');\n\n                /**\n                 * guid use\n                 */\n                var uid = ctrl.validationId = guid();\n\n                /**\n                 * to have a value to rollback to\n                 */\n                var originalViewValue = null;\n\n                /**\n                 * Set initial validity to undefined if no boolean value is transmitted\n                 */\n                var initialValidity = void 0;\n                if (typeof attrs.initialValidity === 'boolean') {\n                    initialValidity = attrs.initialValidity;\n                }\n\n                /**\n                 * Observe validator changes in order to allow dynamically change it\n                 */\n                attrs.$observe('validator', function(value) {\n                    validation = value.split(',');\n                });\n\n                /**\n                 * Set up groups object in order to keep track validation of elements\n                 */\n                if (validationGroup) {\n                    if (!groups[validationGroup]) groups[validationGroup] = {};\n                    groups[validationGroup][ctrl.$name] = false;\n                }\n\n                /**\n                 * Default Valid/Invalid Message\n                 */\n                if (!(messageId || validationGroup)) $validationProvider.addMsgElement(element);\n\n                /**\n                 * Set custom initial validity\n                 * Usage: <input initial-validity=\"true\" ... >\n                 */\n                ctrl.$setValidity(ctrl.$name, initialValidity);\n\n                /**\n                 * Reset the validation for specific form\n                 */\n                scope.$on(ctrl.$name + 'reset-' + uid, function() {\n                    /**\n                     * clear scope.$watch here\n                     * when reset status\n                     * clear the $watch method to prevent\n                     * $watch again while reset the form\n                     */\n                    watch();\n\n                    $timeout(function() {\n                        ctrl.$setViewValue(originalViewValue);\n                        ctrl.$setPristine();\n                        ctrl.$setValidity(ctrl.$name, undefined);\n                        ctrl.$render();\n                        if (messageId || validationGroup) angular.element(document.querySelector('#' + (messageId || validationGroup))).html('');\n                        else $validationProvider.getMsgElement(element).html('');\n\n                        if ($validationProvider.resetCallback) $validationProvider.resetCallback(element);\n                    });\n                });\n\n                /**\n                 * Check validator\n                 */\n                validMethod = (angular.isUndefined(validMethod)) ? $validationProvider.getValidMethod() : validMethod;\n\n                /**\n                 * Click submit form, check the validity when submit\n                 */\n                scope.$on(ctrl.$name + 'submit-' + uid, function(event, index) {\n                    var value = useViewValue ? ctrl.$viewValue : ctrl.$modelValue;\n                    var isValid = false;\n\n                    isValid = checkValidation(scope, element, attrs, ctrl, validation, value);\n\n                    if (validMethod === 'submit') {\n                        // clear previous scope.$watch\n                        watch();\n                        watch = scope.$watch(function() {\n                            return scope.$eval(ngModel);\n                        }, function(value, oldValue) {\n                            // don't watch when init\n                            if (value === oldValue) {\n                                return;\n                            }\n\n                            // scope.$watch will translate '' to undefined\n                            // undefined/null will pass the required submit /^.+/\n                            // cause some error in this validation\n                            if (value === undefined || value === null) {\n                                value = '';\n                            }\n\n                            isValid = checkValidation(scope, element, attrs, ctrl, validation, value);\n                        });\n                    }\n\n                    var setFocus = function(isValid) {\n                        if (isValid) {\n                            delete focusElements[index];\n                        } else {\n                            focusElements[index] = element[0];\n\n                            $timeout(function() {\n                                focusElements[Math.min.apply(null, Object.keys(focusElements))].focus();\n                            }, 0);\n                        }\n                    };\n\n                    if (isValid.constructor === Object) isValid.then(setFocus);\n                    else setFocus(isValid);\n                });\n\n                /**\n                 * Validate blur method\n                 */\n                if (validMethod === 'blur') {\n                    element.bind('blur', function() {\n                        var value = scope.$eval(ngModel);\n\n                        if (scope.$root.$$phase !== '$apply') {\n                            scope.$apply(function() {\n                                checkValidation(scope, element, attrs, ctrl, validation, value);\n                            });\n                        } else {\n                            checkValidation(scope, element, attrs, ctrl, validation, value);\n                        }\n                    });\n\n                    return;\n                }\n\n                /**\n                 * Validate submit & submit-only method\n                 */\n                if (validMethod === 'submit' || validMethod === 'submit-only') {\n                    return;\n                }\n\n                /**\n                 * Validate watch method\n                 * This is the default method\n                 */\n                scope.$watch(function() {\n                    return scope.$eval(ngModel);\n                }, function(value) {\n                    /**\n                     * dirty, pristine, viewValue control here\n                     */\n                    if (ctrl.$pristine && ctrl.$viewValue) {\n                        // has value when initial\n                        originalViewValue = ctrl.$viewValue || '';\n                        ctrl.$setViewValue(ctrl.$viewValue);\n                    } else if (ctrl.$pristine) {\n                        // Don't validate form when the input is clean(pristine)\n                        if (messageId || validationGroup) angular.element(document.querySelector('#' + (messageId || validationGroup))).html('');\n                        else $validationProvider.getMsgElement(element).html('');\n                        return;\n                    }\n                    checkValidation(scope, element, attrs, ctrl, validation, value);\n                });\n\n                $timeout(function() {\n                    /**\n                     * Don't showup the validation Message\n                     */\n                    attrs.$observe('noValidationMessage', function(value) {\n                        var el;\n                        if (messageId || validationGroup) el = angular.element(document.querySelector('#' + (messageId || validationGroup)));\n                        else el = $validationProvider.getMsgElement(element);\n                        if (value === 'true' || value === true) el.css('display', 'none');\n                        else if (value === 'false' || value === false) el.css('display', 'block');\n                    });\n                });\n            }\n        };\n    }\n    Validator.$inject = ['$injector'];\n}).call(this);","/*!\n * angular-vertilize 1.0.1\n * Christopher Collins\n * https://github.com/Sixthdim/angular-vertilize.git\n * License: MIT\n */\n(function () {\n  \"use strict\";\n\n  var module = angular.module('angular.vertilize', []);\n\n  // Vertilize Container\n  module.directive('vertilizeContainer', [\n    function(){\n      return {\n        restrict: 'EA',\n        controller: [\n          '$scope', '$window',\n          function($scope, $window){\n            // Alias this\n            var _this = this;\n\n            // Array of children heights\n            _this.childrenHeights = [];\n\n            // API: Allocate child, return index for tracking.\n            _this.allocateMe = function(){\n              _this.childrenHeights.push(0);\n              return (_this.childrenHeights.length - 1);\n            };\n\n            // API: Update a child's height\n            _this.updateMyHeight = function(index, height){\n              _this.childrenHeights[index] = height;\n            };\n\n            // API: Get tallest height\n            _this.getTallestHeight = function(){\n              var height = 0;\n              for (var i=0; i < _this.childrenHeights.length; i=i+1){\n                height = Math.max(height, _this.childrenHeights[i]);\n              }\n              return height;\n            };\n\n            // Add window resize to digest cycle\n            angular.element($window).bind('resize', function(){\n              return $scope.$apply();\n            });\n          }\n        ]\n      };\n    }\n  ]);\n\n  // Vertilize Item\n  module.directive('vertilize', [\n    function(){\n      return {\n        restrict: 'EA',\n        require: '^vertilizeContainer',\n        link: function(scope, element, attrs, parent){\n          // My index allocation\n          var myIndex = parent.allocateMe();\n\n          // Get my real height by cloning so my height is not affected.\n          var getMyRealHeight = function(){\n            var clone = element.clone()\n              .removeAttr('vertilize')\n              .css({\n                height: '',\n                width: element.outerWidth(),\n                position: 'fixed',\n                top: 0,\n                left: 0,\n                visibility: 'hidden'\n              });\n            element.after(clone);\n            var realHeight = clone.height();\n            clone['remove']();\n            return realHeight;\n          };\n\n          // Watch my height\n          scope.$watch(getMyRealHeight, function(myNewHeight){\n            if (myNewHeight){\n              parent.updateMyHeight(myIndex, myNewHeight);\n            }\n          });\n\n          // Watch for tallest height change\n          scope.$watch(parent.getTallestHeight, function(tallestHeight){\n            if (tallestHeight){\n              element.css('height', tallestHeight);\n            }\n          });\n        }\n      };\n    }\n  ]);\n\n}());\n","//! moment.js\n//! version : 2.18.1\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n\n;(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n        typeof define === 'function' && define.amd ? define(factory) :\n            global.moment = factory()\n}(this, (function () { 'use strict';\n\n    var hookCallback;\n\n    function hooks () {\n        return hookCallback.apply(null, arguments);\n    }\n\n// This is done to register the method called with moment()\n// without creating circular dependencies.\n    function setHookCallback (callback) {\n        hookCallback = callback;\n    }\n\n    function isArray(input) {\n        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n    }\n\n    function isObject(input) {\n        // IE8 will treat undefined and null as object if it wasn't for\n        // input != null\n        return input != null && Object.prototype.toString.call(input) === '[object Object]';\n    }\n\n    function isObjectEmpty(obj) {\n        var k;\n        for (k in obj) {\n            // even if its not own property I'd still call it non-empty\n            return false;\n        }\n        return true;\n    }\n\n    function isUndefined(input) {\n        return input === void 0;\n    }\n\n    function isNumber(input) {\n        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n    }\n\n    function isDate(input) {\n        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n    }\n\n    function map(arr, fn) {\n        var res = [], i;\n        for (i = 0; i < arr.length; ++i) {\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n\n    function extend(a, b) {\n        for (var i in b) {\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n        if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n        }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf = b.valueOf;\n        }\n\n        return a;\n    }\n\n    function createUTC (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty           : false,\n            unusedTokens    : [],\n            unusedInput     : [],\n            overflow        : -2,\n            charsLeftOver   : 0,\n            nullInput       : false,\n            invalidMonth    : null,\n            invalidFormat   : false,\n            userInvalidated : false,\n            iso             : false,\n            parsedDateParts : [],\n            meridiem        : null,\n            rfc2822         : false,\n            weekdayMismatch : false\n        };\n    }\n\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n\n    var some;\n    if (Array.prototype.some) {\n        some = Array.prototype.some;\n    } else {\n        some = function (fun) {\n            var t = Object(this);\n            var len = t.length >>> 0;\n\n            for (var i = 0; i < len; i++) {\n                if (i in t && fun.call(this, t[i], i, t)) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    var some$1 = some;\n\n    function isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m);\n            var parsedParts = some$1.call(flags.parsedDateParts, function (i) {\n                return i != null;\n            });\n            var isNowValid = !isNaN(m._d.getTime()) &&\n                flags.overflow < 0 &&\n                !flags.empty &&\n                !flags.invalidMonth &&\n                !flags.invalidWeekday &&\n                !flags.nullInput &&\n                !flags.invalidFormat &&\n                !flags.userInvalidated &&\n                (!flags.meridiem || (flags.meridiem && parsedParts));\n\n            if (m._strict) {\n                isNowValid = isNowValid &&\n                    flags.charsLeftOver === 0 &&\n                    flags.unusedTokens.length === 0 &&\n                    flags.bigHour === undefined;\n            }\n\n            if (Object.isFrozen == null || !Object.isFrozen(m)) {\n                m._isValid = isNowValid;\n            }\n            else {\n                return isNowValid;\n            }\n        }\n        return m._isValid;\n    }\n\n    function createInvalid (flags) {\n        var m = createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        }\n        else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n\n        return m;\n    }\n\n// Plugins that add properties should also add the key here (null value),\n// so we can properly clone ourselves.\n    var momentProperties = hooks.momentProperties = [];\n\n    function copyConfig(to, from) {\n        var i, prop, val;\n\n        if (!isUndefined(from._isAMomentObject)) {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (!isUndefined(from._i)) {\n            to._i = from._i;\n        }\n        if (!isUndefined(from._f)) {\n            to._f = from._f;\n        }\n        if (!isUndefined(from._l)) {\n            to._l = from._l;\n        }\n        if (!isUndefined(from._strict)) {\n            to._strict = from._strict;\n        }\n        if (!isUndefined(from._tzm)) {\n            to._tzm = from._tzm;\n        }\n        if (!isUndefined(from._isUTC)) {\n            to._isUTC = from._isUTC;\n        }\n        if (!isUndefined(from._offset)) {\n            to._offset = from._offset;\n        }\n        if (!isUndefined(from._pf)) {\n            to._pf = getParsingFlags(from);\n        }\n        if (!isUndefined(from._locale)) {\n            to._locale = from._locale;\n        }\n\n        if (momentProperties.length > 0) {\n            for (i = 0; i < momentProperties.length; i++) {\n                prop = momentProperties[i];\n                val = from[prop];\n                if (!isUndefined(val)) {\n                    to[prop] = val;\n                }\n            }\n        }\n\n        return to;\n    }\n\n    var updateInProgress = false;\n\n// Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        if (!this.isValid()) {\n            this._d = new Date(NaN);\n        }\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n\n    function isMoment (obj) {\n        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n    }\n\n    function absFloor (number) {\n        if (number < 0) {\n            // -0 -> 0\n            return Math.ceil(number) || 0;\n        } else {\n            return Math.floor(number);\n        }\n    }\n\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion,\n            value = 0;\n\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n\n        return value;\n    }\n\n// compare two arrays, return the number of differences\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length),\n            lengthDiff = Math.abs(array1.length - array2.length),\n            diffs = 0,\n            i;\n        for (i = 0; i < len; i++) {\n            if ((dontConvert && array1[i] !== array2[i]) ||\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n\n    function warn(msg) {\n        if (hooks.suppressDeprecationWarnings === false &&\n            (typeof console !==  'undefined') && console.warn) {\n            console.warn('Deprecation warning: ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var firstTime = true;\n\n        return extend(function () {\n            if (hooks.deprecationHandler != null) {\n                hooks.deprecationHandler(null, msg);\n            }\n            if (firstTime) {\n                var args = [];\n                var arg;\n                for (var i = 0; i < arguments.length; i++) {\n                    arg = '';\n                    if (typeof arguments[i] === 'object') {\n                        arg += '\\n[' + i + '] ';\n                        for (var key in arguments[0]) {\n                            arg += key + ': ' + arguments[0][key] + ', ';\n                        }\n                        arg = arg.slice(0, -2); // Remove trailing comma and space\n                    } else {\n                        arg = arguments[i];\n                    }\n                    args.push(arg);\n                }\n                warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + (new Error()).stack);\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n\n    var deprecations = {};\n\n    function deprecateSimple(name, msg) {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(name, msg);\n        }\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n\n    hooks.suppressDeprecationWarnings = false;\n    hooks.deprecationHandler = null;\n\n    function isFunction(input) {\n        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n    }\n\n    function set (config) {\n        var prop, i;\n        for (i in config) {\n            prop = config[i];\n            if (isFunction(prop)) {\n                this[i] = prop;\n            } else {\n                this['_' + i] = prop;\n            }\n        }\n        this._config = config;\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        this._dayOfMonthOrdinalParseLenient = new RegExp(\n            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n            '|' + (/\\d{1,2}/).source);\n    }\n\n    function mergeConfigs(parentConfig, childConfig) {\n        var res = extend({}, parentConfig), prop;\n        for (prop in childConfig) {\n            if (hasOwnProp(childConfig, prop)) {\n                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                    res[prop] = {};\n                    extend(res[prop], parentConfig[prop]);\n                    extend(res[prop], childConfig[prop]);\n                } else if (childConfig[prop] != null) {\n                    res[prop] = childConfig[prop];\n                } else {\n                    delete res[prop];\n                }\n            }\n        }\n        for (prop in parentConfig) {\n            if (hasOwnProp(parentConfig, prop) &&\n                !hasOwnProp(childConfig, prop) &&\n                isObject(parentConfig[prop])) {\n                // make sure changes to properties don't modify parent config\n                res[prop] = extend({}, res[prop]);\n            }\n        }\n        return res;\n    }\n\n    function Locale(config) {\n        if (config != null) {\n            this.set(config);\n        }\n    }\n\n    var keys;\n\n    if (Object.keys) {\n        keys = Object.keys;\n    } else {\n        keys = function (obj) {\n            var i, res = [];\n            for (i in obj) {\n                if (hasOwnProp(obj, i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        };\n    }\n\n    var keys$1 = keys;\n\n    var defaultCalendar = {\n        sameDay : '[Today at] LT',\n        nextDay : '[Tomorrow at] LT',\n        nextWeek : 'dddd [at] LT',\n        lastDay : '[Yesterday at] LT',\n        lastWeek : '[Last] dddd [at] LT',\n        sameElse : 'L'\n    };\n\n    function calendar (key, mom, now) {\n        var output = this._calendar[key] || this._calendar['sameElse'];\n        return isFunction(output) ? output.call(mom, now) : output;\n    }\n\n    var defaultLongDateFormat = {\n        LTS  : 'h:mm:ss A',\n        LT   : 'h:mm A',\n        L    : 'MM/DD/YYYY',\n        LL   : 'MMMM D, YYYY',\n        LLL  : 'MMMM D, YYYY h:mm A',\n        LLLL : 'dddd, MMMM D, YYYY h:mm A'\n    };\n\n    function longDateFormat (key) {\n        var format = this._longDateFormat[key],\n            formatUpper = this._longDateFormat[key.toUpperCase()];\n\n        if (format || !formatUpper) {\n            return format;\n        }\n\n        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n            return val.slice(1);\n        });\n\n        return this._longDateFormat[key];\n    }\n\n    var defaultInvalidDate = 'Invalid date';\n\n    function invalidDate () {\n        return this._invalidDate;\n    }\n\n    var defaultOrdinal = '%d';\n    var defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\n    function ordinal (number) {\n        return this._ordinal.replace('%d', number);\n    }\n\n    var defaultRelativeTime = {\n        future : 'in %s',\n        past   : '%s ago',\n        s  : 'a few seconds',\n        ss : '%d seconds',\n        m  : 'a minute',\n        mm : '%d minutes',\n        h  : 'an hour',\n        hh : '%d hours',\n        d  : 'a day',\n        dd : '%d days',\n        M  : 'a month',\n        MM : '%d months',\n        y  : 'a year',\n        yy : '%d years'\n    };\n\n    function relativeTime (number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return (isFunction(output)) ?\n            output(number, withoutSuffix, string, isFuture) :\n            output.replace(/%d/i, number);\n    }\n\n    function pastFuture (diff, output) {\n        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n    }\n\n    var aliases = {};\n\n    function addUnitAlias (unit, shorthand) {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n    }\n\n    function normalizeUnits(units) {\n        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n    }\n\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {},\n            normalizedProp,\n            prop;\n\n        for (prop in inputObject) {\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n\n        return normalizedInput;\n    }\n\n    var priorities = {};\n\n    function addUnitPriority(unit, priority) {\n        priorities[unit] = priority;\n    }\n\n    function getPrioritizedUnits(unitsObj) {\n        var units = [];\n        for (var u in unitsObj) {\n            units.push({unit: u, priority: priorities[u]});\n        }\n        units.sort(function (a, b) {\n            return a.priority - b.priority;\n        });\n        return units;\n    }\n\n    function makeGetSet (unit, keepTime) {\n        return function (value) {\n            if (value != null) {\n                set$1(this, unit, value);\n                hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get(this, unit);\n            }\n        };\n    }\n\n    function get (mom, unit) {\n        return mom.isValid() ?\n            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n    }\n\n    function set$1 (mom, unit, value) {\n        if (mom.isValid()) {\n            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n        }\n    }\n\n// MOMENTS\n\n    function stringGet (units) {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units]();\n        }\n        return this;\n    }\n\n\n    function stringSet (units, value) {\n        if (typeof units === 'object') {\n            units = normalizeObjectUnits(units);\n            var prioritized = getPrioritizedUnits(units);\n            for (var i = 0; i < prioritized.length; i++) {\n                this[prioritized[i].unit](units[prioritized[i].unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (isFunction(this[units])) {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = '' + Math.abs(number),\n            zerosToFill = targetLength - absNumber.length,\n            sign = number >= 0;\n        return (sign ? (forceSign ? '+' : '') : '-') +\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n    }\n\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\n    var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\n    var formatFunctions = {};\n\n    var formatTokenFunctions = {};\n\n// token:    'M'\n// padded:   ['MM', 2]\n// ordinal:  'Mo'\n// callback: function () { this.month() + 1 }\n    function addFormatToken (token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === 'string') {\n            func = function () {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function () {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function () {\n                return this.localeData().ordinal(func.apply(this, arguments), token);\n            };\n        }\n    }\n\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, '');\n        }\n        return input.replace(/\\\\/g, '');\n    }\n\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens), i, length;\n\n        for (i = 0, length = array.length; i < length; i++) {\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n\n        return function (mom) {\n            var output = '', i;\n            for (i = 0; i < length; i++) {\n                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n            }\n            return output;\n        };\n    }\n\n// format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\n        return formatFunctions[format](m);\n    }\n\n    function expandFormat(format, locale) {\n        var i = 5;\n\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n\n        localFormattingTokens.lastIndex = 0;\n        while (i >= 0 && localFormattingTokens.test(format)) {\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n\n        return format;\n    }\n\n    var match1         = /\\d/;            //       0 - 9\n    var match2         = /\\d\\d/;          //      00 - 99\n    var match3         = /\\d{3}/;         //     000 - 999\n    var match4         = /\\d{4}/;         //    0000 - 9999\n    var match6         = /[+-]?\\d{6}/;    // -999999 - 999999\n    var match1to2      = /\\d\\d?/;         //       0 - 99\n    var match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999\n    var match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\n    var match1to3      = /\\d{1,3}/;       //       0 - 999\n    var match1to4      = /\\d{1,4}/;       //       0 - 9999\n    var match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\n    var matchUnsigned  = /\\d+/;           //       0 - inf\n    var matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\n    var matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\n    var matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n\n    var matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\n// any word (or two) characters or numbers including two/three word month in arabic.\n// includes scottish gaelic two word and hyphenated months\n    var matchWord = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i;\n\n\n    var regexes = {};\n\n    function addRegexToken (token, regex, strictRegex) {\n        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n            return (isStrict && strictRegex) ? strictRegex : regex;\n        };\n    }\n\n    function getParseRegexForToken (token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n\n        return regexes[token](config._strict, config._locale);\n    }\n\n// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n            return p1 || p2 || p3 || p4;\n        }));\n    }\n\n    function regexEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n\n    var tokens = {};\n\n    function addParseToken (token, callback) {\n        var i, func = callback;\n        if (typeof token === 'string') {\n            token = [token];\n        }\n        if (isNumber(callback)) {\n            func = function (input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        for (i = 0; i < token.length; i++) {\n            tokens[token[i]] = func;\n        }\n    }\n\n    function addWeekParseToken (token, callback) {\n        addParseToken(token, function (input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n\n    var YEAR = 0;\n    var MONTH = 1;\n    var DATE = 2;\n    var HOUR = 3;\n    var MINUTE = 4;\n    var SECOND = 5;\n    var MILLISECOND = 6;\n    var WEEK = 7;\n    var WEEKDAY = 8;\n\n    var indexOf;\n\n    if (Array.prototype.indexOf) {\n        indexOf = Array.prototype.indexOf;\n    } else {\n        indexOf = function (o) {\n            // I know\n            var i;\n            for (i = 0; i < this.length; ++i) {\n                if (this[i] === o) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n    }\n\n    var indexOf$1 = indexOf;\n\n    function daysInMonth(year, month) {\n        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();\n    }\n\n// FORMATTING\n\n    addFormatToken('M', ['MM', 2], 'Mo', function () {\n        return this.month() + 1;\n    });\n\n    addFormatToken('MMM', 0, 0, function (format) {\n        return this.localeData().monthsShort(this, format);\n    });\n\n    addFormatToken('MMMM', 0, 0, function (format) {\n        return this.localeData().months(this, format);\n    });\n\n// ALIASES\n\n    addUnitAlias('month', 'M');\n\n// PRIORITY\n\n    addUnitPriority('month', 8);\n\n// PARSING\n\n    addRegexToken('M',    match1to2);\n    addRegexToken('MM',   match1to2, match2);\n    addRegexToken('MMM',  function (isStrict, locale) {\n        return locale.monthsShortRegex(isStrict);\n    });\n    addRegexToken('MMMM', function (isStrict, locale) {\n        return locale.monthsRegex(isStrict);\n    });\n\n    addParseToken(['M', 'MM'], function (input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n\n    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n\n// LOCALES\n\n    var MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/;\n    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\n    function localeMonths (m, format) {\n        if (!m) {\n            return isArray(this._months) ? this._months :\n                this._months['standalone'];\n        }\n        return isArray(this._months) ? this._months[m.month()] :\n            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n    }\n\n    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\n    function localeMonthsShort (m, format) {\n        if (!m) {\n            return isArray(this._monthsShort) ? this._monthsShort :\n                this._monthsShort['standalone'];\n        }\n        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\n            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n    }\n\n    function handleStrictParse(monthName, format, strict) {\n        var i, ii, mom, llc = monthName.toLocaleLowerCase();\n        if (!this._monthsParse) {\n            // this is not used\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n            for (i = 0; i < 12; ++i) {\n                mom = createUTC([2000, i]);\n                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'MMM') {\n                ii = indexOf$1.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf$1.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'MMM') {\n                ii = indexOf$1.call(this._shortMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf$1.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf$1.call(this._longMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf$1.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeMonthsParse (monthName, format, strict) {\n        var i, mom, regex;\n\n        if (this._monthsParseExact) {\n            return handleStrictParse.call(this, monthName, format, strict);\n        }\n\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n\n        // TODO: add sorting\n        // Sorting makes sure if one month (or abbr) is a prefix of another\n        // see sorting in computeMonthsParse\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n\n// MOMENTS\n\n    function setMonth (mom, value) {\n        var dayOfMonth;\n\n        if (!mom.isValid()) {\n            // No op\n            return mom;\n        }\n\n        if (typeof value === 'string') {\n            if (/^\\d+$/.test(value)) {\n                value = toInt(value);\n            } else {\n                value = mom.localeData().monthsParse(value);\n                // TODO: Another silent failure?\n                if (!isNumber(value)) {\n                    return mom;\n                }\n            }\n        }\n\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n        return mom;\n    }\n\n    function getSetMonth (value) {\n        if (value != null) {\n            setMonth(this, value);\n            hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get(this, 'Month');\n        }\n    }\n\n    function getDaysInMonth () {\n        return daysInMonth(this.year(), this.month());\n    }\n\n    var defaultMonthsShortRegex = matchWord;\n    function monthsShortRegex (isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsShortStrictRegex;\n            } else {\n                return this._monthsShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsShortRegex')) {\n                this._monthsShortRegex = defaultMonthsShortRegex;\n            }\n            return this._monthsShortStrictRegex && isStrict ?\n                this._monthsShortStrictRegex : this._monthsShortRegex;\n        }\n    }\n\n    var defaultMonthsRegex = matchWord;\n    function monthsRegex (isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsStrictRegex;\n            } else {\n                return this._monthsRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                this._monthsRegex = defaultMonthsRegex;\n            }\n            return this._monthsStrictRegex && isStrict ?\n                this._monthsStrictRegex : this._monthsRegex;\n        }\n    }\n\n    function computeMonthsParse () {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var shortPieces = [], longPieces = [], mixedPieces = [],\n            i, mom;\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            shortPieces.push(this.monthsShort(mom, ''));\n            longPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.monthsShort(mom, ''));\n        }\n        // Sorting makes sure if one month (or abbr) is a prefix of another it\n        // will match the longer piece.\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 12; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n        }\n        for (i = 0; i < 24; i++) {\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._monthsShortRegex = this._monthsRegex;\n        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n    }\n\n// FORMATTING\n\n    addFormatToken('Y', 0, 0, function () {\n        var y = this.year();\n        return y <= 9999 ? '' + y : '+' + y;\n    });\n\n    addFormatToken(0, ['YY', 2], 0, function () {\n        return this.year() % 100;\n    });\n\n    addFormatToken(0, ['YYYY',   4],       0, 'year');\n    addFormatToken(0, ['YYYYY',  5],       0, 'year');\n    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n// ALIASES\n\n    addUnitAlias('year', 'y');\n\n// PRIORITIES\n\n    addUnitPriority('year', 1);\n\n// PARSING\n\n    addRegexToken('Y',      matchSigned);\n    addRegexToken('YY',     match1to2, match2);\n    addRegexToken('YYYY',   match1to4, match4);\n    addRegexToken('YYYYY',  match1to6, match6);\n    addRegexToken('YYYYYY', match1to6, match6);\n\n    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n    addParseToken('YYYY', function (input, array) {\n        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken('YY', function (input, array) {\n        array[YEAR] = hooks.parseTwoDigitYear(input);\n    });\n    addParseToken('Y', function (input, array) {\n        array[YEAR] = parseInt(input, 10);\n    });\n\n// HELPERS\n\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n\n    function isLeapYear(year) {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n    }\n\n// HOOKS\n\n    hooks.parseTwoDigitYear = function (input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n\n// MOMENTS\n\n    var getSetYear = makeGetSet('FullYear', true);\n\n    function getIsLeapYear () {\n        return isLeapYear(this.year());\n    }\n\n    function createDate (y, m, d, h, M, s, ms) {\n        // can't just apply() to create a date:\n        // https://stackoverflow.com/q/181348\n        var date = new Date(y, m, d, h, M, s, ms);\n\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {\n            date.setFullYear(y);\n        }\n        return date;\n    }\n\n    function createUTCDate (y) {\n        var date = new Date(Date.UTC.apply(null, arguments));\n\n        // the Date.UTC function remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {\n            date.setUTCFullYear(y);\n        }\n        return date;\n    }\n\n// start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n            fwd = 7 + dow - doy,\n            // first-week day local weekday -- which local weekday is fwd\n            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\n        return -fwdlw + fwd - 1;\n    }\n\n// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n        var localWeekday = (7 + weekday - dow) % 7,\n            weekOffset = firstWeekOffset(year, dow, doy),\n            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n            resYear, resDayOfYear;\n\n        if (dayOfYear <= 0) {\n            resYear = year - 1;\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\n        } else if (dayOfYear > daysInYear(year)) {\n            resYear = year + 1;\n            resDayOfYear = dayOfYear - daysInYear(year);\n        } else {\n            resYear = year;\n            resDayOfYear = dayOfYear;\n        }\n\n        return {\n            year: resYear,\n            dayOfYear: resDayOfYear\n        };\n    }\n\n    function weekOfYear(mom, dow, doy) {\n        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n            resWeek, resYear;\n\n        if (week < 1) {\n            resYear = mom.year() - 1;\n            resWeek = week + weeksInYear(resYear, dow, doy);\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n            resWeek = week - weeksInYear(mom.year(), dow, doy);\n            resYear = mom.year() + 1;\n        } else {\n            resYear = mom.year();\n            resWeek = week;\n        }\n\n        return {\n            week: resWeek,\n            year: resYear\n        };\n    }\n\n    function weeksInYear(year, dow, doy) {\n        var weekOffset = firstWeekOffset(year, dow, doy),\n            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n    }\n\n// FORMATTING\n\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\n    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n// ALIASES\n\n    addUnitAlias('week', 'w');\n    addUnitAlias('isoWeek', 'W');\n\n// PRIORITIES\n\n    addUnitPriority('week', 5);\n    addUnitPriority('isoWeek', 5);\n\n// PARSING\n\n    addRegexToken('w',  match1to2);\n    addRegexToken('ww', match1to2, match2);\n    addRegexToken('W',  match1to2);\n    addRegexToken('WW', match1to2, match2);\n\n    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n        week[token.substr(0, 1)] = toInt(input);\n    });\n\n// HELPERS\n\n// LOCALES\n\n    function localeWeek (mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n\n    var defaultLocaleWeek = {\n        dow : 0, // Sunday is the first day of the week.\n        doy : 6  // The week that contains Jan 1st is the first week of the year.\n    };\n\n    function localeFirstDayOfWeek () {\n        return this._week.dow;\n    }\n\n    function localeFirstDayOfYear () {\n        return this._week.doy;\n    }\n\n// MOMENTS\n\n    function getSetWeek (input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    function getSetISOWeek (input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n// FORMATTING\n\n    addFormatToken('d', 0, 'do', 'day');\n\n    addFormatToken('dd', 0, 0, function (format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n\n    addFormatToken('ddd', 0, 0, function (format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n\n    addFormatToken('dddd', 0, 0, function (format) {\n        return this.localeData().weekdays(this, format);\n    });\n\n    addFormatToken('e', 0, 0, 'weekday');\n    addFormatToken('E', 0, 0, 'isoWeekday');\n\n// ALIASES\n\n    addUnitAlias('day', 'd');\n    addUnitAlias('weekday', 'e');\n    addUnitAlias('isoWeekday', 'E');\n\n// PRIORITY\n    addUnitPriority('day', 11);\n    addUnitPriority('weekday', 11);\n    addUnitPriority('isoWeekday', 11);\n\n// PARSING\n\n    addRegexToken('d',    match1to2);\n    addRegexToken('e',    match1to2);\n    addRegexToken('E',    match1to2);\n    addRegexToken('dd',   function (isStrict, locale) {\n        return locale.weekdaysMinRegex(isStrict);\n    });\n    addRegexToken('ddd',   function (isStrict, locale) {\n        return locale.weekdaysShortRegex(isStrict);\n    });\n    addRegexToken('dddd',   function (isStrict, locale) {\n        return locale.weekdaysRegex(isStrict);\n    });\n\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n        var weekday = config._locale.weekdaysParse(input, token, config._strict);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n        week[token] = toInt(input);\n    });\n\n// HELPERS\n\n    function parseWeekday(input, locale) {\n        if (typeof input !== 'string') {\n            return input;\n        }\n\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n\n        input = locale.weekdaysParse(input);\n        if (typeof input === 'number') {\n            return input;\n        }\n\n        return null;\n    }\n\n    function parseIsoWeekday(input, locale) {\n        if (typeof input === 'string') {\n            return locale.weekdaysParse(input) % 7 || 7;\n        }\n        return isNaN(input) ? null : input;\n    }\n\n// LOCALES\n\n    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\n    function localeWeekdays (m, format) {\n        if (!m) {\n            return isArray(this._weekdays) ? this._weekdays :\n                this._weekdays['standalone'];\n        }\n        return isArray(this._weekdays) ? this._weekdays[m.day()] :\n            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];\n    }\n\n    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\n    function localeWeekdaysShort (m) {\n        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n    }\n\n    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\n    function localeWeekdaysMin (m) {\n        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n    }\n\n    function handleStrictParse$1(weekdayName, format, strict) {\n        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._minWeekdaysParse = [];\n\n            for (i = 0; i < 7; ++i) {\n                mom = createUTC([2000, 1]).day(i);\n                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'dddd') {\n                ii = indexOf$1.call(this._weekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf$1.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'dddd') {\n                ii = indexOf$1.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf$1.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf$1.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf$1.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf$1.call(this._minWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf$1.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeWeekdaysParse (weekdayName, format, strict) {\n        var i, mom, regex;\n\n        if (this._weekdaysParseExact) {\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\n        }\n\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._minWeekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._fullWeekdaysParse = [];\n        }\n\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n\n            mom = createUTC([2000, 1]).day(i);\n            if (strict && !this._fullWeekdaysParse[i]) {\n                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');\n                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');\n                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');\n            }\n            if (!this._weekdaysParse[i]) {\n                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n\n// MOMENTS\n\n    function getSetDayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, 'd');\n        } else {\n            return day;\n        }\n    }\n\n    function getSetLocaleDayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, 'd');\n    }\n\n    function getSetISODayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n\n        if (input != null) {\n            var weekday = parseIsoWeekday(input, this.localeData());\n            return this.day(this.day() % 7 ? weekday : weekday - 7);\n        } else {\n            return this.day() || 7;\n        }\n    }\n\n    var defaultWeekdaysRegex = matchWord;\n    function weekdaysRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysStrictRegex;\n            } else {\n                return this._weekdaysRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                this._weekdaysRegex = defaultWeekdaysRegex;\n            }\n            return this._weekdaysStrictRegex && isStrict ?\n                this._weekdaysStrictRegex : this._weekdaysRegex;\n        }\n    }\n\n    var defaultWeekdaysShortRegex = matchWord;\n    function weekdaysShortRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysShortStrictRegex;\n            } else {\n                return this._weekdaysShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n            }\n            return this._weekdaysShortStrictRegex && isStrict ?\n                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n        }\n    }\n\n    var defaultWeekdaysMinRegex = matchWord;\n    function weekdaysMinRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysMinStrictRegex;\n            } else {\n                return this._weekdaysMinRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n            }\n            return this._weekdaysMinStrictRegex && isStrict ?\n                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n        }\n    }\n\n\n    function computeWeekdaysParse () {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\n            i, mom, minp, shortp, longp;\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, 1]).day(i);\n            minp = this.weekdaysMin(mom, '');\n            shortp = this.weekdaysShort(mom, '');\n            longp = this.weekdays(mom, '');\n            minPieces.push(minp);\n            shortPieces.push(shortp);\n            longPieces.push(longp);\n            mixedPieces.push(minp);\n            mixedPieces.push(shortp);\n            mixedPieces.push(longp);\n        }\n        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n        // will match the longer piece.\n        minPieces.sort(cmpLenRev);\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 7; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._weekdaysShortRegex = this._weekdaysRegex;\n        this._weekdaysMinRegex = this._weekdaysRegex;\n\n        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n    }\n\n// FORMATTING\n\n    function hFormat() {\n        return this.hours() % 12 || 12;\n    }\n\n    function kFormat() {\n        return this.hours() || 24;\n    }\n\n    addFormatToken('H', ['HH', 2], 0, 'hour');\n    addFormatToken('h', ['hh', 2], 0, hFormat);\n    addFormatToken('k', ['kk', 2], 0, kFormat);\n\n    addFormatToken('hmm', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('hmmss', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2);\n    });\n\n    addFormatToken('Hmm', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('Hmmss', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2);\n    });\n\n    function meridiem (token, lowercase) {\n        addFormatToken(token, 0, 0, function () {\n            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n        });\n    }\n\n    meridiem('a', true);\n    meridiem('A', false);\n\n// ALIASES\n\n    addUnitAlias('hour', 'h');\n\n// PRIORITY\n    addUnitPriority('hour', 13);\n\n// PARSING\n\n    function matchMeridiem (isStrict, locale) {\n        return locale._meridiemParse;\n    }\n\n    addRegexToken('a',  matchMeridiem);\n    addRegexToken('A',  matchMeridiem);\n    addRegexToken('H',  match1to2);\n    addRegexToken('h',  match1to2);\n    addRegexToken('k',  match1to2);\n    addRegexToken('HH', match1to2, match2);\n    addRegexToken('hh', match1to2, match2);\n    addRegexToken('kk', match1to2, match2);\n\n    addRegexToken('hmm', match3to4);\n    addRegexToken('hmmss', match5to6);\n    addRegexToken('Hmm', match3to4);\n    addRegexToken('Hmmss', match5to6);\n\n    addParseToken(['H', 'HH'], HOUR);\n    addParseToken(['k', 'kk'], function (input, array, config) {\n        var kInput = toInt(input);\n        array[HOUR] = kInput === 24 ? 0 : kInput;\n    });\n    addParseToken(['a', 'A'], function (input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken(['h', 'hh'], function (input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmmss', function (input, array, config) {\n        var pos1 = input.length - 4;\n        var pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('Hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n    });\n    addParseToken('Hmmss', function (input, array, config) {\n        var pos1 = input.length - 4;\n        var pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n    });\n\n// LOCALES\n\n    function localeIsPM (input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return ((input + '').toLowerCase().charAt(0) === 'p');\n    }\n\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\n    function localeMeridiem (hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? 'pm' : 'PM';\n        } else {\n            return isLower ? 'am' : 'AM';\n        }\n    }\n\n\n// MOMENTS\n\n// Setting the hour should keep the time, because the user explicitly\n// specified which hour he wants. So trying to maintain the same hour (in\n// a new timezone) makes sense. Adding/subtracting hours does not follow\n// this rule.\n    var getSetHour = makeGetSet('Hours', true);\n\n// months\n// week\n// weekdays\n// meridiem\n    var baseConfig = {\n        calendar: defaultCalendar,\n        longDateFormat: defaultLongDateFormat,\n        invalidDate: defaultInvalidDate,\n        ordinal: defaultOrdinal,\n        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n        relativeTime: defaultRelativeTime,\n\n        months: defaultLocaleMonths,\n        monthsShort: defaultLocaleMonthsShort,\n\n        week: defaultLocaleWeek,\n\n        weekdays: defaultLocaleWeekdays,\n        weekdaysMin: defaultLocaleWeekdaysMin,\n        weekdaysShort: defaultLocaleWeekdaysShort,\n\n        meridiemParse: defaultLocaleMeridiemParse\n    };\n\n// internal storage for locale config files\n    var locales = {};\n    var localeFamilies = {};\n    var globalLocale;\n\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace('_', '-') : key;\n    }\n\n// pick the locale from the array\n// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0, j, next, locale, split;\n\n        while (i < names.length) {\n            split = normalizeLocale(names[i]).split('-');\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split('-') : null;\n            while (j > 0) {\n                locale = loadLocale(split.slice(0, j).join('-'));\n                if (locale) {\n                    return locale;\n                }\n                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                    //the next array item is better than a shallower substring of this one\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return null;\n    }\n\n    function loadLocale(name) {\n        var oldLocale = null;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (!locales[name] && (typeof module !== 'undefined') &&\n            module && module.exports) {\n            try {\n                oldLocale = globalLocale._abbr;\n                require('./locale/' + name);\n                // because defineLocale currently also sets the global locale, we\n                // want to undo that for lazy loaded locales\n                getSetGlobalLocale(oldLocale);\n            } catch (e) { }\n        }\n        return locales[name];\n    }\n\n// This function will load locale and then set the global locale.  If\n// no arguments are passed in, it will simply return the current global\n// locale key.\n    function getSetGlobalLocale (key, values) {\n        var data;\n        if (key) {\n            if (isUndefined(values)) {\n                data = getLocale(key);\n            }\n            else {\n                data = defineLocale(key, values);\n            }\n\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            }\n        }\n\n        return globalLocale._abbr;\n    }\n\n    function defineLocale (name, config) {\n        if (config !== null) {\n            var parentConfig = baseConfig;\n            config.abbr = name;\n            if (locales[name] != null) {\n                deprecateSimple('defineLocaleOverride',\n                    'use moment.updateLocale(localeName, config) to change ' +\n                    'an existing locale. moment.defineLocale(localeName, ' +\n                    'config) should only be used for creating a new locale ' +\n                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n                parentConfig = locales[name]._config;\n            } else if (config.parentLocale != null) {\n                if (locales[config.parentLocale] != null) {\n                    parentConfig = locales[config.parentLocale]._config;\n                } else {\n                    if (!localeFamilies[config.parentLocale]) {\n                        localeFamilies[config.parentLocale] = [];\n                    }\n                    localeFamilies[config.parentLocale].push({\n                        name: name,\n                        config: config\n                    });\n                    return null;\n                }\n            }\n            locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n            if (localeFamilies[name]) {\n                localeFamilies[name].forEach(function (x) {\n                    defineLocale(x.name, x.config);\n                });\n            }\n\n            // backwards compat for now: also set the locale\n            // make sure we set the locale AFTER all child locales have been\n            // created, so we won't end up with the child locale set.\n            getSetGlobalLocale(name);\n\n\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n\n    function updateLocale(name, config) {\n        if (config != null) {\n            var locale, parentConfig = baseConfig;\n            // MERGE\n            if (locales[name] != null) {\n                parentConfig = locales[name]._config;\n            }\n            config = mergeConfigs(parentConfig, config);\n            locale = new Locale(config);\n            locale.parentLocale = locales[name];\n            locales[name] = locale;\n\n            // backwards compat for now: also set the locale\n            getSetGlobalLocale(name);\n        } else {\n            // pass null for config to unupdate, useful for tests\n            if (locales[name] != null) {\n                if (locales[name].parentLocale != null) {\n                    locales[name] = locales[name].parentLocale;\n                } else if (locales[name] != null) {\n                    delete locales[name];\n                }\n            }\n        }\n        return locales[name];\n    }\n\n// returns locale data\n    function getLocale (key) {\n        var locale;\n\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n\n        if (!key) {\n            return globalLocale;\n        }\n\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [key];\n        }\n\n        return chooseLocale(key);\n    }\n\n    function listLocales() {\n        return keys$1(locales);\n    }\n\n    function checkOverflow (m) {\n        var overflow;\n        var a = m._a;\n\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow =\n                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n                    a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n                        a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n                            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n                                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n                                    a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n                                        -1;\n\n            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n                overflow = DATE;\n            }\n            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n                overflow = WEEK;\n            }\n            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n                overflow = WEEKDAY;\n            }\n\n            getParsingFlags(m).overflow = overflow;\n        }\n\n        return m;\n    }\n\n// iso 8601 regex\n// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n    var basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\n    var tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\n\n    var isoDates = [\n        ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n        ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n        ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n        ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n        ['YYYY-DDD', /\\d{4}-\\d{3}/],\n        ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n        ['YYYYYYMMDD', /[+-]\\d{10}/],\n        ['YYYYMMDD', /\\d{8}/],\n        // YYYYMM is NOT allowed by the standard\n        ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n        ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n        ['YYYYDDD', /\\d{7}/]\n    ];\n\n// iso time formats and regexes\n    var isoTimes = [\n        ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n        ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n        ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n        ['HH:mm', /\\d\\d:\\d\\d/],\n        ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n        ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n        ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n        ['HHmm', /\\d\\d\\d\\d/],\n        ['HH', /\\d\\d/]\n    ];\n\n    var aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\n// date from iso format\n    function configFromISO(config) {\n        var i, l,\n            string = config._i,\n            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n            allowTime, dateFormat, timeFormat, tzFormat;\n\n        if (match) {\n            getParsingFlags(config).iso = true;\n\n            for (i = 0, l = isoDates.length; i < l; i++) {\n                if (isoDates[i][1].exec(match[1])) {\n                    dateFormat = isoDates[i][0];\n                    allowTime = isoDates[i][2] !== false;\n                    break;\n                }\n            }\n            if (dateFormat == null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[3]) {\n                for (i = 0, l = isoTimes.length; i < l; i++) {\n                    if (isoTimes[i][1].exec(match[3])) {\n                        // match[2] should be 'T' or space\n                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\n                        break;\n                    }\n                }\n                if (timeFormat == null) {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            if (!allowTime && timeFormat != null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[4]) {\n                if (tzRegex.exec(match[4])) {\n                    tzFormat = 'Z';\n                } else {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n\n// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n    var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d?\\d\\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(?:\\d\\d)?\\d\\d\\s)(\\d\\d:\\d\\d)(\\:\\d\\d)?(\\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\\d{4}))$/;\n\n// date and time from ref 2822 format\n    function configFromRFC2822(config) {\n        var string, match, dayFormat,\n            dateFormat, timeFormat, tzFormat;\n        var timezones = {\n            ' GMT': ' +0000',\n            ' EDT': ' -0400',\n            ' EST': ' -0500',\n            ' CDT': ' -0500',\n            ' CST': ' -0600',\n            ' MDT': ' -0600',\n            ' MST': ' -0700',\n            ' PDT': ' -0700',\n            ' PST': ' -0800'\n        };\n        var military = 'YXWVUTSRQPONZABCDEFGHIKLM';\n        var timezone, timezoneIndex;\n\n        string = config._i\n            .replace(/\\([^\\)]*\\)|[\\n\\t]/g, ' ') // Remove comments and folding whitespace\n            .replace(/(\\s\\s+)/g, ' ') // Replace multiple-spaces with a single space\n            .replace(/^\\s|\\s$/g, ''); // Remove leading and trailing spaces\n        match = basicRfcRegex.exec(string);\n\n        if (match) {\n            dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';\n            dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');\n            timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');\n\n            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\n            if (match[1]) { // day of week given\n                var momentDate = new Date(match[2]);\n                var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];\n\n                if (match[1].substr(0,3) !== momentDay) {\n                    getParsingFlags(config).weekdayMismatch = true;\n                    config._isValid = false;\n                    return;\n                }\n            }\n\n            switch (match[5].length) {\n                case 2: // military\n                    if (timezoneIndex === 0) {\n                        timezone = ' +0000';\n                    } else {\n                        timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;\n                        timezone = ((timezoneIndex < 0) ? ' -' : ' +') +\n                            (('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';\n                    }\n                    break;\n                case 4: // Zone\n                    timezone = timezones[match[5]];\n                    break;\n                default: // UT or +/-9999\n                    timezone = timezones[' GMT'];\n            }\n            match[5] = timezone;\n            config._i = match.splice(1).join('');\n            tzFormat = ' ZZ';\n            config._f = dayFormat + dateFormat + timeFormat + tzFormat;\n            configFromStringAndFormat(config);\n            getParsingFlags(config).rfc2822 = true;\n        } else {\n            config._isValid = false;\n        }\n    }\n\n// date from iso format or fallback\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        configFromRFC2822(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        // Final attempt, use Input Fallback\n        hooks.createFromInputFallback(config);\n    }\n\n    hooks.createFromInputFallback = deprecate(\n        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n        'discouraged and will be removed in an upcoming major release. Please refer to ' +\n        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n        function (config) {\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n        }\n    );\n\n// Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function currentDateArray(config) {\n        // hooks is actually the exported moment object\n        var nowValue = new Date(hooks.now());\n        if (config._useUTC) {\n            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n        }\n        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n    }\n\n// convert an array to a date.\n// the array should mirror the parameters below\n// note: all values past the year are optional and will default to the lowest possible value.\n// [year, month, day , hour, minute, second, millisecond]\n    function configFromArray (config) {\n        var i, date, input = [], currentDate, yearToUse;\n\n        if (config._d) {\n            return;\n        }\n\n        currentDate = currentDateArray(config);\n\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear != null) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n            config._a[i] = input[i] = currentDate[i];\n        }\n\n        // Zero out whatever was not defaulted, including time\n        for (; i < 7; i++) {\n            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n        }\n\n        // Check for 24:00:00.000\n        if (config._a[HOUR] === 24 &&\n            config._a[MINUTE] === 0 &&\n            config._a[SECOND] === 0 &&\n            config._a[MILLISECOND] === 0) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n    }\n\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\n\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n            if (weekday < 1 || weekday > 7) {\n                weekdayOverflow = true;\n            }\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n\n            var curWeek = weekOfYear(createLocal(), dow, doy);\n\n            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n            // Default to current week.\n            week = defaults(w.w, curWeek.week);\n\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < 0 || weekday > 6) {\n                    weekdayOverflow = true;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from begining of week\n                weekday = w.e + dow;\n                if (w.e < 0 || w.e > 6) {\n                    weekdayOverflow = true;\n                }\n            } else {\n                // default to begining of week\n                weekday = dow;\n            }\n        }\n        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n            getParsingFlags(config)._overflowWeeks = true;\n        } else if (weekdayOverflow != null) {\n            getParsingFlags(config)._overflowWeekday = true;\n        } else {\n            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n            config._a[YEAR] = temp.year;\n            config._dayOfYear = temp.dayOfYear;\n        }\n    }\n\n// constant that refers to the ISO standard\n    hooks.ISO_8601 = function () {};\n\n// constant that refers to the RFC 2822 form\n    hooks.RFC_2822 = function () {};\n\n// date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n        if (config._f === hooks.RFC_2822) {\n            configFromRFC2822(config);\n            return;\n        }\n        config._a = [];\n        getParsingFlags(config).empty = true;\n\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = '' + config._i,\n            i, parsedInput, tokens, token, skipped,\n            stringLength = string.length,\n            totalParsedInputLength = 0;\n\n        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n            // console.log('token', token, 'parsedInput', parsedInput,\n            //         'regex', getParseRegexForToken(token, config));\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                }\n                else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            }\n            else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n\n        // clear _12h flag if hour is <= 12\n        if (config._a[HOUR] <= 12 &&\n            getParsingFlags(config).bigHour === true &&\n            config._a[HOUR] > 0) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n\n        getParsingFlags(config).parsedDateParts = config._a.slice(0);\n        getParsingFlags(config).meridiem = config._meridiem;\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\n        configFromArray(config);\n        checkOverflow(config);\n    }\n\n\n    function meridiemFixWrap (locale, hour, meridiem) {\n        var isPm;\n\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n\n// date from string and array of format strings\n    function configFromStringAndArray(config) {\n        var tempConfig,\n            bestMoment,\n\n            scoreToBeat,\n            i,\n            currentScore;\n\n        if (config._f.length === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n\n        for (i = 0; i < config._f.length; i++) {\n            currentScore = 0;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n\n            if (!isValid(tempConfig)) {\n                continue;\n            }\n\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n            getParsingFlags(tempConfig).score = currentScore;\n\n            if (scoreToBeat == null || currentScore < scoreToBeat) {\n                scoreToBeat = currentScore;\n                bestMoment = tempConfig;\n            }\n        }\n\n        extend(config, bestMoment || tempConfig);\n    }\n\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n\n        var i = normalizeObjectUnits(config._i);\n        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n            return obj && parseInt(obj, 10);\n        });\n\n        configFromArray(config);\n    }\n\n    function createFromConfig (config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, 'd');\n            res._nextDay = undefined;\n        }\n\n        return res;\n    }\n\n    function prepareConfig (config) {\n        var input = config._i,\n            format = config._f;\n\n        config._locale = config._locale || getLocale(config._l);\n\n        if (input === null || (format === undefined && input === '')) {\n            return createInvalid({nullInput: true});\n        }\n\n        if (typeof input === 'string') {\n            config._i = input = config._locale.preparse(input);\n        }\n\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isDate(input)) {\n            config._d = input;\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        }  else {\n            configFromInput(config);\n        }\n\n        if (!isValid(config)) {\n            config._d = null;\n        }\n\n        return config;\n    }\n\n    function configFromInput(config) {\n        var input = config._i;\n        if (isUndefined(input)) {\n            config._d = new Date(hooks.now());\n        } else if (isDate(input)) {\n            config._d = new Date(input.valueOf());\n        } else if (typeof input === 'string') {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function (obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (isObject(input)) {\n            configFromObject(config);\n        } else if (isNumber(input)) {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            hooks.createFromInputFallback(config);\n        }\n    }\n\n    function createLocalOrUTC (input, format, locale, strict, isUTC) {\n        var c = {};\n\n        if (locale === true || locale === false) {\n            strict = locale;\n            locale = undefined;\n        }\n\n        if ((isObject(input) && isObjectEmpty(input)) ||\n            (isArray(input) && input.length === 0)) {\n            input = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n\n        return createFromConfig(c);\n    }\n\n    function createLocal (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n\n    var prototypeMin = deprecate(\n        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n        function () {\n            var other = createLocal.apply(null, arguments);\n            if (this.isValid() && other.isValid()) {\n                return other < this ? this : other;\n            } else {\n                return createInvalid();\n            }\n        }\n    );\n\n    var prototypeMax = deprecate(\n        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n        function () {\n            var other = createLocal.apply(null, arguments);\n            if (this.isValid() && other.isValid()) {\n                return other > this ? this : other;\n            } else {\n                return createInvalid();\n            }\n        }\n    );\n\n// Pick a moment m from moments so that m[fn](other) is true for all\n// other. This relies on the function fn to be transitive.\n//\n// moments should either be an array of moment objects or an array, whose\n// first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return createLocal();\n        }\n        res = moments[0];\n        for (i = 1; i < moments.length; ++i) {\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n\n// TODO: Use [].sort instead?\n    function min () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isBefore', args);\n    }\n\n    function max () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isAfter', args);\n    }\n\n    var now = function () {\n        return Date.now ? Date.now() : +(new Date());\n    };\n\n    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n\n    function isDurationValid(m) {\n        for (var key in m) {\n            if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n                return false;\n            }\n        }\n\n        var unitHasDecimal = false;\n        for (var i = 0; i < ordering.length; ++i) {\n            if (m[ordering[i]]) {\n                if (unitHasDecimal) {\n                    return false; // only allow non-integers for smallest unit\n                }\n                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                    unitHasDecimal = true;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function isValid$1() {\n        return this._isValid;\n    }\n\n    function createInvalid$1() {\n        return createDuration(NaN);\n    }\n\n    function Duration (duration) {\n        var normalizedInput = normalizeObjectUnits(duration),\n            years = normalizedInput.year || 0,\n            quarters = normalizedInput.quarter || 0,\n            months = normalizedInput.month || 0,\n            weeks = normalizedInput.week || 0,\n            days = normalizedInput.day || 0,\n            hours = normalizedInput.hour || 0,\n            minutes = normalizedInput.minute || 0,\n            seconds = normalizedInput.second || 0,\n            milliseconds = normalizedInput.millisecond || 0;\n\n        this._isValid = isDurationValid(normalizedInput);\n\n        // representation for dateAddRemove\n        this._milliseconds = +milliseconds +\n            seconds * 1e3 + // 1000\n            minutes * 6e4 + // 1000 * 60\n            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days +\n            weeks * 7;\n        // It is impossible translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months +\n            quarters * 3 +\n            years * 12;\n\n        this._data = {};\n\n        this._locale = getLocale();\n\n        this._bubble();\n    }\n\n    function isDuration (obj) {\n        return obj instanceof Duration;\n    }\n\n    function absRound (number) {\n        if (number < 0) {\n            return Math.round(-1 * number) * -1;\n        } else {\n            return Math.round(number);\n        }\n    }\n\n// FORMATTING\n\n    function offset (token, separator) {\n        addFormatToken(token, 0, 0, function () {\n            var offset = this.utcOffset();\n            var sign = '+';\n            if (offset < 0) {\n                offset = -offset;\n                sign = '-';\n            }\n            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n        });\n    }\n\n    offset('Z', ':');\n    offset('ZZ', '');\n\n// PARSING\n\n    addRegexToken('Z',  matchShortOffset);\n    addRegexToken('ZZ', matchShortOffset);\n    addParseToken(['Z', 'ZZ'], function (input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(matchShortOffset, input);\n    });\n\n// HELPERS\n\n// timezone chunker\n// '+10:00' > ['10',  '00']\n// '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n    function offsetFromString(matcher, string) {\n        var matches = (string || '').match(matcher);\n\n        if (matches === null) {\n            return null;\n        }\n\n        var chunk   = matches[matches.length - 1] || [];\n        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n        var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n        return minutes === 0 ?\n            0 :\n            parts[0] === '+' ? minutes : -minutes;\n    }\n\n// Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(res._d.valueOf() + diff);\n            hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return createLocal(input).local();\n        }\n    }\n\n    function getDateOffset (m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n    }\n\n// HOOKS\n\n// This function will be called whenever a moment is mutated.\n// It is intended to keep the offset in sync with the timezone.\n    hooks.updateOffset = function () {};\n\n// MOMENTS\n\n// keepLocalTime = true means only change the timezone, without\n// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n// +0200, so we adjust the time as needed, to be valid.\n//\n// Keeping the time actually adds/subtracts (one hour)\n// from the actual represented time. That is why we call updateOffset\n// a second time. In case it wants us to change the offset again\n// _changeInProgress == true case, then we have to adjust, because\n// there is no such time in the given timezone.\n    function getSetOffset (input, keepLocalTime, keepMinutes) {\n        var offset = this._offset || 0,\n            localAdjust;\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        if (input != null) {\n            if (typeof input === 'string') {\n                input = offsetFromString(matchShortOffset, input);\n                if (input === null) {\n                    return this;\n                }\n            } else if (Math.abs(input) < 16 && !keepMinutes) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, 'm');\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n\n    function getSetZone (input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== 'string') {\n                input = -input;\n            }\n\n            this.utcOffset(input, keepLocalTime);\n\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n\n    function setOffsetToUTC (keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n\n    function setOffsetToLocal (keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), 'm');\n            }\n        }\n        return this;\n    }\n\n    function setOffsetToParsedOffset () {\n        if (this._tzm != null) {\n            this.utcOffset(this._tzm, false, true);\n        } else if (typeof this._i === 'string') {\n            var tZone = offsetFromString(matchOffset, this._i);\n            if (tZone != null) {\n                this.utcOffset(tZone);\n            }\n            else {\n                this.utcOffset(0, true);\n            }\n        }\n        return this;\n    }\n\n    function hasAlignedHourOffset (input) {\n        if (!this.isValid()) {\n            return false;\n        }\n        input = input ? createLocal(input).utcOffset() : 0;\n\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n\n    function isDaylightSavingTime () {\n        return (\n            this.utcOffset() > this.clone().month(0).utcOffset() ||\n            this.utcOffset() > this.clone().month(5).utcOffset()\n        );\n    }\n\n    function isDaylightSavingTimeShifted () {\n        if (!isUndefined(this._isDSTShifted)) {\n            return this._isDSTShifted;\n        }\n\n        var c = {};\n\n        copyConfig(c, this);\n        c = prepareConfig(c);\n\n        if (c._a) {\n            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n            this._isDSTShifted = this.isValid() &&\n                compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n\n        return this._isDSTShifted;\n    }\n\n    function isLocal () {\n        return this.isValid() ? !this._isUTC : false;\n    }\n\n    function isUtcOffset () {\n        return this.isValid() ? this._isUTC : false;\n    }\n\n    function isUtc () {\n        return this.isValid() ? this._isUTC && this._offset === 0 : false;\n    }\n\n// ASP.NET json date format regex\n    var aspNetRegex = /^(\\-)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\n\n// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n// and further modified to allow for strings containing both week and day\n    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;\n\n    function createDuration (input, key) {\n        var duration = input,\n            // matching against regexp is expensive, do it on demand\n            match = null,\n            sign,\n            ret,\n            diffRes;\n\n        if (isDuration(input)) {\n            duration = {\n                ms : input._milliseconds,\n                d  : input._days,\n                M  : input._months\n            };\n        } else if (isNumber(input)) {\n            duration = {};\n            if (key) {\n                duration[key] = input;\n            } else {\n                duration.milliseconds = input;\n            }\n        } else if (!!(match = aspNetRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y  : 0,\n                d  : toInt(match[DATE])                         * sign,\n                h  : toInt(match[HOUR])                         * sign,\n                m  : toInt(match[MINUTE])                       * sign,\n                s  : toInt(match[SECOND])                       * sign,\n                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n            };\n        } else if (!!(match = isoRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y : parseIso(match[2], sign),\n                M : parseIso(match[3], sign),\n                w : parseIso(match[4], sign),\n                d : parseIso(match[5], sign),\n                h : parseIso(match[6], sign),\n                m : parseIso(match[7], sign),\n                s : parseIso(match[8], sign)\n            };\n        } else if (duration == null) {// checks for null or undefined\n            duration = {};\n        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n\n        ret = new Duration(duration);\n\n        if (isDuration(input) && hasOwnProp(input, '_locale')) {\n            ret._locale = input._locale;\n        }\n\n        return ret;\n    }\n\n    createDuration.fn = Duration.prototype;\n    createDuration.invalid = createInvalid$1;\n\n    function parseIso (inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(',', '.'));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n\n    function positiveMomentsDifference(base, other) {\n        var res = {milliseconds: 0, months: 0};\n\n        res.months = other.month() - base.month() +\n            (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\n            --res.months;\n        }\n\n        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\n        return res;\n    }\n\n    function momentsDifference(base, other) {\n        var res;\n        if (!(base.isValid() && other.isValid())) {\n            return {milliseconds: 0, months: 0};\n        }\n\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n\n        return res;\n    }\n\n// TODO: remove 'name' arg after deprecation is removed\n    function createAdder(direction, name) {\n        return function (val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\n                    'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n                tmp = val; val = period; period = tmp;\n            }\n\n            val = typeof val === 'string' ? +val : val;\n            dur = createDuration(val, period);\n            addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n\n    function addSubtract (mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds,\n            days = absRound(duration._days),\n            months = absRound(duration._months);\n\n        if (!mom.isValid()) {\n            // No op\n            return;\n        }\n\n        updateOffset = updateOffset == null ? true : updateOffset;\n\n        if (milliseconds) {\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n        }\n        if (days) {\n            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n        }\n        if (months) {\n            setMonth(mom, get(mom, 'Month') + months * isAdding);\n        }\n        if (updateOffset) {\n            hooks.updateOffset(mom, days || months);\n        }\n    }\n\n    var add      = createAdder(1, 'add');\n    var subtract = createAdder(-1, 'subtract');\n\n    function getCalendarFormat(myMoment, now) {\n        var diff = myMoment.diff(now, 'days', true);\n        return diff < -6 ? 'sameElse' :\n            diff < -1 ? 'lastWeek' :\n                diff < 0 ? 'lastDay' :\n                    diff < 1 ? 'sameDay' :\n                        diff < 2 ? 'nextDay' :\n                            diff < 7 ? 'nextWeek' : 'sameElse';\n    }\n\n    function calendar$1 (time, formats) {\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || createLocal(),\n            sod = cloneWithOffset(now, this).startOf('day'),\n            format = hooks.calendarFormat(this, sod) || 'sameElse';\n\n        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n\n        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n    }\n\n    function clone () {\n        return new Moment(this);\n    }\n\n    function isAfter (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() > localInput.valueOf();\n        } else {\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n        }\n    }\n\n    function isBefore (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() < localInput.valueOf();\n        } else {\n            return this.clone().endOf(units).valueOf() < localInput.valueOf();\n        }\n    }\n\n    function isBetween (from, to, units, inclusivity) {\n        inclusivity = inclusivity || '()';\n        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&\n            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));\n    }\n\n    function isSame (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input),\n            inputMs;\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units || 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() === localInput.valueOf();\n        } else {\n            inputMs = localInput.valueOf();\n            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n        }\n    }\n\n    function isSameOrAfter (input, units) {\n        return this.isSame(input, units) || this.isAfter(input,units);\n    }\n\n    function isSameOrBefore (input, units) {\n        return this.isSame(input, units) || this.isBefore(input,units);\n    }\n\n    function diff (input, units, asFloat) {\n        var that,\n            zoneDelta,\n            delta, output;\n\n        if (!this.isValid()) {\n            return NaN;\n        }\n\n        that = cloneWithOffset(input, this);\n\n        if (!that.isValid()) {\n            return NaN;\n        }\n\n        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\n        units = normalizeUnits(units);\n\n        if (units === 'year' || units === 'month' || units === 'quarter') {\n            output = monthDiff(this, that);\n            if (units === 'quarter') {\n                output = output / 3;\n            } else if (units === 'year') {\n                output = output / 12;\n            }\n        } else {\n            delta = this - that;\n            output = units === 'second' ? delta / 1e3 : // 1000\n                units === 'minute' ? delta / 6e4 : // 1000 * 60\n                    units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60\n                        units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst\n                            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst\n                                delta;\n        }\n        return asFloat ? output : absFloor(output);\n    }\n\n    function monthDiff (a, b) {\n        // difference in months\n        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n            // b is in (anchor - 1 month, anchor + 1 month)\n            anchor = a.clone().add(wholeMonthDiff, 'months'),\n            anchor2, adjust;\n\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n\n        //check for negative zero, return zero if negative zero\n        return -(wholeMonthDiff + adjust) || 0;\n    }\n\n    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\n    function toString () {\n        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n    }\n\n    function toISOString() {\n        if (!this.isValid()) {\n            return null;\n        }\n        var m = this.clone().utc();\n        if (m.year() < 0 || m.year() > 9999) {\n            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n        }\n        if (isFunction(Date.prototype.toISOString)) {\n            // native implementation is ~50x faster, use it when we can\n            return this.toDate().toISOString();\n        }\n        return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n    }\n\n    /**\n     * Return a human readable representation of a moment that can\n     * also be evaluated to get a new moment which is the same\n     *\n     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n     */\n    function inspect () {\n        if (!this.isValid()) {\n            return 'moment.invalid(/* ' + this._i + ' */)';\n        }\n        var func = 'moment';\n        var zone = '';\n        if (!this.isLocal()) {\n            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n            zone = 'Z';\n        }\n        var prefix = '[' + func + '(\"]';\n        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\n        var datetime = '-MM-DD[T]HH:mm:ss.SSS';\n        var suffix = zone + '[\")]';\n\n        return this.format(prefix + year + datetime + suffix);\n    }\n\n    function format (inputString) {\n        if (!inputString) {\n            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n        }\n        var output = formatMoment(this, inputString);\n        return this.localeData().postformat(output);\n    }\n\n    function from (time, withoutSuffix) {\n        if (this.isValid() &&\n            ((isMoment(time) && time.isValid()) ||\n            createLocal(time).isValid())) {\n            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function fromNow (withoutSuffix) {\n        return this.from(createLocal(), withoutSuffix);\n    }\n\n    function to (time, withoutSuffix) {\n        if (this.isValid() &&\n            ((isMoment(time) && time.isValid()) ||\n            createLocal(time).isValid())) {\n            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function toNow (withoutSuffix) {\n        return this.to(createLocal(), withoutSuffix);\n    }\n\n// If passed a locale key, it will set the locale for this\n// instance.  Otherwise, it will return the locale configuration\n// variables for this instance.\n    function locale (key) {\n        var newLocaleData;\n\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n\n    var lang = deprecate(\n        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n        function (key) {\n            if (key === undefined) {\n                return this.localeData();\n            } else {\n                return this.locale(key);\n            }\n        }\n    );\n\n    function localeData () {\n        return this._locale;\n    }\n\n    function startOf (units) {\n        units = normalizeUnits(units);\n        // the following switch intentionally omits break keywords\n        // to utilize falling through the cases.\n        switch (units) {\n            case 'year':\n                this.month(0);\n            /* falls through */\n            case 'quarter':\n            case 'month':\n                this.date(1);\n            /* falls through */\n            case 'week':\n            case 'isoWeek':\n            case 'day':\n            case 'date':\n                this.hours(0);\n            /* falls through */\n            case 'hour':\n                this.minutes(0);\n            /* falls through */\n            case 'minute':\n                this.seconds(0);\n            /* falls through */\n            case 'second':\n                this.milliseconds(0);\n        }\n\n        // weeks are a special case\n        if (units === 'week') {\n            this.weekday(0);\n        }\n        if (units === 'isoWeek') {\n            this.isoWeekday(1);\n        }\n\n        // quarters are also special\n        if (units === 'quarter') {\n            this.month(Math.floor(this.month() / 3) * 3);\n        }\n\n        return this;\n    }\n\n    function endOf (units) {\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond') {\n            return this;\n        }\n\n        // 'date' is an alias for 'day', so it should be considered as such.\n        if (units === 'date') {\n            units = 'day';\n        }\n\n        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n    }\n\n    function valueOf () {\n        return this._d.valueOf() - ((this._offset || 0) * 60000);\n    }\n\n    function unix () {\n        return Math.floor(this.valueOf() / 1000);\n    }\n\n    function toDate () {\n        return new Date(this.valueOf());\n    }\n\n    function toArray () {\n        var m = this;\n        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n    }\n\n    function toObject () {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds()\n        };\n    }\n\n    function toJSON () {\n        // new Date(NaN).toJSON() === null\n        return this.isValid() ? this.toISOString() : null;\n    }\n\n    function isValid$2 () {\n        return isValid(this);\n    }\n\n    function parsingFlags () {\n        return extend({}, getParsingFlags(this));\n    }\n\n    function invalidAt () {\n        return getParsingFlags(this).overflow;\n    }\n\n    function creationData() {\n        return {\n            input: this._i,\n            format: this._f,\n            locale: this._locale,\n            isUTC: this._isUTC,\n            strict: this._strict\n        };\n    }\n\n// FORMATTING\n\n    addFormatToken(0, ['gg', 2], 0, function () {\n        return this.weekYear() % 100;\n    });\n\n    addFormatToken(0, ['GG', 2], 0, function () {\n        return this.isoWeekYear() % 100;\n    });\n\n    function addWeekYearFormatToken (token, getter) {\n        addFormatToken(0, [token, token.length], 0, getter);\n    }\n\n    addWeekYearFormatToken('gggg',     'weekYear');\n    addWeekYearFormatToken('ggggg',    'weekYear');\n    addWeekYearFormatToken('GGGG',  'isoWeekYear');\n    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n// ALIASES\n\n    addUnitAlias('weekYear', 'gg');\n    addUnitAlias('isoWeekYear', 'GG');\n\n// PRIORITY\n\n    addUnitPriority('weekYear', 1);\n    addUnitPriority('isoWeekYear', 1);\n\n\n// PARSING\n\n    addRegexToken('G',      matchSigned);\n    addRegexToken('g',      matchSigned);\n    addRegexToken('GG',     match1to2, match2);\n    addRegexToken('gg',     match1to2, match2);\n    addRegexToken('GGGG',   match1to4, match4);\n    addRegexToken('gggg',   match1to4, match4);\n    addRegexToken('GGGGG',  match1to6, match6);\n    addRegexToken('ggggg',  match1to6, match6);\n\n    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n        week[token.substr(0, 2)] = toInt(input);\n    });\n\n    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n        week[token] = hooks.parseTwoDigitYear(input);\n    });\n\n// MOMENTS\n\n    function getSetWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n            input,\n            this.week(),\n            this.weekday(),\n            this.localeData()._week.dow,\n            this.localeData()._week.doy);\n    }\n\n    function getSetISOWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n            input, this.isoWeek(), this.isoWeekday(), 1, 4);\n    }\n\n    function getISOWeeksInYear () {\n        return weeksInYear(this.year(), 1, 4);\n    }\n\n    function getWeeksInYear () {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n\n    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n        var weeksTarget;\n        if (input == null) {\n            return weekOfYear(this, dow, doy).year;\n        } else {\n            weeksTarget = weeksInYear(input, dow, doy);\n            if (week > weeksTarget) {\n                week = weeksTarget;\n            }\n            return setWeekAll.call(this, input, week, weekday, dow, doy);\n        }\n    }\n\n    function setWeekAll(weekYear, week, weekday, dow, doy) {\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\n        this.year(date.getUTCFullYear());\n        this.month(date.getUTCMonth());\n        this.date(date.getUTCDate());\n        return this;\n    }\n\n// FORMATTING\n\n    addFormatToken('Q', 0, 'Qo', 'quarter');\n\n// ALIASES\n\n    addUnitAlias('quarter', 'Q');\n\n// PRIORITY\n\n    addUnitPriority('quarter', 7);\n\n// PARSING\n\n    addRegexToken('Q', match1);\n    addParseToken('Q', function (input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n\n// MOMENTS\n\n    function getSetQuarter (input) {\n        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n    }\n\n// FORMATTING\n\n    addFormatToken('D', ['DD', 2], 'Do', 'date');\n\n// ALIASES\n\n    addUnitAlias('date', 'D');\n\n// PRIOROITY\n    addUnitPriority('date', 9);\n\n// PARSING\n\n    addRegexToken('D',  match1to2);\n    addRegexToken('DD', match1to2, match2);\n    addRegexToken('Do', function (isStrict, locale) {\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        return isStrict ?\n            (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\n            locale._dayOfMonthOrdinalParseLenient;\n    });\n\n    addParseToken(['D', 'DD'], DATE);\n    addParseToken('Do', function (input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0], 10);\n    });\n\n// MOMENTS\n\n    var getSetDayOfMonth = makeGetSet('Date', true);\n\n// FORMATTING\n\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n// ALIASES\n\n    addUnitAlias('dayOfYear', 'DDD');\n\n// PRIORITY\n    addUnitPriority('dayOfYear', 4);\n\n// PARSING\n\n    addRegexToken('DDD',  match1to3);\n    addRegexToken('DDDD', match3);\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n\n// HELPERS\n\n// MOMENTS\n\n    function getSetDayOfYear (input) {\n        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n    }\n\n// FORMATTING\n\n    addFormatToken('m', ['mm', 2], 0, 'minute');\n\n// ALIASES\n\n    addUnitAlias('minute', 'm');\n\n// PRIORITY\n\n    addUnitPriority('minute', 14);\n\n// PARSING\n\n    addRegexToken('m',  match1to2);\n    addRegexToken('mm', match1to2, match2);\n    addParseToken(['m', 'mm'], MINUTE);\n\n// MOMENTS\n\n    var getSetMinute = makeGetSet('Minutes', false);\n\n// FORMATTING\n\n    addFormatToken('s', ['ss', 2], 0, 'second');\n\n// ALIASES\n\n    addUnitAlias('second', 's');\n\n// PRIORITY\n\n    addUnitPriority('second', 15);\n\n// PARSING\n\n    addRegexToken('s',  match1to2);\n    addRegexToken('ss', match1to2, match2);\n    addParseToken(['s', 'ss'], SECOND);\n\n// MOMENTS\n\n    var getSetSecond = makeGetSet('Seconds', false);\n\n// FORMATTING\n\n    addFormatToken('S', 0, 0, function () {\n        return ~~(this.millisecond() / 100);\n    });\n\n    addFormatToken(0, ['SS', 2], 0, function () {\n        return ~~(this.millisecond() / 10);\n    });\n\n    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n    addFormatToken(0, ['SSSS', 4], 0, function () {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, ['SSSSS', 5], 0, function () {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, ['SSSSSS', 6], 0, function () {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n        return this.millisecond() * 1000000;\n    });\n\n\n// ALIASES\n\n    addUnitAlias('millisecond', 'ms');\n\n// PRIORITY\n\n    addUnitPriority('millisecond', 16);\n\n// PARSING\n\n    addRegexToken('S',    match1to3, match1);\n    addRegexToken('SS',   match1to3, match2);\n    addRegexToken('SSS',  match1to3, match3);\n\n    var token;\n    for (token = 'SSSS'; token.length <= 9; token += 'S') {\n        addRegexToken(token, matchUnsigned);\n    }\n\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt(('0.' + input) * 1000);\n    }\n\n    for (token = 'S'; token.length <= 9; token += 'S') {\n        addParseToken(token, parseMs);\n    }\n// MOMENTS\n\n    var getSetMillisecond = makeGetSet('Milliseconds', false);\n\n// FORMATTING\n\n    addFormatToken('z',  0, 0, 'zoneAbbr');\n    addFormatToken('zz', 0, 0, 'zoneName');\n\n// MOMENTS\n\n    function getZoneAbbr () {\n        return this._isUTC ? 'UTC' : '';\n    }\n\n    function getZoneName () {\n        return this._isUTC ? 'Coordinated Universal Time' : '';\n    }\n\n    var proto = Moment.prototype;\n\n    proto.add               = add;\n    proto.calendar          = calendar$1;\n    proto.clone             = clone;\n    proto.diff              = diff;\n    proto.endOf             = endOf;\n    proto.format            = format;\n    proto.from              = from;\n    proto.fromNow           = fromNow;\n    proto.to                = to;\n    proto.toNow             = toNow;\n    proto.get               = stringGet;\n    proto.invalidAt         = invalidAt;\n    proto.isAfter           = isAfter;\n    proto.isBefore          = isBefore;\n    proto.isBetween         = isBetween;\n    proto.isSame            = isSame;\n    proto.isSameOrAfter     = isSameOrAfter;\n    proto.isSameOrBefore    = isSameOrBefore;\n    proto.isValid           = isValid$2;\n    proto.lang              = lang;\n    proto.locale            = locale;\n    proto.localeData        = localeData;\n    proto.max               = prototypeMax;\n    proto.min               = prototypeMin;\n    proto.parsingFlags      = parsingFlags;\n    proto.set               = stringSet;\n    proto.startOf           = startOf;\n    proto.subtract          = subtract;\n    proto.toArray           = toArray;\n    proto.toObject          = toObject;\n    proto.toDate            = toDate;\n    proto.toISOString       = toISOString;\n    proto.inspect           = inspect;\n    proto.toJSON            = toJSON;\n    proto.toString          = toString;\n    proto.unix              = unix;\n    proto.valueOf           = valueOf;\n    proto.creationData      = creationData;\n\n// Year\n    proto.year       = getSetYear;\n    proto.isLeapYear = getIsLeapYear;\n\n// Week Year\n    proto.weekYear    = getSetWeekYear;\n    proto.isoWeekYear = getSetISOWeekYear;\n\n// Quarter\n    proto.quarter = proto.quarters = getSetQuarter;\n\n// Month\n    proto.month       = getSetMonth;\n    proto.daysInMonth = getDaysInMonth;\n\n// Week\n    proto.week           = proto.weeks        = getSetWeek;\n    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\n    proto.weeksInYear    = getWeeksInYear;\n    proto.isoWeeksInYear = getISOWeeksInYear;\n\n// Day\n    proto.date       = getSetDayOfMonth;\n    proto.day        = proto.days             = getSetDayOfWeek;\n    proto.weekday    = getSetLocaleDayOfWeek;\n    proto.isoWeekday = getSetISODayOfWeek;\n    proto.dayOfYear  = getSetDayOfYear;\n\n// Hour\n    proto.hour = proto.hours = getSetHour;\n\n// Minute\n    proto.minute = proto.minutes = getSetMinute;\n\n// Second\n    proto.second = proto.seconds = getSetSecond;\n\n// Millisecond\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\n\n// Offset\n    proto.utcOffset            = getSetOffset;\n    proto.utc                  = setOffsetToUTC;\n    proto.local                = setOffsetToLocal;\n    proto.parseZone            = setOffsetToParsedOffset;\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    proto.isDST                = isDaylightSavingTime;\n    proto.isLocal              = isLocal;\n    proto.isUtcOffset          = isUtcOffset;\n    proto.isUtc                = isUtc;\n    proto.isUTC                = isUtc;\n\n// Timezone\n    proto.zoneAbbr = getZoneAbbr;\n    proto.zoneName = getZoneName;\n\n// Deprecations\n    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\n    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\n    function createUnix (input) {\n        return createLocal(input * 1000);\n    }\n\n    function createInZone () {\n        return createLocal.apply(null, arguments).parseZone();\n    }\n\n    function preParsePostFormat (string) {\n        return string;\n    }\n\n    var proto$1 = Locale.prototype;\n\n    proto$1.calendar        = calendar;\n    proto$1.longDateFormat  = longDateFormat;\n    proto$1.invalidDate     = invalidDate;\n    proto$1.ordinal         = ordinal;\n    proto$1.preparse        = preParsePostFormat;\n    proto$1.postformat      = preParsePostFormat;\n    proto$1.relativeTime    = relativeTime;\n    proto$1.pastFuture      = pastFuture;\n    proto$1.set             = set;\n\n// Month\n    proto$1.months            =        localeMonths;\n    proto$1.monthsShort       =        localeMonthsShort;\n    proto$1.monthsParse       =        localeMonthsParse;\n    proto$1.monthsRegex       = monthsRegex;\n    proto$1.monthsShortRegex  = monthsShortRegex;\n\n// Week\n    proto$1.week = localeWeek;\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\n    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\n// Day of Week\n    proto$1.weekdays       =        localeWeekdays;\n    proto$1.weekdaysMin    =        localeWeekdaysMin;\n    proto$1.weekdaysShort  =        localeWeekdaysShort;\n    proto$1.weekdaysParse  =        localeWeekdaysParse;\n\n    proto$1.weekdaysRegex       =        weekdaysRegex;\n    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;\n    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;\n\n// Hours\n    proto$1.isPM = localeIsPM;\n    proto$1.meridiem = localeMeridiem;\n\n    function get$1 (format, index, field, setter) {\n        var locale = getLocale();\n        var utc = createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n\n    function listMonthsImpl (format, index, field) {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n\n        if (index != null) {\n            return get$1(format, index, field, 'month');\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < 12; i++) {\n            out[i] = get$1(format, i, field, 'month');\n        }\n        return out;\n    }\n\n// ()\n// (5)\n// (fmt, 5)\n// (fmt)\n// (true)\n// (true, 5)\n// (true, fmt, 5)\n// (true, fmt)\n    function listWeekdaysImpl (localeSorted, format, index, field) {\n        if (typeof localeSorted === 'boolean') {\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        } else {\n            format = localeSorted;\n            index = format;\n            localeSorted = false;\n\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        }\n\n        var locale = getLocale(),\n            shift = localeSorted ? locale._week.dow : 0;\n\n        if (index != null) {\n            return get$1(format, (index + shift) % 7, field, 'day');\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < 7; i++) {\n            out[i] = get$1(format, (i + shift) % 7, field, 'day');\n        }\n        return out;\n    }\n\n    function listMonths (format, index) {\n        return listMonthsImpl(format, index, 'months');\n    }\n\n    function listMonthsShort (format, index) {\n        return listMonthsImpl(format, index, 'monthsShort');\n    }\n\n    function listWeekdays (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n    }\n\n    function listWeekdaysShort (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n    }\n\n    function listWeekdaysMin (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n    }\n\n    getSetGlobalLocale('en', {\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (toInt(number % 100 / 10) === 1) ? 'th' :\n                    (b === 1) ? 'st' :\n                        (b === 2) ? 'nd' :\n                            (b === 3) ? 'rd' : 'th';\n            return number + output;\n        }\n    });\n\n// Side effect imports\n    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\n    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n\n    var mathAbs = Math.abs;\n\n    function abs () {\n        var data           = this._data;\n\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days         = mathAbs(this._days);\n        this._months       = mathAbs(this._months);\n\n        data.milliseconds  = mathAbs(data.milliseconds);\n        data.seconds       = mathAbs(data.seconds);\n        data.minutes       = mathAbs(data.minutes);\n        data.hours         = mathAbs(data.hours);\n        data.months        = mathAbs(data.months);\n        data.years         = mathAbs(data.years);\n\n        return this;\n    }\n\n    function addSubtract$1 (duration, input, value, direction) {\n        var other = createDuration(input, value);\n\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days         += direction * other._days;\n        duration._months       += direction * other._months;\n\n        return duration._bubble();\n    }\n\n// supports only 2.0-style add(1, 's') or add(duration)\n    function add$1 (input, value) {\n        return addSubtract$1(this, input, value, 1);\n    }\n\n// supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function subtract$1 (input, value) {\n        return addSubtract$1(this, input, value, -1);\n    }\n\n    function absCeil (number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n\n    function bubble () {\n        var milliseconds = this._milliseconds;\n        var days         = this._days;\n        var months       = this._months;\n        var data         = this._data;\n        var seconds, minutes, hours, years, monthsFromDays;\n\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n            (milliseconds <= 0 && days <= 0 && months <= 0))) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n\n        seconds           = absFloor(milliseconds / 1000);\n        data.seconds      = seconds % 60;\n\n        minutes           = absFloor(seconds / 60);\n        data.minutes      = minutes % 60;\n\n        hours             = absFloor(minutes / 60);\n        data.hours        = hours % 24;\n\n        days += absFloor(hours / 24);\n\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        data.days   = days;\n        data.months = months;\n        data.years  = years;\n\n        return this;\n    }\n\n    function daysToMonths (days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return days * 4800 / 146097;\n    }\n\n    function monthsToDays (months) {\n        // the reverse of daysToMonths\n        return months * 146097 / 4800;\n    }\n\n    function as (units) {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        var days;\n        var months;\n        var milliseconds = this._milliseconds;\n\n        units = normalizeUnits(units);\n\n        if (units === 'month' || units === 'year') {\n            days   = this._days   + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            return units === 'month' ? months : months / 12;\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch (units) {\n                case 'week'   : return days / 7     + milliseconds / 6048e5;\n                case 'day'    : return days         + milliseconds / 864e5;\n                case 'hour'   : return days * 24    + milliseconds / 36e5;\n                case 'minute' : return days * 1440  + milliseconds / 6e4;\n                case 'second' : return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n                default: throw new Error('Unknown unit ' + units);\n            }\n        }\n    }\n\n// TODO: Use this.as('ms')?\n    function valueOf$1 () {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        return (\n            this._milliseconds +\n            this._days * 864e5 +\n            (this._months % 12) * 2592e6 +\n            toInt(this._months / 12) * 31536e6\n        );\n    }\n\n    function makeAs (alias) {\n        return function () {\n            return this.as(alias);\n        };\n    }\n\n    var asMilliseconds = makeAs('ms');\n    var asSeconds      = makeAs('s');\n    var asMinutes      = makeAs('m');\n    var asHours        = makeAs('h');\n    var asDays         = makeAs('d');\n    var asWeeks        = makeAs('w');\n    var asMonths       = makeAs('M');\n    var asYears        = makeAs('y');\n\n    function get$2 (units) {\n        units = normalizeUnits(units);\n        return this.isValid() ? this[units + 's']() : NaN;\n    }\n\n    function makeGetter(name) {\n        return function () {\n            return this.isValid() ? this._data[name] : NaN;\n        };\n    }\n\n    var milliseconds = makeGetter('milliseconds');\n    var seconds      = makeGetter('seconds');\n    var minutes      = makeGetter('minutes');\n    var hours        = makeGetter('hours');\n    var days         = makeGetter('days');\n    var months       = makeGetter('months');\n    var years        = makeGetter('years');\n\n    function weeks () {\n        return absFloor(this.days() / 7);\n    }\n\n    var round = Math.round;\n    var thresholds = {\n        ss: 44,         // a few seconds to seconds\n        s : 45,         // seconds to minute\n        m : 45,         // minutes to hour\n        h : 22,         // hours to day\n        d : 26,         // days to month\n        M : 11          // months to year\n    };\n\n// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n\n    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {\n        var duration = createDuration(posNegDuration).abs();\n        var seconds  = round(duration.as('s'));\n        var minutes  = round(duration.as('m'));\n        var hours    = round(duration.as('h'));\n        var days     = round(duration.as('d'));\n        var months   = round(duration.as('M'));\n        var years    = round(duration.as('y'));\n\n        var a = seconds <= thresholds.ss && ['s', seconds]  ||\n            seconds < thresholds.s   && ['ss', seconds] ||\n            minutes <= 1             && ['m']           ||\n            minutes < thresholds.m   && ['mm', minutes] ||\n            hours   <= 1             && ['h']           ||\n            hours   < thresholds.h   && ['hh', hours]   ||\n            days    <= 1             && ['d']           ||\n            days    < thresholds.d   && ['dd', days]    ||\n            months  <= 1             && ['M']           ||\n            months  < thresholds.M   && ['MM', months]  ||\n            years   <= 1             && ['y']           || ['yy', years];\n\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n\n// This function allows you to set the rounding function for relative time strings\n    function getSetRelativeTimeRounding (roundingFunction) {\n        if (roundingFunction === undefined) {\n            return round;\n        }\n        if (typeof(roundingFunction) === 'function') {\n            round = roundingFunction;\n            return true;\n        }\n        return false;\n    }\n\n// This function allows you to set a threshold for relative time strings\n    function getSetRelativeTimeThreshold (threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        if (threshold === 's') {\n            thresholds.ss = limit - 1;\n        }\n        return true;\n    }\n\n    function humanize (withSuffix) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var locale = this.localeData();\n        var output = relativeTime$1(this, !withSuffix, locale);\n\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n\n        return locale.postformat(output);\n    }\n\n    var abs$1 = Math.abs;\n\n    function toISOString$1() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var seconds = abs$1(this._milliseconds) / 1000;\n        var days         = abs$1(this._days);\n        var months       = abs$1(this._months);\n        var minutes, hours, years;\n\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes           = absFloor(seconds / 60);\n        hours             = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n\n        // 12 months -> 1 year\n        years  = absFloor(months / 12);\n        months %= 12;\n\n\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        var Y = years;\n        var M = months;\n        var D = days;\n        var h = hours;\n        var m = minutes;\n        var s = seconds;\n        var total = this.asSeconds();\n\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return 'P0D';\n        }\n\n        return (total < 0 ? '-' : '') +\n            'P' +\n            (Y ? Y + 'Y' : '') +\n            (M ? M + 'M' : '') +\n            (D ? D + 'D' : '') +\n            ((h || m || s) ? 'T' : '') +\n            (h ? h + 'H' : '') +\n            (m ? m + 'M' : '') +\n            (s ? s + 'S' : '');\n    }\n\n    var proto$2 = Duration.prototype;\n\n    proto$2.isValid        = isValid$1;\n    proto$2.abs            = abs;\n    proto$2.add            = add$1;\n    proto$2.subtract       = subtract$1;\n    proto$2.as             = as;\n    proto$2.asMilliseconds = asMilliseconds;\n    proto$2.asSeconds      = asSeconds;\n    proto$2.asMinutes      = asMinutes;\n    proto$2.asHours        = asHours;\n    proto$2.asDays         = asDays;\n    proto$2.asWeeks        = asWeeks;\n    proto$2.asMonths       = asMonths;\n    proto$2.asYears        = asYears;\n    proto$2.valueOf        = valueOf$1;\n    proto$2._bubble        = bubble;\n    proto$2.get            = get$2;\n    proto$2.milliseconds   = milliseconds;\n    proto$2.seconds        = seconds;\n    proto$2.minutes        = minutes;\n    proto$2.hours          = hours;\n    proto$2.days           = days;\n    proto$2.weeks          = weeks;\n    proto$2.months         = months;\n    proto$2.years          = years;\n    proto$2.humanize       = humanize;\n    proto$2.toISOString    = toISOString$1;\n    proto$2.toString       = toISOString$1;\n    proto$2.toJSON         = toISOString$1;\n    proto$2.locale         = locale;\n    proto$2.localeData     = localeData;\n\n// Deprecations\n    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\n    proto$2.lang = lang;\n\n// Side effect imports\n\n// FORMATTING\n\n    addFormatToken('X', 0, 0, 'unix');\n    addFormatToken('x', 0, 0, 'valueOf');\n\n// PARSING\n\n    addRegexToken('x', matchSigned);\n    addRegexToken('X', matchTimestamp);\n    addParseToken('X', function (input, array, config) {\n        config._d = new Date(parseFloat(input, 10) * 1000);\n    });\n    addParseToken('x', function (input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n\n// Side effect imports\n\n\n    hooks.version = '2.18.1';\n\n    setHookCallback(createLocal);\n\n    hooks.fn                    = proto;\n    hooks.min                   = min;\n    hooks.max                   = max;\n    hooks.now                   = now;\n    hooks.utc                   = createUTC;\n    hooks.unix                  = createUnix;\n    hooks.months                = listMonths;\n    hooks.isDate                = isDate;\n    hooks.locale                = getSetGlobalLocale;\n    hooks.invalid               = createInvalid;\n    hooks.duration              = createDuration;\n    hooks.isMoment              = isMoment;\n    hooks.weekdays              = listWeekdays;\n    hooks.parseZone             = createInZone;\n    hooks.localeData            = getLocale;\n    hooks.isDuration            = isDuration;\n    hooks.monthsShort           = listMonthsShort;\n    hooks.weekdaysMin           = listWeekdaysMin;\n    hooks.defineLocale          = defineLocale;\n    hooks.updateLocale          = updateLocale;\n    hooks.locales               = listLocales;\n    hooks.weekdaysShort         = listWeekdaysShort;\n    hooks.normalizeUnits        = normalizeUnits;\n    hooks.relativeTimeRounding = getSetRelativeTimeRounding;\n    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n    hooks.calendarFormat        = getCalendarFormat;\n    hooks.prototype             = proto;\n\n    return hooks;\n\n})));","/**\n * Owl Carousel v2.2.1\n * Copyright 2013-2017 David Deutsch\n * Licensed under  ()\n */\n/**\n * Owl carousel\n * @version 2.1.6\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n * @todo Lazy Load Icon\n * @todo prevent animationend bubling\n * @todo itemsScaleUp\n * @todo Test Zepto\n * @todo stagePadding calculate wrong active classes\n */\n;(function($, window, document, undefined) {\n\n    /**\n     * Creates a carousel.\n     * @class The Owl Carousel.\n     * @public\n     * @param {HTMLElement|jQuery} element - The element to create the carousel for.\n     * @param {Object} [options] - The options\n     */\n    function Owl(element, options) {\n\n        /**\n         * Current settings for the carousel.\n         * @public\n         */\n        this.settings = null;\n\n        /**\n         * Current options set by the caller including defaults.\n         * @public\n         */\n        this.options = $.extend({}, Owl.Defaults, options);\n\n        /**\n         * Plugin element.\n         * @public\n         */\n        this.$element = $(element);\n\n        /**\n         * Proxied event handlers.\n         * @protected\n         */\n        this._handlers = {};\n\n        /**\n         * References to the running plugins of this carousel.\n         * @protected\n         */\n        this._plugins = {};\n\n        /**\n         * Currently suppressed events to prevent them from beeing retriggered.\n         * @protected\n         */\n        this._supress = {};\n\n        /**\n         * Absolute current position.\n         * @protected\n         */\n        this._current = null;\n\n        /**\n         * Animation speed in milliseconds.\n         * @protected\n         */\n        this._speed = null;\n\n        /**\n         * Coordinates of all items in pixel.\n         * @todo The name of this member is missleading.\n         * @protected\n         */\n        this._coordinates = [];\n\n        /**\n         * Current breakpoint.\n         * @todo Real media queries would be nice.\n         * @protected\n         */\n        this._breakpoint = null;\n\n        /**\n         * Current width of the plugin element.\n         */\n        this._width = null;\n\n        /**\n         * All real items.\n         * @protected\n         */\n        this._items = [];\n\n        /**\n         * All cloned items.\n         * @protected\n         */\n        this._clones = [];\n\n        /**\n         * Merge values of all items.\n         * @todo Maybe this could be part of a plugin.\n         * @protected\n         */\n        this._mergers = [];\n\n        /**\n         * Widths of all items.\n         */\n        this._widths = [];\n\n        /**\n         * Invalidated parts within the update process.\n         * @protected\n         */\n        this._invalidated = {};\n\n        /**\n         * Ordered list of workers for the update process.\n         * @protected\n         */\n        this._pipe = [];\n\n        /**\n         * Current state information for the drag operation.\n         * @todo #261\n         * @protected\n         */\n        this._drag = {\n            time: null,\n            target: null,\n            pointer: null,\n            stage: {\n                start: null,\n                current: null\n            },\n            direction: null\n        };\n\n        /**\n         * Current state information and their tags.\n         * @type {Object}\n         * @protected\n         */\n        this._states = {\n            current: {},\n            tags: {\n                'initializing': [ 'busy' ],\n                'animating': [ 'busy' ],\n                'dragging': [ 'interacting' ]\n            }\n        };\n\n        $.each([ 'onResize', 'onThrottledResize' ], $.proxy(function(i, handler) {\n            this._handlers[handler] = $.proxy(this[handler], this);\n        }, this));\n\n        $.each(Owl.Plugins, $.proxy(function(key, plugin) {\n            this._plugins[key.charAt(0).toLowerCase() + key.slice(1)]\n                = new plugin(this);\n        }, this));\n\n        $.each(Owl.Workers, $.proxy(function(priority, worker) {\n            this._pipe.push({\n                'filter': worker.filter,\n                'run': $.proxy(worker.run, this)\n            });\n        }, this));\n\n        this.setup();\n        this.initialize();\n    }\n\n    /**\n     * Default options for the carousel.\n     * @public\n     */\n    Owl.Defaults = {\n        items: 3,\n        loop: false,\n        center: false,\n        rewind: false,\n\n        mouseDrag: true,\n        touchDrag: true,\n        pullDrag: true,\n        freeDrag: false,\n\n        margin: 0,\n        stagePadding: 0,\n\n        merge: false,\n        mergeFit: true,\n        autoWidth: false,\n\n        startPosition: 0,\n        rtl: false,\n\n        smartSpeed: 250,\n        fluidSpeed: false,\n        dragEndSpeed: false,\n\n        responsive: {},\n        responsiveRefreshRate: 200,\n        responsiveBaseElement: window,\n\n        fallbackEasing: 'swing',\n\n        info: false,\n\n        nestedItemSelector: false,\n        itemElement: 'div',\n        stageElement: 'div',\n\n        refreshClass: 'owl-refresh',\n        loadedClass: 'owl-loaded',\n        loadingClass: 'owl-loading',\n        rtlClass: 'owl-rtl',\n        responsiveClass: 'owl-responsive',\n        dragClass: 'owl-drag',\n        itemClass: 'owl-item',\n        stageClass: 'owl-stage',\n        stageOuterClass: 'owl-stage-outer',\n        grabClass: 'owl-grab'\n    };\n\n    /**\n     * Enumeration for width.\n     * @public\n     * @readonly\n     * @enum {String}\n     */\n    Owl.Width = {\n        Default: 'default',\n        Inner: 'inner',\n        Outer: 'outer'\n    };\n\n    /**\n     * Enumeration for types.\n     * @public\n     * @readonly\n     * @enum {String}\n     */\n    Owl.Type = {\n        Event: 'event',\n        State: 'state'\n    };\n\n    /**\n     * Contains all registered plugins.\n     * @public\n     */\n    Owl.Plugins = {};\n\n    /**\n     * List of workers involved in the update process.\n     */\n    Owl.Workers = [ {\n        filter: [ 'width', 'settings' ],\n        run: function() {\n            this._width = this.$element.width();\n        }\n    }, {\n        filter: [ 'width', 'items', 'settings' ],\n        run: function(cache) {\n            cache.current = this._items && this._items[this.relative(this._current)];\n        }\n    }, {\n        filter: [ 'items', 'settings' ],\n        run: function() {\n            this.$stage.children('.cloned').remove();\n        }\n    }, {\n        filter: [ 'width', 'items', 'settings' ],\n        run: function(cache) {\n            var margin = this.settings.margin || '',\n                grid = !this.settings.autoWidth,\n                rtl = this.settings.rtl,\n                css = {\n                    'width': 'auto',\n                    'margin-left': rtl ? margin : '',\n                    'margin-right': rtl ? '' : margin\n                };\n\n            !grid && this.$stage.children().css(css);\n\n            cache.css = css;\n        }\n    }, {\n        filter: [ 'width', 'items', 'settings' ],\n        run: function(cache) {\n            var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,\n                merge = null,\n                iterator = this._items.length,\n                grid = !this.settings.autoWidth,\n                widths = [];\n\n            cache.items = {\n                merge: false,\n                width: width\n            };\n\n            while (iterator--) {\n                merge = this._mergers[iterator];\n                merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;\n\n                cache.items.merge = merge > 1 || cache.items.merge;\n\n                widths[iterator] = !grid ? this._items[iterator].width() : width * merge;\n            }\n\n            this._widths = widths;\n        }\n    }, {\n        filter: [ 'items', 'settings' ],\n        run: function() {\n            var clones = [],\n                items = this._items,\n                settings = this.settings,\n                // TODO: Should be computed from number of min width items in stage\n                view = Math.max(settings.items * 2, 4),\n                size = Math.ceil(items.length / 2) * 2,\n                repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,\n                append = '',\n                prepend = '';\n\n            repeat /= 2;\n\n            while (repeat--) {\n                // Switch to only using appended clones\n                clones.push(this.normalize(clones.length / 2, true));\n                append = append + items[clones[clones.length - 1]][0].outerHTML;\n                clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));\n                prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;\n            }\n\n            this._clones = clones;\n\n            $(append).addClass('cloned').appendTo(this.$stage);\n            $(prepend).addClass('cloned').prependTo(this.$stage);\n        }\n    }, {\n        filter: [ 'width', 'items', 'settings' ],\n        run: function() {\n            var rtl = this.settings.rtl ? 1 : -1,\n                size = this._clones.length + this._items.length,\n                iterator = -1,\n                previous = 0,\n                current = 0,\n                coordinates = [];\n\n            while (++iterator < size) {\n                previous = coordinates[iterator - 1] || 0;\n                current = this._widths[this.relative(iterator)] + this.settings.margin;\n                coordinates.push(previous + current * rtl);\n            }\n\n            this._coordinates = coordinates;\n        }\n    }, {\n        filter: [ 'width', 'items', 'settings' ],\n        run: function() {\n            var padding = this.settings.stagePadding,\n                coordinates = this._coordinates,\n                css = {\n                    'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,\n                    'padding-left': padding || '',\n                    'padding-right': padding || ''\n                };\n\n            this.$stage.css(css);\n        }\n    }, {\n        filter: [ 'width', 'items', 'settings' ],\n        run: function(cache) {\n            var iterator = this._coordinates.length,\n                grid = !this.settings.autoWidth,\n                items = this.$stage.children();\n\n            if (grid && cache.items.merge) {\n                while (iterator--) {\n                    cache.css.width = this._widths[this.relative(iterator)];\n                    items.eq(iterator).css(cache.css);\n                }\n            } else if (grid) {\n                cache.css.width = cache.items.width;\n                items.css(cache.css);\n            }\n        }\n    }, {\n        filter: [ 'items' ],\n        run: function() {\n            this._coordinates.length < 1 && this.$stage.removeAttr('style');\n        }\n    }, {\n        filter: [ 'width', 'items', 'settings' ],\n        run: function(cache) {\n            cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;\n            cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));\n            this.reset(cache.current);\n        }\n    }, {\n        filter: [ 'position' ],\n        run: function() {\n            this.animate(this.coordinates(this._current));\n        }\n    }, {\n        filter: [ 'width', 'position', 'items', 'settings' ],\n        run: function() {\n            var rtl = this.settings.rtl ? 1 : -1,\n                padding = this.settings.stagePadding * 2,\n                begin = this.coordinates(this.current()) + padding,\n                end = begin + this.width() * rtl,\n                inner, outer, matches = [], i, n;\n\n            for (i = 0, n = this._coordinates.length; i < n; i++) {\n                inner = this._coordinates[i - 1] || 0;\n                outer = Math.abs(this._coordinates[i]) + padding * rtl;\n\n                if ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))\n                    || (this.op(outer, '<', begin) && this.op(outer, '>', end))) {\n                    matches.push(i);\n                }\n            }\n\n            this.$stage.children('.active').removeClass('active');\n            this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');\n\n            if (this.settings.center) {\n                this.$stage.children('.center').removeClass('center');\n                this.$stage.children().eq(this.current()).addClass('center');\n            }\n        }\n    } ];\n\n    /**\n     * Initializes the carousel.\n     * @protected\n     */\n    Owl.prototype.initialize = function() {\n        this.enter('initializing');\n        this.trigger('initialize');\n\n        this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);\n\n        if (this.settings.autoWidth && !this.is('pre-loading')) {\n            var imgs, nestedSelector, width;\n            imgs = this.$element.find('img');\n            nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;\n            width = this.$element.children(nestedSelector).width();\n\n            if (imgs.length && width <= 0) {\n                this.preloadAutoWidthImages(imgs);\n            }\n        }\n\n        this.$element.addClass(this.options.loadingClass);\n\n        // create stage\n        this.$stage = $('<' + this.settings.stageElement + ' class=\"' + this.settings.stageClass + '\"/>')\n            .wrap('<div class=\"' + this.settings.stageOuterClass + '\"/>');\n\n        // append stage\n        this.$element.append(this.$stage.parent());\n\n        // append content\n        this.replace(this.$element.children().not(this.$stage.parent()));\n\n        // check visibility\n        if (this.$element.is(':visible')) {\n            // update view\n            this.refresh();\n        } else {\n            // invalidate width\n            this.invalidate('width');\n        }\n\n        this.$element\n            .removeClass(this.options.loadingClass)\n            .addClass(this.options.loadedClass);\n\n        // register event handlers\n        this.registerEventHandlers();\n\n        this.leave('initializing');\n        this.trigger('initialized');\n    };\n\n    /**\n     * Setups the current settings.\n     * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?\n     * @todo Support for media queries by using `matchMedia` would be nice.\n     * @public\n     */\n    Owl.prototype.setup = function() {\n        var viewport = this.viewport(),\n            overwrites = this.options.responsive,\n            match = -1,\n            settings = null;\n\n        if (!overwrites) {\n            settings = $.extend({}, this.options);\n        } else {\n            $.each(overwrites, function(breakpoint) {\n                if (breakpoint <= viewport && breakpoint > match) {\n                    match = Number(breakpoint);\n                }\n            });\n\n            settings = $.extend({}, this.options, overwrites[match]);\n            if (typeof settings.stagePadding === 'function') {\n                settings.stagePadding = settings.stagePadding();\n            }\n            delete settings.responsive;\n\n            // responsive class\n            if (settings.responsiveClass) {\n                this.$element.attr('class',\n                    this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\\\S+\\\\s', 'g'), '$1' + match)\n                );\n            }\n        }\n\n        this.trigger('change', { property: { name: 'settings', value: settings } });\n        this._breakpoint = match;\n        this.settings = settings;\n        this.invalidate('settings');\n        this.trigger('changed', { property: { name: 'settings', value: this.settings } });\n    };\n\n    /**\n     * Updates option logic if necessery.\n     * @protected\n     */\n    Owl.prototype.optionsLogic = function() {\n        if (this.settings.autoWidth) {\n            this.settings.stagePadding = false;\n            this.settings.merge = false;\n        }\n    };\n\n    /**\n     * Prepares an item before add.\n     * @todo Rename event parameter `content` to `item`.\n     * @protected\n     * @returns {jQuery|HTMLElement} - The item container.\n     */\n    Owl.prototype.prepare = function(item) {\n        var event = this.trigger('prepare', { content: item });\n\n        if (!event.data) {\n            event.data = $('<' + this.settings.itemElement + '/>')\n                .addClass(this.options.itemClass).append(item)\n        }\n\n        this.trigger('prepared', { content: event.data });\n\n        return event.data;\n    };\n\n    /**\n     * Updates the view.\n     * @public\n     */\n    Owl.prototype.update = function() {\n        var i = 0,\n            n = this._pipe.length,\n            filter = $.proxy(function(p) { return this[p] }, this._invalidated),\n            cache = {};\n\n        while (i < n) {\n            if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {\n                this._pipe[i].run(cache);\n            }\n            i++;\n        }\n\n        this._invalidated = {};\n\n        !this.is('valid') && this.enter('valid');\n    };\n\n    /**\n     * Gets the width of the view.\n     * @public\n     * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.\n     * @returns {Number} - The width of the view in pixel.\n     */\n    Owl.prototype.width = function(dimension) {\n        dimension = dimension || Owl.Width.Default;\n        switch (dimension) {\n            case Owl.Width.Inner:\n            case Owl.Width.Outer:\n                return this._width;\n            default:\n                return this._width - this.settings.stagePadding * 2 + this.settings.margin;\n        }\n    };\n\n    /**\n     * Refreshes the carousel primarily for adaptive purposes.\n     * @public\n     */\n    Owl.prototype.refresh = function() {\n        this.enter('refreshing');\n        this.trigger('refresh');\n\n        this.setup();\n\n        this.optionsLogic();\n\n        this.$element.addClass(this.options.refreshClass);\n\n        this.update();\n\n        this.$element.removeClass(this.options.refreshClass);\n\n        this.leave('refreshing');\n        this.trigger('refreshed');\n    };\n\n    /**\n     * Checks window `resize` event.\n     * @protected\n     */\n    Owl.prototype.onThrottledResize = function() {\n        window.clearTimeout(this.resizeTimer);\n        this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);\n    };\n\n    /**\n     * Checks window `resize` event.\n     * @protected\n     */\n    Owl.prototype.onResize = function() {\n        if (!this._items.length) {\n            return false;\n        }\n\n        if (this._width === this.$element.width()) {\n            return false;\n        }\n\n        if (!this.$element.is(':visible')) {\n            return false;\n        }\n\n        this.enter('resizing');\n\n        if (this.trigger('resize').isDefaultPrevented()) {\n            this.leave('resizing');\n            return false;\n        }\n\n        this.invalidate('width');\n\n        this.refresh();\n\n        this.leave('resizing');\n        this.trigger('resized');\n    };\n\n    /**\n     * Registers event handlers.\n     * @todo Check `msPointerEnabled`\n     * @todo #261\n     * @protected\n     */\n    Owl.prototype.registerEventHandlers = function() {\n        if ($.support.transition) {\n            this.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));\n        }\n\n        if (this.settings.responsive !== false) {\n            this.on(window, 'resize', this._handlers.onThrottledResize);\n        }\n\n        if (this.settings.mouseDrag) {\n            this.$element.addClass(this.options.dragClass);\n            this.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));\n            this.$stage.on('dragstart.owl.core selectstart.owl.core', function() { return false });\n        }\n\n        if (this.settings.touchDrag){\n            this.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));\n            this.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));\n        }\n    };\n\n    /**\n     * Handles `touchstart` and `mousedown` events.\n     * @todo Horizontal swipe threshold as option\n     * @todo #261\n     * @protected\n     * @param {Event} event - The event arguments.\n     */\n    Owl.prototype.onDragStart = function(event) {\n        var stage = null;\n\n        if (event.which === 3) {\n            return;\n        }\n\n        if ($.support.transform) {\n            stage = this.$stage.css('transform').replace(/.*\\(|\\)| /g, '').split(',');\n            stage = {\n                x: stage[stage.length === 16 ? 12 : 4],\n                y: stage[stage.length === 16 ? 13 : 5]\n            };\n        } else {\n            stage = this.$stage.position();\n            stage = {\n                x: this.settings.rtl ?\n                stage.left + this.$stage.width() - this.width() + this.settings.margin :\n                    stage.left,\n                y: stage.top\n            };\n        }\n\n        if (this.is('animating')) {\n            $.support.transform ? this.animate(stage.x) : this.$stage.stop()\n            this.invalidate('position');\n        }\n\n        this.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');\n\n        this.speed(0);\n\n        this._drag.time = new Date().getTime();\n        this._drag.target = $(event.target);\n        this._drag.stage.start = stage;\n        this._drag.stage.current = stage;\n        this._drag.pointer = this.pointer(event);\n\n        $(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));\n\n        $(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {\n            var delta = this.difference(this._drag.pointer, this.pointer(event));\n\n            $(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));\n\n            if (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {\n                return;\n            }\n\n            event.preventDefault();\n\n            this.enter('dragging');\n            this.trigger('drag');\n        }, this));\n    };\n\n    /**\n     * Handles the `touchmove` and `mousemove` events.\n     * @todo #261\n     * @protected\n     * @param {Event} event - The event arguments.\n     */\n    Owl.prototype.onDragMove = function(event) {\n        var minimum = null,\n            maximum = null,\n            pull = null,\n            delta = this.difference(this._drag.pointer, this.pointer(event)),\n            stage = this.difference(this._drag.stage.start, delta);\n\n        if (!this.is('dragging')) {\n            return;\n        }\n\n        event.preventDefault();\n\n        if (this.settings.loop) {\n            minimum = this.coordinates(this.minimum());\n            maximum = this.coordinates(this.maximum() + 1) - minimum;\n            stage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;\n        } else {\n            minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());\n            maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());\n            pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;\n            stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);\n        }\n\n        this._drag.stage.current = stage;\n\n        this.animate(stage.x);\n    };\n\n    /**\n     * Handles the `touchend` and `mouseup` events.\n     * @todo #261\n     * @todo Threshold for click event\n     * @protected\n     * @param {Event} event - The event arguments.\n     */\n    Owl.prototype.onDragEnd = function(event) {\n        var delta = this.difference(this._drag.pointer, this.pointer(event)),\n            stage = this._drag.stage.current,\n            direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';\n\n        $(document).off('.owl.core');\n\n        this.$element.removeClass(this.options.grabClass);\n\n        if (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {\n            this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);\n            this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));\n            this.invalidate('position');\n            this.update();\n\n            this._drag.direction = direction;\n\n            if (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {\n                this._drag.target.one('click.owl.core', function() { return false; });\n            }\n        }\n\n        if (!this.is('dragging')) {\n            return;\n        }\n\n        this.leave('dragging');\n        this.trigger('dragged');\n    };\n\n    /**\n     * Gets absolute position of the closest item for a coordinate.\n     * @todo Setting `freeDrag` makes `closest` not reusable. See #165.\n     * @protected\n     * @param {Number} coordinate - The coordinate in pixel.\n     * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.\n     * @return {Number} - The absolute position of the closest item.\n     */\n    Owl.prototype.closest = function(coordinate, direction) {\n        var position = -1,\n            pull = 30,\n            width = this.width(),\n            coordinates = this.coordinates();\n\n        if (!this.settings.freeDrag) {\n            // check closest item\n            $.each(coordinates, $.proxy(function(index, value) {\n                // on a left pull, check on current index\n                if (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {\n                    position = index;\n                    // on a right pull, check on previous index\n                    // to do so, subtract width from value and set position = index + 1\n                } else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {\n                    position = index + 1;\n                } else if (this.op(coordinate, '<', value)\n                    && this.op(coordinate, '>', coordinates[index + 1] || value - width)) {\n                    position = direction === 'left' ? index + 1 : index;\n                }\n                return position === -1;\n            }, this));\n        }\n\n        if (!this.settings.loop) {\n            // non loop boundries\n            if (this.op(coordinate, '>', coordinates[this.minimum()])) {\n                position = coordinate = this.minimum();\n            } else if (this.op(coordinate, '<', coordinates[this.maximum()])) {\n                position = coordinate = this.maximum();\n            }\n        }\n\n        return position;\n    };\n\n    /**\n     * Animates the stage.\n     * @todo #270\n     * @public\n     * @param {Number} coordinate - The coordinate in pixels.\n     */\n    Owl.prototype.animate = function(coordinate) {\n        var animate = this.speed() > 0;\n\n        this.is('animating') && this.onTransitionEnd();\n\n        if (animate) {\n            this.enter('animating');\n            this.trigger('translate');\n        }\n\n        if ($.support.transform3d && $.support.transition) {\n            this.$stage.css({\n                transform: 'translate3d(' + coordinate + 'px,0px,0px)',\n                transition: (this.speed() / 1000) + 's'\n            });\n        } else if (animate) {\n            this.$stage.animate({\n                left: coordinate + 'px'\n            }, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));\n        } else {\n            this.$stage.css({\n                left: coordinate + 'px'\n            });\n        }\n    };\n\n    /**\n     * Checks whether the carousel is in a specific state or not.\n     * @param {String} state - The state to check.\n     * @returns {Boolean} - The flag which indicates if the carousel is busy.\n     */\n    Owl.prototype.is = function(state) {\n        return this._states.current[state] && this._states.current[state] > 0;\n    };\n\n    /**\n     * Sets the absolute position of the current item.\n     * @public\n     * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.\n     * @returns {Number} - The absolute position of the current item.\n     */\n    Owl.prototype.current = function(position) {\n        if (position === undefined) {\n            return this._current;\n        }\n\n        if (this._items.length === 0) {\n            return undefined;\n        }\n\n        position = this.normalize(position);\n\n        if (this._current !== position) {\n            var event = this.trigger('change', { property: { name: 'position', value: position } });\n\n            if (event.data !== undefined) {\n                position = this.normalize(event.data);\n            }\n\n            this._current = position;\n\n            this.invalidate('position');\n\n            this.trigger('changed', { property: { name: 'position', value: this._current } });\n        }\n\n        return this._current;\n    };\n\n    /**\n     * Invalidates the given part of the update routine.\n     * @param {String} [part] - The part to invalidate.\n     * @returns {Array.<String>} - The invalidated parts.\n     */\n    Owl.prototype.invalidate = function(part) {\n        if ($.type(part) === 'string') {\n            this._invalidated[part] = true;\n            this.is('valid') && this.leave('valid');\n        }\n        return $.map(this._invalidated, function(v, i) { return i });\n    };\n\n    /**\n     * Resets the absolute position of the current item.\n     * @public\n     * @param {Number} position - The absolute position of the new item.\n     */\n    Owl.prototype.reset = function(position) {\n        position = this.normalize(position);\n\n        if (position === undefined) {\n            return;\n        }\n\n        this._speed = 0;\n        this._current = position;\n\n        this.suppress([ 'translate', 'translated' ]);\n\n        this.animate(this.coordinates(position));\n\n        this.release([ 'translate', 'translated' ]);\n    };\n\n    /**\n     * Normalizes an absolute or a relative position of an item.\n     * @public\n     * @param {Number} position - The absolute or relative position to normalize.\n     * @param {Boolean} [relative=false] - Whether the given position is relative or not.\n     * @returns {Number} - The normalized position.\n     */\n    Owl.prototype.normalize = function(position, relative) {\n        var n = this._items.length,\n            m = relative ? 0 : this._clones.length;\n\n        if (!this.isNumeric(position) || n < 1) {\n            position = undefined;\n        } else if (position < 0 || position >= n + m) {\n            position = ((position - m / 2) % n + n) % n + m / 2;\n        }\n\n        return position;\n    };\n\n    /**\n     * Converts an absolute position of an item into a relative one.\n     * @public\n     * @param {Number} position - The absolute position to convert.\n     * @returns {Number} - The converted position.\n     */\n    Owl.prototype.relative = function(position) {\n        position -= this._clones.length / 2;\n        return this.normalize(position, true);\n    };\n\n    /**\n     * Gets the maximum position for the current item.\n     * @public\n     * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n     * @returns {Number}\n     */\n    Owl.prototype.maximum = function(relative) {\n        var settings = this.settings,\n            maximum = this._coordinates.length,\n            iterator,\n            reciprocalItemsWidth,\n            elementWidth;\n\n        if (settings.loop) {\n            maximum = this._clones.length / 2 + this._items.length - 1;\n        } else if (settings.autoWidth || settings.merge) {\n            iterator = this._items.length;\n            reciprocalItemsWidth = this._items[--iterator].width();\n            elementWidth = this.$element.width();\n            while (iterator--) {\n                reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;\n                if (reciprocalItemsWidth > elementWidth) {\n                    break;\n                }\n            }\n            maximum = iterator + 1;\n        } else if (settings.center) {\n            maximum = this._items.length - 1;\n        } else {\n            maximum = this._items.length - settings.items;\n        }\n\n        if (relative) {\n            maximum -= this._clones.length / 2;\n        }\n\n        return Math.max(maximum, 0);\n    };\n\n    /**\n     * Gets the minimum position for the current item.\n     * @public\n     * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n     * @returns {Number}\n     */\n    Owl.prototype.minimum = function(relative) {\n        return relative ? 0 : this._clones.length / 2;\n    };\n\n    /**\n     * Gets an item at the specified relative position.\n     * @public\n     * @param {Number} [position] - The relative position of the item.\n     * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n     */\n    Owl.prototype.items = function(position) {\n        if (position === undefined) {\n            return this._items.slice();\n        }\n\n        position = this.normalize(position, true);\n        return this._items[position];\n    };\n\n    /**\n     * Gets an item at the specified relative position.\n     * @public\n     * @param {Number} [position] - The relative position of the item.\n     * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n     */\n    Owl.prototype.mergers = function(position) {\n        if (position === undefined) {\n            return this._mergers.slice();\n        }\n\n        position = this.normalize(position, true);\n        return this._mergers[position];\n    };\n\n    /**\n     * Gets the absolute positions of clones for an item.\n     * @public\n     * @param {Number} [position] - The relative position of the item.\n     * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.\n     */\n    Owl.prototype.clones = function(position) {\n        var odd = this._clones.length / 2,\n            even = odd + this._items.length,\n            map = function(index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };\n\n        if (position === undefined) {\n            return $.map(this._clones, function(v, i) { return map(i) });\n        }\n\n        return $.map(this._clones, function(v, i) { return v === position ? map(i) : null });\n    };\n\n    /**\n     * Sets the current animation speed.\n     * @public\n     * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.\n     * @returns {Number} - The current animation speed in milliseconds.\n     */\n    Owl.prototype.speed = function(speed) {\n        if (speed !== undefined) {\n            this._speed = speed;\n        }\n\n        return this._speed;\n    };\n\n    /**\n     * Gets the coordinate of an item.\n     * @todo The name of this method is missleanding.\n     * @public\n     * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.\n     * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.\n     */\n    Owl.prototype.coordinates = function(position) {\n        var multiplier = 1,\n            newPosition = position - 1,\n            coordinate;\n\n        if (position === undefined) {\n            return $.map(this._coordinates, $.proxy(function(coordinate, index) {\n                return this.coordinates(index);\n            }, this));\n        }\n\n        if (this.settings.center) {\n            if (this.settings.rtl) {\n                multiplier = -1;\n                newPosition = position + 1;\n            }\n\n            coordinate = this._coordinates[position];\n            coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;\n        } else {\n            coordinate = this._coordinates[newPosition] || 0;\n        }\n\n        coordinate = Math.ceil(coordinate);\n\n        return coordinate;\n    };\n\n    /**\n     * Calculates the speed for a translation.\n     * @protected\n     * @param {Number} from - The absolute position of the start item.\n     * @param {Number} to - The absolute position of the target item.\n     * @param {Number} [factor=undefined] - The time factor in milliseconds.\n     * @returns {Number} - The time in milliseconds for the translation.\n     */\n    Owl.prototype.duration = function(from, to, factor) {\n        if (factor === 0) {\n            return 0;\n        }\n\n        return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));\n    };\n\n    /**\n     * Slides to the specified item.\n     * @public\n     * @param {Number} position - The position of the item.\n     * @param {Number} [speed] - The time in milliseconds for the transition.\n     */\n    Owl.prototype.to = function(position, speed) {\n        var current = this.current(),\n            revert = null,\n            distance = position - this.relative(current),\n            direction = (distance > 0) - (distance < 0),\n            items = this._items.length,\n            minimum = this.minimum(),\n            maximum = this.maximum();\n\n        if (this.settings.loop) {\n            if (!this.settings.rewind && Math.abs(distance) > items / 2) {\n                distance += direction * -1 * items;\n            }\n\n            position = current + distance;\n            revert = ((position - minimum) % items + items) % items + minimum;\n\n            if (revert !== position && revert - distance <= maximum && revert - distance > 0) {\n                current = revert - distance;\n                position = revert;\n                this.reset(current);\n            }\n        } else if (this.settings.rewind) {\n            maximum += 1;\n            position = (position % maximum + maximum) % maximum;\n        } else {\n            position = Math.max(minimum, Math.min(maximum, position));\n        }\n\n        this.speed(this.duration(current, position, speed));\n        this.current(position);\n\n        if (this.$element.is(':visible')) {\n            this.update();\n        }\n    };\n\n    /**\n     * Slides to the next item.\n     * @public\n     * @param {Number} [speed] - The time in milliseconds for the transition.\n     */\n    Owl.prototype.next = function(speed) {\n        speed = speed || false;\n        this.to(this.relative(this.current()) + 1, speed);\n    };\n\n    /**\n     * Slides to the previous item.\n     * @public\n     * @param {Number} [speed] - The time in milliseconds for the transition.\n     */\n    Owl.prototype.prev = function(speed) {\n        speed = speed || false;\n        this.to(this.relative(this.current()) - 1, speed);\n    };\n\n    /**\n     * Handles the end of an animation.\n     * @protected\n     * @param {Event} event - The event arguments.\n     */\n    Owl.prototype.onTransitionEnd = function(event) {\n\n        // if css2 animation then event object is undefined\n        if (event !== undefined) {\n            event.stopPropagation();\n\n            // Catch only owl-stage transitionEnd event\n            if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {\n                return false;\n            }\n        }\n\n        this.leave('animating');\n        this.trigger('translated');\n    };\n\n    /**\n     * Gets viewport width.\n     * @protected\n     * @return {Number} - The width in pixel.\n     */\n    Owl.prototype.viewport = function() {\n        var width;\n        if (this.options.responsiveBaseElement !== window) {\n            width = $(this.options.responsiveBaseElement).width();\n        } else if (window.innerWidth) {\n            width = window.innerWidth;\n        } else if (document.documentElement && document.documentElement.clientWidth) {\n            width = document.documentElement.clientWidth;\n        } else {\n            console.warn('Can not detect viewport width.');\n        }\n        return width;\n    };\n\n    /**\n     * Replaces the current content.\n     * @public\n     * @param {HTMLElement|jQuery|String} content - The new content.\n     */\n    Owl.prototype.replace = function(content) {\n        this.$stage.empty();\n        this._items = [];\n\n        if (content) {\n            content = (content instanceof jQuery) ? content : $(content);\n        }\n\n        if (this.settings.nestedItemSelector) {\n            content = content.find('.' + this.settings.nestedItemSelector);\n        }\n\n        content.filter(function() {\n            return this.nodeType === 1;\n        }).each($.proxy(function(index, item) {\n            item = this.prepare(item);\n            this.$stage.append(item);\n            this._items.push(item);\n            this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n        }, this));\n\n        this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);\n\n        this.invalidate('items');\n    };\n\n    /**\n     * Adds an item.\n     * @todo Use `item` instead of `content` for the event arguments.\n     * @public\n     * @param {HTMLElement|jQuery|String} content - The item content to add.\n     * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.\n     */\n    Owl.prototype.add = function(content, position) {\n        var current = this.relative(this._current);\n\n        position = position === undefined ? this._items.length : this.normalize(position, true);\n        content = content instanceof jQuery ? content : $(content);\n\n        this.trigger('add', { content: content, position: position });\n\n        content = this.prepare(content);\n\n        if (this._items.length === 0 || position === this._items.length) {\n            this._items.length === 0 && this.$stage.append(content);\n            this._items.length !== 0 && this._items[position - 1].after(content);\n            this._items.push(content);\n            this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n        } else {\n            this._items[position].before(content);\n            this._items.splice(position, 0, content);\n            this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n        }\n\n        this._items[current] && this.reset(this._items[current].index());\n\n        this.invalidate('items');\n\n        this.trigger('added', { content: content, position: position });\n    };\n\n    /**\n     * Removes an item by its position.\n     * @todo Use `item` instead of `content` for the event arguments.\n     * @public\n     * @param {Number} position - The relative position of the item to remove.\n     */\n    Owl.prototype.remove = function(position) {\n        position = this.normalize(position, true);\n\n        if (position === undefined) {\n            return;\n        }\n\n        this.trigger('remove', { content: this._items[position], position: position });\n\n        this._items[position].remove();\n        this._items.splice(position, 1);\n        this._mergers.splice(position, 1);\n\n        this.invalidate('items');\n\n        this.trigger('removed', { content: null, position: position });\n    };\n\n    /**\n     * Preloads images with auto width.\n     * @todo Replace by a more generic approach\n     * @protected\n     */\n    Owl.prototype.preloadAutoWidthImages = function(images) {\n        images.each($.proxy(function(i, element) {\n            this.enter('pre-loading');\n            element = $(element);\n            $(new Image()).one('load', $.proxy(function(e) {\n                element.attr('src', e.target.src);\n                element.css('opacity', 1);\n                this.leave('pre-loading');\n                !this.is('pre-loading') && !this.is('initializing') && this.refresh();\n            }, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));\n        }, this));\n    };\n\n    /**\n     * Destroys the carousel.\n     * @public\n     */\n    Owl.prototype.destroy = function() {\n\n        this.$element.off('.owl.core');\n        this.$stage.off('.owl.core');\n        $(document).off('.owl.core');\n\n        if (this.settings.responsive !== false) {\n            window.clearTimeout(this.resizeTimer);\n            this.off(window, 'resize', this._handlers.onThrottledResize);\n        }\n\n        for (var i in this._plugins) {\n            this._plugins[i].destroy();\n        }\n\n        this.$stage.children('.cloned').remove();\n\n        this.$stage.unwrap();\n        this.$stage.children().contents().unwrap();\n        this.$stage.children().unwrap();\n\n        this.$element\n            .removeClass(this.options.refreshClass)\n            .removeClass(this.options.loadingClass)\n            .removeClass(this.options.loadedClass)\n            .removeClass(this.options.rtlClass)\n            .removeClass(this.options.dragClass)\n            .removeClass(this.options.grabClass)\n            .attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\\\S+\\\\s', 'g'), ''))\n            .removeData('owl.carousel');\n    };\n\n    /**\n     * Operators to calculate right-to-left and left-to-right.\n     * @protected\n     * @param {Number} [a] - The left side operand.\n     * @param {String} [o] - The operator.\n     * @param {Number} [b] - The right side operand.\n     */\n    Owl.prototype.op = function(a, o, b) {\n        var rtl = this.settings.rtl;\n        switch (o) {\n            case '<':\n                return rtl ? a > b : a < b;\n            case '>':\n                return rtl ? a < b : a > b;\n            case '>=':\n                return rtl ? a <= b : a >= b;\n            case '<=':\n                return rtl ? a >= b : a <= b;\n            default:\n                break;\n        }\n    };\n\n    /**\n     * Attaches to an internal event.\n     * @protected\n     * @param {HTMLElement} element - The event source.\n     * @param {String} event - The event name.\n     * @param {Function} listener - The event handler to attach.\n     * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.\n     */\n    Owl.prototype.on = function(element, event, listener, capture) {\n        if (element.addEventListener) {\n            element.addEventListener(event, listener, capture);\n        } else if (element.attachEvent) {\n            element.attachEvent('on' + event, listener);\n        }\n    };\n\n    /**\n     * Detaches from an internal event.\n     * @protected\n     * @param {HTMLElement} element - The event source.\n     * @param {String} event - The event name.\n     * @param {Function} listener - The attached event handler to detach.\n     * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.\n     */\n    Owl.prototype.off = function(element, event, listener, capture) {\n        if (element.removeEventListener) {\n            element.removeEventListener(event, listener, capture);\n        } else if (element.detachEvent) {\n            element.detachEvent('on' + event, listener);\n        }\n    };\n\n    /**\n     * Triggers a public event.\n     * @todo Remove `status`, `relatedTarget` should be used instead.\n     * @protected\n     * @param {String} name - The event name.\n     * @param {*} [data=null] - The event data.\n     * @param {String} [namespace=carousel] - The event namespace.\n     * @param {String} [state] - The state which is associated with the event.\n     * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.\n     * @returns {Event} - The event arguments.\n     */\n    Owl.prototype.trigger = function(name, data, namespace, state, enter) {\n        var status = {\n            item: { count: this._items.length, index: this.current() }\n        }, handler = $.camelCase(\n            $.grep([ 'on', name, namespace ], function(v) { return v })\n                .join('-').toLowerCase()\n        ), event = $.Event(\n            [ name, 'owl', namespace || 'carousel' ].join('.').toLowerCase(),\n            $.extend({ relatedTarget: this }, status, data)\n        );\n\n        if (!this._supress[name]) {\n            $.each(this._plugins, function(name, plugin) {\n                if (plugin.onTrigger) {\n                    plugin.onTrigger(event);\n                }\n            });\n\n            this.register({ type: Owl.Type.Event, name: name });\n            this.$element.trigger(event);\n\n            if (this.settings && typeof this.settings[handler] === 'function') {\n                this.settings[handler].call(this, event);\n            }\n        }\n\n        return event;\n    };\n\n    /**\n     * Enters a state.\n     * @param name - The state name.\n     */\n    Owl.prototype.enter = function(name) {\n        $.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\n            if (this._states.current[name] === undefined) {\n                this._states.current[name] = 0;\n            }\n\n            this._states.current[name]++;\n        }, this));\n    };\n\n    /**\n     * Leaves a state.\n     * @param name - The state name.\n     */\n    Owl.prototype.leave = function(name) {\n        $.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\n            this._states.current[name]--;\n        }, this));\n    };\n\n    /**\n     * Registers an event or state.\n     * @public\n     * @param {Object} object - The event or state to register.\n     */\n    Owl.prototype.register = function(object) {\n        if (object.type === Owl.Type.Event) {\n            if (!$.event.special[object.name]) {\n                $.event.special[object.name] = {};\n            }\n\n            if (!$.event.special[object.name].owl) {\n                var _default = $.event.special[object.name]._default;\n                $.event.special[object.name]._default = function(e) {\n                    if (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {\n                        return _default.apply(this, arguments);\n                    }\n                    return e.namespace && e.namespace.indexOf('owl') > -1;\n                };\n                $.event.special[object.name].owl = true;\n            }\n        } else if (object.type === Owl.Type.State) {\n            if (!this._states.tags[object.name]) {\n                this._states.tags[object.name] = object.tags;\n            } else {\n                this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);\n            }\n\n            this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {\n                return $.inArray(tag, this._states.tags[object.name]) === i;\n            }, this));\n        }\n    };\n\n    /**\n     * Suppresses events.\n     * @protected\n     * @param {Array.<String>} events - The events to suppress.\n     */\n    Owl.prototype.suppress = function(events) {\n        $.each(events, $.proxy(function(index, event) {\n            this._supress[event] = true;\n        }, this));\n    };\n\n    /**\n     * Releases suppressed events.\n     * @protected\n     * @param {Array.<String>} events - The events to release.\n     */\n    Owl.prototype.release = function(events) {\n        $.each(events, $.proxy(function(index, event) {\n            delete this._supress[event];\n        }, this));\n    };\n\n    /**\n     * Gets unified pointer coordinates from event.\n     * @todo #261\n     * @protected\n     * @param {Event} - The `mousedown` or `touchstart` event.\n     * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.\n     */\n    Owl.prototype.pointer = function(event) {\n        var result = { x: null, y: null };\n\n        event = event.originalEvent || event || window.event;\n\n        event = event.touches && event.touches.length ?\n            event.touches[0] : event.changedTouches && event.changedTouches.length ?\n            event.changedTouches[0] : event;\n\n        if (event.pageX) {\n            result.x = event.pageX;\n            result.y = event.pageY;\n        } else {\n            result.x = event.clientX;\n            result.y = event.clientY;\n        }\n\n        return result;\n    };\n\n    /**\n     * Determines if the input is a Number or something that can be coerced to a Number\n     * @protected\n     * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested\n     * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number\n     */\n    Owl.prototype.isNumeric = function(number) {\n        return !isNaN(parseFloat(number));\n    };\n\n    /**\n     * Gets the difference of two vectors.\n     * @todo #261\n     * @protected\n     * @param {Object} - The first vector.\n     * @param {Object} - The second vector.\n     * @returns {Object} - The difference.\n     */\n    Owl.prototype.difference = function(first, second) {\n        return {\n            x: first.x - second.x,\n            y: first.y - second.y\n        };\n    };\n\n    /**\n     * The jQuery Plugin for the Owl Carousel\n     * @todo Navigation plugin `next` and `prev`\n     * @public\n     */\n    $.fn.owlCarousel = function(option) {\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        return this.each(function() {\n            var $this = $(this),\n                data = $this.data('owl.carousel');\n\n            if (!data) {\n                data = new Owl(this, typeof option == 'object' && option);\n                $this.data('owl.carousel', data);\n\n                $.each([\n                    'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'\n                ], function(i, event) {\n                    data.register({ type: Owl.Type.Event, name: event });\n                    data.$element.on(event + '.owl.carousel.core', $.proxy(function(e) {\n                        if (e.namespace && e.relatedTarget !== this) {\n                            this.suppress([ event ]);\n                            data[event].apply(this, [].slice.call(arguments, 1));\n                            this.release([ event ]);\n                        }\n                    }, data));\n                });\n            }\n\n            if (typeof option == 'string' && option.charAt(0) !== '_') {\n                data[option].apply(data, args);\n            }\n        });\n    };\n\n    /**\n     * The constructor for the jQuery Plugin\n     * @public\n     */\n    $.fn.owlCarousel.Constructor = Owl;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * AutoRefresh Plugin\n * @version 2.1.0\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n    /**\n     * Creates the auto refresh plugin.\n     * @class The Auto Refresh Plugin\n     * @param {Owl} carousel - The Owl Carousel\n     */\n    var AutoRefresh = function(carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * Refresh interval.\n         * @protected\n         * @type {number}\n         */\n        this._interval = null;\n\n        /**\n         * Whether the element is currently visible or not.\n         * @protected\n         * @type {Boolean}\n         */\n        this._visible = null;\n\n        /**\n         * All event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'initialized.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.autoRefresh) {\n                    this.watch();\n                }\n            }, this)\n        };\n\n        // set default options\n        this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);\n\n        // register event handlers\n        this._core.$element.on(this._handlers);\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    AutoRefresh.Defaults = {\n        autoRefresh: true,\n        autoRefreshInterval: 500\n    };\n\n    /**\n     * Watches the element.\n     */\n    AutoRefresh.prototype.watch = function() {\n        if (this._interval) {\n            return;\n        }\n\n        this._visible = this._core.$element.is(':visible');\n        this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);\n    };\n\n    /**\n     * Refreshes the element.\n     */\n    AutoRefresh.prototype.refresh = function() {\n        if (this._core.$element.is(':visible') === this._visible) {\n            return;\n        }\n\n        this._visible = !this._visible;\n\n        this._core.$element.toggleClass('owl-hidden', !this._visible);\n\n        this._visible && (this._core.invalidate('width') && this._core.refresh());\n    };\n\n    /**\n     * Destroys the plugin.\n     */\n    AutoRefresh.prototype.destroy = function() {\n        var handler, property;\n\n        window.clearInterval(this._interval);\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Lazy Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n    /**\n     * Creates the lazy plugin.\n     * @class The Lazy Plugin\n     * @param {Owl} carousel - The Owl Carousel\n     */\n    var Lazy = function(carousel) {\n\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * Already loaded items.\n         * @protected\n         * @type {Array.<jQuery>}\n         */\n        this._loaded = [];\n\n        /**\n         * Event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function(e) {\n                if (!e.namespace) {\n                    return;\n                }\n\n                if (!this._core.settings || !this._core.settings.lazyLoad) {\n                    return;\n                }\n\n                if ((e.property && e.property.name == 'position') || e.type == 'initialized') {\n                    var settings = this._core.settings,\n                        n = (settings.center && Math.ceil(settings.items / 2) || settings.items),\n                        i = ((settings.center && n * -1) || 0),\n                        position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,\n                        clones = this._core.clones().length,\n                        load = $.proxy(function(i, v) { this.load(v) }, this);\n\n                    while (i++ < n) {\n                        this.load(clones / 2 + this._core.relative(position));\n                        clones && $.each(this._core.clones(this._core.relative(position)), load);\n                        position++;\n                    }\n                }\n            }, this)\n        };\n\n        // set the default options\n        this._core.options = $.extend({}, Lazy.Defaults, this._core.options);\n\n        // register event handler\n        this._core.$element.on(this._handlers);\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    Lazy.Defaults = {\n        lazyLoad: false\n    };\n\n    /**\n     * Loads all resources of an item at the specified position.\n     * @param {Number} position - The absolute position of the item.\n     * @protected\n     */\n    Lazy.prototype.load = function(position) {\n        var $item = this._core.$stage.children().eq(position),\n            $elements = $item && $item.find('.owl-lazy');\n\n        if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {\n            return;\n        }\n\n        $elements.each($.proxy(function(index, element) {\n            var $element = $(element), image,\n                url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src');\n\n            this._core.trigger('load', { element: $element, url: url }, 'lazy');\n\n            if ($element.is('img')) {\n                $element.one('load.owl.lazy', $.proxy(function() {\n                    $element.css('opacity', 1);\n                    this._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n                }, this)).attr('src', url);\n            } else {\n                image = new Image();\n                image.onload = $.proxy(function() {\n                    $element.css({\n                        'background-image': 'url(\"' + url + '\")',\n                        'opacity': '1'\n                    });\n                    this._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n                }, this);\n                image.src = url;\n            }\n        }, this));\n\n        this._loaded.push($item.get(0));\n    };\n\n    /**\n     * Destroys the plugin.\n     * @public\n     */\n    Lazy.prototype.destroy = function() {\n        var handler, property;\n\n        for (handler in this.handlers) {\n            this._core.$element.off(handler, this.handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * AutoHeight Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n    /**\n     * Creates the auto height plugin.\n     * @class The Auto Height Plugin\n     * @param {Owl} carousel - The Owl Carousel\n     */\n    var AutoHeight = function(carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * All event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.autoHeight) {\n                    this.update();\n                }\n            }, this),\n            'changed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.autoHeight && e.property.name == 'position'){\n                    this.update();\n                }\n            }, this),\n            'loaded.owl.lazy': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.autoHeight\n                    && e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {\n                    this.update();\n                }\n            }, this)\n        };\n\n        // set default options\n        this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);\n\n        // register event handlers\n        this._core.$element.on(this._handlers);\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    AutoHeight.Defaults = {\n        autoHeight: false,\n        autoHeightClass: 'owl-height'\n    };\n\n    /**\n     * Updates the view.\n     */\n    AutoHeight.prototype.update = function() {\n        var start = this._core._current,\n            end = start + this._core.settings.items,\n            visible = this._core.$stage.children().toArray().slice(start, end),\n            heights = [],\n            maxheight = 0;\n\n        $.each(visible, function(index, item) {\n            heights.push($(item).height());\n        });\n\n        maxheight = Math.max.apply(null, heights);\n\n        this._core.$stage.parent()\n            .height(maxheight)\n            .addClass(this._core.settings.autoHeightClass);\n    };\n\n    AutoHeight.prototype.destroy = function() {\n        var handler, property;\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Video Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n    /**\n     * Creates the video plugin.\n     * @class The Video Plugin\n     * @param {Owl} carousel - The Owl Carousel\n     */\n    var Video = function(carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * Cache all video URLs.\n         * @protected\n         * @type {Object}\n         */\n        this._videos = {};\n\n        /**\n         * Current playing item.\n         * @protected\n         * @type {jQuery}\n         */\n        this._playing = null;\n\n        /**\n         * All event handlers.\n         * @todo The cloned content removale is too late\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'initialized.owl.carousel': $.proxy(function(e) {\n                if (e.namespace) {\n                    this._core.register({ type: 'state', name: 'playing', tags: [ 'interacting' ] });\n                }\n            }, this),\n            'resize.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.video && this.isInFullScreen()) {\n                    e.preventDefault();\n                }\n            }, this),\n            'refreshed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.is('resizing')) {\n                    this._core.$stage.find('.cloned .owl-video-frame').remove();\n                }\n            }, this),\n            'changed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && e.property.name === 'position' && this._playing) {\n                    this.stop();\n                }\n            }, this),\n            'prepared.owl.carousel': $.proxy(function(e) {\n                if (!e.namespace) {\n                    return;\n                }\n\n                var $element = $(e.content).find('.owl-video');\n\n                if ($element.length) {\n                    $element.css('display', 'none');\n                    this.fetch($element, $(e.content));\n                }\n            }, this)\n        };\n\n        // set default options\n        this._core.options = $.extend({}, Video.Defaults, this._core.options);\n\n        // register event handlers\n        this._core.$element.on(this._handlers);\n\n        this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {\n            this.play(e);\n        }, this));\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    Video.Defaults = {\n        video: false,\n        videoHeight: false,\n        videoWidth: false\n    };\n\n    /**\n     * Gets the video ID and the type (YouTube/Vimeo/vzaar only).\n     * @protected\n     * @param {jQuery} target - The target containing the video data.\n     * @param {jQuery} item - The item containing the video.\n     */\n    Video.prototype.fetch = function(target, item) {\n        var type = (function() {\n                if (target.attr('data-vimeo-id')) {\n                    return 'vimeo';\n                } else if (target.attr('data-vzaar-id')) {\n                    return 'vzaar'\n                } else {\n                    return 'youtube';\n                }\n            })(),\n            id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),\n            width = target.attr('data-width') || this._core.settings.videoWidth,\n            height = target.attr('data-height') || this._core.settings.videoHeight,\n            url = target.attr('href');\n\n        if (url) {\n\n            /*\n             Parses the id's out of the following urls (and probably more):\n             https://www.youtube.com/watch?v=:id\n             https://youtu.be/:id\n             https://vimeo.com/:id\n             https://vimeo.com/channels/:channel/:id\n             https://vimeo.com/groups/:group/videos/:id\n             https://app.vzaar.com/videos/:id\n\n             Visual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F\n             */\n\n            id = url.match(/(http:|https:|)\\/\\/(player.|www.|app.)?(vimeo\\.com|youtu(be\\.com|\\.be|be\\.googleapis\\.com)|vzaar\\.com)\\/(video\\/|videos\\/|embed\\/|channels\\/.+\\/|groups\\/.+\\/|watch\\?v=|v\\/)?([A-Za-z0-9._%-]*)(\\&\\S+)?/);\n\n            if (id[3].indexOf('youtu') > -1) {\n                type = 'youtube';\n            } else if (id[3].indexOf('vimeo') > -1) {\n                type = 'vimeo';\n            } else if (id[3].indexOf('vzaar') > -1) {\n                type = 'vzaar';\n            } else {\n                throw new Error('Video URL not supported.');\n            }\n            id = id[6];\n        } else {\n            throw new Error('Missing video URL.');\n        }\n\n        this._videos[url] = {\n            type: type,\n            id: id,\n            width: width,\n            height: height\n        };\n\n        item.attr('data-video', url);\n\n        this.thumbnail(target, this._videos[url]);\n    };\n\n    /**\n     * Creates video thumbnail.\n     * @protected\n     * @param {jQuery} target - The target containing the video data.\n     * @param {Object} info - The video info object.\n     * @see `fetch`\n     */\n    Video.prototype.thumbnail = function(target, video) {\n        var tnLink,\n            icon,\n            path,\n            dimensions = video.width && video.height ? 'style=\"width:' + video.width + 'px;height:' + video.height + 'px;\"' : '',\n            customTn = target.find('img'),\n            srcType = 'src',\n            lazyClass = '',\n            settings = this._core.settings,\n            create = function(path) {\n                icon = '<div class=\"owl-video-play-icon\"></div>';\n\n                if (settings.lazyLoad) {\n                    tnLink = '<div class=\"owl-video-tn ' + lazyClass + '\" ' + srcType + '=\"' + path + '\"></div>';\n                } else {\n                    tnLink = '<div class=\"owl-video-tn\" style=\"opacity:1;background-image:url(' + path + ')\"></div>';\n                }\n                target.after(tnLink);\n                target.after(icon);\n            };\n\n        // wrap video content into owl-video-wrapper div\n        target.wrap('<div class=\"owl-video-wrapper\"' + dimensions + '></div>');\n\n        if (this._core.settings.lazyLoad) {\n            srcType = 'data-src';\n            lazyClass = 'owl-lazy';\n        }\n\n        // custom thumbnail\n        if (customTn.length) {\n            create(customTn.attr(srcType));\n            customTn.remove();\n            return false;\n        }\n\n        if (video.type === 'youtube') {\n            path = \"//img.youtube.com/vi/\" + video.id + \"/hqdefault.jpg\";\n            create(path);\n        } else if (video.type === 'vimeo') {\n            $.ajax({\n                type: 'GET',\n                url: '//vimeo.com/api/v2/video/' + video.id + '.json',\n                jsonp: 'callback',\n                dataType: 'jsonp',\n                success: function(data) {\n                    path = data[0].thumbnail_large;\n                    create(path);\n                }\n            });\n        } else if (video.type === 'vzaar') {\n            $.ajax({\n                type: 'GET',\n                url: '//vzaar.com/api/videos/' + video.id + '.json',\n                jsonp: 'callback',\n                dataType: 'jsonp',\n                success: function(data) {\n                    path = data.framegrab_url;\n                    create(path);\n                }\n            });\n        }\n    };\n\n    /**\n     * Stops the current video.\n     * @public\n     */\n    Video.prototype.stop = function() {\n        this._core.trigger('stop', null, 'video');\n        this._playing.find('.owl-video-frame').remove();\n        this._playing.removeClass('owl-video-playing');\n        this._playing = null;\n        this._core.leave('playing');\n        this._core.trigger('stopped', null, 'video');\n    };\n\n    /**\n     * Starts the current video.\n     * @public\n     * @param {Event} event - The event arguments.\n     */\n    Video.prototype.play = function(event) {\n        var target = $(event.target),\n            item = target.closest('.' + this._core.settings.itemClass),\n            video = this._videos[item.attr('data-video')],\n            width = video.width || '100%',\n            height = video.height || this._core.$stage.height(),\n            html;\n\n        if (this._playing) {\n            return;\n        }\n\n        this._core.enter('playing');\n        this._core.trigger('play', null, 'video');\n\n        item = this._core.items(this._core.relative(item.index()));\n\n        this._core.reset(item.index());\n\n        if (video.type === 'youtube') {\n            html = '<iframe width=\"' + width + '\" height=\"' + height + '\" src=\"//www.youtube.com/embed/' +\n                video.id + '?autoplay=1&rel=0&v=' + video.id + '\" frameborder=\"0\" allowfullscreen></iframe>';\n        } else if (video.type === 'vimeo') {\n            html = '<iframe src=\"//player.vimeo.com/video/' + video.id +\n                '?autoplay=1\" width=\"' + width + '\" height=\"' + height +\n                '\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';\n        } else if (video.type === 'vzaar') {\n            html = '<iframe frameborder=\"0\"' + 'height=\"' + height + '\"' + 'width=\"' + width +\n                '\" allowfullscreen mozallowfullscreen webkitAllowFullScreen ' +\n                'src=\"//view.vzaar.com/' + video.id + '/player?autoplay=true\"></iframe>';\n        }\n\n        $('<div class=\"owl-video-frame\">' + html + '</div>').insertAfter(item.find('.owl-video'));\n\n        this._playing = item.addClass('owl-video-playing');\n    };\n\n    /**\n     * Checks whether an video is currently in full screen mode or not.\n     * @todo Bad style because looks like a readonly method but changes members.\n     * @protected\n     * @returns {Boolean}\n     */\n    Video.prototype.isInFullScreen = function() {\n        var element = document.fullscreenElement || document.mozFullScreenElement ||\n            document.webkitFullscreenElement;\n\n        return element && $(element).parent().hasClass('owl-video-frame');\n    };\n\n    /**\n     * Destroys the plugin.\n     */\n    Video.prototype.destroy = function() {\n        var handler, property;\n\n        this._core.$element.off('click.owl.video');\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Video = Video;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Animate Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n    /**\n     * Creates the animate plugin.\n     * @class The Navigation Plugin\n     * @param {Owl} scope - The Owl Carousel\n     */\n    var Animate = function(scope) {\n        this.core = scope;\n        this.core.options = $.extend({}, Animate.Defaults, this.core.options);\n        this.swapping = true;\n        this.previous = undefined;\n        this.next = undefined;\n\n        this.handlers = {\n            'change.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && e.property.name == 'position') {\n                    this.previous = this.core.current();\n                    this.next = e.property.value;\n                }\n            }, this),\n            'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {\n                if (e.namespace) {\n                    this.swapping = e.type == 'translated';\n                }\n            }, this),\n            'translate.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {\n                    this.swap();\n                }\n            }, this)\n        };\n\n        this.core.$element.on(this.handlers);\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    Animate.Defaults = {\n        animateOut: false,\n        animateIn: false\n    };\n\n    /**\n     * Toggles the animation classes whenever an translations starts.\n     * @protected\n     * @returns {Boolean|undefined}\n     */\n    Animate.prototype.swap = function() {\n\n        if (this.core.settings.items !== 1) {\n            return;\n        }\n\n        if (!$.support.animation || !$.support.transition) {\n            return;\n        }\n\n        this.core.speed(0);\n\n        var left,\n            clear = $.proxy(this.clear, this),\n            previous = this.core.$stage.children().eq(this.previous),\n            next = this.core.$stage.children().eq(this.next),\n            incoming = this.core.settings.animateIn,\n            outgoing = this.core.settings.animateOut;\n\n        if (this.core.current() === this.previous) {\n            return;\n        }\n\n        if (outgoing) {\n            left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);\n            previous.one($.support.animation.end, clear)\n                .css( { 'left': left + 'px' } )\n                .addClass('animated owl-animated-out')\n                .addClass(outgoing);\n        }\n\n        if (incoming) {\n            next.one($.support.animation.end, clear)\n                .addClass('animated owl-animated-in')\n                .addClass(incoming);\n        }\n    };\n\n    Animate.prototype.clear = function(e) {\n        $(e.target).css( { 'left': '' } )\n            .removeClass('animated owl-animated-out owl-animated-in')\n            .removeClass(this.core.settings.animateIn)\n            .removeClass(this.core.settings.animateOut);\n        this.core.onTransitionEnd();\n    };\n\n    /**\n     * Destroys the plugin.\n     * @public\n     */\n    Animate.prototype.destroy = function() {\n        var handler, property;\n\n        for (handler in this.handlers) {\n            this.core.$element.off(handler, this.handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Animate = Animate;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Autoplay Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n    /**\n     * Creates the autoplay plugin.\n     * @class The Autoplay Plugin\n     * @param {Owl} scope - The Owl Carousel\n     */\n    var Autoplay = function(carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * The autoplay timeout.\n         * @type {Timeout}\n         */\n        this._timeout = null;\n\n        /**\n         * Indicates whenever the autoplay is paused.\n         * @type {Boolean}\n         */\n        this._paused = false;\n\n        /**\n         * All event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'changed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && e.property.name === 'settings') {\n                    if (this._core.settings.autoplay) {\n                        this.play();\n                    } else {\n                        this.stop();\n                    }\n                } else if (e.namespace && e.property.name === 'position') {\n                    //console.log('play?', e);\n                    if (this._core.settings.autoplay) {\n                        this._setAutoPlayInterval();\n                    }\n                }\n            }, this),\n            'initialized.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.autoplay) {\n                    this.play();\n                }\n            }, this),\n            'play.owl.autoplay': $.proxy(function(e, t, s) {\n                if (e.namespace) {\n                    this.play(t, s);\n                }\n            }, this),\n            'stop.owl.autoplay': $.proxy(function(e) {\n                if (e.namespace) {\n                    this.stop();\n                }\n            }, this),\n            'mouseover.owl.autoplay': $.proxy(function() {\n                if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n                    this.pause();\n                }\n            }, this),\n            'mouseleave.owl.autoplay': $.proxy(function() {\n                if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n                    this.play();\n                }\n            }, this),\n            'touchstart.owl.core': $.proxy(function() {\n                if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n                    this.pause();\n                }\n            }, this),\n            'touchend.owl.core': $.proxy(function() {\n                if (this._core.settings.autoplayHoverPause) {\n                    this.play();\n                }\n            }, this)\n        };\n\n        // register event handlers\n        this._core.$element.on(this._handlers);\n\n        // set default options\n        this._core.options = $.extend({}, Autoplay.Defaults, this._core.options);\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    Autoplay.Defaults = {\n        autoplay: false,\n        autoplayTimeout: 5000,\n        autoplayHoverPause: false,\n        autoplaySpeed: false\n    };\n\n    /**\n     * Starts the autoplay.\n     * @public\n     * @param {Number} [timeout] - The interval before the next animation starts.\n     * @param {Number} [speed] - The animation speed for the animations.\n     */\n    Autoplay.prototype.play = function(timeout, speed) {\n        this._paused = false;\n\n        if (this._core.is('rotating')) {\n            return;\n        }\n\n        this._core.enter('rotating');\n\n        this._setAutoPlayInterval();\n    };\n\n    /**\n     * Gets a new timeout\n     * @private\n     * @param {Number} [timeout] - The interval before the next animation starts.\n     * @param {Number} [speed] - The animation speed for the animations.\n     * @return {Timeout}\n     */\n    Autoplay.prototype._getNextTimeout = function(timeout, speed) {\n        if ( this._timeout ) {\n            window.clearTimeout(this._timeout);\n        }\n        return window.setTimeout($.proxy(function() {\n            if (this._paused || this._core.is('busy') || this._core.is('interacting') || document.hidden) {\n                return;\n            }\n            this._core.next(speed || this._core.settings.autoplaySpeed);\n        }, this), timeout || this._core.settings.autoplayTimeout);\n    };\n\n    /**\n     * Sets autoplay in motion.\n     * @private\n     */\n    Autoplay.prototype._setAutoPlayInterval = function() {\n        this._timeout = this._getNextTimeout();\n    };\n\n    /**\n     * Stops the autoplay.\n     * @public\n     */\n    Autoplay.prototype.stop = function() {\n        if (!this._core.is('rotating')) {\n            return;\n        }\n\n        window.clearTimeout(this._timeout);\n        this._core.leave('rotating');\n    };\n\n    /**\n     * Stops the autoplay.\n     * @public\n     */\n    Autoplay.prototype.pause = function() {\n        if (!this._core.is('rotating')) {\n            return;\n        }\n\n        this._paused = true;\n    };\n\n    /**\n     * Destroys the plugin.\n     */\n    Autoplay.prototype.destroy = function() {\n        var handler, property;\n\n        this.stop();\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Navigation Plugin\n * @version 2.1.0\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n    'use strict';\n\n    /**\n     * Creates the navigation plugin.\n     * @class The Navigation Plugin\n     * @param {Owl} carousel - The Owl Carousel.\n     */\n    var Navigation = function(carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * Indicates whether the plugin is initialized or not.\n         * @protected\n         * @type {Boolean}\n         */\n        this._initialized = false;\n\n        /**\n         * The current paging indexes.\n         * @protected\n         * @type {Array}\n         */\n        this._pages = [];\n\n        /**\n         * All DOM elements of the user interface.\n         * @protected\n         * @type {Object}\n         */\n        this._controls = {};\n\n        /**\n         * Markup for an indicator.\n         * @protected\n         * @type {Array.<String>}\n         */\n        this._templates = [];\n\n        /**\n         * The carousel element.\n         * @type {jQuery}\n         */\n        this.$element = this._core.$element;\n\n        /**\n         * Overridden methods of the carousel.\n         * @protected\n         * @type {Object}\n         */\n        this._overrides = {\n            next: this._core.next,\n            prev: this._core.prev,\n            to: this._core.to\n        };\n\n        /**\n         * All event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'prepared.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.dotsData) {\n                    this._templates.push('<div class=\"' + this._core.settings.dotClass + '\">' +\n                        $(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');\n                }\n            }, this),\n            'added.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.dotsData) {\n                    this._templates.splice(e.position, 0, this._templates.pop());\n                }\n            }, this),\n            'remove.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.dotsData) {\n                    this._templates.splice(e.position, 1);\n                }\n            }, this),\n            'changed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && e.property.name == 'position') {\n                    this.draw();\n                }\n            }, this),\n            'initialized.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && !this._initialized) {\n                    this._core.trigger('initialize', null, 'navigation');\n                    this.initialize();\n                    this.update();\n                    this.draw();\n                    this._initialized = true;\n                    this._core.trigger('initialized', null, 'navigation');\n                }\n            }, this),\n            'refreshed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._initialized) {\n                    this._core.trigger('refresh', null, 'navigation');\n                    this.update();\n                    this.draw();\n                    this._core.trigger('refreshed', null, 'navigation');\n                }\n            }, this)\n        };\n\n        // set default options\n        this._core.options = $.extend({}, Navigation.Defaults, this._core.options);\n\n        // register event handlers\n        this.$element.on(this._handlers);\n    };\n\n    /**\n     * Default options.\n     * @public\n     * @todo Rename `slideBy` to `navBy`\n     */\n    Navigation.Defaults = {\n        nav: false,\n        navText: [ 'prev', 'next' ],\n        navSpeed: false,\n        navElement: 'div',\n        navContainer: false,\n        navContainerClass: 'owl-nav',\n        navClass: [ 'owl-prev', 'owl-next' ],\n        slideBy: 1,\n        dotClass: 'owl-dot',\n        dotsClass: 'owl-dots',\n        dots: true,\n        dotsEach: false,\n        dotsData: false,\n        dotsSpeed: false,\n        dotsContainer: false\n    };\n\n    /**\n     * Initializes the layout of the plugin and extends the carousel.\n     * @protected\n     */\n    Navigation.prototype.initialize = function() {\n        var override,\n            settings = this._core.settings;\n\n        // create DOM structure for relative navigation\n        this._controls.$relative = (settings.navContainer ? $(settings.navContainer)\n            : $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');\n\n        this._controls.$previous = $('<' + settings.navElement + '>')\n            .addClass(settings.navClass[0])\n            .html(settings.navText[0])\n            .prependTo(this._controls.$relative)\n            .on('click', $.proxy(function(e) {\n                this.prev(settings.navSpeed);\n            }, this));\n        this._controls.$next = $('<' + settings.navElement + '>')\n            .addClass(settings.navClass[1])\n            .html(settings.navText[1])\n            .appendTo(this._controls.$relative)\n            .on('click', $.proxy(function(e) {\n                this.next(settings.navSpeed);\n            }, this));\n\n        // create DOM structure for absolute navigation\n        if (!settings.dotsData) {\n            this._templates = [ $('<div>')\n                .addClass(settings.dotClass)\n                .append($('<span>'))\n                .prop('outerHTML') ];\n        }\n\n        this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)\n            : $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');\n\n        this._controls.$absolute.on('click', 'div', $.proxy(function(e) {\n            var index = $(e.target).parent().is(this._controls.$absolute)\n                ? $(e.target).index() : $(e.target).parent().index();\n\n            e.preventDefault();\n\n            this.to(index, settings.dotsSpeed);\n        }, this));\n\n        // override public methods of the carousel\n        for (override in this._overrides) {\n            this._core[override] = $.proxy(this[override], this);\n        }\n    };\n\n    /**\n     * Destroys the plugin.\n     * @protected\n     */\n    Navigation.prototype.destroy = function() {\n        var handler, control, property, override;\n\n        for (handler in this._handlers) {\n            this.$element.off(handler, this._handlers[handler]);\n        }\n        for (control in this._controls) {\n            this._controls[control].remove();\n        }\n        for (override in this.overides) {\n            this._core[override] = this._overrides[override];\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    /**\n     * Updates the internal state.\n     * @protected\n     */\n    Navigation.prototype.update = function() {\n        var i, j, k,\n            lower = this._core.clones().length / 2,\n            upper = lower + this._core.items().length,\n            maximum = this._core.maximum(true),\n            settings = this._core.settings,\n            size = settings.center || settings.autoWidth || settings.dotsData\n                ? 1 : settings.dotsEach || settings.items;\n\n        if (settings.slideBy !== 'page') {\n            settings.slideBy = Math.min(settings.slideBy, settings.items);\n        }\n\n        if (settings.dots || settings.slideBy == 'page') {\n            this._pages = [];\n\n            for (i = lower, j = 0, k = 0; i < upper; i++) {\n                if (j >= size || j === 0) {\n                    this._pages.push({\n                        start: Math.min(maximum, i - lower),\n                        end: i - lower + size - 1\n                    });\n                    if (Math.min(maximum, i - lower) === maximum) {\n                        break;\n                    }\n                    j = 0, ++k;\n                }\n                j += this._core.mergers(this._core.relative(i));\n            }\n        }\n    };\n\n    /**\n     * Draws the user interface.\n     * @todo The option `dotsData` wont work.\n     * @protected\n     */\n    Navigation.prototype.draw = function() {\n        var difference,\n            settings = this._core.settings,\n            disabled = this._core.items().length <= settings.items,\n            index = this._core.relative(this._core.current()),\n            loop = settings.loop || settings.rewind;\n\n        this._controls.$relative.toggleClass('disabled', !settings.nav || disabled);\n\n        if (settings.nav) {\n            this._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));\n            this._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));\n        }\n\n        this._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);\n\n        if (settings.dots) {\n            difference = this._pages.length - this._controls.$absolute.children().length;\n\n            if (settings.dotsData && difference !== 0) {\n                this._controls.$absolute.html(this._templates.join(''));\n            } else if (difference > 0) {\n                this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));\n            } else if (difference < 0) {\n                this._controls.$absolute.children().slice(difference).remove();\n            }\n\n            this._controls.$absolute.find('.active').removeClass('active');\n            this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');\n        }\n    };\n\n    /**\n     * Extends event data.\n     * @protected\n     * @param {Event} event - The event object which gets thrown.\n     */\n    Navigation.prototype.onTrigger = function(event) {\n        var settings = this._core.settings;\n\n        event.page = {\n            index: $.inArray(this.current(), this._pages),\n            count: this._pages.length,\n            size: settings && (settings.center || settings.autoWidth || settings.dotsData\n                ? 1 : settings.dotsEach || settings.items)\n        };\n    };\n\n    /**\n     * Gets the current page position of the carousel.\n     * @protected\n     * @returns {Number}\n     */\n    Navigation.prototype.current = function() {\n        var current = this._core.relative(this._core.current());\n        return $.grep(this._pages, $.proxy(function(page, index) {\n            return page.start <= current && page.end >= current;\n        }, this)).pop();\n    };\n\n    /**\n     * Gets the current succesor/predecessor position.\n     * @protected\n     * @returns {Number}\n     */\n    Navigation.prototype.getPosition = function(successor) {\n        var position, length,\n            settings = this._core.settings;\n\n        if (settings.slideBy == 'page') {\n            position = $.inArray(this.current(), this._pages);\n            length = this._pages.length;\n            successor ? ++position : --position;\n            position = this._pages[((position % length) + length) % length].start;\n        } else {\n            position = this._core.relative(this._core.current());\n            length = this._core.items().length;\n            successor ? position += settings.slideBy : position -= settings.slideBy;\n        }\n\n        return position;\n    };\n\n    /**\n     * Slides to the next item or page.\n     * @public\n     * @param {Number} [speed=false] - The time in milliseconds for the transition.\n     */\n    Navigation.prototype.next = function(speed) {\n        $.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);\n    };\n\n    /**\n     * Slides to the previous item or page.\n     * @public\n     * @param {Number} [speed=false] - The time in milliseconds for the transition.\n     */\n    Navigation.prototype.prev = function(speed) {\n        $.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);\n    };\n\n    /**\n     * Slides to the specified item or page.\n     * @public\n     * @param {Number} position - The position of the item or page.\n     * @param {Number} [speed] - The time in milliseconds for the transition.\n     * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.\n     */\n    Navigation.prototype.to = function(position, speed, standard) {\n        var length;\n\n        if (!standard && this._pages.length) {\n            length = this._pages.length;\n            $.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);\n        } else {\n            $.proxy(this._overrides.to, this._core)(position, speed);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Hash Plugin\n * @version 2.1.0\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n    'use strict';\n\n    /**\n     * Creates the hash plugin.\n     * @class The Hash Plugin\n     * @param {Owl} carousel - The Owl Carousel\n     */\n    var Hash = function(carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * Hash index for the items.\n         * @protected\n         * @type {Object}\n         */\n        this._hashes = {};\n\n        /**\n         * The carousel element.\n         * @type {jQuery}\n         */\n        this.$element = this._core.$element;\n\n        /**\n         * All event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'initialized.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.startPosition === 'URLHash') {\n                    $(window).trigger('hashchange.owl.navigation');\n                }\n            }, this),\n            'prepared.owl.carousel': $.proxy(function(e) {\n                if (e.namespace) {\n                    var hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');\n\n                    if (!hash) {\n                        return;\n                    }\n\n                    this._hashes[hash] = e.content;\n                }\n            }, this),\n            'changed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && e.property.name === 'position') {\n                    var current = this._core.items(this._core.relative(this._core.current())),\n                        hash = $.map(this._hashes, function(item, hash) {\n                            return item === current ? hash : null;\n                        }).join();\n\n                    if (!hash || window.location.hash.slice(1) === hash) {\n                        return;\n                    }\n\n                    window.location.hash = hash;\n                }\n            }, this)\n        };\n\n        // set default options\n        this._core.options = $.extend({}, Hash.Defaults, this._core.options);\n\n        // register the event handlers\n        this.$element.on(this._handlers);\n\n        // register event listener for hash navigation\n        $(window).on('hashchange.owl.navigation', $.proxy(function(e) {\n            var hash = window.location.hash.substring(1),\n                items = this._core.$stage.children(),\n                position = this._hashes[hash] && items.index(this._hashes[hash]);\n\n            if (position === undefined || position === this._core.current()) {\n                return;\n            }\n\n            this._core.to(this._core.relative(position), false, true);\n        }, this));\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    Hash.Defaults = {\n        URLhashListener: false\n    };\n\n    /**\n     * Destroys the plugin.\n     * @public\n     */\n    Hash.prototype.destroy = function() {\n        var handler, property;\n\n        $(window).off('hashchange.owl.navigation');\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Hash = Hash;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Support Plugin\n *\n * @version 2.1.0\n * @author Vivid Planet Software GmbH\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n    var style = $('<support>').get(0).style,\n        prefixes = 'Webkit Moz O ms'.split(' '),\n        events = {\n            transition: {\n                end: {\n                    WebkitTransition: 'webkitTransitionEnd',\n                    MozTransition: 'transitionend',\n                    OTransition: 'oTransitionEnd',\n                    transition: 'transitionend'\n                }\n            },\n            animation: {\n                end: {\n                    WebkitAnimation: 'webkitAnimationEnd',\n                    MozAnimation: 'animationend',\n                    OAnimation: 'oAnimationEnd',\n                    animation: 'animationend'\n                }\n            }\n        },\n        tests = {\n            csstransforms: function() {\n                return !!test('transform');\n            },\n            csstransforms3d: function() {\n                return !!test('perspective');\n            },\n            csstransitions: function() {\n                return !!test('transition');\n            },\n            cssanimations: function() {\n                return !!test('animation');\n            }\n        };\n\n    function test(property, prefixed) {\n        var result = false,\n            upper = property.charAt(0).toUpperCase() + property.slice(1);\n\n        $.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function(i, property) {\n            if (style[property] !== undefined) {\n                result = prefixed ? property : true;\n                return false;\n            }\n        });\n\n        return result;\n    }\n\n    function prefixed(property) {\n        return test(property, true);\n    }\n\n    if (tests.csstransitions()) {\n        /* jshint -W053 */\n        $.support.transition = new String(prefixed('transition'))\n        $.support.transition.end = events.transition.end[ $.support.transition ];\n    }\n\n    if (tests.cssanimations()) {\n        /* jshint -W053 */\n        $.support.animation = new String(prefixed('animation'))\n        $.support.animation.end = events.animation.end[ $.support.animation ];\n    }\n\n    if (tests.csstransforms()) {\n        /* jshint -W053 */\n        $.support.transform = new String(prefixed('transform'));\n        $.support.transform3d = tests.csstransforms3d();\n    }\n\n})(window.Zepto || window.jQuery, window, document);","/**\n * Rangy, a cross-browser JavaScript range and selection library\n * https://github.com/timdown/rangy\n *\n * Copyright 2015, Tim Down\n * Licensed under the MIT license.\n * Version: 1.3.1-dev\n * Build date: 20 May 2015\n */\n\n(function(factory, root) {\n    if (typeof define == \"function\" && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(factory);\n    } else if (typeof module != \"undefined\" && typeof exports == \"object\") {\n        // Node/CommonJS style\n        module.exports = factory();\n    } else {\n        // No AMD or CommonJS support so we place Rangy in (probably) the global variable\n        root.rangy = factory();\n    }\n})(function() {\n\n    var OBJECT = \"object\", FUNCTION = \"function\", UNDEFINED = \"undefined\";\n\n    // Minimal set of properties required for DOM Level 2 Range compliance. Comparison constants such as START_TO_START\n    // are omitted because ranges in KHTML do not have them but otherwise work perfectly well. See issue 113.\n    var domRangeProperties = [\"startContainer\", \"startOffset\", \"endContainer\", \"endOffset\", \"collapsed\",\n        \"commonAncestorContainer\"];\n\n    // Minimal set of methods required for DOM Level 2 Range compliance\n    var domRangeMethods = [\"setStart\", \"setStartBefore\", \"setStartAfter\", \"setEnd\", \"setEndBefore\",\n        \"setEndAfter\", \"collapse\", \"selectNode\", \"selectNodeContents\", \"compareBoundaryPoints\", \"deleteContents\",\n        \"extractContents\", \"cloneContents\", \"insertNode\", \"surroundContents\", \"cloneRange\", \"toString\", \"detach\"];\n\n    var textRangeProperties = [\"boundingHeight\", \"boundingLeft\", \"boundingTop\", \"boundingWidth\", \"htmlText\", \"text\"];\n\n    // Subset of TextRange's full set of methods that we're interested in\n    var textRangeMethods = [\"collapse\", \"compareEndPoints\", \"duplicate\", \"moveToElementText\", \"parentElement\", \"select\",\n        \"setEndPoint\", \"getBoundingClientRect\"];\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Trio of functions taken from Peter Michaux's article:\n    // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting\n    function isHostMethod(o, p) {\n        var t = typeof o[p];\n        return t == FUNCTION || (!!(t == OBJECT && o[p])) || t == \"unknown\";\n    }\n\n    function isHostObject(o, p) {\n        return !!(typeof o[p] == OBJECT && o[p]);\n    }\n\n    function isHostProperty(o, p) {\n        return typeof o[p] != UNDEFINED;\n    }\n\n    // Creates a convenience function to save verbose repeated calls to tests functions\n    function createMultiplePropertyTest(testFunc) {\n        return function(o, props) {\n            var i = props.length;\n            while (i--) {\n                if (!testFunc(o, props[i])) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    }\n\n    // Next trio of functions are a convenience to save verbose repeated calls to previous two functions\n    var areHostMethods = createMultiplePropertyTest(isHostMethod);\n    var areHostObjects = createMultiplePropertyTest(isHostObject);\n    var areHostProperties = createMultiplePropertyTest(isHostProperty);\n\n    function isTextRange(range) {\n        return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);\n    }\n\n    function getBody(doc) {\n        return isHostObject(doc, \"body\") ? doc.body : doc.getElementsByTagName(\"body\")[0];\n    }\n\n    var forEach = [].forEach ?\n        function(arr, func) {\n            arr.forEach(func);\n        } :\n        function(arr, func) {\n            for (var i = 0, len = arr.length; i < len; ++i) {\n                func(arr[i], i);\n            }\n        };\n\n    var modules = {};\n\n    var isBrowser = (typeof window != UNDEFINED && typeof document != UNDEFINED);\n\n    var util = {\n        isHostMethod: isHostMethod,\n        isHostObject: isHostObject,\n        isHostProperty: isHostProperty,\n        areHostMethods: areHostMethods,\n        areHostObjects: areHostObjects,\n        areHostProperties: areHostProperties,\n        isTextRange: isTextRange,\n        getBody: getBody,\n        forEach: forEach\n    };\n\n    var api = {\n        version: \"1.3.1-dev\",\n        initialized: false,\n        isBrowser: isBrowser,\n        supported: true,\n        util: util,\n        features: {},\n        modules: modules,\n        config: {\n            alertOnFail: false,\n            alertOnWarn: false,\n            preferTextRange: false,\n            autoInitialize: (typeof rangyAutoInitialize == UNDEFINED) ? true : rangyAutoInitialize\n        }\n    };\n\n    function consoleLog(msg) {\n        if (typeof console != UNDEFINED && isHostMethod(console, \"log\")) {\n            console.log(msg);\n        }\n    }\n\n    function alertOrLog(msg, shouldAlert) {\n        if (isBrowser && shouldAlert) {\n            alert(msg);\n        } else  {\n            consoleLog(msg);\n        }\n    }\n\n    function fail(reason) {\n        api.initialized = true;\n        api.supported = false;\n        alertOrLog(\"Rangy is not supported in this environment. Reason: \" + reason, api.config.alertOnFail);\n    }\n\n    api.fail = fail;\n\n    function warn(msg) {\n        alertOrLog(\"Rangy warning: \" + msg, api.config.alertOnWarn);\n    }\n\n    api.warn = warn;\n\n    // Add utility extend() method\n    var extend;\n    if ({}.hasOwnProperty) {\n        util.extend = extend = function(obj, props, deep) {\n            var o, p;\n            for (var i in props) {\n                if (props.hasOwnProperty(i)) {\n                    o = obj[i];\n                    p = props[i];\n                    if (deep && o !== null && typeof o == \"object\" && p !== null && typeof p == \"object\") {\n                        extend(o, p, true);\n                    }\n                    obj[i] = p;\n                }\n            }\n            // Special case for toString, which does not display up in for...in loops in IE <= 8\n            if (props.hasOwnProperty(\"toString\")) {\n                obj.toString = props.toString;\n            }\n            return obj;\n        };\n\n        util.createOptions = function(optionsParam, defaults) {\n            var options = {};\n            extend(options, defaults);\n            if (optionsParam) {\n                extend(options, optionsParam);\n            }\n            return options;\n        };\n    } else {\n        fail(\"hasOwnProperty not supported\");\n    }\n\n    // Test whether we're in a browser and bail out if not\n    if (!isBrowser) {\n        fail(\"Rangy can only run in a browser\");\n    }\n\n    // Test whether Array.prototype.slice can be relied on for NodeLists and use an alternative toArray() if not\n    (function() {\n        var toArray;\n\n        if (isBrowser) {\n            var el = document.createElement(\"div\");\n            el.appendChild(document.createElement(\"span\"));\n            var slice = [].slice;\n            try {\n                if (slice.call(el.childNodes, 0)[0].nodeType == 1) {\n                    toArray = function(arrayLike) {\n                        return slice.call(arrayLike, 0);\n                    };\n                }\n            } catch (e) {}\n        }\n\n        if (!toArray) {\n            toArray = function(arrayLike) {\n                var arr = [];\n                for (var i = 0, len = arrayLike.length; i < len; ++i) {\n                    arr[i] = arrayLike[i];\n                }\n                return arr;\n            };\n        }\n\n        util.toArray = toArray;\n    })();\n\n    // Very simple event handler wrapper function that doesn't attempt to solve issues such as \"this\" handling or\n    // normalization of event properties\n    var addListener;\n    if (isBrowser) {\n        if (isHostMethod(document, \"addEventListener\")) {\n            addListener = function(obj, eventType, listener) {\n                obj.addEventListener(eventType, listener, false);\n            };\n        } else if (isHostMethod(document, \"attachEvent\")) {\n            addListener = function(obj, eventType, listener) {\n                obj.attachEvent(\"on\" + eventType, listener);\n            };\n        } else {\n            fail(\"Document does not have required addEventListener or attachEvent method\");\n        }\n\n        util.addListener = addListener;\n    }\n\n    var initListeners = [];\n\n    function getErrorDesc(ex) {\n        return ex.message || ex.description || String(ex);\n    }\n\n    // Initialization\n    function init() {\n        if (!isBrowser || api.initialized) {\n            return;\n        }\n        var testRange;\n        var implementsDomRange = false, implementsTextRange = false;\n\n        // First, perform basic feature tests\n\n        if (isHostMethod(document, \"createRange\")) {\n            testRange = document.createRange();\n            if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {\n                implementsDomRange = true;\n            }\n        }\n\n        var body = getBody(document);\n        if (!body || body.nodeName.toLowerCase() != \"body\") {\n            fail(\"No body element found\");\n            return;\n        }\n\n        if (body && isHostMethod(body, \"createTextRange\")) {\n            testRange = body.createTextRange();\n            if (isTextRange(testRange)) {\n                implementsTextRange = true;\n            }\n        }\n\n        if (!implementsDomRange && !implementsTextRange) {\n            fail(\"Neither Range nor TextRange are available\");\n            return;\n        }\n\n        api.initialized = true;\n        api.features = {\n            implementsDomRange: implementsDomRange,\n            implementsTextRange: implementsTextRange\n        };\n\n        // Initialize modules\n        var module, errorMessage;\n        for (var moduleName in modules) {\n            if ( (module = modules[moduleName]) instanceof Module ) {\n                module.init(module, api);\n            }\n        }\n\n        // Call init listeners\n        for (var i = 0, len = initListeners.length; i < len; ++i) {\n            try {\n                initListeners[i](api);\n            } catch (ex) {\n                errorMessage = \"Rangy init listener threw an exception. Continuing. Detail: \" + getErrorDesc(ex);\n                consoleLog(errorMessage);\n            }\n        }\n    }\n\n    function deprecationNotice(deprecated, replacement, module) {\n        if (module) {\n            deprecated += \" in module \" + module.name;\n        }\n        api.warn(\"DEPRECATED: \" + deprecated + \" is deprecated. Please use \" +\n            replacement + \" instead.\");\n    }\n\n    function createAliasForDeprecatedMethod(owner, deprecated, replacement, module) {\n        owner[deprecated] = function() {\n            deprecationNotice(deprecated, replacement, module);\n            return owner[replacement].apply(owner, util.toArray(arguments));\n        };\n    }\n\n    util.deprecationNotice = deprecationNotice;\n    util.createAliasForDeprecatedMethod = createAliasForDeprecatedMethod;\n\n    // Allow external scripts to initialize this library in case it's loaded after the document has loaded\n    api.init = init;\n\n    // Execute listener immediately if already initialized\n    api.addInitListener = function(listener) {\n        if (api.initialized) {\n            listener(api);\n        } else {\n            initListeners.push(listener);\n        }\n    };\n\n    var shimListeners = [];\n\n    api.addShimListener = function(listener) {\n        shimListeners.push(listener);\n    };\n\n    function shim(win) {\n        win = win || window;\n        init();\n\n        // Notify listeners\n        for (var i = 0, len = shimListeners.length; i < len; ++i) {\n            shimListeners[i](win);\n        }\n    }\n\n    if (isBrowser) {\n        api.shim = api.createMissingNativeApi = shim;\n        createAliasForDeprecatedMethod(api, \"createMissingNativeApi\", \"shim\");\n    }\n\n    function Module(name, dependencies, initializer) {\n        this.name = name;\n        this.dependencies = dependencies;\n        this.initialized = false;\n        this.supported = false;\n        this.initializer = initializer;\n    }\n\n    Module.prototype = {\n        init: function() {\n            var requiredModuleNames = this.dependencies || [];\n            for (var i = 0, len = requiredModuleNames.length, requiredModule, moduleName; i < len; ++i) {\n                moduleName = requiredModuleNames[i];\n\n                requiredModule = modules[moduleName];\n                if (!requiredModule || !(requiredModule instanceof Module)) {\n                    throw new Error(\"required module '\" + moduleName + \"' not found\");\n                }\n\n                requiredModule.init();\n\n                if (!requiredModule.supported) {\n                    throw new Error(\"required module '\" + moduleName + \"' not supported\");\n                }\n            }\n\n            // Now run initializer\n            this.initializer(this);\n        },\n\n        fail: function(reason) {\n            this.initialized = true;\n            this.supported = false;\n            throw new Error(reason);\n        },\n\n        warn: function(msg) {\n            api.warn(\"Module \" + this.name + \": \" + msg);\n        },\n\n        deprecationNotice: function(deprecated, replacement) {\n            api.warn(\"DEPRECATED: \" + deprecated + \" in module \" + this.name + \" is deprecated. Please use \" +\n                replacement + \" instead\");\n        },\n\n        createError: function(msg) {\n            return new Error(\"Error in Rangy \" + this.name + \" module: \" + msg);\n        }\n    };\n\n    function createModule(name, dependencies, initFunc) {\n        var newModule = new Module(name, dependencies, function(module) {\n            if (!module.initialized) {\n                module.initialized = true;\n                try {\n                    initFunc(api, module);\n                    module.supported = true;\n                } catch (ex) {\n                    var errorMessage = \"Module '\" + name + \"' failed to load: \" + getErrorDesc(ex);\n                    consoleLog(errorMessage);\n                    if (ex.stack) {\n                        consoleLog(ex.stack);\n                    }\n                }\n            }\n        });\n        modules[name] = newModule;\n        return newModule;\n    }\n\n    api.createModule = function(name) {\n        // Allow 2 or 3 arguments (second argument is an optional array of dependencies)\n        var initFunc, dependencies;\n        if (arguments.length == 2) {\n            initFunc = arguments[1];\n            dependencies = [];\n        } else {\n            initFunc = arguments[2];\n            dependencies = arguments[1];\n        }\n\n        var module = createModule(name, dependencies, initFunc);\n\n        // Initialize the module immediately if the core is already initialized\n        if (api.initialized && api.supported) {\n            module.init();\n        }\n    };\n\n    api.createCoreModule = function(name, dependencies, initFunc) {\n        createModule(name, dependencies, initFunc);\n    };\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Ensure rangy.rangePrototype and rangy.selectionPrototype are available immediately\n\n    function RangePrototype() {}\n    api.RangePrototype = RangePrototype;\n    api.rangePrototype = new RangePrototype();\n\n    function SelectionPrototype() {}\n    api.selectionPrototype = new SelectionPrototype();\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // DOM utility methods used by Rangy\n    api.createCoreModule(\"DomUtil\", [], function(api, module) {\n        var UNDEF = \"undefined\";\n        var util = api.util;\n        var getBody = util.getBody;\n\n        // Perform feature tests\n        if (!util.areHostMethods(document, [\"createDocumentFragment\", \"createElement\", \"createTextNode\"])) {\n            module.fail(\"document missing a Node creation method\");\n        }\n\n        if (!util.isHostMethod(document, \"getElementsByTagName\")) {\n            module.fail(\"document missing getElementsByTagName method\");\n        }\n\n        var el = document.createElement(\"div\");\n        if (!util.areHostMethods(el, [\"insertBefore\", \"appendChild\", \"cloneNode\"] ||\n                !util.areHostObjects(el, [\"previousSibling\", \"nextSibling\", \"childNodes\", \"parentNode\"]))) {\n            module.fail(\"Incomplete Element implementation\");\n        }\n\n        // innerHTML is required for Range's createContextualFragment method\n        if (!util.isHostProperty(el, \"innerHTML\")) {\n            module.fail(\"Element is missing innerHTML property\");\n        }\n\n        var textNode = document.createTextNode(\"test\");\n        if (!util.areHostMethods(textNode, [\"splitText\", \"deleteData\", \"insertData\", \"appendData\", \"cloneNode\"] ||\n                !util.areHostObjects(el, [\"previousSibling\", \"nextSibling\", \"childNodes\", \"parentNode\"]) ||\n                !util.areHostProperties(textNode, [\"data\"]))) {\n            module.fail(\"Incomplete Text Node implementation\");\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven't been\n        // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that\n        // contains just the document as a single element and the value searched for is the document.\n        var arrayContains = /*Array.prototype.indexOf ?\n         function(arr, val) {\n         return arr.indexOf(val) > -1;\n         }:*/\n\n            function(arr, val) {\n                var i = arr.length;\n                while (i--) {\n                    if (arr[i] === val) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n\n        // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI\n        function isHtmlNamespace(node) {\n            var ns;\n            return typeof node.namespaceURI == UNDEF || ((ns = node.namespaceURI) === null || ns == \"http://www.w3.org/1999/xhtml\");\n        }\n\n        function parentElement(node) {\n            var parent = node.parentNode;\n            return (parent.nodeType == 1) ? parent : null;\n        }\n\n        function getNodeIndex(node) {\n            var i = 0;\n            while( (node = node.previousSibling) ) {\n                ++i;\n            }\n            return i;\n        }\n\n        function getNodeLength(node) {\n            switch (node.nodeType) {\n                case 7:\n                case 10:\n                    return 0;\n                case 3:\n                case 8:\n                    return node.length;\n                default:\n                    return node.childNodes.length;\n            }\n        }\n\n        function getCommonAncestor(node1, node2) {\n            var ancestors = [], n;\n            for (n = node1; n; n = n.parentNode) {\n                ancestors.push(n);\n            }\n\n            for (n = node2; n; n = n.parentNode) {\n                if (arrayContains(ancestors, n)) {\n                    return n;\n                }\n            }\n\n            return null;\n        }\n\n        function isAncestorOf(ancestor, descendant, selfIsAncestor) {\n            var n = selfIsAncestor ? descendant : descendant.parentNode;\n            while (n) {\n                if (n === ancestor) {\n                    return true;\n                } else {\n                    n = n.parentNode;\n                }\n            }\n            return false;\n        }\n\n        function isOrIsAncestorOf(ancestor, descendant) {\n            return isAncestorOf(ancestor, descendant, true);\n        }\n\n        function getClosestAncestorIn(node, ancestor, selfIsAncestor) {\n            var p, n = selfIsAncestor ? node : node.parentNode;\n            while (n) {\n                p = n.parentNode;\n                if (p === ancestor) {\n                    return n;\n                }\n                n = p;\n            }\n            return null;\n        }\n\n        function isCharacterDataNode(node) {\n            var t = node.nodeType;\n            return t == 3 || t == 4 || t == 8 ; // Text, CDataSection or Comment\n        }\n\n        function isTextOrCommentNode(node) {\n            if (!node) {\n                return false;\n            }\n            var t = node.nodeType;\n            return t == 3 || t == 8 ; // Text or Comment\n        }\n\n        function insertAfter(node, precedingNode) {\n            var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;\n            if (nextNode) {\n                parent.insertBefore(node, nextNode);\n            } else {\n                parent.appendChild(node);\n            }\n            return node;\n        }\n\n        // Note that we cannot use splitText() because it is bugridden in IE 9.\n        function splitDataNode(node, index, positionsToPreserve) {\n            var newNode = node.cloneNode(false);\n            newNode.deleteData(0, index);\n            node.deleteData(index, node.length - index);\n            insertAfter(newNode, node);\n\n            // Preserve positions\n            if (positionsToPreserve) {\n                for (var i = 0, position; position = positionsToPreserve[i++]; ) {\n                    // Handle case where position was inside the portion of node after the split point\n                    if (position.node == node && position.offset > index) {\n                        position.node = newNode;\n                        position.offset -= index;\n                    }\n                    // Handle the case where the position is a node offset within node's parent\n                    else if (position.node == node.parentNode && position.offset > getNodeIndex(node)) {\n                        ++position.offset;\n                    }\n                }\n            }\n            return newNode;\n        }\n\n        function getDocument(node) {\n            if (node.nodeType == 9) {\n                return node;\n            } else if (typeof node.ownerDocument != UNDEF) {\n                return node.ownerDocument;\n            } else if (typeof node.document != UNDEF) {\n                return node.document;\n            } else if (node.parentNode) {\n                return getDocument(node.parentNode);\n            } else {\n                throw module.createError(\"getDocument: no document found for node\");\n            }\n        }\n\n        function getWindow(node) {\n            var doc = getDocument(node);\n            if (typeof doc.defaultView != UNDEF) {\n                return doc.defaultView;\n            } else if (typeof doc.parentWindow != UNDEF) {\n                return doc.parentWindow;\n            } else {\n                throw module.createError(\"Cannot get a window object for node\");\n            }\n        }\n\n        function getIframeDocument(iframeEl) {\n            if (typeof iframeEl.contentDocument != UNDEF) {\n                return iframeEl.contentDocument;\n            } else if (typeof iframeEl.contentWindow != UNDEF) {\n                return iframeEl.contentWindow.document;\n            } else {\n                throw module.createError(\"getIframeDocument: No Document object found for iframe element\");\n            }\n        }\n\n        function getIframeWindow(iframeEl) {\n            if (typeof iframeEl.contentWindow != UNDEF) {\n                return iframeEl.contentWindow;\n            } else if (typeof iframeEl.contentDocument != UNDEF) {\n                return iframeEl.contentDocument.defaultView;\n            } else {\n                throw module.createError(\"getIframeWindow: No Window object found for iframe element\");\n            }\n        }\n\n        // This looks bad. Is it worth it?\n        function isWindow(obj) {\n            return obj && util.isHostMethod(obj, \"setTimeout\") && util.isHostObject(obj, \"document\");\n        }\n\n        function getContentDocument(obj, module, methodName) {\n            var doc;\n\n            if (!obj) {\n                doc = document;\n            }\n\n            // Test if a DOM node has been passed and obtain a document object for it if so\n            else if (util.isHostProperty(obj, \"nodeType\")) {\n                doc = (obj.nodeType == 1 && obj.tagName.toLowerCase() == \"iframe\") ?\n                    getIframeDocument(obj) : getDocument(obj);\n            }\n\n            // Test if the doc parameter appears to be a Window object\n            else if (isWindow(obj)) {\n                doc = obj.document;\n            }\n\n            if (!doc) {\n                throw module.createError(methodName + \"(): Parameter must be a Window object or DOM node\");\n            }\n\n            return doc;\n        }\n\n        function getRootContainer(node) {\n            var parent;\n            while ( (parent = node.parentNode) ) {\n                node = parent;\n            }\n            return node;\n        }\n\n        function comparePoints(nodeA, offsetA, nodeB, offsetB) {\n            // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing\n            var nodeC, root, childA, childB, n;\n            if (nodeA == nodeB) {\n                // Case 1: nodes are the same\n                return offsetA === offsetB ? 0 : (offsetA < offsetB) ? -1 : 1;\n            } else if ( (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) ) {\n                // Case 2: node C (container B or an ancestor) is a child node of A\n                return offsetA <= getNodeIndex(nodeC) ? -1 : 1;\n            } else if ( (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) ) {\n                // Case 3: node C (container A or an ancestor) is a child node of B\n                return getNodeIndex(nodeC) < offsetB  ? -1 : 1;\n            } else {\n                root = getCommonAncestor(nodeA, nodeB);\n                if (!root) {\n                    throw new Error(\"comparePoints error: nodes have no common ancestor\");\n                }\n\n                // Case 4: containers are siblings or descendants of siblings\n                childA = (nodeA === root) ? root : getClosestAncestorIn(nodeA, root, true);\n                childB = (nodeB === root) ? root : getClosestAncestorIn(nodeB, root, true);\n\n                if (childA === childB) {\n                    // This shouldn't be possible\n                    throw module.createError(\"comparePoints got to case 4 and childA and childB are the same!\");\n                } else {\n                    n = root.firstChild;\n                    while (n) {\n                        if (n === childA) {\n                            return -1;\n                        } else if (n === childB) {\n                            return 1;\n                        }\n                        n = n.nextSibling;\n                    }\n                }\n            }\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Test for IE's crash (IE 6/7) or exception (IE >= 8) when a reference to garbage-collected text node is queried\n        var crashyTextNodes = false;\n\n        function isBrokenNode(node) {\n            var n;\n            try {\n                n = node.parentNode;\n                return false;\n            } catch (e) {\n                return true;\n            }\n        }\n\n        (function() {\n            var el = document.createElement(\"b\");\n            el.innerHTML = \"1\";\n            var textNode = el.firstChild;\n            el.innerHTML = \"<br />\";\n            crashyTextNodes = isBrokenNode(textNode);\n\n            api.features.crashyTextNodes = crashyTextNodes;\n        })();\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        function inspectNode(node) {\n            if (!node) {\n                return \"[No node]\";\n            }\n            if (crashyTextNodes && isBrokenNode(node)) {\n                return \"[Broken node]\";\n            }\n            if (isCharacterDataNode(node)) {\n                return '\"' + node.data + '\"';\n            }\n            if (node.nodeType == 1) {\n                var idAttr = node.id ? ' id=\"' + node.id + '\"' : \"\";\n                return \"<\" + node.nodeName + idAttr + \">[index:\" + getNodeIndex(node) + \",length:\" + node.childNodes.length + \"][\" + (node.innerHTML || \"[innerHTML not supported]\").slice(0, 25) + \"]\";\n            }\n            return node.nodeName;\n        }\n\n        function fragmentFromNodeChildren(node) {\n            var fragment = getDocument(node).createDocumentFragment(), child;\n            while ( (child = node.firstChild) ) {\n                fragment.appendChild(child);\n            }\n            return fragment;\n        }\n\n        var getComputedStyleProperty;\n        if (typeof window.getComputedStyle != UNDEF) {\n            getComputedStyleProperty = function(el, propName) {\n                return getWindow(el).getComputedStyle(el, null)[propName];\n            };\n        } else if (typeof document.documentElement.currentStyle != UNDEF) {\n            getComputedStyleProperty = function(el, propName) {\n                return el.currentStyle ? el.currentStyle[propName] : \"\";\n            };\n        } else {\n            module.fail(\"No means of obtaining computed style properties found\");\n        }\n\n        function createTestElement(doc, html, contentEditable) {\n            var body = getBody(doc);\n            var el = doc.createElement(\"div\");\n            el.contentEditable = \"\" + !!contentEditable;\n            if (html) {\n                el.innerHTML = html;\n            }\n\n            // Insert the test element at the start of the body to prevent scrolling to the bottom in iOS (issue #292)\n            var bodyFirstChild = body.firstChild;\n            if (bodyFirstChild) {\n                body.insertBefore(el, bodyFirstChild);\n            } else {\n                body.appendChild(el);\n            }\n\n            return el;\n        }\n\n        function removeNode(node) {\n            return node.parentNode.removeChild(node);\n        }\n\n        function NodeIterator(root) {\n            this.root = root;\n            this._next = root;\n        }\n\n        NodeIterator.prototype = {\n            _current: null,\n\n            hasNext: function() {\n                return !!this._next;\n            },\n\n            next: function() {\n                var n = this._current = this._next;\n                var child, next;\n                if (this._current) {\n                    child = n.firstChild;\n                    if (child) {\n                        this._next = child;\n                    } else {\n                        next = null;\n                        while ((n !== this.root) && !(next = n.nextSibling)) {\n                            n = n.parentNode;\n                        }\n                        this._next = next;\n                    }\n                }\n                return this._current;\n            },\n\n            detach: function() {\n                this._current = this._next = this.root = null;\n            }\n        };\n\n        function createIterator(root) {\n            return new NodeIterator(root);\n        }\n\n        function DomPosition(node, offset) {\n            this.node = node;\n            this.offset = offset;\n        }\n\n        DomPosition.prototype = {\n            equals: function(pos) {\n                return !!pos && this.node === pos.node && this.offset == pos.offset;\n            },\n\n            inspect: function() {\n                return \"[DomPosition(\" + inspectNode(this.node) + \":\" + this.offset + \")]\";\n            },\n\n            toString: function() {\n                return this.inspect();\n            }\n        };\n\n        function DOMException(codeName) {\n            this.code = this[codeName];\n            this.codeName = codeName;\n            this.message = \"DOMException: \" + this.codeName;\n        }\n\n        DOMException.prototype = {\n            INDEX_SIZE_ERR: 1,\n            HIERARCHY_REQUEST_ERR: 3,\n            WRONG_DOCUMENT_ERR: 4,\n            NO_MODIFICATION_ALLOWED_ERR: 7,\n            NOT_FOUND_ERR: 8,\n            NOT_SUPPORTED_ERR: 9,\n            INVALID_STATE_ERR: 11,\n            INVALID_NODE_TYPE_ERR: 24\n        };\n\n        DOMException.prototype.toString = function() {\n            return this.message;\n        };\n\n        api.dom = {\n            arrayContains: arrayContains,\n            isHtmlNamespace: isHtmlNamespace,\n            parentElement: parentElement,\n            getNodeIndex: getNodeIndex,\n            getNodeLength: getNodeLength,\n            getCommonAncestor: getCommonAncestor,\n            isAncestorOf: isAncestorOf,\n            isOrIsAncestorOf: isOrIsAncestorOf,\n            getClosestAncestorIn: getClosestAncestorIn,\n            isCharacterDataNode: isCharacterDataNode,\n            isTextOrCommentNode: isTextOrCommentNode,\n            insertAfter: insertAfter,\n            splitDataNode: splitDataNode,\n            getDocument: getDocument,\n            getWindow: getWindow,\n            getIframeWindow: getIframeWindow,\n            getIframeDocument: getIframeDocument,\n            getBody: getBody,\n            isWindow: isWindow,\n            getContentDocument: getContentDocument,\n            getRootContainer: getRootContainer,\n            comparePoints: comparePoints,\n            isBrokenNode: isBrokenNode,\n            inspectNode: inspectNode,\n            getComputedStyleProperty: getComputedStyleProperty,\n            createTestElement: createTestElement,\n            removeNode: removeNode,\n            fragmentFromNodeChildren: fragmentFromNodeChildren,\n            createIterator: createIterator,\n            DomPosition: DomPosition\n        };\n\n        api.DOMException = DOMException;\n    });\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Pure JavaScript implementation of DOM Range\n    api.createCoreModule(\"DomRange\", [\"DomUtil\"], function(api, module) {\n        var dom = api.dom;\n        var util = api.util;\n        var DomPosition = dom.DomPosition;\n        var DOMException = api.DOMException;\n\n        var isCharacterDataNode = dom.isCharacterDataNode;\n        var getNodeIndex = dom.getNodeIndex;\n        var isOrIsAncestorOf = dom.isOrIsAncestorOf;\n        var getDocument = dom.getDocument;\n        var comparePoints = dom.comparePoints;\n        var splitDataNode = dom.splitDataNode;\n        var getClosestAncestorIn = dom.getClosestAncestorIn;\n        var getNodeLength = dom.getNodeLength;\n        var arrayContains = dom.arrayContains;\n        var getRootContainer = dom.getRootContainer;\n        var crashyTextNodes = api.features.crashyTextNodes;\n\n        var removeNode = dom.removeNode;\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Utility functions\n\n        function isNonTextPartiallySelected(node, range) {\n            return (node.nodeType != 3) &&\n                (isOrIsAncestorOf(node, range.startContainer) || isOrIsAncestorOf(node, range.endContainer));\n        }\n\n        function getRangeDocument(range) {\n            return range.document || getDocument(range.startContainer);\n        }\n\n        function getRangeRoot(range) {\n            return getRootContainer(range.startContainer);\n        }\n\n        function getBoundaryBeforeNode(node) {\n            return new DomPosition(node.parentNode, getNodeIndex(node));\n        }\n\n        function getBoundaryAfterNode(node) {\n            return new DomPosition(node.parentNode, getNodeIndex(node) + 1);\n        }\n\n        function insertNodeAtPosition(node, n, o) {\n            var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;\n            if (isCharacterDataNode(n)) {\n                if (o == n.length) {\n                    dom.insertAfter(node, n);\n                } else {\n                    n.parentNode.insertBefore(node, o == 0 ? n : splitDataNode(n, o));\n                }\n            } else if (o >= n.childNodes.length) {\n                n.appendChild(node);\n            } else {\n                n.insertBefore(node, n.childNodes[o]);\n            }\n            return firstNodeInserted;\n        }\n\n        function rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {\n            assertRangeValid(rangeA);\n            assertRangeValid(rangeB);\n\n            if (getRangeDocument(rangeB) != getRangeDocument(rangeA)) {\n                throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n            }\n\n            var startComparison = comparePoints(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset),\n                endComparison = comparePoints(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);\n\n            return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n        }\n\n        function cloneSubtree(iterator) {\n            var partiallySelected;\n            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {\n                partiallySelected = iterator.isPartiallySelectedSubtree();\n                node = node.cloneNode(!partiallySelected);\n                if (partiallySelected) {\n                    subIterator = iterator.getSubtreeIterator();\n                    node.appendChild(cloneSubtree(subIterator));\n                    subIterator.detach();\n                }\n\n                if (node.nodeType == 10) { // DocumentType\n                    throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n                }\n                frag.appendChild(node);\n            }\n            return frag;\n        }\n\n        function iterateSubtree(rangeIterator, func, iteratorState) {\n            var it, n;\n            iteratorState = iteratorState || { stop: false };\n            for (var node, subRangeIterator; node = rangeIterator.next(); ) {\n                if (rangeIterator.isPartiallySelectedSubtree()) {\n                    if (func(node) === false) {\n                        iteratorState.stop = true;\n                        return;\n                    } else {\n                        // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of\n                        // the node selected by the Range.\n                        subRangeIterator = rangeIterator.getSubtreeIterator();\n                        iterateSubtree(subRangeIterator, func, iteratorState);\n                        subRangeIterator.detach();\n                        if (iteratorState.stop) {\n                            return;\n                        }\n                    }\n                } else {\n                    // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its\n                    // descendants\n                    it = dom.createIterator(node);\n                    while ( (n = it.next()) ) {\n                        if (func(n) === false) {\n                            iteratorState.stop = true;\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n\n        function deleteSubtree(iterator) {\n            var subIterator;\n            while (iterator.next()) {\n                if (iterator.isPartiallySelectedSubtree()) {\n                    subIterator = iterator.getSubtreeIterator();\n                    deleteSubtree(subIterator);\n                    subIterator.detach();\n                } else {\n                    iterator.remove();\n                }\n            }\n        }\n\n        function extractSubtree(iterator) {\n            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {\n\n                if (iterator.isPartiallySelectedSubtree()) {\n                    node = node.cloneNode(false);\n                    subIterator = iterator.getSubtreeIterator();\n                    node.appendChild(extractSubtree(subIterator));\n                    subIterator.detach();\n                } else {\n                    iterator.remove();\n                }\n                if (node.nodeType == 10) { // DocumentType\n                    throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n                }\n                frag.appendChild(node);\n            }\n            return frag;\n        }\n\n        function getNodesInRange(range, nodeTypes, filter) {\n            var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;\n            var filterExists = !!filter;\n            if (filterNodeTypes) {\n                regex = new RegExp(\"^(\" + nodeTypes.join(\"|\") + \")$\");\n            }\n\n            var nodes = [];\n            iterateSubtree(new RangeIterator(range, false), function(node) {\n                if (filterNodeTypes && !regex.test(node.nodeType)) {\n                    return;\n                }\n                if (filterExists && !filter(node)) {\n                    return;\n                }\n                // Don't include a boundary container if it is a character data node and the range does not contain any\n                // of its character data. See issue 190.\n                var sc = range.startContainer;\n                if (node == sc && isCharacterDataNode(sc) && range.startOffset == sc.length) {\n                    return;\n                }\n\n                var ec = range.endContainer;\n                if (node == ec && isCharacterDataNode(ec) && range.endOffset == 0) {\n                    return;\n                }\n\n                nodes.push(node);\n            });\n            return nodes;\n        }\n\n        function inspect(range) {\n            var name = (typeof range.getName == \"undefined\") ? \"Range\" : range.getName();\n            return \"[\" + name + \"(\" + dom.inspectNode(range.startContainer) + \":\" + range.startOffset + \", \" +\n                dom.inspectNode(range.endContainer) + \":\" + range.endOffset + \")]\";\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)\n\n        function RangeIterator(range, clonePartiallySelectedTextNodes) {\n            this.range = range;\n            this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n\n\n            if (!range.collapsed) {\n                this.sc = range.startContainer;\n                this.so = range.startOffset;\n                this.ec = range.endContainer;\n                this.eo = range.endOffset;\n                var root = range.commonAncestorContainer;\n\n                if (this.sc === this.ec && isCharacterDataNode(this.sc)) {\n                    this.isSingleCharacterDataNode = true;\n                    this._first = this._last = this._next = this.sc;\n                } else {\n                    this._first = this._next = (this.sc === root && !isCharacterDataNode(this.sc)) ?\n                        this.sc.childNodes[this.so] : getClosestAncestorIn(this.sc, root, true);\n                    this._last = (this.ec === root && !isCharacterDataNode(this.ec)) ?\n                        this.ec.childNodes[this.eo - 1] : getClosestAncestorIn(this.ec, root, true);\n                }\n            }\n        }\n\n        RangeIterator.prototype = {\n            _current: null,\n            _next: null,\n            _first: null,\n            _last: null,\n            isSingleCharacterDataNode: false,\n\n            reset: function() {\n                this._current = null;\n                this._next = this._first;\n            },\n\n            hasNext: function() {\n                return !!this._next;\n            },\n\n            next: function() {\n                // Move to next node\n                var current = this._current = this._next;\n                if (current) {\n                    this._next = (current !== this._last) ? current.nextSibling : null;\n\n                    // Check for partially selected text nodes\n                    if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n                        if (current === this.ec) {\n                            (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);\n                        }\n                        if (this._current === this.sc) {\n                            (current = current.cloneNode(true)).deleteData(0, this.so);\n                        }\n                    }\n                }\n\n                return current;\n            },\n\n            remove: function() {\n                var current = this._current, start, end;\n\n                if (isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {\n                    start = (current === this.sc) ? this.so : 0;\n                    end = (current === this.ec) ? this.eo : current.length;\n                    if (start != end) {\n                        current.deleteData(start, end - start);\n                    }\n                } else {\n                    if (current.parentNode) {\n                        removeNode(current);\n                    } else {\n                    }\n                }\n            },\n\n            // Checks if the current node is partially selected\n            isPartiallySelectedSubtree: function() {\n                var current = this._current;\n                return isNonTextPartiallySelected(current, this.range);\n            },\n\n            getSubtreeIterator: function() {\n                var subRange;\n                if (this.isSingleCharacterDataNode) {\n                    subRange = this.range.cloneRange();\n                    subRange.collapse(false);\n                } else {\n                    subRange = new Range(getRangeDocument(this.range));\n                    var current = this._current;\n                    var startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);\n\n                    if (isOrIsAncestorOf(current, this.sc)) {\n                        startContainer = this.sc;\n                        startOffset = this.so;\n                    }\n                    if (isOrIsAncestorOf(current, this.ec)) {\n                        endContainer = this.ec;\n                        endOffset = this.eo;\n                    }\n\n                    updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);\n                }\n                return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);\n            },\n\n            detach: function() {\n                this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;\n            }\n        };\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];\n        var rootContainerNodeTypes = [2, 9, 11];\n        var readonlyNodeTypes = [5, 6, 10, 12];\n        var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];\n        var surroundNodeTypes = [1, 3, 4, 5, 7, 8];\n\n        function createAncestorFinder(nodeTypes) {\n            return function(node, selfIsAncestor) {\n                var t, n = selfIsAncestor ? node : node.parentNode;\n                while (n) {\n                    t = n.nodeType;\n                    if (arrayContains(nodeTypes, t)) {\n                        return n;\n                    }\n                    n = n.parentNode;\n                }\n                return null;\n            };\n        }\n\n        var getDocumentOrFragmentContainer = createAncestorFinder( [9, 11] );\n        var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);\n        var getDocTypeNotationEntityAncestor = createAncestorFinder( [6, 10, 12] );\n\n        function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {\n            if (getDocTypeNotationEntityAncestor(node, allowSelf)) {\n                throw new DOMException(\"INVALID_NODE_TYPE_ERR\");\n            }\n        }\n\n        function assertValidNodeType(node, invalidTypes) {\n            if (!arrayContains(invalidTypes, node.nodeType)) {\n                throw new DOMException(\"INVALID_NODE_TYPE_ERR\");\n            }\n        }\n\n        function assertValidOffset(node, offset) {\n            if (offset < 0 || offset > (isCharacterDataNode(node) ? node.length : node.childNodes.length)) {\n                throw new DOMException(\"INDEX_SIZE_ERR\");\n            }\n        }\n\n        function assertSameDocumentOrFragment(node1, node2) {\n            if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {\n                throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n            }\n        }\n\n        function assertNodeNotReadOnly(node) {\n            if (getReadonlyAncestor(node, true)) {\n                throw new DOMException(\"NO_MODIFICATION_ALLOWED_ERR\");\n            }\n        }\n\n        function assertNode(node, codeName) {\n            if (!node) {\n                throw new DOMException(codeName);\n            }\n        }\n\n        function isValidOffset(node, offset) {\n            return offset <= (isCharacterDataNode(node) ? node.length : node.childNodes.length);\n        }\n\n        function isRangeValid(range) {\n            return (!!range.startContainer && !!range.endContainer &&\n            !(crashyTextNodes && (dom.isBrokenNode(range.startContainer) || dom.isBrokenNode(range.endContainer))) &&\n            getRootContainer(range.startContainer) == getRootContainer(range.endContainer) &&\n            isValidOffset(range.startContainer, range.startOffset) &&\n            isValidOffset(range.endContainer, range.endOffset));\n        }\n\n        function assertRangeValid(range) {\n            if (!isRangeValid(range)) {\n                throw new Error(\"Range error: Range is not valid. This usually happens after DOM mutation. Range: (\" + range.inspect() + \")\");\n            }\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Test the browser's innerHTML support to decide how to implement createContextualFragment\n        var styleEl = document.createElement(\"style\");\n        var htmlParsingConforms = false;\n        try {\n            styleEl.innerHTML = \"<b>x</b>\";\n            htmlParsingConforms = (styleEl.firstChild.nodeType == 3); // Opera incorrectly creates an element node\n        } catch (e) {\n            // IE 6 and 7 throw\n        }\n\n        api.features.htmlParsingConforms = htmlParsingConforms;\n\n        var createContextualFragment = htmlParsingConforms ?\n\n            // Implementation as per HTML parsing spec, trusting in the browser's implementation of innerHTML. See\n            // discussion and base code for this implementation at issue 67.\n            // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface\n            // Thanks to Aleks Williams.\n            function(fragmentStr) {\n                // \"Let node the context object's start's node.\"\n                var node = this.startContainer;\n                var doc = getDocument(node);\n\n                // \"If the context object's start's node is null, raise an INVALID_STATE_ERR\n                // exception and abort these steps.\"\n                if (!node) {\n                    throw new DOMException(\"INVALID_STATE_ERR\");\n                }\n\n                // \"Let element be as follows, depending on node's interface:\"\n                // Document, Document Fragment: null\n                var el = null;\n\n                // \"Element: node\"\n                if (node.nodeType == 1) {\n                    el = node;\n\n                    // \"Text, Comment: node's parentElement\"\n                } else if (isCharacterDataNode(node)) {\n                    el = dom.parentElement(node);\n                }\n\n                // \"If either element is null or element's ownerDocument is an HTML document\n                // and element's local name is \"html\" and element's namespace is the HTML\n                // namespace\"\n                if (el === null || (\n                        el.nodeName == \"HTML\" &&\n                        dom.isHtmlNamespace(getDocument(el).documentElement) &&\n                        dom.isHtmlNamespace(el)\n                    )) {\n\n                    // \"let element be a new Element with \"body\" as its local name and the HTML\n                    // namespace as its namespace.\"\"\n                    el = doc.createElement(\"body\");\n                } else {\n                    el = el.cloneNode(false);\n                }\n\n                // \"If the node's document is an HTML document: Invoke the HTML fragment parsing algorithm.\"\n                // \"If the node's document is an XML document: Invoke the XML fragment parsing algorithm.\"\n                // \"In either case, the algorithm must be invoked with fragment as the input\n                // and element as the context element.\"\n                el.innerHTML = fragmentStr;\n\n                // \"If this raises an exception, then abort these steps. Otherwise, let new\n                // children be the nodes returned.\"\n\n                // \"Let fragment be a new DocumentFragment.\"\n                // \"Append all new children to fragment.\"\n                // \"Return fragment.\"\n                return dom.fragmentFromNodeChildren(el);\n            } :\n\n            // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that\n            // previous versions of Rangy used (with the exception of using a body element rather than a div)\n            function(fragmentStr) {\n                var doc = getRangeDocument(this);\n                var el = doc.createElement(\"body\");\n                el.innerHTML = fragmentStr;\n\n                return dom.fragmentFromNodeChildren(el);\n            };\n\n        function splitRangeBoundaries(range, positionsToPreserve) {\n            assertRangeValid(range);\n\n            var sc = range.startContainer, so = range.startOffset, ec = range.endContainer, eo = range.endOffset;\n            var startEndSame = (sc === ec);\n\n            if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n                splitDataNode(ec, eo, positionsToPreserve);\n            }\n\n            if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n                sc = splitDataNode(sc, so, positionsToPreserve);\n                if (startEndSame) {\n                    eo -= so;\n                    ec = sc;\n                } else if (ec == sc.parentNode && eo >= getNodeIndex(sc)) {\n                    eo++;\n                }\n                so = 0;\n            }\n            range.setStartAndEnd(sc, so, ec, eo);\n        }\n\n        function rangeToHtml(range) {\n            assertRangeValid(range);\n            var container = range.commonAncestorContainer.parentNode.cloneNode(false);\n            container.appendChild( range.cloneContents() );\n            return container.innerHTML;\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        var rangeProperties = [\"startContainer\", \"startOffset\", \"endContainer\", \"endOffset\", \"collapsed\",\n            \"commonAncestorContainer\"];\n\n        var s2s = 0, s2e = 1, e2e = 2, e2s = 3;\n        var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;\n\n        util.extend(api.rangePrototype, {\n            compareBoundaryPoints: function(how, range) {\n                assertRangeValid(this);\n                assertSameDocumentOrFragment(this.startContainer, range.startContainer);\n\n                var nodeA, offsetA, nodeB, offsetB;\n                var prefixA = (how == e2s || how == s2s) ? \"start\" : \"end\";\n                var prefixB = (how == s2e || how == s2s) ? \"start\" : \"end\";\n                nodeA = this[prefixA + \"Container\"];\n                offsetA = this[prefixA + \"Offset\"];\n                nodeB = range[prefixB + \"Container\"];\n                offsetB = range[prefixB + \"Offset\"];\n                return comparePoints(nodeA, offsetA, nodeB, offsetB);\n            },\n\n            insertNode: function(node) {\n                assertRangeValid(this);\n                assertValidNodeType(node, insertableNodeTypes);\n                assertNodeNotReadOnly(this.startContainer);\n\n                if (isOrIsAncestorOf(node, this.startContainer)) {\n                    throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n                }\n\n                // No check for whether the container of the start of the Range is of a type that does not allow\n                // children of the type of node: the browser's DOM implementation should do this for us when we attempt\n                // to add the node\n\n                var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);\n                this.setStartBefore(firstNodeInserted);\n            },\n\n            cloneContents: function() {\n                assertRangeValid(this);\n\n                var clone, frag;\n                if (this.collapsed) {\n                    return getRangeDocument(this).createDocumentFragment();\n                } else {\n                    if (this.startContainer === this.endContainer && isCharacterDataNode(this.startContainer)) {\n                        clone = this.startContainer.cloneNode(true);\n                        clone.data = clone.data.slice(this.startOffset, this.endOffset);\n                        frag = getRangeDocument(this).createDocumentFragment();\n                        frag.appendChild(clone);\n                        return frag;\n                    } else {\n                        var iterator = new RangeIterator(this, true);\n                        clone = cloneSubtree(iterator);\n                        iterator.detach();\n                    }\n                    return clone;\n                }\n            },\n\n            canSurroundContents: function() {\n                assertRangeValid(this);\n                assertNodeNotReadOnly(this.startContainer);\n                assertNodeNotReadOnly(this.endContainer);\n\n                // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n                // no non-text nodes.\n                var iterator = new RangeIterator(this, true);\n                var boundariesInvalid = (iterator._first && (isNonTextPartiallySelected(iterator._first, this)) ||\n                (iterator._last && isNonTextPartiallySelected(iterator._last, this)));\n                iterator.detach();\n                return !boundariesInvalid;\n            },\n\n            surroundContents: function(node) {\n                assertValidNodeType(node, surroundNodeTypes);\n\n                if (!this.canSurroundContents()) {\n                    throw new DOMException(\"INVALID_STATE_ERR\");\n                }\n\n                // Extract the contents\n                var content = this.extractContents();\n\n                // Clear the children of the node\n                if (node.hasChildNodes()) {\n                    while (node.lastChild) {\n                        node.removeChild(node.lastChild);\n                    }\n                }\n\n                // Insert the new node and add the extracted contents\n                insertNodeAtPosition(node, this.startContainer, this.startOffset);\n                node.appendChild(content);\n\n                this.selectNode(node);\n            },\n\n            cloneRange: function() {\n                assertRangeValid(this);\n                var range = new Range(getRangeDocument(this));\n                var i = rangeProperties.length, prop;\n                while (i--) {\n                    prop = rangeProperties[i];\n                    range[prop] = this[prop];\n                }\n                return range;\n            },\n\n            toString: function() {\n                assertRangeValid(this);\n                var sc = this.startContainer;\n                if (sc === this.endContainer && isCharacterDataNode(sc)) {\n                    return (sc.nodeType == 3 || sc.nodeType == 4) ? sc.data.slice(this.startOffset, this.endOffset) : \"\";\n                } else {\n                    var textParts = [], iterator = new RangeIterator(this, true);\n                    iterateSubtree(iterator, function(node) {\n                        // Accept only text or CDATA nodes, not comments\n                        if (node.nodeType == 3 || node.nodeType == 4) {\n                            textParts.push(node.data);\n                        }\n                    });\n                    iterator.detach();\n                    return textParts.join(\"\");\n                }\n            },\n\n            // The methods below are all non-standard. The following batch were introduced by Mozilla but have since\n            // been removed from Mozilla.\n\n            compareNode: function(node) {\n                assertRangeValid(this);\n\n                var parent = node.parentNode;\n                var nodeIndex = getNodeIndex(node);\n\n                if (!parent) {\n                    throw new DOMException(\"NOT_FOUND_ERR\");\n                }\n\n                var startComparison = this.comparePoint(parent, nodeIndex),\n                    endComparison = this.comparePoint(parent, nodeIndex + 1);\n\n                if (startComparison < 0) { // Node starts before\n                    return (endComparison > 0) ? n_b_a : n_b;\n                } else {\n                    return (endComparison > 0) ? n_a : n_i;\n                }\n            },\n\n            comparePoint: function(node, offset) {\n                assertRangeValid(this);\n                assertNode(node, \"HIERARCHY_REQUEST_ERR\");\n                assertSameDocumentOrFragment(node, this.startContainer);\n\n                if (comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {\n                    return -1;\n                } else if (comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {\n                    return 1;\n                }\n                return 0;\n            },\n\n            createContextualFragment: createContextualFragment,\n\n            toHtml: function() {\n                return rangeToHtml(this);\n            },\n\n            // touchingIsIntersecting determines whether this method considers a node that borders a range intersects\n            // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)\n            intersectsNode: function(node, touchingIsIntersecting) {\n                assertRangeValid(this);\n                if (getRootContainer(node) != getRangeRoot(this)) {\n                    return false;\n                }\n\n                var parent = node.parentNode, offset = getNodeIndex(node);\n                if (!parent) {\n                    return true;\n                }\n\n                var startComparison = comparePoints(parent, offset, this.endContainer, this.endOffset),\n                    endComparison = comparePoints(parent, offset + 1, this.startContainer, this.startOffset);\n\n                return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n            },\n\n            isPointInRange: function(node, offset) {\n                assertRangeValid(this);\n                assertNode(node, \"HIERARCHY_REQUEST_ERR\");\n                assertSameDocumentOrFragment(node, this.startContainer);\n\n                return (comparePoints(node, offset, this.startContainer, this.startOffset) >= 0) &&\n                    (comparePoints(node, offset, this.endContainer, this.endOffset) <= 0);\n            },\n\n            // The methods below are non-standard and invented by me.\n\n            // Sharing a boundary start-to-end or end-to-start does not count as intersection.\n            intersectsRange: function(range) {\n                return rangesIntersect(this, range, false);\n            },\n\n            // Sharing a boundary start-to-end or end-to-start does count as intersection.\n            intersectsOrTouchesRange: function(range) {\n                return rangesIntersect(this, range, true);\n            },\n\n            intersection: function(range) {\n                if (this.intersectsRange(range)) {\n                    var startComparison = comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),\n                        endComparison = comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);\n\n                    var intersectionRange = this.cloneRange();\n                    if (startComparison == -1) {\n                        intersectionRange.setStart(range.startContainer, range.startOffset);\n                    }\n                    if (endComparison == 1) {\n                        intersectionRange.setEnd(range.endContainer, range.endOffset);\n                    }\n                    return intersectionRange;\n                }\n                return null;\n            },\n\n            union: function(range) {\n                if (this.intersectsOrTouchesRange(range)) {\n                    var unionRange = this.cloneRange();\n                    if (comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {\n                        unionRange.setStart(range.startContainer, range.startOffset);\n                    }\n                    if (comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {\n                        unionRange.setEnd(range.endContainer, range.endOffset);\n                    }\n                    return unionRange;\n                } else {\n                    throw new DOMException(\"Ranges do not intersect\");\n                }\n            },\n\n            containsNode: function(node, allowPartial) {\n                if (allowPartial) {\n                    return this.intersectsNode(node, false);\n                } else {\n                    return this.compareNode(node) == n_i;\n                }\n            },\n\n            containsNodeContents: function(node) {\n                return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, getNodeLength(node)) <= 0;\n            },\n\n            containsRange: function(range) {\n                var intersection = this.intersection(range);\n                return intersection !== null && range.equals(intersection);\n            },\n\n            containsNodeText: function(node) {\n                var nodeRange = this.cloneRange();\n                nodeRange.selectNode(node);\n                var textNodes = nodeRange.getNodes([3]);\n                if (textNodes.length > 0) {\n                    nodeRange.setStart(textNodes[0], 0);\n                    var lastTextNode = textNodes.pop();\n                    nodeRange.setEnd(lastTextNode, lastTextNode.length);\n                    return this.containsRange(nodeRange);\n                } else {\n                    return this.containsNodeContents(node);\n                }\n            },\n\n            getNodes: function(nodeTypes, filter) {\n                assertRangeValid(this);\n                return getNodesInRange(this, nodeTypes, filter);\n            },\n\n            getDocument: function() {\n                return getRangeDocument(this);\n            },\n\n            collapseBefore: function(node) {\n                this.setEndBefore(node);\n                this.collapse(false);\n            },\n\n            collapseAfter: function(node) {\n                this.setStartAfter(node);\n                this.collapse(true);\n            },\n\n            getBookmark: function(containerNode) {\n                var doc = getRangeDocument(this);\n                var preSelectionRange = api.createRange(doc);\n                containerNode = containerNode || dom.getBody(doc);\n                preSelectionRange.selectNodeContents(containerNode);\n                var range = this.intersection(preSelectionRange);\n                var start = 0, end = 0;\n                if (range) {\n                    preSelectionRange.setEnd(range.startContainer, range.startOffset);\n                    start = preSelectionRange.toString().length;\n                    end = start + range.toString().length;\n                }\n\n                return {\n                    start: start,\n                    end: end,\n                    containerNode: containerNode\n                };\n            },\n\n            moveToBookmark: function(bookmark) {\n                var containerNode = bookmark.containerNode;\n                var charIndex = 0;\n                this.setStart(containerNode, 0);\n                this.collapse(true);\n                var nodeStack = [containerNode], node, foundStart = false, stop = false;\n                var nextCharIndex, i, childNodes;\n\n                while (!stop && (node = nodeStack.pop())) {\n                    if (node.nodeType == 3) {\n                        nextCharIndex = charIndex + node.length;\n                        if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {\n                            this.setStart(node, bookmark.start - charIndex);\n                            foundStart = true;\n                        }\n                        if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {\n                            this.setEnd(node, bookmark.end - charIndex);\n                            stop = true;\n                        }\n                        charIndex = nextCharIndex;\n                    } else {\n                        childNodes = node.childNodes;\n                        i = childNodes.length;\n                        while (i--) {\n                            nodeStack.push(childNodes[i]);\n                        }\n                    }\n                }\n            },\n\n            getName: function() {\n                return \"DomRange\";\n            },\n\n            equals: function(range) {\n                return Range.rangesEqual(this, range);\n            },\n\n            isValid: function() {\n                return isRangeValid(this);\n            },\n\n            inspect: function() {\n                return inspect(this);\n            },\n\n            detach: function() {\n                // In DOM4, detach() is now a no-op.\n            }\n        });\n\n        function copyComparisonConstantsToObject(obj) {\n            obj.START_TO_START = s2s;\n            obj.START_TO_END = s2e;\n            obj.END_TO_END = e2e;\n            obj.END_TO_START = e2s;\n\n            obj.NODE_BEFORE = n_b;\n            obj.NODE_AFTER = n_a;\n            obj.NODE_BEFORE_AND_AFTER = n_b_a;\n            obj.NODE_INSIDE = n_i;\n        }\n\n        function copyComparisonConstants(constructor) {\n            copyComparisonConstantsToObject(constructor);\n            copyComparisonConstantsToObject(constructor.prototype);\n        }\n\n        function createRangeContentRemover(remover, boundaryUpdater) {\n            return function() {\n                assertRangeValid(this);\n\n                var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;\n\n                var iterator = new RangeIterator(this, true);\n\n                // Work out where to position the range after content removal\n                var node, boundary;\n                if (sc !== root) {\n                    node = getClosestAncestorIn(sc, root, true);\n                    boundary = getBoundaryAfterNode(node);\n                    sc = boundary.node;\n                    so = boundary.offset;\n                }\n\n                // Check none of the range is read-only\n                iterateSubtree(iterator, assertNodeNotReadOnly);\n\n                iterator.reset();\n\n                // Remove the content\n                var returnValue = remover(iterator);\n                iterator.detach();\n\n                // Move to the new position\n                boundaryUpdater(this, sc, so, sc, so);\n\n                return returnValue;\n            };\n        }\n\n        function createPrototypeRange(constructor, boundaryUpdater) {\n            function createBeforeAfterNodeSetter(isBefore, isStart) {\n                return function(node) {\n                    assertValidNodeType(node, beforeAfterNodeTypes);\n                    assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);\n\n                    var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);\n                    (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);\n                };\n            }\n\n            function setRangeStart(range, node, offset) {\n                var ec = range.endContainer, eo = range.endOffset;\n                if (node !== range.startContainer || offset !== range.startOffset) {\n                    // Check the root containers of the range and the new boundary, and also check whether the new boundary\n                    // is after the current end. In either case, collapse the range to the new position\n                    if (getRootContainer(node) != getRootContainer(ec) || comparePoints(node, offset, ec, eo) == 1) {\n                        ec = node;\n                        eo = offset;\n                    }\n                    boundaryUpdater(range, node, offset, ec, eo);\n                }\n            }\n\n            function setRangeEnd(range, node, offset) {\n                var sc = range.startContainer, so = range.startOffset;\n                if (node !== range.endContainer || offset !== range.endOffset) {\n                    // Check the root containers of the range and the new boundary, and also check whether the new boundary\n                    // is after the current end. In either case, collapse the range to the new position\n                    if (getRootContainer(node) != getRootContainer(sc) || comparePoints(node, offset, sc, so) == -1) {\n                        sc = node;\n                        so = offset;\n                    }\n                    boundaryUpdater(range, sc, so, node, offset);\n                }\n            }\n\n            // Set up inheritance\n            var F = function() {};\n            F.prototype = api.rangePrototype;\n            constructor.prototype = new F();\n\n            util.extend(constructor.prototype, {\n                setStart: function(node, offset) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n                    assertValidOffset(node, offset);\n\n                    setRangeStart(this, node, offset);\n                },\n\n                setEnd: function(node, offset) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n                    assertValidOffset(node, offset);\n\n                    setRangeEnd(this, node, offset);\n                },\n\n                /**\n                 * Convenience method to set a range's start and end boundaries. Overloaded as follows:\n                 * - Two parameters (node, offset) creates a collapsed range at that position\n                 * - Three parameters (node, startOffset, endOffset) creates a range contained with node starting at\n                 *   startOffset and ending at endOffset\n                 * - Four parameters (startNode, startOffset, endNode, endOffset) creates a range starting at startOffset in\n                 *   startNode and ending at endOffset in endNode\n                 */\n                setStartAndEnd: function() {\n                    var args = arguments;\n                    var sc = args[0], so = args[1], ec = sc, eo = so;\n\n                    switch (args.length) {\n                        case 3:\n                            eo = args[2];\n                            break;\n                        case 4:\n                            ec = args[2];\n                            eo = args[3];\n                            break;\n                    }\n\n                    boundaryUpdater(this, sc, so, ec, eo);\n                },\n\n                setBoundary: function(node, offset, isStart) {\n                    this[\"set\" + (isStart ? \"Start\" : \"End\")](node, offset);\n                },\n\n                setStartBefore: createBeforeAfterNodeSetter(true, true),\n                setStartAfter: createBeforeAfterNodeSetter(false, true),\n                setEndBefore: createBeforeAfterNodeSetter(true, false),\n                setEndAfter: createBeforeAfterNodeSetter(false, false),\n\n                collapse: function(isStart) {\n                    assertRangeValid(this);\n                    if (isStart) {\n                        boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);\n                    } else {\n                        boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);\n                    }\n                },\n\n                selectNodeContents: function(node) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n\n                    boundaryUpdater(this, node, 0, node, getNodeLength(node));\n                },\n\n                selectNode: function(node) {\n                    assertNoDocTypeNotationEntityAncestor(node, false);\n                    assertValidNodeType(node, beforeAfterNodeTypes);\n\n                    var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);\n                    boundaryUpdater(this, start.node, start.offset, end.node, end.offset);\n                },\n\n                extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),\n\n                deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),\n\n                canSurroundContents: function() {\n                    assertRangeValid(this);\n                    assertNodeNotReadOnly(this.startContainer);\n                    assertNodeNotReadOnly(this.endContainer);\n\n                    // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n                    // no non-text nodes.\n                    var iterator = new RangeIterator(this, true);\n                    var boundariesInvalid = (iterator._first && isNonTextPartiallySelected(iterator._first, this) ||\n                    (iterator._last && isNonTextPartiallySelected(iterator._last, this)));\n                    iterator.detach();\n                    return !boundariesInvalid;\n                },\n\n                splitBoundaries: function() {\n                    splitRangeBoundaries(this);\n                },\n\n                splitBoundariesPreservingPositions: function(positionsToPreserve) {\n                    splitRangeBoundaries(this, positionsToPreserve);\n                },\n\n                normalizeBoundaries: function() {\n                    assertRangeValid(this);\n\n                    var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;\n\n                    var mergeForward = function(node) {\n                        var sibling = node.nextSibling;\n                        if (sibling && sibling.nodeType == node.nodeType) {\n                            ec = node;\n                            eo = node.length;\n                            node.appendData(sibling.data);\n                            removeNode(sibling);\n                        }\n                    };\n\n                    var mergeBackward = function(node) {\n                        var sibling = node.previousSibling;\n                        if (sibling && sibling.nodeType == node.nodeType) {\n                            sc = node;\n                            var nodeLength = node.length;\n                            so = sibling.length;\n                            node.insertData(0, sibling.data);\n                            removeNode(sibling);\n                            if (sc == ec) {\n                                eo += so;\n                                ec = sc;\n                            } else if (ec == node.parentNode) {\n                                var nodeIndex = getNodeIndex(node);\n                                if (eo == nodeIndex) {\n                                    ec = node;\n                                    eo = nodeLength;\n                                } else if (eo > nodeIndex) {\n                                    eo--;\n                                }\n                            }\n                        }\n                    };\n\n                    var normalizeStart = true;\n                    var sibling;\n\n                    if (isCharacterDataNode(ec)) {\n                        if (eo == ec.length) {\n                            mergeForward(ec);\n                        } else if (eo == 0) {\n                            sibling = ec.previousSibling;\n                            if (sibling && sibling.nodeType == ec.nodeType) {\n                                eo = sibling.length;\n                                if (sc == ec) {\n                                    normalizeStart = false;\n                                }\n                                sibling.appendData(ec.data);\n                                removeNode(ec);\n                                ec = sibling;\n                            }\n                        }\n                    } else {\n                        if (eo > 0) {\n                            var endNode = ec.childNodes[eo - 1];\n                            if (endNode && isCharacterDataNode(endNode)) {\n                                mergeForward(endNode);\n                            }\n                        }\n                        normalizeStart = !this.collapsed;\n                    }\n\n                    if (normalizeStart) {\n                        if (isCharacterDataNode(sc)) {\n                            if (so == 0) {\n                                mergeBackward(sc);\n                            } else if (so == sc.length) {\n                                sibling = sc.nextSibling;\n                                if (sibling && sibling.nodeType == sc.nodeType) {\n                                    if (ec == sibling) {\n                                        ec = sc;\n                                        eo += sc.length;\n                                    }\n                                    sc.appendData(sibling.data);\n                                    removeNode(sibling);\n                                }\n                            }\n                        } else {\n                            if (so < sc.childNodes.length) {\n                                var startNode = sc.childNodes[so];\n                                if (startNode && isCharacterDataNode(startNode)) {\n                                    mergeBackward(startNode);\n                                }\n                            }\n                        }\n                    } else {\n                        sc = ec;\n                        so = eo;\n                    }\n\n                    boundaryUpdater(this, sc, so, ec, eo);\n                },\n\n                collapseToPoint: function(node, offset) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n                    assertValidOffset(node, offset);\n                    this.setStartAndEnd(node, offset);\n                }\n            });\n\n            copyComparisonConstants(constructor);\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Updates commonAncestorContainer and collapsed after boundary change\n        function updateCollapsedAndCommonAncestor(range) {\n            range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);\n            range.commonAncestorContainer = range.collapsed ?\n                range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);\n        }\n\n        function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {\n            range.startContainer = startContainer;\n            range.startOffset = startOffset;\n            range.endContainer = endContainer;\n            range.endOffset = endOffset;\n            range.document = dom.getDocument(startContainer);\n\n            updateCollapsedAndCommonAncestor(range);\n        }\n\n        function Range(doc) {\n            this.startContainer = doc;\n            this.startOffset = 0;\n            this.endContainer = doc;\n            this.endOffset = 0;\n            this.document = doc;\n            updateCollapsedAndCommonAncestor(this);\n        }\n\n        createPrototypeRange(Range, updateBoundaries);\n\n        util.extend(Range, {\n            rangeProperties: rangeProperties,\n            RangeIterator: RangeIterator,\n            copyComparisonConstants: copyComparisonConstants,\n            createPrototypeRange: createPrototypeRange,\n            inspect: inspect,\n            toHtml: rangeToHtml,\n            getRangeDocument: getRangeDocument,\n            rangesEqual: function(r1, r2) {\n                return r1.startContainer === r2.startContainer &&\n                    r1.startOffset === r2.startOffset &&\n                    r1.endContainer === r2.endContainer &&\n                    r1.endOffset === r2.endOffset;\n            }\n        });\n\n        api.DomRange = Range;\n    });\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Wrappers for the browser's native DOM Range and/or TextRange implementation\n    api.createCoreModule(\"WrappedRange\", [\"DomRange\"], function(api, module) {\n        var WrappedRange, WrappedTextRange;\n        var dom = api.dom;\n        var util = api.util;\n        var DomPosition = dom.DomPosition;\n        var DomRange = api.DomRange;\n        var getBody = dom.getBody;\n        var getContentDocument = dom.getContentDocument;\n        var isCharacterDataNode = dom.isCharacterDataNode;\n\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        if (api.features.implementsDomRange) {\n            // This is a wrapper around the browser's native DOM Range. It has two aims:\n            // - Provide workarounds for specific browser bugs\n            // - provide convenient extensions, which are inherited from Rangy's DomRange\n\n            (function() {\n                var rangeProto;\n                var rangeProperties = DomRange.rangeProperties;\n\n                function updateRangeProperties(range) {\n                    var i = rangeProperties.length, prop;\n                    while (i--) {\n                        prop = rangeProperties[i];\n                        range[prop] = range.nativeRange[prop];\n                    }\n                    // Fix for broken collapsed property in IE 9.\n                    range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);\n                }\n\n                function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {\n                    var startMoved = (range.startContainer !== startContainer || range.startOffset != startOffset);\n                    var endMoved = (range.endContainer !== endContainer || range.endOffset != endOffset);\n                    var nativeRangeDifferent = !range.equals(range.nativeRange);\n\n                    // Always set both boundaries for the benefit of IE9 (see issue 35)\n                    if (startMoved || endMoved || nativeRangeDifferent) {\n                        range.setEnd(endContainer, endOffset);\n                        range.setStart(startContainer, startOffset);\n                    }\n                }\n\n                var createBeforeAfterNodeSetter;\n\n                WrappedRange = function(range) {\n                    if (!range) {\n                        throw module.createError(\"WrappedRange: Range must be specified\");\n                    }\n                    this.nativeRange = range;\n                    updateRangeProperties(this);\n                };\n\n                DomRange.createPrototypeRange(WrappedRange, updateNativeRange);\n\n                rangeProto = WrappedRange.prototype;\n\n                rangeProto.selectNode = function(node) {\n                    this.nativeRange.selectNode(node);\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.cloneContents = function() {\n                    return this.nativeRange.cloneContents();\n                };\n\n                // Due to a long-standing Firefox bug that I have not been able to find a reliable way to detect,\n                // insertNode() is never delegated to the native range.\n\n                rangeProto.surroundContents = function(node) {\n                    this.nativeRange.surroundContents(node);\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.collapse = function(isStart) {\n                    this.nativeRange.collapse(isStart);\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.cloneRange = function() {\n                    return new WrappedRange(this.nativeRange.cloneRange());\n                };\n\n                rangeProto.refresh = function() {\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.toString = function() {\n                    return this.nativeRange.toString();\n                };\n\n                // Create test range and node for feature detection\n\n                var testTextNode = document.createTextNode(\"test\");\n                getBody(document).appendChild(testTextNode);\n                var range = document.createRange();\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and\n                // correct for it\n\n                range.setStart(testTextNode, 0);\n                range.setEnd(testTextNode, 0);\n\n                try {\n                    range.setStart(testTextNode, 1);\n\n                    rangeProto.setStart = function(node, offset) {\n                        this.nativeRange.setStart(node, offset);\n                        updateRangeProperties(this);\n                    };\n\n                    rangeProto.setEnd = function(node, offset) {\n                        this.nativeRange.setEnd(node, offset);\n                        updateRangeProperties(this);\n                    };\n\n                    createBeforeAfterNodeSetter = function(name) {\n                        return function(node) {\n                            this.nativeRange[name](node);\n                            updateRangeProperties(this);\n                        };\n                    };\n\n                } catch(ex) {\n\n                    rangeProto.setStart = function(node, offset) {\n                        try {\n                            this.nativeRange.setStart(node, offset);\n                        } catch (ex) {\n                            this.nativeRange.setEnd(node, offset);\n                            this.nativeRange.setStart(node, offset);\n                        }\n                        updateRangeProperties(this);\n                    };\n\n                    rangeProto.setEnd = function(node, offset) {\n                        try {\n                            this.nativeRange.setEnd(node, offset);\n                        } catch (ex) {\n                            this.nativeRange.setStart(node, offset);\n                            this.nativeRange.setEnd(node, offset);\n                        }\n                        updateRangeProperties(this);\n                    };\n\n                    createBeforeAfterNodeSetter = function(name, oppositeName) {\n                        return function(node) {\n                            try {\n                                this.nativeRange[name](node);\n                            } catch (ex) {\n                                this.nativeRange[oppositeName](node);\n                                this.nativeRange[name](node);\n                            }\n                            updateRangeProperties(this);\n                        };\n                    };\n                }\n\n                rangeProto.setStartBefore = createBeforeAfterNodeSetter(\"setStartBefore\", \"setEndBefore\");\n                rangeProto.setStartAfter = createBeforeAfterNodeSetter(\"setStartAfter\", \"setEndAfter\");\n                rangeProto.setEndBefore = createBeforeAfterNodeSetter(\"setEndBefore\", \"setStartBefore\");\n                rangeProto.setEndAfter = createBeforeAfterNodeSetter(\"setEndAfter\", \"setStartAfter\");\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Always use DOM4-compliant selectNodeContents implementation: it's simpler and less code than testing\n                // whether the native implementation can be trusted\n                rangeProto.selectNodeContents = function(node) {\n                    this.setStartAndEnd(node, 0, dom.getNodeLength(node));\n                };\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for and correct WebKit bug that has the behaviour of compareBoundaryPoints round the wrong way for\n                // constants START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738\n\n                range.selectNodeContents(testTextNode);\n                range.setEnd(testTextNode, 3);\n\n                var range2 = document.createRange();\n                range2.selectNodeContents(testTextNode);\n                range2.setEnd(testTextNode, 4);\n                range2.setStart(testTextNode, 2);\n\n                if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 &&\n                    range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {\n                    // This is the wrong way round, so correct for it\n\n                    rangeProto.compareBoundaryPoints = function(type, range) {\n                        range = range.nativeRange || range;\n                        if (type == range.START_TO_END) {\n                            type = range.END_TO_START;\n                        } else if (type == range.END_TO_START) {\n                            type = range.START_TO_END;\n                        }\n                        return this.nativeRange.compareBoundaryPoints(type, range);\n                    };\n                } else {\n                    rangeProto.compareBoundaryPoints = function(type, range) {\n                        return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);\n                    };\n                }\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for IE deleteContents() and extractContents() bug and correct it. See issue 107.\n\n                var el = document.createElement(\"div\");\n                el.innerHTML = \"123\";\n                var textNode = el.firstChild;\n                var body = getBody(document);\n                body.appendChild(el);\n\n                range.setStart(textNode, 1);\n                range.setEnd(textNode, 2);\n                range.deleteContents();\n\n                if (textNode.data == \"13\") {\n                    // Behaviour is correct per DOM4 Range so wrap the browser's implementation of deleteContents() and\n                    // extractContents()\n                    rangeProto.deleteContents = function() {\n                        this.nativeRange.deleteContents();\n                        updateRangeProperties(this);\n                    };\n\n                    rangeProto.extractContents = function() {\n                        var frag = this.nativeRange.extractContents();\n                        updateRangeProperties(this);\n                        return frag;\n                    };\n                } else {\n                }\n\n                body.removeChild(el);\n                body = null;\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for existence of createContextualFragment and delegate to it if it exists\n                if (util.isHostMethod(range, \"createContextualFragment\")) {\n                    rangeProto.createContextualFragment = function(fragmentStr) {\n                        return this.nativeRange.createContextualFragment(fragmentStr);\n                    };\n                }\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Clean up\n                getBody(document).removeChild(testTextNode);\n\n                rangeProto.getName = function() {\n                    return \"WrappedRange\";\n                };\n\n                api.WrappedRange = WrappedRange;\n\n                api.createNativeRange = function(doc) {\n                    doc = getContentDocument(doc, module, \"createNativeRange\");\n                    return doc.createRange();\n                };\n            })();\n        }\n\n        if (api.features.implementsTextRange) {\n            /*\n             This is a workaround for a bug where IE returns the wrong container element from the TextRange's parentElement()\n             method. For example, in the following (where pipes denote the selection boundaries):\n\n             <ul id=\"ul\"><li id=\"a\">| a </li><li id=\"b\"> b |</li></ul>\n\n             var range = document.selection.createRange();\n             alert(range.parentElement().id); // Should alert \"ul\" but alerts \"b\"\n\n             This method returns the common ancestor node of the following:\n             - the parentElement() of the textRange\n             - the parentElement() of the textRange after calling collapse(true)\n             - the parentElement() of the textRange after calling collapse(false)\n             */\n            var getTextRangeContainerElement = function(textRange) {\n                var parentEl = textRange.parentElement();\n                var range = textRange.duplicate();\n                range.collapse(true);\n                var startEl = range.parentElement();\n                range = textRange.duplicate();\n                range.collapse(false);\n                var endEl = range.parentElement();\n                var startEndContainer = (startEl == endEl) ? startEl : dom.getCommonAncestor(startEl, endEl);\n\n                return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);\n            };\n\n            var textRangeIsCollapsed = function(textRange) {\n                return textRange.compareEndPoints(\"StartToEnd\", textRange) == 0;\n            };\n\n            // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started\n            // out as an improved version of code found in Tim Cameron Ryan's IERange (http://code.google.com/p/ierange/)\n            // but has grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange\n            // bugs, handling for inputs and images, plus optimizations.\n            var getTextRangeBoundaryPosition = function(textRange, wholeRangeContainerElement, isStart, isCollapsed, startInfo) {\n                var workingRange = textRange.duplicate();\n                workingRange.collapse(isStart);\n                var containerElement = workingRange.parentElement();\n\n                // Sometimes collapsing a TextRange that's at the start of a text node can move it into the previous node, so\n                // check for that\n                if (!dom.isOrIsAncestorOf(wholeRangeContainerElement, containerElement)) {\n                    containerElement = wholeRangeContainerElement;\n                }\n\n\n                // Deal with nodes that cannot \"contain rich HTML markup\". In practice, this means form inputs, images and\n                // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx\n                if (!containerElement.canHaveHTML) {\n                    var pos = new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));\n                    return {\n                        boundaryPosition: pos,\n                        nodeInfo: {\n                            nodeIndex: pos.offset,\n                            containerElement: pos.node\n                        }\n                    };\n                }\n\n                var workingNode = dom.getDocument(containerElement).createElement(\"span\");\n\n                // Workaround for HTML5 Shiv's insane violation of document.createElement(). See Rangy issue 104 and HTML5\n                // Shiv issue 64: https://github.com/aFarkas/html5shiv/issues/64\n                if (workingNode.parentNode) {\n                    dom.removeNode(workingNode);\n                }\n\n                var comparison, workingComparisonType = isStart ? \"StartToStart\" : \"StartToEnd\";\n                var previousNode, nextNode, boundaryPosition, boundaryNode;\n                var start = (startInfo && startInfo.containerElement == containerElement) ? startInfo.nodeIndex : 0;\n                var childNodeCount = containerElement.childNodes.length;\n                var end = childNodeCount;\n\n                // Check end first. Code within the loop assumes that the endth child node of the container is definitely\n                // after the range boundary.\n                var nodeIndex = end;\n\n                while (true) {\n                    if (nodeIndex == childNodeCount) {\n                        containerElement.appendChild(workingNode);\n                    } else {\n                        containerElement.insertBefore(workingNode, containerElement.childNodes[nodeIndex]);\n                    }\n                    workingRange.moveToElementText(workingNode);\n                    comparison = workingRange.compareEndPoints(workingComparisonType, textRange);\n                    if (comparison == 0 || start == end) {\n                        break;\n                    } else if (comparison == -1) {\n                        if (end == start + 1) {\n                            // We know the endth child node is after the range boundary, so we must be done.\n                            break;\n                        } else {\n                            start = nodeIndex;\n                        }\n                    } else {\n                        end = (end == start + 1) ? start : nodeIndex;\n                    }\n                    nodeIndex = Math.floor((start + end) / 2);\n                    containerElement.removeChild(workingNode);\n                }\n\n\n                // We've now reached or gone past the boundary of the text range we're interested in\n                // so have identified the node we want\n                boundaryNode = workingNode.nextSibling;\n\n                if (comparison == -1 && boundaryNode && isCharacterDataNode(boundaryNode)) {\n                    // This is a character data node (text, comment, cdata). The working range is collapsed at the start of\n                    // the node containing the text range's boundary, so we move the end of the working range to the\n                    // boundary point and measure the length of its text to get the boundary's offset within the node.\n                    workingRange.setEndPoint(isStart ? \"EndToStart\" : \"EndToEnd\", textRange);\n\n                    var offset;\n\n                    if (/[\\r\\n]/.test(boundaryNode.data)) {\n                        /*\n                         For the particular case of a boundary within a text node containing rendered line breaks (within a\n                         <pre> element, for example), we need a slightly complicated approach to get the boundary's offset in\n                         IE. The facts:\n\n                         - Each line break is represented as \\r in the text node's data/nodeValue properties\n                         - Each line break is represented as \\r\\n in the TextRange's 'text' property\n                         - The 'text' property of the TextRange does not contain trailing line breaks\n\n                         To get round the problem presented by the final fact above, we can use the fact that TextRange's\n                         moveStart() and moveEnd() methods return the actual number of characters moved, which is not\n                         necessarily the same as the number of characters it was instructed to move. The simplest approach is\n                         to use this to store the characters moved when moving both the start and end of the range to the\n                         start of the document body and subtracting the start offset from the end offset (the\n                         \"move-negative-gazillion\" method). However, this is extremely slow when the document is large and\n                         the range is near the end of it. Clearly doing the mirror image (i.e. moving the range boundaries to\n                         the end of the document) has the same problem.\n\n                         Another approach that works is to use moveStart() to move the start boundary of the range up to the\n                         end boundary one character at a time and incrementing a counter with the value returned by the\n                         moveStart() call. However, the check for whether the start boundary has reached the end boundary is\n                         expensive, so this method is slow (although unlike \"move-negative-gazillion\" is largely unaffected\n                         by the location of the range within the document).\n\n                         The approach used below is a hybrid of the two methods above. It uses the fact that a string\n                         containing the TextRange's 'text' property with each \\r\\n converted to a single \\r character cannot\n                         be longer than the text of the TextRange, so the start of the range is moved that length initially\n                         and then a character at a time to make up for any trailing line breaks not contained in the 'text'\n                         property. This has good performance in most situations compared to the previous two methods.\n                         */\n                        var tempRange = workingRange.duplicate();\n                        var rangeLength = tempRange.text.replace(/\\r\\n/g, \"\\r\").length;\n\n                        offset = tempRange.moveStart(\"character\", rangeLength);\n                        while ( (comparison = tempRange.compareEndPoints(\"StartToEnd\", tempRange)) == -1) {\n                            offset++;\n                            tempRange.moveStart(\"character\", 1);\n                        }\n                    } else {\n                        offset = workingRange.text.length;\n                    }\n                    boundaryPosition = new DomPosition(boundaryNode, offset);\n                } else {\n\n                    // If the boundary immediately follows a character data node and this is the end boundary, we should favour\n                    // a position within that, and likewise for a start boundary preceding a character data node\n                    previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;\n                    nextNode = (isCollapsed || isStart) && workingNode.nextSibling;\n                    if (nextNode && isCharacterDataNode(nextNode)) {\n                        boundaryPosition = new DomPosition(nextNode, 0);\n                    } else if (previousNode && isCharacterDataNode(previousNode)) {\n                        boundaryPosition = new DomPosition(previousNode, previousNode.data.length);\n                    } else {\n                        boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));\n                    }\n                }\n\n                // Clean up\n                dom.removeNode(workingNode);\n\n                return {\n                    boundaryPosition: boundaryPosition,\n                    nodeInfo: {\n                        nodeIndex: nodeIndex,\n                        containerElement: containerElement\n                    }\n                };\n            };\n\n            // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that\n            // node. This function started out as an optimized version of code found in Tim Cameron Ryan's IERange\n            // (http://code.google.com/p/ierange/)\n            var createBoundaryTextRange = function(boundaryPosition, isStart) {\n                var boundaryNode, boundaryParent, boundaryOffset = boundaryPosition.offset;\n                var doc = dom.getDocument(boundaryPosition.node);\n                var workingNode, childNodes, workingRange = getBody(doc).createTextRange();\n                var nodeIsDataNode = isCharacterDataNode(boundaryPosition.node);\n\n                if (nodeIsDataNode) {\n                    boundaryNode = boundaryPosition.node;\n                    boundaryParent = boundaryNode.parentNode;\n                } else {\n                    childNodes = boundaryPosition.node.childNodes;\n                    boundaryNode = (boundaryOffset < childNodes.length) ? childNodes[boundaryOffset] : null;\n                    boundaryParent = boundaryPosition.node;\n                }\n\n                // Position the range immediately before the node containing the boundary\n                workingNode = doc.createElement(\"span\");\n\n                // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within\n                // the element rather than immediately before or after it\n                workingNode.innerHTML = \"&#feff;\";\n\n                // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report\n                // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12\n                if (boundaryNode) {\n                    boundaryParent.insertBefore(workingNode, boundaryNode);\n                } else {\n                    boundaryParent.appendChild(workingNode);\n                }\n\n                workingRange.moveToElementText(workingNode);\n                workingRange.collapse(!isStart);\n\n                // Clean up\n                boundaryParent.removeChild(workingNode);\n\n                // Move the working range to the text offset, if required\n                if (nodeIsDataNode) {\n                    workingRange[isStart ? \"moveStart\" : \"moveEnd\"](\"character\", boundaryOffset);\n                }\n\n                return workingRange;\n            };\n\n            /*------------------------------------------------------------------------------------------------------------*/\n\n            // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy's DomRange as a\n            // prototype\n\n            WrappedTextRange = function(textRange) {\n                this.textRange = textRange;\n                this.refresh();\n            };\n\n            WrappedTextRange.prototype = new DomRange(document);\n\n            WrappedTextRange.prototype.refresh = function() {\n                var start, end, startBoundary;\n\n                // TextRange's parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.\n                var rangeContainerElement = getTextRangeContainerElement(this.textRange);\n\n                if (textRangeIsCollapsed(this.textRange)) {\n                    end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true,\n                        true).boundaryPosition;\n                } else {\n                    startBoundary = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);\n                    start = startBoundary.boundaryPosition;\n\n                    // An optimization used here is that if the start and end boundaries have the same parent element, the\n                    // search scope for the end boundary can be limited to exclude the portion of the element that precedes\n                    // the start boundary\n                    end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false,\n                        startBoundary.nodeInfo).boundaryPosition;\n                }\n\n                this.setStart(start.node, start.offset);\n                this.setEnd(end.node, end.offset);\n            };\n\n            WrappedTextRange.prototype.getName = function() {\n                return \"WrappedTextRange\";\n            };\n\n            DomRange.copyComparisonConstants(WrappedTextRange);\n\n            var rangeToTextRange = function(range) {\n                if (range.collapsed) {\n                    return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n                } else {\n                    var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n                    var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);\n                    var textRange = getBody( DomRange.getRangeDocument(range) ).createTextRange();\n                    textRange.setEndPoint(\"StartToStart\", startRange);\n                    textRange.setEndPoint(\"EndToEnd\", endRange);\n                    return textRange;\n                }\n            };\n\n            WrappedTextRange.rangeToTextRange = rangeToTextRange;\n\n            WrappedTextRange.prototype.toTextRange = function() {\n                return rangeToTextRange(this);\n            };\n\n            api.WrappedTextRange = WrappedTextRange;\n\n            // IE 9 and above have both implementations and Rangy makes both available. The next few lines sets which\n            // implementation to use by default.\n            if (!api.features.implementsDomRange || api.config.preferTextRange) {\n                // Add WrappedTextRange as the Range property of the global object to allow expression like Range.END_TO_END to work\n                var globalObj = (function(f) { return f(\"return this;\")(); })(Function);\n                if (typeof globalObj.Range == \"undefined\") {\n                    globalObj.Range = WrappedTextRange;\n                }\n\n                api.createNativeRange = function(doc) {\n                    doc = getContentDocument(doc, module, \"createNativeRange\");\n                    return getBody(doc).createTextRange();\n                };\n\n                api.WrappedRange = WrappedTextRange;\n            }\n        }\n\n        api.createRange = function(doc) {\n            doc = getContentDocument(doc, module, \"createRange\");\n            return new api.WrappedRange(api.createNativeRange(doc));\n        };\n\n        api.createRangyRange = function(doc) {\n            doc = getContentDocument(doc, module, \"createRangyRange\");\n            return new DomRange(doc);\n        };\n\n        util.createAliasForDeprecatedMethod(api, \"createIframeRange\", \"createRange\");\n        util.createAliasForDeprecatedMethod(api, \"createIframeRangyRange\", \"createRangyRange\");\n\n        api.addShimListener(function(win) {\n            var doc = win.document;\n            if (typeof doc.createRange == \"undefined\") {\n                doc.createRange = function() {\n                    return api.createRange(doc);\n                };\n            }\n            doc = win = null;\n        });\n    });\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // This module creates a selection object wrapper that conforms as closely as possible to the Selection specification\n    // in the HTML Editing spec (http://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections)\n    api.createCoreModule(\"WrappedSelection\", [\"DomRange\", \"WrappedRange\"], function(api, module) {\n        api.config.checkSelectionRanges = true;\n\n        var BOOLEAN = \"boolean\";\n        var NUMBER = \"number\";\n        var dom = api.dom;\n        var util = api.util;\n        var isHostMethod = util.isHostMethod;\n        var DomRange = api.DomRange;\n        var WrappedRange = api.WrappedRange;\n        var DOMException = api.DOMException;\n        var DomPosition = dom.DomPosition;\n        var getNativeSelection;\n        var selectionIsCollapsed;\n        var features = api.features;\n        var CONTROL = \"Control\";\n        var getDocument = dom.getDocument;\n        var getBody = dom.getBody;\n        var rangesEqual = DomRange.rangesEqual;\n\n\n        // Utility function to support direction parameters in the API that may be a string (\"backward\", \"backwards\",\n        // \"forward\" or \"forwards\") or a Boolean (true for backwards).\n        function isDirectionBackward(dir) {\n            return (typeof dir == \"string\") ? /^backward(s)?$/i.test(dir) : !!dir;\n        }\n\n        function getWindow(win, methodName) {\n            if (!win) {\n                return window;\n            } else if (dom.isWindow(win)) {\n                return win;\n            } else if (win instanceof WrappedSelection) {\n                return win.win;\n            } else {\n                var doc = dom.getContentDocument(win, module, methodName);\n                return dom.getWindow(doc);\n            }\n        }\n\n        function getWinSelection(winParam) {\n            return getWindow(winParam, \"getWinSelection\").getSelection();\n        }\n\n        function getDocSelection(winParam) {\n            return getWindow(winParam, \"getDocSelection\").document.selection;\n        }\n\n        function winSelectionIsBackward(sel) {\n            var backward = false;\n            if (sel.anchorNode) {\n                backward = (dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1);\n            }\n            return backward;\n        }\n\n        // Test for the Range/TextRange and Selection features required\n        // Test for ability to retrieve selection\n        var implementsWinGetSelection = isHostMethod(window, \"getSelection\"),\n            implementsDocSelection = util.isHostObject(document, \"selection\");\n\n        features.implementsWinGetSelection = implementsWinGetSelection;\n        features.implementsDocSelection = implementsDocSelection;\n\n        var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);\n\n        if (useDocumentSelection) {\n            getNativeSelection = getDocSelection;\n            api.isSelectionValid = function(winParam) {\n                var doc = getWindow(winParam, \"isSelectionValid\").document, nativeSel = doc.selection;\n\n                // Check whether the selection TextRange is actually contained within the correct document\n                return (nativeSel.type != \"None\" || getDocument(nativeSel.createRange().parentElement()) == doc);\n            };\n        } else if (implementsWinGetSelection) {\n            getNativeSelection = getWinSelection;\n            api.isSelectionValid = function() {\n                return true;\n            };\n        } else {\n            module.fail(\"Neither document.selection or window.getSelection() detected.\");\n            return false;\n        }\n\n        api.getNativeSelection = getNativeSelection;\n\n        var testSelection = getNativeSelection();\n\n        // In Firefox, the selection is null in an iframe with display: none. See issue #138.\n        if (!testSelection) {\n            module.fail(\"Native selection was null (possibly issue 138?)\");\n            return false;\n        }\n\n        var testRange = api.createNativeRange(document);\n        var body = getBody(document);\n\n        // Obtaining a range from a selection\n        var selectionHasAnchorAndFocus = util.areHostProperties(testSelection,\n            [\"anchorNode\", \"focusNode\", \"anchorOffset\", \"focusOffset\"]);\n\n        features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;\n\n        // Test for existence of native selection extend() method\n        var selectionHasExtend = isHostMethod(testSelection, \"extend\");\n        features.selectionHasExtend = selectionHasExtend;\n\n        // Test if rangeCount exists\n        var selectionHasRangeCount = (typeof testSelection.rangeCount == NUMBER);\n        features.selectionHasRangeCount = selectionHasRangeCount;\n\n        var selectionSupportsMultipleRanges = false;\n        var collapsedNonEditableSelectionsSupported = true;\n\n        var addRangeBackwardToNative = selectionHasExtend ?\n            function(nativeSelection, range) {\n                var doc = DomRange.getRangeDocument(range);\n                var endRange = api.createRange(doc);\n                endRange.collapseToPoint(range.endContainer, range.endOffset);\n                nativeSelection.addRange(getNativeRange(endRange));\n                nativeSelection.extend(range.startContainer, range.startOffset);\n            } : null;\n\n        if (util.areHostMethods(testSelection, [\"addRange\", \"getRangeAt\", \"removeAllRanges\"]) &&\n            typeof testSelection.rangeCount == NUMBER && features.implementsDomRange) {\n\n            (function() {\n                // Previously an iframe was used but this caused problems in some circumstances in IE, so tests are\n                // performed on the current document's selection. See issue 109.\n\n                // Note also that if a selection previously existed, it is wiped and later restored by these tests. This\n                // will result in the selection direction begin reversed if the original selection was backwards and the\n                // browser does not support setting backwards selections (Internet Explorer, I'm looking at you).\n                var sel = window.getSelection();\n                if (sel) {\n                    // Store the current selection\n                    var originalSelectionRangeCount = sel.rangeCount;\n                    var selectionHasMultipleRanges = (originalSelectionRangeCount > 1);\n                    var originalSelectionRanges = [];\n                    var originalSelectionBackward = winSelectionIsBackward(sel);\n                    for (var i = 0; i < originalSelectionRangeCount; ++i) {\n                        originalSelectionRanges[i] = sel.getRangeAt(i);\n                    }\n\n                    // Create some test elements\n                    var testEl = dom.createTestElement(document, \"\", false);\n                    var textNode = testEl.appendChild( document.createTextNode(\"\\u00a0\\u00a0\\u00a0\") );\n\n                    // Test whether the native selection will allow a collapsed selection within a non-editable element\n                    var r1 = document.createRange();\n\n                    r1.setStart(textNode, 1);\n                    r1.collapse(true);\n                    sel.removeAllRanges();\n                    sel.addRange(r1);\n                    collapsedNonEditableSelectionsSupported = (sel.rangeCount == 1);\n                    sel.removeAllRanges();\n\n                    // Test whether the native selection is capable of supporting multiple ranges.\n                    if (!selectionHasMultipleRanges) {\n                        // Doing the original feature test here in Chrome 36 (and presumably later versions) prints a\n                        // console error of \"Discontiguous selection is not supported.\" that cannot be suppressed. There's\n                        // nothing we can do about this while retaining the feature test so we have to resort to a browser\n                        // sniff. I'm not happy about it. See\n                        // https://code.google.com/p/chromium/issues/detail?id=399791\n                        var chromeMatch = window.navigator.appVersion.match(/Chrome\\/(.*?) /);\n                        if (chromeMatch && parseInt(chromeMatch[1]) >= 36) {\n                            selectionSupportsMultipleRanges = false;\n                        } else {\n                            var r2 = r1.cloneRange();\n                            r1.setStart(textNode, 0);\n                            r2.setEnd(textNode, 3);\n                            r2.setStart(textNode, 2);\n                            sel.addRange(r1);\n                            sel.addRange(r2);\n                            selectionSupportsMultipleRanges = (sel.rangeCount == 2);\n                        }\n                    }\n\n                    // Clean up\n                    dom.removeNode(testEl);\n                    sel.removeAllRanges();\n\n                    for (i = 0; i < originalSelectionRangeCount; ++i) {\n                        if (i == 0 && originalSelectionBackward) {\n                            if (addRangeBackwardToNative) {\n                                addRangeBackwardToNative(sel, originalSelectionRanges[i]);\n                            } else {\n                                api.warn(\"Rangy initialization: original selection was backwards but selection has been restored forwards because the browser does not support Selection.extend\");\n                                sel.addRange(originalSelectionRanges[i]);\n                            }\n                        } else {\n                            sel.addRange(originalSelectionRanges[i]);\n                        }\n                    }\n                }\n            })();\n        }\n\n        features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;\n        features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;\n\n        // ControlRanges\n        var implementsControlRange = false, testControlRange;\n\n        if (body && isHostMethod(body, \"createControlRange\")) {\n            testControlRange = body.createControlRange();\n            if (util.areHostProperties(testControlRange, [\"item\", \"add\"])) {\n                implementsControlRange = true;\n            }\n        }\n        features.implementsControlRange = implementsControlRange;\n\n        // Selection collapsedness\n        if (selectionHasAnchorAndFocus) {\n            selectionIsCollapsed = function(sel) {\n                return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;\n            };\n        } else {\n            selectionIsCollapsed = function(sel) {\n                return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;\n            };\n        }\n\n        function updateAnchorAndFocusFromRange(sel, range, backward) {\n            var anchorPrefix = backward ? \"end\" : \"start\", focusPrefix = backward ? \"start\" : \"end\";\n            sel.anchorNode = range[anchorPrefix + \"Container\"];\n            sel.anchorOffset = range[anchorPrefix + \"Offset\"];\n            sel.focusNode = range[focusPrefix + \"Container\"];\n            sel.focusOffset = range[focusPrefix + \"Offset\"];\n        }\n\n        function updateAnchorAndFocusFromNativeSelection(sel) {\n            var nativeSel = sel.nativeSelection;\n            sel.anchorNode = nativeSel.anchorNode;\n            sel.anchorOffset = nativeSel.anchorOffset;\n            sel.focusNode = nativeSel.focusNode;\n            sel.focusOffset = nativeSel.focusOffset;\n        }\n\n        function updateEmptySelection(sel) {\n            sel.anchorNode = sel.focusNode = null;\n            sel.anchorOffset = sel.focusOffset = 0;\n            sel.rangeCount = 0;\n            sel.isCollapsed = true;\n            sel._ranges.length = 0;\n        }\n\n        function getNativeRange(range) {\n            var nativeRange;\n            if (range instanceof DomRange) {\n                nativeRange = api.createNativeRange(range.getDocument());\n                nativeRange.setEnd(range.endContainer, range.endOffset);\n                nativeRange.setStart(range.startContainer, range.startOffset);\n            } else if (range instanceof WrappedRange) {\n                nativeRange = range.nativeRange;\n            } else if (features.implementsDomRange && (range instanceof dom.getWindow(range.startContainer).Range)) {\n                nativeRange = range;\n            }\n            return nativeRange;\n        }\n\n        function rangeContainsSingleElement(rangeNodes) {\n            if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {\n                return false;\n            }\n            for (var i = 1, len = rangeNodes.length; i < len; ++i) {\n                if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function getSingleElementFromRange(range) {\n            var nodes = range.getNodes();\n            if (!rangeContainsSingleElement(nodes)) {\n                throw module.createError(\"getSingleElementFromRange: range \" + range.inspect() + \" did not consist of a single element\");\n            }\n            return nodes[0];\n        }\n\n        // Simple, quick test which only needs to distinguish between a TextRange and a ControlRange\n        function isTextRange(range) {\n            return !!range && typeof range.text != \"undefined\";\n        }\n\n        function updateFromTextRange(sel, range) {\n            // Create a Range from the selected TextRange\n            var wrappedRange = new WrappedRange(range);\n            sel._ranges = [wrappedRange];\n\n            updateAnchorAndFocusFromRange(sel, wrappedRange, false);\n            sel.rangeCount = 1;\n            sel.isCollapsed = wrappedRange.collapsed;\n        }\n\n        function updateControlSelection(sel) {\n            // Update the wrapped selection based on what's now in the native selection\n            sel._ranges.length = 0;\n            if (sel.docSelection.type == \"None\") {\n                updateEmptySelection(sel);\n            } else {\n                var controlRange = sel.docSelection.createRange();\n                if (isTextRange(controlRange)) {\n                    // This case (where the selection type is \"Control\" and calling createRange() on the selection returns\n                    // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected\n                    // ControlRange have been removed from the ControlRange and removed from the document.\n                    updateFromTextRange(sel, controlRange);\n                } else {\n                    sel.rangeCount = controlRange.length;\n                    var range, doc = getDocument(controlRange.item(0));\n                    for (var i = 0; i < sel.rangeCount; ++i) {\n                        range = api.createRange(doc);\n                        range.selectNode(controlRange.item(i));\n                        sel._ranges.push(range);\n                    }\n                    sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;\n                    updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);\n                }\n            }\n        }\n\n        function addRangeToControlSelection(sel, range) {\n            var controlRange = sel.docSelection.createRange();\n            var rangeElement = getSingleElementFromRange(range);\n\n            // Create a new ControlRange containing all the elements in the selected ControlRange plus the element\n            // contained by the supplied range\n            var doc = getDocument(controlRange.item(0));\n            var newControlRange = getBody(doc).createControlRange();\n            for (var i = 0, len = controlRange.length; i < len; ++i) {\n                newControlRange.add(controlRange.item(i));\n            }\n            try {\n                newControlRange.add(rangeElement);\n            } catch (ex) {\n                throw module.createError(\"addRange(): Element within the specified Range could not be added to control selection (does it have layout?)\");\n            }\n            newControlRange.select();\n\n            // Update the wrapped selection based on what's now in the native selection\n            updateControlSelection(sel);\n        }\n\n        var getSelectionRangeAt;\n\n        if (isHostMethod(testSelection, \"getRangeAt\")) {\n            // try/catch is present because getRangeAt() must have thrown an error in some browser and some situation.\n            // Unfortunately, I didn't write a comment about the specifics and am now scared to take it out. Let that be a\n            // lesson to us all, especially me.\n            getSelectionRangeAt = function(sel, index) {\n                try {\n                    return sel.getRangeAt(index);\n                } catch (ex) {\n                    return null;\n                }\n            };\n        } else if (selectionHasAnchorAndFocus) {\n            getSelectionRangeAt = function(sel) {\n                var doc = getDocument(sel.anchorNode);\n                var range = api.createRange(doc);\n                range.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);\n\n                // Handle the case when the selection was selected backwards (from the end to the start in the\n                // document)\n                if (range.collapsed !== this.isCollapsed) {\n                    range.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);\n                }\n\n                return range;\n            };\n        }\n\n        function WrappedSelection(selection, docSelection, win) {\n            this.nativeSelection = selection;\n            this.docSelection = docSelection;\n            this._ranges = [];\n            this.win = win;\n            this.refresh();\n        }\n\n        WrappedSelection.prototype = api.selectionPrototype;\n\n        function deleteProperties(sel) {\n            sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;\n            sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;\n            sel.detached = true;\n        }\n\n        var cachedRangySelections = [];\n\n        function actOnCachedSelection(win, action) {\n            var i = cachedRangySelections.length, cached, sel;\n            while (i--) {\n                cached = cachedRangySelections[i];\n                sel = cached.selection;\n                if (action == \"deleteAll\") {\n                    deleteProperties(sel);\n                } else if (cached.win == win) {\n                    if (action == \"delete\") {\n                        cachedRangySelections.splice(i, 1);\n                        return true;\n                    } else {\n                        return sel;\n                    }\n                }\n            }\n            if (action == \"deleteAll\") {\n                cachedRangySelections.length = 0;\n            }\n            return null;\n        }\n\n        var getSelection = function(win) {\n            // Check if the parameter is a Rangy Selection object\n            if (win && win instanceof WrappedSelection) {\n                win.refresh();\n                return win;\n            }\n\n            win = getWindow(win, \"getNativeSelection\");\n\n            var sel = actOnCachedSelection(win);\n            var nativeSel = getNativeSelection(win), docSel = implementsDocSelection ? getDocSelection(win) : null;\n            if (sel) {\n                sel.nativeSelection = nativeSel;\n                sel.docSelection = docSel;\n                sel.refresh();\n            } else {\n                sel = new WrappedSelection(nativeSel, docSel, win);\n                cachedRangySelections.push( { win: win, selection: sel } );\n            }\n            return sel;\n        };\n\n        api.getSelection = getSelection;\n\n        util.createAliasForDeprecatedMethod(api, \"getIframeSelection\", \"getSelection\");\n\n        var selProto = WrappedSelection.prototype;\n\n        function createControlSelection(sel, ranges) {\n            // Ensure that the selection becomes of type \"Control\"\n            var doc = getDocument(ranges[0].startContainer);\n            var controlRange = getBody(doc).createControlRange();\n            for (var i = 0, el, len = ranges.length; i < len; ++i) {\n                el = getSingleElementFromRange(ranges[i]);\n                try {\n                    controlRange.add(el);\n                } catch (ex) {\n                    throw module.createError(\"setRanges(): Element within one of the specified Ranges could not be added to control selection (does it have layout?)\");\n                }\n            }\n            controlRange.select();\n\n            // Update the wrapped selection based on what's now in the native selection\n            updateControlSelection(sel);\n        }\n\n        // Selecting a range\n        if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, [\"removeAllRanges\", \"addRange\"])) {\n            selProto.removeAllRanges = function() {\n                this.nativeSelection.removeAllRanges();\n                updateEmptySelection(this);\n            };\n\n            var addRangeBackward = function(sel, range) {\n                addRangeBackwardToNative(sel.nativeSelection, range);\n                sel.refresh();\n            };\n\n            if (selectionHasRangeCount) {\n                selProto.addRange = function(range, direction) {\n                    if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n                        addRangeToControlSelection(this, range);\n                    } else {\n                        if (isDirectionBackward(direction) && selectionHasExtend) {\n                            addRangeBackward(this, range);\n                        } else {\n                            var previousRangeCount;\n                            if (selectionSupportsMultipleRanges) {\n                                previousRangeCount = this.rangeCount;\n                            } else {\n                                this.removeAllRanges();\n                                previousRangeCount = 0;\n                            }\n                            // Clone the native range so that changing the selected range does not affect the selection.\n                            // This is contrary to the spec but is the only way to achieve consistency between browsers. See\n                            // issue 80.\n                            var clonedNativeRange = getNativeRange(range).cloneRange();\n                            try {\n                                this.nativeSelection.addRange(clonedNativeRange);\n                            } catch (ex) {\n                            }\n\n                            // Check whether adding the range was successful\n                            this.rangeCount = this.nativeSelection.rangeCount;\n\n                            if (this.rangeCount == previousRangeCount + 1) {\n                                // The range was added successfully\n\n                                // Check whether the range that we added to the selection is reflected in the last range extracted from\n                                // the selection\n                                if (api.config.checkSelectionRanges) {\n                                    var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);\n                                    if (nativeRange && !rangesEqual(nativeRange, range)) {\n                                        // Happens in WebKit with, for example, a selection placed at the start of a text node\n                                        range = new WrappedRange(nativeRange);\n                                    }\n                                }\n                                this._ranges[this.rangeCount - 1] = range;\n                                updateAnchorAndFocusFromRange(this, range, selectionIsBackward(this.nativeSelection));\n                                this.isCollapsed = selectionIsCollapsed(this);\n                            } else {\n                                // The range was not added successfully. The simplest thing is to refresh\n                                this.refresh();\n                            }\n                        }\n                    }\n                };\n            } else {\n                selProto.addRange = function(range, direction) {\n                    if (isDirectionBackward(direction) && selectionHasExtend) {\n                        addRangeBackward(this, range);\n                    } else {\n                        this.nativeSelection.addRange(getNativeRange(range));\n                        this.refresh();\n                    }\n                };\n            }\n\n            selProto.setRanges = function(ranges) {\n                if (implementsControlRange && implementsDocSelection && ranges.length > 1) {\n                    createControlSelection(this, ranges);\n                } else {\n                    this.removeAllRanges();\n                    for (var i = 0, len = ranges.length; i < len; ++i) {\n                        this.addRange(ranges[i]);\n                    }\n                }\n            };\n        } else if (isHostMethod(testSelection, \"empty\") && isHostMethod(testRange, \"select\") &&\n            implementsControlRange && useDocumentSelection) {\n\n            selProto.removeAllRanges = function() {\n                // Added try/catch as fix for issue #21\n                try {\n                    this.docSelection.empty();\n\n                    // Check for empty() not working (issue #24)\n                    if (this.docSelection.type != \"None\") {\n                        // Work around failure to empty a control selection by instead selecting a TextRange and then\n                        // calling empty()\n                        var doc;\n                        if (this.anchorNode) {\n                            doc = getDocument(this.anchorNode);\n                        } else if (this.docSelection.type == CONTROL) {\n                            var controlRange = this.docSelection.createRange();\n                            if (controlRange.length) {\n                                doc = getDocument( controlRange.item(0) );\n                            }\n                        }\n                        if (doc) {\n                            var textRange = getBody(doc).createTextRange();\n                            textRange.select();\n                            this.docSelection.empty();\n                        }\n                    }\n                } catch(ex) {}\n                updateEmptySelection(this);\n            };\n\n            selProto.addRange = function(range) {\n                if (this.docSelection.type == CONTROL) {\n                    addRangeToControlSelection(this, range);\n                } else {\n                    api.WrappedTextRange.rangeToTextRange(range).select();\n                    this._ranges[0] = range;\n                    this.rangeCount = 1;\n                    this.isCollapsed = this._ranges[0].collapsed;\n                    updateAnchorAndFocusFromRange(this, range, false);\n                }\n            };\n\n            selProto.setRanges = function(ranges) {\n                this.removeAllRanges();\n                var rangeCount = ranges.length;\n                if (rangeCount > 1) {\n                    createControlSelection(this, ranges);\n                } else if (rangeCount) {\n                    this.addRange(ranges[0]);\n                }\n            };\n        } else {\n            module.fail(\"No means of selecting a Range or TextRange was found\");\n            return false;\n        }\n\n        selProto.getRangeAt = function(index) {\n            if (index < 0 || index >= this.rangeCount) {\n                throw new DOMException(\"INDEX_SIZE_ERR\");\n            } else {\n                // Clone the range to preserve selection-range independence. See issue 80.\n                return this._ranges[index].cloneRange();\n            }\n        };\n\n        var refreshSelection;\n\n        if (useDocumentSelection) {\n            refreshSelection = function(sel) {\n                var range;\n                if (api.isSelectionValid(sel.win)) {\n                    range = sel.docSelection.createRange();\n                } else {\n                    range = getBody(sel.win.document).createTextRange();\n                    range.collapse(true);\n                }\n\n                if (sel.docSelection.type == CONTROL) {\n                    updateControlSelection(sel);\n                } else if (isTextRange(range)) {\n                    updateFromTextRange(sel, range);\n                } else {\n                    updateEmptySelection(sel);\n                }\n            };\n        } else if (isHostMethod(testSelection, \"getRangeAt\") && typeof testSelection.rangeCount == NUMBER) {\n            refreshSelection = function(sel) {\n                if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {\n                    updateControlSelection(sel);\n                } else {\n                    sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;\n                    if (sel.rangeCount) {\n                        for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n                            sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));\n                        }\n                        updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));\n                        sel.isCollapsed = selectionIsCollapsed(sel);\n                    } else {\n                        updateEmptySelection(sel);\n                    }\n                }\n            };\n        } else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && features.implementsDomRange) {\n            refreshSelection = function(sel) {\n                var range, nativeSel = sel.nativeSelection;\n                if (nativeSel.anchorNode) {\n                    range = getSelectionRangeAt(nativeSel, 0);\n                    sel._ranges = [range];\n                    sel.rangeCount = 1;\n                    updateAnchorAndFocusFromNativeSelection(sel);\n                    sel.isCollapsed = selectionIsCollapsed(sel);\n                } else {\n                    updateEmptySelection(sel);\n                }\n            };\n        } else {\n            module.fail(\"No means of obtaining a Range or TextRange from the user's selection was found\");\n            return false;\n        }\n\n        selProto.refresh = function(checkForChanges) {\n            var oldRanges = checkForChanges ? this._ranges.slice(0) : null;\n            var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;\n\n            refreshSelection(this);\n            if (checkForChanges) {\n                // Check the range count first\n                var i = oldRanges.length;\n                if (i != this._ranges.length) {\n                    return true;\n                }\n\n                // Now check the direction. Checking the anchor position is the same is enough since we're checking all the\n                // ranges after this\n                if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {\n                    return true;\n                }\n\n                // Finally, compare each range in turn\n                while (i--) {\n                    if (!rangesEqual(oldRanges[i], this._ranges[i])) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        };\n\n        // Removal of a single range\n        var removeRangeManually = function(sel, range) {\n            var ranges = sel.getAllRanges();\n            sel.removeAllRanges();\n            for (var i = 0, len = ranges.length; i < len; ++i) {\n                if (!rangesEqual(range, ranges[i])) {\n                    sel.addRange(ranges[i]);\n                }\n            }\n            if (!sel.rangeCount) {\n                updateEmptySelection(sel);\n            }\n        };\n\n        if (implementsControlRange && implementsDocSelection) {\n            selProto.removeRange = function(range) {\n                if (this.docSelection.type == CONTROL) {\n                    var controlRange = this.docSelection.createRange();\n                    var rangeElement = getSingleElementFromRange(range);\n\n                    // Create a new ControlRange containing all the elements in the selected ControlRange minus the\n                    // element contained by the supplied range\n                    var doc = getDocument(controlRange.item(0));\n                    var newControlRange = getBody(doc).createControlRange();\n                    var el, removed = false;\n                    for (var i = 0, len = controlRange.length; i < len; ++i) {\n                        el = controlRange.item(i);\n                        if (el !== rangeElement || removed) {\n                            newControlRange.add(controlRange.item(i));\n                        } else {\n                            removed = true;\n                        }\n                    }\n                    newControlRange.select();\n\n                    // Update the wrapped selection based on what's now in the native selection\n                    updateControlSelection(this);\n                } else {\n                    removeRangeManually(this, range);\n                }\n            };\n        } else {\n            selProto.removeRange = function(range) {\n                removeRangeManually(this, range);\n            };\n        }\n\n        // Detecting if a selection is backward\n        var selectionIsBackward;\n        if (!useDocumentSelection && selectionHasAnchorAndFocus && features.implementsDomRange) {\n            selectionIsBackward = winSelectionIsBackward;\n\n            selProto.isBackward = function() {\n                return selectionIsBackward(this);\n            };\n        } else {\n            selectionIsBackward = selProto.isBackward = function() {\n                return false;\n            };\n        }\n\n        // Create an alias for backwards compatibility. From 1.3, everything is \"backward\" rather than \"backwards\"\n        selProto.isBackwards = selProto.isBackward;\n\n        // Selection stringifier\n        // This is conformant to the old HTML5 selections draft spec but differs from WebKit and Mozilla's implementation.\n        // The current spec does not yet define this method.\n        selProto.toString = function() {\n            var rangeTexts = [];\n            for (var i = 0, len = this.rangeCount; i < len; ++i) {\n                rangeTexts[i] = \"\" + this._ranges[i];\n            }\n            return rangeTexts.join(\"\");\n        };\n\n        function assertNodeInSameDocument(sel, node) {\n            if (sel.win.document != getDocument(node)) {\n                throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n            }\n        }\n\n        // No current browser conforms fully to the spec for this method, so Rangy's own method is always used\n        selProto.collapse = function(node, offset) {\n            assertNodeInSameDocument(this, node);\n            var range = api.createRange(node);\n            range.collapseToPoint(node, offset);\n            this.setSingleRange(range);\n            this.isCollapsed = true;\n        };\n\n        selProto.collapseToStart = function() {\n            if (this.rangeCount) {\n                var range = this._ranges[0];\n                this.collapse(range.startContainer, range.startOffset);\n            } else {\n                throw new DOMException(\"INVALID_STATE_ERR\");\n            }\n        };\n\n        selProto.collapseToEnd = function() {\n            if (this.rangeCount) {\n                var range = this._ranges[this.rangeCount - 1];\n                this.collapse(range.endContainer, range.endOffset);\n            } else {\n                throw new DOMException(\"INVALID_STATE_ERR\");\n            }\n        };\n\n        // The spec is very specific on how selectAllChildren should be implemented and not all browsers implement it as\n        // specified so the native implementation is never used by Rangy.\n        selProto.selectAllChildren = function(node) {\n            assertNodeInSameDocument(this, node);\n            var range = api.createRange(node);\n            range.selectNodeContents(node);\n            this.setSingleRange(range);\n        };\n\n        selProto.deleteFromDocument = function() {\n            // Sepcial behaviour required for IE's control selections\n            if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n                var controlRange = this.docSelection.createRange();\n                var element;\n                while (controlRange.length) {\n                    element = controlRange.item(0);\n                    controlRange.remove(element);\n                    dom.removeNode(element);\n                }\n                this.refresh();\n            } else if (this.rangeCount) {\n                var ranges = this.getAllRanges();\n                if (ranges.length) {\n                    this.removeAllRanges();\n                    for (var i = 0, len = ranges.length; i < len; ++i) {\n                        ranges[i].deleteContents();\n                    }\n                    // The spec says nothing about what the selection should contain after calling deleteContents on each\n                    // range. Firefox moves the selection to where the final selected range was, so we emulate that\n                    this.addRange(ranges[len - 1]);\n                }\n            }\n        };\n\n        // The following are non-standard extensions\n        selProto.eachRange = function(func, returnValue) {\n            for (var i = 0, len = this._ranges.length; i < len; ++i) {\n                if ( func( this.getRangeAt(i) ) ) {\n                    return returnValue;\n                }\n            }\n        };\n\n        selProto.getAllRanges = function() {\n            var ranges = [];\n            this.eachRange(function(range) {\n                ranges.push(range);\n            });\n            return ranges;\n        };\n\n        selProto.setSingleRange = function(range, direction) {\n            this.removeAllRanges();\n            this.addRange(range, direction);\n        };\n\n        selProto.callMethodOnEachRange = function(methodName, params) {\n            var results = [];\n            this.eachRange( function(range) {\n                results.push( range[methodName].apply(range, params || []) );\n            } );\n            return results;\n        };\n\n        function createStartOrEndSetter(isStart) {\n            return function(node, offset) {\n                var range;\n                if (this.rangeCount) {\n                    range = this.getRangeAt(0);\n                    range[\"set\" + (isStart ? \"Start\" : \"End\")](node, offset);\n                } else {\n                    range = api.createRange(this.win.document);\n                    range.setStartAndEnd(node, offset);\n                }\n                this.setSingleRange(range, this.isBackward());\n            };\n        }\n\n        selProto.setStart = createStartOrEndSetter(true);\n        selProto.setEnd = createStartOrEndSetter(false);\n\n        // Add select() method to Range prototype. Any existing selection will be removed.\n        api.rangePrototype.select = function(direction) {\n            getSelection( this.getDocument() ).setSingleRange(this, direction);\n        };\n\n        selProto.changeEachRange = function(func) {\n            var ranges = [];\n            var backward = this.isBackward();\n\n            this.eachRange(function(range) {\n                func(range);\n                ranges.push(range);\n            });\n\n            this.removeAllRanges();\n            if (backward && ranges.length == 1) {\n                this.addRange(ranges[0], \"backward\");\n            } else {\n                this.setRanges(ranges);\n            }\n        };\n\n        selProto.containsNode = function(node, allowPartial) {\n            return this.eachRange( function(range) {\n                    return range.containsNode(node, allowPartial);\n                }, true ) || false;\n        };\n\n        selProto.getBookmark = function(containerNode) {\n            return {\n                backward: this.isBackward(),\n                rangeBookmarks: this.callMethodOnEachRange(\"getBookmark\", [containerNode])\n            };\n        };\n\n        selProto.moveToBookmark = function(bookmark) {\n            var selRanges = [];\n            for (var i = 0, rangeBookmark, range; rangeBookmark = bookmark.rangeBookmarks[i++]; ) {\n                range = api.createRange(this.win);\n                range.moveToBookmark(rangeBookmark);\n                selRanges.push(range);\n            }\n            if (bookmark.backward) {\n                this.setSingleRange(selRanges[0], \"backward\");\n            } else {\n                this.setRanges(selRanges);\n            }\n        };\n\n        selProto.saveRanges = function() {\n            return {\n                backward: this.isBackward(),\n                ranges: this.callMethodOnEachRange(\"cloneRange\")\n            };\n        };\n\n        selProto.restoreRanges = function(selRanges) {\n            this.removeAllRanges();\n            for (var i = 0, range; range = selRanges.ranges[i]; ++i) {\n                this.addRange(range, (selRanges.backward && i == 0));\n            }\n        };\n\n        selProto.toHtml = function() {\n            var rangeHtmls = [];\n            this.eachRange(function(range) {\n                rangeHtmls.push( DomRange.toHtml(range) );\n            });\n            return rangeHtmls.join(\"\");\n        };\n\n        if (features.implementsTextRange) {\n            selProto.getNativeTextRange = function() {\n                var sel, textRange;\n                if ( (sel = this.docSelection) ) {\n                    var range = sel.createRange();\n                    if (isTextRange(range)) {\n                        return range;\n                    } else {\n                        throw module.createError(\"getNativeTextRange: selection is a control selection\");\n                    }\n                } else if (this.rangeCount > 0) {\n                    return api.WrappedTextRange.rangeToTextRange( this.getRangeAt(0) );\n                } else {\n                    throw module.createError(\"getNativeTextRange: selection contains no range\");\n                }\n            };\n        }\n\n        function inspect(sel) {\n            var rangeInspects = [];\n            var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);\n            var focus = new DomPosition(sel.focusNode, sel.focusOffset);\n            var name = (typeof sel.getName == \"function\") ? sel.getName() : \"Selection\";\n\n            if (typeof sel.rangeCount != \"undefined\") {\n                for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n                    rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));\n                }\n            }\n            return \"[\" + name + \"(Ranges: \" + rangeInspects.join(\", \") +\n                \")(anchor: \" + anchor.inspect() + \", focus: \" + focus.inspect() + \"]\";\n        }\n\n        selProto.getName = function() {\n            return \"WrappedSelection\";\n        };\n\n        selProto.inspect = function() {\n            return inspect(this);\n        };\n\n        selProto.detach = function() {\n            actOnCachedSelection(this.win, \"delete\");\n            deleteProperties(this);\n        };\n\n        WrappedSelection.detachAll = function() {\n            actOnCachedSelection(null, \"deleteAll\");\n        };\n\n        WrappedSelection.inspect = inspect;\n        WrappedSelection.isDirectionBackward = isDirectionBackward;\n\n        api.Selection = WrappedSelection;\n\n        api.selectionPrototype = selProto;\n\n        api.addShimListener(function(win) {\n            if (typeof win.getSelection == \"undefined\") {\n                win.getSelection = function() {\n                    return getSelection(win);\n                };\n            }\n            win = null;\n        });\n    });\n\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Wait for document to load before initializing\n    var docReady = false;\n\n    var loadHandler = function(e) {\n        if (!docReady) {\n            docReady = true;\n            if (!api.initialized && api.config.autoInitialize) {\n                init();\n            }\n        }\n    };\n\n    if (isBrowser) {\n        // Test whether the document has already been loaded and initialize immediately if so\n        if (document.readyState == \"complete\") {\n            loadHandler();\n        } else {\n            if (isHostMethod(document, \"addEventListener\")) {\n                document.addEventListener(\"DOMContentLoaded\", loadHandler, false);\n            }\n\n            // Add a fallback in case the DOMContentLoaded event isn't supported\n            addListener(window, \"load\", loadHandler);\n        }\n    }\n\n    return api;\n}, this);\n\n/**\n * Selection save and restore module for Rangy.\n * Saves and restores user selections using marker invisible elements in the DOM.\n *\n * Part of Rangy, a cross-browser JavaScript range and selection library\n * https://github.com/timdown/rangy\n *\n * Depends on Rangy core.\n *\n * Copyright 2015, Tim Down\n * Licensed under the MIT license.\n * Version: 1.3.1-dev\n * Build date: 20 May 2015\n */\n(function(factory, root) {\n    if (typeof define == \"function\" && define.amd) {\n        // AMD. Register as an anonymous module with a dependency on Rangy.\n        define([\"./rangy-core\"], factory);\n    } else if (typeof module != \"undefined\" && typeof exports == \"object\") {\n        // Node/CommonJS style\n        module.exports = factory( require(\"rangy\") );\n    } else {\n        // No AMD or CommonJS support so we use the rangy property of root (probably the global variable)\n        factory(root.rangy);\n    }\n})(function(rangy) {\n    rangy.createModule(\"SaveRestore\", [\"WrappedRange\"], function(api, module) {\n        var dom = api.dom;\n        var removeNode = dom.removeNode;\n        var isDirectionBackward = api.Selection.isDirectionBackward;\n        var markerTextChar = \"\\ufeff\";\n\n        function gEBI(id, doc) {\n            return (doc || document).getElementById(id);\n        }\n\n        function insertRangeBoundaryMarker(range, atStart) {\n            var markerId = \"selectionBoundary_\" + (+new Date()) + \"_\" + (\"\" + Math.random()).slice(2);\n            var markerEl;\n            var doc = dom.getDocument(range.startContainer);\n\n            // Clone the Range and collapse to the appropriate boundary point\n            var boundaryRange = range.cloneRange();\n            boundaryRange.collapse(atStart);\n\n            // Create the marker element containing a single invisible character using DOM methods and insert it\n            markerEl = doc.createElement(\"span\");\n            markerEl.id = markerId;\n            markerEl.style.lineHeight = \"0\";\n            markerEl.style.display = \"none\";\n            markerEl.className = \"rangySelectionBoundary\";\n            markerEl.appendChild(doc.createTextNode(markerTextChar));\n\n            boundaryRange.insertNode(markerEl);\n            return markerEl;\n        }\n\n        function setRangeBoundary(doc, range, markerId, atStart) {\n            var markerEl = gEBI(markerId, doc);\n            if (markerEl) {\n                range[atStart ? \"setStartBefore\" : \"setEndBefore\"](markerEl);\n                removeNode(markerEl);\n            } else {\n                module.warn(\"Marker element has been removed. Cannot restore selection.\");\n            }\n        }\n\n        function compareRanges(r1, r2) {\n            return r2.compareBoundaryPoints(r1.START_TO_START, r1);\n        }\n\n        function saveRange(range, direction) {\n            var startEl, endEl, doc = api.DomRange.getRangeDocument(range), text = range.toString();\n            var backward = isDirectionBackward(direction);\n\n            if (range.collapsed) {\n                endEl = insertRangeBoundaryMarker(range, false);\n                return {\n                    document: doc,\n                    markerId: endEl.id,\n                    collapsed: true\n                };\n            } else {\n                endEl = insertRangeBoundaryMarker(range, false);\n                startEl = insertRangeBoundaryMarker(range, true);\n\n                return {\n                    document: doc,\n                    startMarkerId: startEl.id,\n                    endMarkerId: endEl.id,\n                    collapsed: false,\n                    backward: backward,\n                    toString: function() {\n                        return \"original text: '\" + text + \"', new text: '\" + range.toString() + \"'\";\n                    }\n                };\n            }\n        }\n\n        function restoreRange(rangeInfo, normalize) {\n            var doc = rangeInfo.document;\n            if (typeof normalize == \"undefined\") {\n                normalize = true;\n            }\n            var range = api.createRange(doc);\n            if (rangeInfo.collapsed) {\n                var markerEl = gEBI(rangeInfo.markerId, doc);\n                if (markerEl) {\n                    markerEl.style.display = \"inline\";\n                    var previousNode = markerEl.previousSibling;\n\n                    // Workaround for issue 17\n                    if (previousNode && previousNode.nodeType == 3) {\n                        removeNode(markerEl);\n                        range.collapseToPoint(previousNode, previousNode.length);\n                    } else {\n                        range.collapseBefore(markerEl);\n                        removeNode(markerEl);\n                    }\n                } else {\n                    module.warn(\"Marker element has been removed. Cannot restore selection.\");\n                }\n            } else {\n                setRangeBoundary(doc, range, rangeInfo.startMarkerId, true);\n                setRangeBoundary(doc, range, rangeInfo.endMarkerId, false);\n            }\n\n            if (normalize) {\n                range.normalizeBoundaries();\n            }\n\n            return range;\n        }\n\n        function saveRanges(ranges, direction) {\n            var rangeInfos = [], range, doc;\n            var backward = isDirectionBackward(direction);\n\n            // Order the ranges by position within the DOM, latest first, cloning the array to leave the original untouched\n            ranges = ranges.slice(0);\n            ranges.sort(compareRanges);\n\n            for (var i = 0, len = ranges.length; i < len; ++i) {\n                rangeInfos[i] = saveRange(ranges[i], backward);\n            }\n\n            // Now that all the markers are in place and DOM manipulation over, adjust each range's boundaries to lie\n            // between its markers\n            for (i = len - 1; i >= 0; --i) {\n                range = ranges[i];\n                doc = api.DomRange.getRangeDocument(range);\n                if (range.collapsed) {\n                    range.collapseAfter(gEBI(rangeInfos[i].markerId, doc));\n                } else {\n                    range.setEndBefore(gEBI(rangeInfos[i].endMarkerId, doc));\n                    range.setStartAfter(gEBI(rangeInfos[i].startMarkerId, doc));\n                }\n            }\n\n            return rangeInfos;\n        }\n\n        function saveSelection(win) {\n            if (!api.isSelectionValid(win)) {\n                module.warn(\"Cannot save selection. This usually happens when the selection is collapsed and the selection document has lost focus.\");\n                return null;\n            }\n            var sel = api.getSelection(win);\n            var ranges = sel.getAllRanges();\n            var backward = (ranges.length == 1 && sel.isBackward());\n\n            var rangeInfos = saveRanges(ranges, backward);\n\n            // Ensure current selection is unaffected\n            if (backward) {\n                sel.setSingleRange(ranges[0], backward);\n            } else {\n                sel.setRanges(ranges);\n            }\n\n            return {\n                win: win,\n                rangeInfos: rangeInfos,\n                restored: false\n            };\n        }\n\n        function restoreRanges(rangeInfos) {\n            var ranges = [];\n\n            // Ranges are in reverse order of appearance in the DOM. We want to restore earliest first to avoid\n            // normalization affecting previously restored ranges.\n            var rangeCount = rangeInfos.length;\n\n            for (var i = rangeCount - 1; i >= 0; i--) {\n                ranges[i] = restoreRange(rangeInfos[i], true);\n            }\n\n            return ranges;\n        }\n\n        function restoreSelection(savedSelection, preserveDirection) {\n            if (!savedSelection.restored) {\n                var rangeInfos = savedSelection.rangeInfos;\n                var sel = api.getSelection(savedSelection.win);\n                var ranges = restoreRanges(rangeInfos), rangeCount = rangeInfos.length;\n\n                if (rangeCount == 1 && preserveDirection && api.features.selectionHasExtend && rangeInfos[0].backward) {\n                    sel.removeAllRanges();\n                    sel.addRange(ranges[0], true);\n                } else {\n                    sel.setRanges(ranges);\n                }\n\n                savedSelection.restored = true;\n            }\n        }\n\n        function removeMarkerElement(doc, markerId) {\n            var markerEl = gEBI(markerId, doc);\n            if (markerEl) {\n                removeNode(markerEl);\n            }\n        }\n\n        function removeMarkers(savedSelection) {\n            var rangeInfos = savedSelection.rangeInfos;\n            for (var i = 0, len = rangeInfos.length, rangeInfo; i < len; ++i) {\n                rangeInfo = rangeInfos[i];\n                if (rangeInfo.collapsed) {\n                    removeMarkerElement(savedSelection.doc, rangeInfo.markerId);\n                } else {\n                    removeMarkerElement(savedSelection.doc, rangeInfo.startMarkerId);\n                    removeMarkerElement(savedSelection.doc, rangeInfo.endMarkerId);\n                }\n            }\n        }\n\n        api.util.extend(api, {\n            saveRange: saveRange,\n            restoreRange: restoreRange,\n            saveRanges: saveRanges,\n            restoreRanges: restoreRanges,\n            saveSelection: saveSelection,\n            restoreSelection: restoreSelection,\n            removeMarkerElement: removeMarkerElement,\n            removeMarkers: removeMarkers\n        });\n    });\n\n    return rangy;\n}, this);","/*!\n * FullCalendar v3.4.0\n * Docs & License: https://fullcalendar.io/\n * (c) 2017 Adam Shaw\n */\n\n(function(factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([ 'jquery', 'moment' ], factory);\n    }\n    else if (typeof exports === 'object') { // Node/CommonJS\n        module.exports = factory(require('jquery'), require('moment'));\n    }\n    else {\n        factory(jQuery, moment);\n    }\n})(function($, moment) {\n\n    ;;\n\n    var FC = $.fullCalendar = {\n        version: \"3.4.0\",\n        // When introducing internal API incompatibilities (where fullcalendar plugins would break),\n        // the minor version of the calendar should be upped (ex: 2.7.2 -> 2.8.0)\n        // and the below integer should be incremented.\n        internalApiVersion: 9\n    };\n    var fcViews = FC.views = {};\n\n\n    $.fn.fullCalendar = function(options) {\n        var args = Array.prototype.slice.call(arguments, 1); // for a possible method call\n        var res = this; // what this function will return (this jQuery object by default)\n\n        this.each(function(i, _element) { // loop each DOM element involved\n            var element = $(_element);\n            var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)\n            var singleRes; // the returned value of this single method call\n\n            // a method call\n            if (typeof options === 'string') {\n                if (calendar && $.isFunction(calendar[options])) {\n                    singleRes = calendar[options].apply(calendar, args);\n                    if (!i) {\n                        res = singleRes; // record the first method call result\n                    }\n                    if (options === 'destroy') { // for the destroy method, must remove Calendar object data\n                        element.removeData('fullCalendar');\n                    }\n                }\n            }\n            // a new calendar initialization\n            else if (!calendar) { // don't initialize twice\n                calendar = new Calendar(element, options);\n                element.data('fullCalendar', calendar);\n                calendar.render();\n            }\n        });\n\n        return res;\n    };\n\n\n    var complexOptions = [ // names of options that are objects whose properties should be combined\n        'header',\n        'footer',\n        'buttonText',\n        'buttonIcons',\n        'themeButtonIcons'\n    ];\n\n\n// Merges an array of option objects into a single object\n    function mergeOptions(optionObjs) {\n        return mergeProps(optionObjs, complexOptions);\n    }\n\n    ;;\n\n// exports\n    FC.intersectRanges = intersectRanges;\n    FC.applyAll = applyAll;\n    FC.debounce = debounce;\n    FC.isInt = isInt;\n    FC.htmlEscape = htmlEscape;\n    FC.cssToStr = cssToStr;\n    FC.proxy = proxy;\n    FC.capitaliseFirstLetter = capitaliseFirstLetter;\n\n\n    /* FullCalendar-specific DOM Utilities\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n\n// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left\n// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.\n    function compensateScroll(rowEls, scrollbarWidths) {\n        if (scrollbarWidths.left) {\n            rowEls.css({\n                'border-left-width': 1,\n                'margin-left': scrollbarWidths.left - 1\n            });\n        }\n        if (scrollbarWidths.right) {\n            rowEls.css({\n                'border-right-width': 1,\n                'margin-right': scrollbarWidths.right - 1\n            });\n        }\n    }\n\n\n// Undoes compensateScroll and restores all borders/margins\n    function uncompensateScroll(rowEls) {\n        rowEls.css({\n            'margin-left': '',\n            'margin-right': '',\n            'border-left-width': '',\n            'border-right-width': ''\n        });\n    }\n\n\n// Make the mouse cursor express that an event is not allowed in the current area\n    function disableCursor() {\n        $('body').addClass('fc-not-allowed');\n    }\n\n\n// Returns the mouse cursor to its original look\n    function enableCursor() {\n        $('body').removeClass('fc-not-allowed');\n    }\n\n\n// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.\n// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering\n// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and\n// reduces the available height.\n    function distributeHeight(els, availableHeight, shouldRedistribute) {\n\n        // *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,\n        // and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.\n\n        var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element\n        var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*\n        var flexEls = []; // elements that are allowed to expand. array of DOM nodes\n        var flexOffsets = []; // amount of vertical space it takes up\n        var flexHeights = []; // actual css height\n        var usedHeight = 0;\n\n        undistributeHeight(els); // give all elements their natural height\n\n        // find elements that are below the recommended height (expandable).\n        // important to query for heights in a single first pass (to avoid reflow oscillation).\n        els.each(function(i, el) {\n            var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;\n            var naturalOffset = $(el).outerHeight(true);\n\n            if (naturalOffset < minOffset) {\n                flexEls.push(el);\n                flexOffsets.push(naturalOffset);\n                flexHeights.push($(el).height());\n            }\n            else {\n                // this element stretches past recommended height (non-expandable). mark the space as occupied.\n                usedHeight += naturalOffset;\n            }\n        });\n\n        // readjust the recommended height to only consider the height available to non-maxed-out rows.\n        if (shouldRedistribute) {\n            availableHeight -= usedHeight;\n            minOffset1 = Math.floor(availableHeight / flexEls.length);\n            minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*\n        }\n\n        // assign heights to all expandable elements\n        $(flexEls).each(function(i, el) {\n            var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;\n            var naturalOffset = flexOffsets[i];\n            var naturalHeight = flexHeights[i];\n            var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding\n\n            if (naturalOffset < minOffset) { // we check this again because redistribution might have changed things\n                $(el).height(newHeight);\n            }\n        });\n    }\n\n\n// Undoes distrubuteHeight, restoring all els to their natural height\n    function undistributeHeight(els) {\n        els.height('');\n    }\n\n\n// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the\n// cells to be that width.\n// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline\n    function matchCellWidths(els) {\n        var maxInnerWidth = 0;\n\n        els.find('> *').each(function(i, innerEl) {\n            var innerWidth = $(innerEl).outerWidth();\n            if (innerWidth > maxInnerWidth) {\n                maxInnerWidth = innerWidth;\n            }\n        });\n\n        maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance\n\n        els.width(maxInnerWidth);\n\n        return maxInnerWidth;\n    }\n\n\n// Given one element that resides inside another,\n// Subtracts the height of the inner element from the outer element.\n    function subtractInnerElHeight(outerEl, innerEl) {\n        var both = outerEl.add(innerEl);\n        var diff;\n\n        // effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked\n        both.css({\n            position: 'relative', // cause a reflow, which will force fresh dimension recalculation\n            left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll\n        });\n        diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions\n        both.css({ position: '', left: '' }); // undo hack\n\n        return diff;\n    }\n\n\n    /* Element Geom Utilities\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n    FC.getOuterRect = getOuterRect;\n    FC.getClientRect = getClientRect;\n    FC.getContentRect = getContentRect;\n    FC.getScrollbarWidths = getScrollbarWidths;\n\n\n// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51\n    function getScrollParent(el) {\n        var position = el.css('position'),\n            scrollParent = el.parents().filter(function() {\n                var parent = $(this);\n                return (/(auto|scroll)/).test(\n                    parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x')\n                );\n            }).eq(0);\n\n        return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;\n    }\n\n\n// Queries the outer bounding area of a jQuery element.\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\n// Origin is optional.\n    function getOuterRect(el, origin) {\n        var offset = el.offset();\n        var left = offset.left - (origin ? origin.left : 0);\n        var top = offset.top - (origin ? origin.top : 0);\n\n        return {\n            left: left,\n            right: left + el.outerWidth(),\n            top: top,\n            bottom: top + el.outerHeight()\n        };\n    }\n\n\n// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\n// Origin is optional.\n// WARNING: given element can't have borders\n// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\n    function getClientRect(el, origin) {\n        var offset = el.offset();\n        var scrollbarWidths = getScrollbarWidths(el);\n        var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);\n        var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);\n\n        return {\n            left: left,\n            right: left + el[0].clientWidth, // clientWidth includes padding but NOT scrollbars\n            top: top,\n            bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars\n        };\n    }\n\n\n// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\n// Origin is optional.\n    function getContentRect(el, origin) {\n        var offset = el.offset(); // just outside of border, margin not included\n        var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -\n            (origin ? origin.left : 0);\n        var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -\n            (origin ? origin.top : 0);\n\n        return {\n            left: left,\n            right: left + el.width(),\n            top: top,\n            bottom: top + el.height()\n        };\n    }\n\n\n// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.\n// WARNING: given element can't have borders (which will cause offsetWidth/offsetHeight to be larger).\n// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\n    function getScrollbarWidths(el) {\n        var leftRightWidth = el[0].offsetWidth - el[0].clientWidth;\n        var bottomWidth = el[0].offsetHeight - el[0].clientHeight;\n        var widths;\n\n        leftRightWidth = sanitizeScrollbarWidth(leftRightWidth);\n        bottomWidth = sanitizeScrollbarWidth(bottomWidth);\n\n        widths = { left: 0, right: 0, top: 0, bottom: bottomWidth };\n\n        if (getIsLeftRtlScrollbars() && el.css('direction') == 'rtl') { // is the scrollbar on the left side?\n            widths.left = leftRightWidth;\n        }\n        else {\n            widths.right = leftRightWidth;\n        }\n\n        return widths;\n    }\n\n\n// The scrollbar width computations in getScrollbarWidths are sometimes flawed when it comes to\n// retina displays, rounding, and IE11. Massage them into a usable value.\n    function sanitizeScrollbarWidth(width) {\n        width = Math.max(0, width); // no negatives\n        width = Math.round(width);\n        return width;\n    }\n\n\n// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side\n\n    var _isLeftRtlScrollbars = null;\n\n    function getIsLeftRtlScrollbars() { // responsible for caching the computation\n        if (_isLeftRtlScrollbars === null) {\n            _isLeftRtlScrollbars = computeIsLeftRtlScrollbars();\n        }\n        return _isLeftRtlScrollbars;\n    }\n\n    function computeIsLeftRtlScrollbars() { // creates an offscreen test element, then removes it\n        var el = $('<div><div/></div>')\n            .css({\n                position: 'absolute',\n                top: -1000,\n                left: 0,\n                border: 0,\n                padding: 0,\n                overflow: 'scroll',\n                direction: 'rtl'\n            })\n            .appendTo('body');\n        var innerEl = el.children();\n        var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?\n        el.remove();\n        return res;\n    }\n\n\n// Retrieves a jQuery element's computed CSS value as a floating-point number.\n// If the queried value is non-numeric (ex: IE can return \"medium\" for border width), will just return zero.\n    function getCssFloat(el, prop) {\n        return parseFloat(el.css(prop)) || 0;\n    }\n\n\n    /* Mouse / Touch Utilities\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n    FC.preventDefault = preventDefault;\n\n\n// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\n    function isPrimaryMouseButton(ev) {\n        return ev.which == 1 && !ev.ctrlKey;\n    }\n\n\n    function getEvX(ev) {\n        var touches = ev.originalEvent.touches;\n\n        // on mobile FF, pageX for touch events is present, but incorrect,\n        // so, look at touch coordinates first.\n        if (touches && touches.length) {\n            return touches[0].pageX;\n        }\n\n        return ev.pageX;\n    }\n\n\n    function getEvY(ev) {\n        var touches = ev.originalEvent.touches;\n\n        // on mobile FF, pageX for touch events is present, but incorrect,\n        // so, look at touch coordinates first.\n        if (touches && touches.length) {\n            return touches[0].pageY;\n        }\n\n        return ev.pageY;\n    }\n\n\n    function getEvIsTouch(ev) {\n        return /^touch/.test(ev.type);\n    }\n\n\n    function preventSelection(el) {\n        el.addClass('fc-unselectable')\n            .on('selectstart', preventDefault);\n    }\n\n\n    function allowSelection(el) {\n        el.removeClass('fc-unselectable')\n            .off('selectstart', preventDefault);\n    }\n\n\n// Stops a mouse/touch event from doing it's native browser action\n    function preventDefault(ev) {\n        ev.preventDefault();\n    }\n\n\n    /* General Geometry Utils\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n    FC.intersectRects = intersectRects;\n\n// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\n    function intersectRects(rect1, rect2) {\n        var res = {\n            left: Math.max(rect1.left, rect2.left),\n            right: Math.min(rect1.right, rect2.right),\n            top: Math.max(rect1.top, rect2.top),\n            bottom: Math.min(rect1.bottom, rect2.bottom)\n        };\n\n        if (res.left < res.right && res.top < res.bottom) {\n            return res;\n        }\n        return false;\n    }\n\n\n// Returns a new point that will have been moved to reside within the given rectangle\n    function constrainPoint(point, rect) {\n        return {\n            left: Math.min(Math.max(point.left, rect.left), rect.right),\n            top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n        };\n    }\n\n\n// Returns a point that is the center of the given rectangle\n    function getRectCenter(rect) {\n        return {\n            left: (rect.left + rect.right) / 2,\n            top: (rect.top + rect.bottom) / 2\n        };\n    }\n\n\n// Subtracts point2's coordinates from point1's coordinates, returning a delta\n    function diffPoints(point1, point2) {\n        return {\n            left: point1.left - point2.left,\n            top: point1.top - point2.top\n        };\n    }\n\n\n    /* Object Ordering by Field\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n    FC.parseFieldSpecs = parseFieldSpecs;\n    FC.compareByFieldSpecs = compareByFieldSpecs;\n    FC.compareByFieldSpec = compareByFieldSpec;\n    FC.flexibleCompare = flexibleCompare;\n\n\n    function parseFieldSpecs(input) {\n        var specs = [];\n        var tokens = [];\n        var i, token;\n\n        if (typeof input === 'string') {\n            tokens = input.split(/\\s*,\\s*/);\n        }\n        else if (typeof input === 'function') {\n            tokens = [ input ];\n        }\n        else if ($.isArray(input)) {\n            tokens = input;\n        }\n\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n\n            if (typeof token === 'string') {\n                specs.push(\n                    token.charAt(0) == '-' ?\n                        { field: token.substring(1), order: -1 } :\n                        { field: token, order: 1 }\n                );\n            }\n            else if (typeof token === 'function') {\n                specs.push({ func: token });\n            }\n        }\n\n        return specs;\n    }\n\n\n    function compareByFieldSpecs(obj1, obj2, fieldSpecs) {\n        var i;\n        var cmp;\n\n        for (i = 0; i < fieldSpecs.length; i++) {\n            cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);\n            if (cmp) {\n                return cmp;\n            }\n        }\n\n        return 0;\n    }\n\n\n    function compareByFieldSpec(obj1, obj2, fieldSpec) {\n        if (fieldSpec.func) {\n            return fieldSpec.func(obj1, obj2);\n        }\n        return flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) *\n            (fieldSpec.order || 1);\n    }\n\n\n    function flexibleCompare(a, b) {\n        if (!a && !b) {\n            return 0;\n        }\n        if (b == null) {\n            return -1;\n        }\n        if (a == null) {\n            return 1;\n        }\n        if ($.type(a) === 'string' || $.type(b) === 'string') {\n            return String(a).localeCompare(String(b));\n        }\n        return a - b;\n    }\n\n\n    /* FullCalendar-specific Misc Utilities\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n\n// Computes the intersection of the two ranges. Will return fresh date clones in a range.\n// Returns undefined if no intersection.\n// Expects all dates to be normalized to the same timezone beforehand.\n// TODO: move to date section?\n    function intersectRanges(subjectRange, constraintRange) {\n        var subjectStart = subjectRange.start;\n        var subjectEnd = subjectRange.end;\n        var constraintStart = constraintRange.start;\n        var constraintEnd = constraintRange.end;\n        var segStart, segEnd;\n        var isStart, isEnd;\n\n        if (subjectEnd > constraintStart && subjectStart < constraintEnd) { // in bounds at all?\n\n            if (subjectStart >= constraintStart) {\n                segStart = subjectStart.clone();\n                isStart = true;\n            }\n            else {\n                segStart = constraintStart.clone();\n                isStart =  false;\n            }\n\n            if (subjectEnd <= constraintEnd) {\n                segEnd = subjectEnd.clone();\n                isEnd = true;\n            }\n            else {\n                segEnd = constraintEnd.clone();\n                isEnd = false;\n            }\n\n            return {\n                start: segStart,\n                end: segEnd,\n                isStart: isStart,\n                isEnd: isEnd\n            };\n        }\n    }\n\n\n    /* Date Utilities\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n    FC.computeGreatestUnit = computeGreatestUnit;\n    FC.divideRangeByDuration = divideRangeByDuration;\n    FC.divideDurationByDuration = divideDurationByDuration;\n    FC.multiplyDuration = multiplyDuration;\n    FC.durationHasTime = durationHasTime;\n\n    var dayIDs = [ 'sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat' ];\n    var unitsDesc = [ 'year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond' ]; // descending\n\n\n// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.\n// Moments will have their timezones normalized.\n    function diffDayTime(a, b) {\n        return moment.duration({\n            days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),\n            ms: a.time() - b.time() // time-of-day from day start. disregards timezone\n        });\n    }\n\n\n// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.\n    function diffDay(a, b) {\n        return moment.duration({\n            days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')\n        });\n    }\n\n\n// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.\n    function diffByUnit(a, b, unit) {\n        return moment.duration(\n            Math.round(a.diff(b, unit, true)), // returnFloat=true\n            unit\n        );\n    }\n\n\n// Computes the unit name of the largest whole-unit period of time.\n// For example, 48 hours will be \"days\" whereas 49 hours will be \"hours\".\n// Accepts start/end, a range object, or an original duration object.\n    function computeGreatestUnit(start, end) {\n        var i, unit;\n        var val;\n\n        for (i = 0; i < unitsDesc.length; i++) {\n            unit = unitsDesc[i];\n            val = computeRangeAs(unit, start, end);\n\n            if (val >= 1 && isInt(val)) {\n                break;\n            }\n        }\n\n        return unit; // will be \"milliseconds\" if nothing else matches\n    }\n\n\n// like computeGreatestUnit, but has special abilities to interpret the source input for clues\n    function computeDurationGreatestUnit(duration, durationInput) {\n        var unit = computeGreatestUnit(duration);\n\n        // prevent days:7 from being interpreted as a week\n        if (unit === 'week' && typeof durationInput === 'object' && durationInput.days) {\n            unit = 'day';\n        }\n\n        return unit;\n    }\n\n\n// Computes the number of units (like \"hours\") in the given range.\n// Range can be a {start,end} object, separate start/end args, or a Duration.\n// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling\n// of month-diffing logic (which tends to vary from version to version).\n    function computeRangeAs(unit, start, end) {\n\n        if (end != null) { // given start, end\n            return end.diff(start, unit, true);\n        }\n        else if (moment.isDuration(start)) { // given duration\n            return start.as(unit);\n        }\n        else { // given { start, end } range object\n            return start.end.diff(start.start, unit, true);\n        }\n    }\n\n\n// Intelligently divides a range (specified by a start/end params) by a duration\n    function divideRangeByDuration(start, end, dur) {\n        var months;\n\n        if (durationHasTime(dur)) {\n            return (end - start) / dur;\n        }\n        months = dur.asMonths();\n        if (Math.abs(months) >= 1 && isInt(months)) {\n            return end.diff(start, 'months', true) / months;\n        }\n        return end.diff(start, 'days', true) / dur.asDays();\n    }\n\n\n// Intelligently divides one duration by another\n    function divideDurationByDuration(dur1, dur2) {\n        var months1, months2;\n\n        if (durationHasTime(dur1) || durationHasTime(dur2)) {\n            return dur1 / dur2;\n        }\n        months1 = dur1.asMonths();\n        months2 = dur2.asMonths();\n        if (\n            Math.abs(months1) >= 1 && isInt(months1) &&\n            Math.abs(months2) >= 1 && isInt(months2)\n        ) {\n            return months1 / months2;\n        }\n        return dur1.asDays() / dur2.asDays();\n    }\n\n\n// Intelligently multiplies a duration by a number\n    function multiplyDuration(dur, n) {\n        var months;\n\n        if (durationHasTime(dur)) {\n            return moment.duration(dur * n);\n        }\n        months = dur.asMonths();\n        if (Math.abs(months) >= 1 && isInt(months)) {\n            return moment.duration({ months: months * n });\n        }\n        return moment.duration({ days: dur.asDays() * n });\n    }\n\n\n    function cloneRange(range) {\n        return {\n            start: range.start.clone(),\n            end: range.end.clone()\n        };\n    }\n\n\n// Trims the beginning and end of inner range to be completely within outerRange.\n// Returns a new range object.\n    function constrainRange(innerRange, outerRange) {\n        innerRange = cloneRange(innerRange);\n\n        if (outerRange.start) {\n            // needs to be inclusively before outerRange's end\n            innerRange.start = constrainDate(innerRange.start, outerRange);\n        }\n\n        if (outerRange.end) {\n            innerRange.end = minMoment(innerRange.end, outerRange.end);\n        }\n\n        return innerRange;\n    }\n\n\n// If the given date is not within the given range, move it inside.\n// (If it's past the end, make it one millisecond before the end).\n// Always returns a new moment.\n    function constrainDate(date, range) {\n        date = date.clone();\n\n        if (range.start) {\n            date = maxMoment(date, range.start);\n        }\n\n        if (range.end && date >= range.end) {\n            date = range.end.clone().subtract(1);\n        }\n\n        return date;\n    }\n\n\n    function isDateWithinRange(date, range) {\n        return (!range.start || date >= range.start) &&\n            (!range.end || date < range.end);\n    }\n\n\n// TODO: deal with repeat code in intersectRanges\n// constraintRange can have unspecified start/end, an open-ended range.\n    function doRangesIntersect(subjectRange, constraintRange) {\n        return (!constraintRange.start || subjectRange.end >= constraintRange.start) &&\n            (!constraintRange.end || subjectRange.start < constraintRange.end);\n    }\n\n\n    function isRangeWithinRange(innerRange, outerRange) {\n        return (!outerRange.start || innerRange.start >= outerRange.start) &&\n            (!outerRange.end || innerRange.end <= outerRange.end);\n    }\n\n\n    function isRangesEqual(range0, range1) {\n        return ((range0.start && range1.start && range0.start.isSame(range1.start)) || (!range0.start && !range1.start)) &&\n            ((range0.end && range1.end && range0.end.isSame(range1.end)) || (!range0.end && !range1.end));\n    }\n\n\n// Returns the moment that's earlier in time. Always a copy.\n    function minMoment(mom1, mom2) {\n        return (mom1.isBefore(mom2) ? mom1 : mom2).clone();\n    }\n\n\n// Returns the moment that's later in time. Always a copy.\n    function maxMoment(mom1, mom2) {\n        return (mom1.isAfter(mom2) ? mom1 : mom2).clone();\n    }\n\n\n// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)\n    function durationHasTime(dur) {\n        return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());\n    }\n\n\n    function isNativeDate(input) {\n        return  Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;\n    }\n\n\n// Returns a boolean about whether the given input is a time string, like \"06:40:00\" or \"06:00\"\n    function isTimeString(str) {\n        return /^\\d+\\:\\d+(?:\\:\\d+\\.?(?:\\d{3})?)?$/.test(str);\n    }\n\n\n    /* Logging and Debug\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n    FC.log = function() {\n        var console = window.console;\n\n        if (console && console.log) {\n            return console.log.apply(console, arguments);\n        }\n    };\n\n    FC.warn = function() {\n        var console = window.console;\n\n        if (console && console.warn) {\n            return console.warn.apply(console, arguments);\n        }\n        else {\n            return FC.log.apply(FC, arguments);\n        }\n    };\n\n\n    /* General Utilities\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n    var hasOwnPropMethod = {}.hasOwnProperty;\n\n\n// Merges an array of objects into a single object.\n// The second argument allows for an array of property names who's object values will be merged together.\n    function mergeProps(propObjs, complexProps) {\n        var dest = {};\n        var i, name;\n        var complexObjs;\n        var j, val;\n        var props;\n\n        if (complexProps) {\n            for (i = 0; i < complexProps.length; i++) {\n                name = complexProps[i];\n                complexObjs = [];\n\n                // collect the trailing object values, stopping when a non-object is discovered\n                for (j = propObjs.length - 1; j >= 0; j--) {\n                    val = propObjs[j][name];\n\n                    if (typeof val === 'object') {\n                        complexObjs.unshift(val);\n                    }\n                    else if (val !== undefined) {\n                        dest[name] = val; // if there were no objects, this value will be used\n                        break;\n                    }\n                }\n\n                // if the trailing values were objects, use the merged value\n                if (complexObjs.length) {\n                    dest[name] = mergeProps(complexObjs);\n                }\n            }\n        }\n\n        // copy values into the destination, going from last to first\n        for (i = propObjs.length - 1; i >= 0; i--) {\n            props = propObjs[i];\n\n            for (name in props) {\n                if (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign\n                    dest[name] = props[name];\n                }\n            }\n        }\n\n        return dest;\n    }\n\n\n// Create an object that has the given prototype. Just like Object.create\n    function createObject(proto) {\n        var f = function() {};\n        f.prototype = proto;\n        return new f();\n    }\n    FC.createObject = createObject;\n\n\n    function copyOwnProps(src, dest) {\n        for (var name in src) {\n            if (hasOwnProp(src, name)) {\n                dest[name] = src[name];\n            }\n        }\n    }\n\n\n    function hasOwnProp(obj, name) {\n        return hasOwnPropMethod.call(obj, name);\n    }\n\n\n// Is the given value a non-object non-function value?\n    function isAtomic(val) {\n        return /undefined|null|boolean|number|string/.test($.type(val));\n    }\n\n\n    function applyAll(functions, thisObj, args) {\n        if ($.isFunction(functions)) {\n            functions = [ functions ];\n        }\n        if (functions) {\n            var i;\n            var ret;\n            for (i=0; i<functions.length; i++) {\n                ret = functions[i].apply(thisObj, args) || ret;\n            }\n            return ret;\n        }\n    }\n\n\n    function firstDefined() {\n        for (var i=0; i<arguments.length; i++) {\n            if (arguments[i] !== undefined) {\n                return arguments[i];\n            }\n        }\n    }\n\n\n    function htmlEscape(s) {\n        return (s + '').replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/'/g, '&#039;')\n            .replace(/\"/g, '&quot;')\n            .replace(/\\n/g, '<br />');\n    }\n\n\n    function stripHtmlEntities(text) {\n        return text.replace(/&.*?;/g, '');\n    }\n\n\n// Given a hash of CSS properties, returns a string of CSS.\n// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.\n    function cssToStr(cssProps) {\n        var statements = [];\n\n        $.each(cssProps, function(name, val) {\n            if (val != null) {\n                statements.push(name + ':' + val);\n            }\n        });\n\n        return statements.join(';');\n    }\n\n\n// Given an object hash of HTML attribute names to values,\n// generates a string that can be injected between < > in HTML\n    function attrsToStr(attrs) {\n        var parts = [];\n\n        $.each(attrs, function(name, val) {\n            if (val != null) {\n                parts.push(name + '=\"' + htmlEscape(val) + '\"');\n            }\n        });\n\n        return parts.join(' ');\n    }\n\n\n    function capitaliseFirstLetter(str) {\n        return str.charAt(0).toUpperCase() + str.slice(1);\n    }\n\n\n    function compareNumbers(a, b) { // for .sort()\n        return a - b;\n    }\n\n\n    function isInt(n) {\n        return n % 1 === 0;\n    }\n\n\n// Returns a method bound to the given object context.\n// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with\n// different contexts as identical when binding/unbinding events.\n    function proxy(obj, methodName) {\n        var method = obj[methodName];\n\n        return function() {\n            return method.apply(obj, arguments);\n        };\n    }\n\n\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714\n    function debounce(func, wait, immediate) {\n        var timeout, args, context, timestamp, result;\n\n        var later = function() {\n            var last = +new Date() - timestamp;\n            if (last < wait) {\n                timeout = setTimeout(later, wait - last);\n            }\n            else {\n                timeout = null;\n                if (!immediate) {\n                    result = func.apply(context, args);\n                    context = args = null;\n                }\n            }\n        };\n\n        return function() {\n            context = this;\n            args = arguments;\n            timestamp = +new Date();\n            var callNow = immediate && !timeout;\n            if (!timeout) {\n                timeout = setTimeout(later, wait);\n            }\n            if (callNow) {\n                result = func.apply(context, args);\n                context = args = null;\n            }\n            return result;\n        };\n    }\n\n    ;;\n\n    /*\n     GENERAL NOTE on moments throughout the *entire rest* of the codebase:\n     All moments are assumed to be ambiguously-zoned unless otherwise noted,\n     with the NOTABLE EXCEOPTION of start/end dates that live on *Event Objects*.\n     Ambiguously-TIMED moments are assumed to be ambiguously-zoned by nature.\n     */\n\n    var ambigDateOfMonthRegex = /^\\s*\\d{4}-\\d\\d$/;\n    var ambigTimeOrZoneRegex =\n        /^\\s*\\d{4}-(?:(\\d\\d-\\d\\d)|(W\\d\\d$)|(W\\d\\d-\\d)|(\\d\\d\\d))((T| )(\\d\\d(:\\d\\d(:\\d\\d(\\.\\d+)?)?)?)?)?$/;\n    var newMomentProto = moment.fn; // where we will attach our new methods\n    var oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods\n\n// tell momentjs to transfer these properties upon clone\n    var momentProperties = moment.momentProperties;\n    momentProperties.push('_fullCalendar');\n    momentProperties.push('_ambigTime');\n    momentProperties.push('_ambigZone');\n\n\n// Creating\n// -------------------------------------------------------------------------------------------------\n\n// Creates a new moment, similar to the vanilla moment(...) constructor, but with\n// extra features (ambiguous time, enhanced formatting). When given an existing moment,\n// it will function as a clone (and retain the zone of the moment). Anything else will\n// result in a moment in the local zone.\n    FC.moment = function() {\n        return makeMoment(arguments);\n    };\n\n// Sames as FC.moment, but forces the resulting moment to be in the UTC timezone.\n    FC.moment.utc = function() {\n        var mom = makeMoment(arguments, true);\n\n        // Force it into UTC because makeMoment doesn't guarantee it\n        // (if given a pre-existing moment for example)\n        if (mom.hasTime()) { // don't give ambiguously-timed moments a UTC zone\n            mom.utc();\n        }\n\n        return mom;\n    };\n\n// Same as FC.moment, but when given an ISO8601 string, the timezone offset is preserved.\n// ISO8601 strings with no timezone offset will become ambiguously zoned.\n    FC.moment.parseZone = function() {\n        return makeMoment(arguments, true, true);\n    };\n\n// Builds an enhanced moment from args. When given an existing moment, it clones. When given a\n// native Date, or called with no arguments (the current time), the resulting moment will be local.\n// Anything else needs to be \"parsed\" (a string or an array), and will be affected by:\n//    parseAsUTC - if there is no zone information, should we parse the input in UTC?\n//    parseZone - if there is zone information, should we force the zone of the moment?\n    function makeMoment(args, parseAsUTC, parseZone) {\n        var input = args[0];\n        var isSingleString = args.length == 1 && typeof input === 'string';\n        var isAmbigTime;\n        var isAmbigZone;\n        var ambigMatch;\n        var mom;\n\n        if (moment.isMoment(input) || isNativeDate(input) || input === undefined) {\n            mom = moment.apply(null, args);\n        }\n        else { // \"parsing\" is required\n            isAmbigTime = false;\n            isAmbigZone = false;\n\n            if (isSingleString) {\n                if (ambigDateOfMonthRegex.test(input)) {\n                    // accept strings like '2014-05', but convert to the first of the month\n                    input += '-01';\n                    args = [ input ]; // for when we pass it on to moment's constructor\n                    isAmbigTime = true;\n                    isAmbigZone = true;\n                }\n                else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {\n                    isAmbigTime = !ambigMatch[5]; // no time part?\n                    isAmbigZone = true;\n                }\n            }\n            else if ($.isArray(input)) {\n                // arrays have no timezone information, so assume ambiguous zone\n                isAmbigZone = true;\n            }\n            // otherwise, probably a string with a format\n\n            if (parseAsUTC || isAmbigTime) {\n                mom = moment.utc.apply(moment, args);\n            }\n            else {\n                mom = moment.apply(null, args);\n            }\n\n            if (isAmbigTime) {\n                mom._ambigTime = true;\n                mom._ambigZone = true; // ambiguous time always means ambiguous zone\n            }\n            else if (parseZone) { // let's record the inputted zone somehow\n                if (isAmbigZone) {\n                    mom._ambigZone = true;\n                }\n                else if (isSingleString) {\n                    mom.utcOffset(input); // if not a valid zone, will assign UTC\n                }\n            }\n        }\n\n        mom._fullCalendar = true; // flag for extended functionality\n\n        return mom;\n    }\n\n\n// Week Number\n// -------------------------------------------------------------------------------------------------\n\n\n// Returns the week number, considering the locale's custom week number calcuation\n// `weeks` is an alias for `week`\n    newMomentProto.week = newMomentProto.weeks = function(input) {\n        var weekCalc = this._locale._fullCalendar_weekCalc;\n\n        if (input == null && typeof weekCalc === 'function') { // custom function only works for getter\n            return weekCalc(this);\n        }\n        else if (weekCalc === 'ISO') {\n            return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter\n        }\n\n        return oldMomentProto.week.apply(this, arguments); // local getter/setter\n    };\n\n\n// Time-of-day\n// -------------------------------------------------------------------------------------------------\n\n// GETTER\n// Returns a Duration with the hours/minutes/seconds/ms values of the moment.\n// If the moment has an ambiguous time, a duration of 00:00 will be returned.\n//\n// SETTER\n// You can supply a Duration, a Moment, or a Duration-like argument.\n// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.\n    newMomentProto.time = function(time) {\n\n        // Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.\n        // `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.\n        if (!this._fullCalendar) {\n            return oldMomentProto.time.apply(this, arguments);\n        }\n\n        if (time == null) { // getter\n            return moment.duration({\n                hours: this.hours(),\n                minutes: this.minutes(),\n                seconds: this.seconds(),\n                milliseconds: this.milliseconds()\n            });\n        }\n        else { // setter\n\n            this._ambigTime = false; // mark that the moment now has a time\n\n            if (!moment.isDuration(time) && !moment.isMoment(time)) {\n                time = moment.duration(time);\n            }\n\n            // The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).\n            // Only for Duration times, not Moment times.\n            var dayHours = 0;\n            if (moment.isDuration(time)) {\n                dayHours = Math.floor(time.asDays()) * 24;\n            }\n\n            // We need to set the individual fields.\n            // Can't use startOf('day') then add duration. In case of DST at start of day.\n            return this.hours(dayHours + time.hours())\n                .minutes(time.minutes())\n                .seconds(time.seconds())\n                .milliseconds(time.milliseconds());\n        }\n    };\n\n// Converts the moment to UTC, stripping out its time-of-day and timezone offset,\n// but preserving its YMD. A moment with a stripped time will display no time\n// nor timezone offset when .format() is called.\n    newMomentProto.stripTime = function() {\n\n        if (!this._ambigTime) {\n\n            this.utc(true); // keepLocalTime=true (for keeping *date* value)\n\n            // set time to zero\n            this.set({\n                hours: 0,\n                minutes: 0,\n                seconds: 0,\n                ms: 0\n            });\n\n            // Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\n            // which clears all ambig flags.\n            this._ambigTime = true;\n            this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset\n        }\n\n        return this; // for chaining\n    };\n\n// Returns if the moment has a non-ambiguous time (boolean)\n    newMomentProto.hasTime = function() {\n        return !this._ambigTime;\n    };\n\n\n// Timezone\n// -------------------------------------------------------------------------------------------------\n\n// Converts the moment to UTC, stripping out its timezone offset, but preserving its\n// YMD and time-of-day. A moment with a stripped timezone offset will display no\n// timezone offset when .format() is called.\n    newMomentProto.stripZone = function() {\n        var wasAmbigTime;\n\n        if (!this._ambigZone) {\n\n            wasAmbigTime = this._ambigTime;\n\n            this.utc(true); // keepLocalTime=true (for keeping date and time values)\n\n            // the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore\n            this._ambigTime = wasAmbigTime || false;\n\n            // Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\n            // which clears the ambig flags.\n            this._ambigZone = true;\n        }\n\n        return this; // for chaining\n    };\n\n// Returns of the moment has a non-ambiguous timezone offset (boolean)\n    newMomentProto.hasZone = function() {\n        return !this._ambigZone;\n    };\n\n\n// implicitly marks a zone\n    newMomentProto.local = function(keepLocalTime) {\n\n        // for when converting from ambiguously-zoned to local,\n        // keep the time values when converting from UTC -> local\n        oldMomentProto.local.call(this, this._ambigZone || keepLocalTime);\n\n        // ensure non-ambiguous\n        // this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals\n        this._ambigTime = false;\n        this._ambigZone = false;\n\n        return this; // for chaining\n    };\n\n\n// implicitly marks a zone\n    newMomentProto.utc = function(keepLocalTime) {\n\n        oldMomentProto.utc.call(this, keepLocalTime);\n\n        // ensure non-ambiguous\n        // this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals\n        this._ambigTime = false;\n        this._ambigZone = false;\n\n        return this;\n    };\n\n\n// implicitly marks a zone (will probably get called upon .utc() and .local())\n    newMomentProto.utcOffset = function(tzo) {\n\n        if (tzo != null) { // setter\n            // these assignments needs to happen before the original zone method is called.\n            // I forget why, something to do with a browser crash.\n            this._ambigTime = false;\n            this._ambigZone = false;\n        }\n\n        return oldMomentProto.utcOffset.apply(this, arguments);\n    };\n\n\n// Formatting\n// -------------------------------------------------------------------------------------------------\n\n    newMomentProto.format = function() {\n\n        if (this._fullCalendar && arguments[0]) { // an enhanced moment? and a format string provided?\n            return formatDate(this, arguments[0]); // our extended formatting\n        }\n        if (this._ambigTime) {\n            return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');\n        }\n        if (this._ambigZone) {\n            return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');\n        }\n        if (this._fullCalendar) { // enhanced non-ambig moment?\n            // moment.format() doesn't ensure english, but we want to.\n            return oldMomentFormat(englishMoment(this));\n        }\n\n        return oldMomentProto.format.apply(this, arguments);\n    };\n\n    newMomentProto.toISOString = function() {\n\n        if (this._ambigTime) {\n            return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');\n        }\n        if (this._ambigZone) {\n            return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');\n        }\n        if (this._fullCalendar) { // enhanced non-ambig moment?\n            // depending on browser, moment might not output english. ensure english.\n            // https://github.com/moment/moment/blob/2.18.1/src/lib/moment/format.js#L22\n            return oldMomentProto.toISOString.apply(englishMoment(this), arguments);\n        }\n\n        return oldMomentProto.toISOString.apply(this, arguments);\n    };\n\n    function englishMoment(mom) {\n        if (mom.locale() !== 'en') {\n            return mom.clone().locale('en');\n        }\n        return mom;\n    }\n\n    ;;\n    (function() {\n\n// exports\n        FC.formatDate = formatDate;\n        FC.formatRange = formatRange;\n        FC.oldMomentFormat = oldMomentFormat;\n        FC.queryMostGranularFormatUnit = queryMostGranularFormatUnit;\n\n\n// Config\n// ---------------------------------------------------------------------------------------------------------------------\n\n        /*\n         Inserted between chunks in the fake (\"intermediate\") formatting string.\n         Important that it passes as whitespace (\\s) because moment often identifies non-standalone months\n         via a regexp with an \\s.\n         */\n        var PART_SEPARATOR = '\\u000b'; // vertical tab\n\n        /*\n         Inserted as the first character of a literal-text chunk to indicate that the literal text is not actually literal text,\n         but rather, a \"special\" token that has custom rendering (see specialTokens map).\n         */\n        var SPECIAL_TOKEN_MARKER = '\\u001f'; // information separator 1\n\n        /*\n         Inserted at the beginning and end of a span of text that must have non-zero numeric characters.\n         Handling of these markers is done in a post-processing step at the very end of text rendering.\n         */\n        var MAYBE_MARKER = '\\u001e'; // information separator 2\n        var MAYBE_REGEXP = new RegExp(MAYBE_MARKER + '([^' + MAYBE_MARKER + ']*)' + MAYBE_MARKER, 'g'); // must be global\n\n        /*\n         Addition formatting tokens we want recognized\n         */\n        var specialTokens = {\n            t: function(date) { // \"a\" or \"p\"\n                return oldMomentFormat(date, 'a').charAt(0);\n            },\n            T: function(date) { // \"A\" or \"P\"\n                return oldMomentFormat(date, 'A').charAt(0);\n            }\n        };\n\n        /*\n         The first characters of formatting tokens for units that are 1 day or larger.\n         `value` is for ranking relative size (lower means bigger).\n         `unit` is a normalized unit, used for comparing moments.\n         */\n        var largeTokenMap = {\n            Y: { value: 1, unit: 'year' },\n            M: { value: 2, unit: 'month' },\n            W: { value: 3, unit: 'week' }, // ISO week\n            w: { value: 3, unit: 'week' }, // local week\n            D: { value: 4, unit: 'day' }, // day of month\n            d: { value: 4, unit: 'day' } // day of week\n        };\n\n\n// Single Date Formatting\n// ---------------------------------------------------------------------------------------------------------------------\n\n        /*\n         Formats `date` with a Moment formatting string, but allow our non-zero areas and special token\n         */\n        function formatDate(date, formatStr) {\n            return renderFakeFormatString(\n                getParsedFormatString(formatStr).fakeFormatString,\n                date\n            );\n        }\n\n        /*\n         Call this if you want Moment's original format method to be used\n         */\n        function oldMomentFormat(mom, formatStr) {\n            return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js\n        }\n\n\n// Date Range Formatting\n// -------------------------------------------------------------------------------------------------\n// TODO: make it work with timezone offset\n\n        /*\n         Using a formatting string meant for a single date, generate a range string, like\n         \"Sep 2 - 9 2013\", that intelligently inserts a separator where the dates differ.\n         If the dates are the same as far as the format string is concerned, just return a single\n         rendering of one date, without any separator.\n         */\n        function formatRange(date1, date2, formatStr, separator, isRTL) {\n            var localeData;\n\n            date1 = FC.moment.parseZone(date1);\n            date2 = FC.moment.parseZone(date2);\n\n            localeData = date1.localeData();\n\n            // Expand localized format strings, like \"LL\" -> \"MMMM D YYYY\".\n            // BTW, this is not important for `formatDate` because it is impossible to put custom tokens\n            // or non-zero areas in Moment's localized format strings.\n            formatStr = localeData.longDateFormat(formatStr) || formatStr;\n\n            return renderParsedFormat(\n                getParsedFormatString(formatStr),\n                date1,\n                date2,\n                separator || ' - ',\n                isRTL\n            );\n        }\n\n        /*\n         Renders a range with an already-parsed format string.\n         */\n        function renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {\n            var sameUnits = parsedFormat.sameUnits;\n            var unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons\n            var unzonedDate2 = date2.clone().stripZone(); // \"\n\n            var renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);\n            var renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);\n\n            var leftI;\n            var leftStr = '';\n            var rightI;\n            var rightStr = '';\n            var middleI;\n            var middleStr1 = '';\n            var middleStr2 = '';\n            var middleStr = '';\n\n            // Start at the leftmost side of the formatting string and continue until you hit a token\n            // that is not the same between dates.\n            for (\n                leftI = 0;\n                leftI < sameUnits.length && (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI]));\n                leftI++\n            ) {\n                leftStr += renderedParts1[leftI];\n            }\n\n            // Similarly, start at the rightmost side of the formatting string and move left\n            for (\n                rightI = sameUnits.length - 1;\n                rightI > leftI && (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI]));\n                rightI--\n            ) {\n                // If current chunk is on the boundary of unique date-content, and is a special-case\n                // date-formatting postfix character, then don't consume it. Consider it unique date-content.\n                // TODO: make configurable\n                if (rightI - 1 === leftI && renderedParts1[rightI] === '.') {\n                    break;\n                }\n\n                rightStr = renderedParts1[rightI] + rightStr;\n            }\n\n            // The area in the middle is different for both of the dates.\n            // Collect them distinctly so we can jam them together later.\n            for (middleI = leftI; middleI <= rightI; middleI++) {\n                middleStr1 += renderedParts1[middleI];\n                middleStr2 += renderedParts2[middleI];\n            }\n\n            if (middleStr1 || middleStr2) {\n                if (isRTL) {\n                    middleStr = middleStr2 + separator + middleStr1;\n                }\n                else {\n                    middleStr = middleStr1 + separator + middleStr2;\n                }\n            }\n\n            return processMaybeMarkers(\n                leftStr + middleStr + rightStr\n            );\n        }\n\n\n// Format String Parsing\n// ---------------------------------------------------------------------------------------------------------------------\n\n        var parsedFormatStrCache = {};\n\n        /*\n         Returns a parsed format string, leveraging a cache.\n         */\n        function getParsedFormatString(formatStr) {\n            return parsedFormatStrCache[formatStr] ||\n                (parsedFormatStrCache[formatStr] = parseFormatString(formatStr));\n        }\n\n        /*\n         Parses a format string into the following:\n         - fakeFormatString: a momentJS formatting string, littered with special control characters that get post-processed.\n         - sameUnits: for every part in fakeFormatString, if the part is a token, the value will be a unit string (like \"day\"),\n         that indicates how similar a range's start & end must be in order to share the same formatted text.\n         If not a token, then the value is null.\n         Always a flat array (not nested liked \"chunks\").\n         */\n        function parseFormatString(formatStr) {\n            var chunks = chunkFormatString(formatStr);\n\n            return {\n                fakeFormatString: buildFakeFormatString(chunks),\n                sameUnits: buildSameUnits(chunks)\n            };\n        }\n\n        /*\n         Break the formatting string into an array of chunks.\n         A 'maybe' chunk will have nested chunks.\n         */\n        function chunkFormatString(formatStr) {\n            var chunks = [];\n            var match;\n\n            // TODO: more descrimination\n            // \\4 is a backreference to the first character of a multi-character set.\n            var chunker = /\\[([^\\]]*)\\]|\\(([^\\)]*)\\)|(LTS|LT|(\\w)\\4*o?)|([^\\w\\[\\(]+)/g;\n\n            while ((match = chunker.exec(formatStr))) {\n                if (match[1]) { // a literal string inside [ ... ]\n                    chunks.push.apply(chunks, // append\n                        splitStringLiteral(match[1])\n                    );\n                }\n                else if (match[2]) { // non-zero formatting inside ( ... )\n                    chunks.push({ maybe: chunkFormatString(match[2]) });\n                }\n                else if (match[3]) { // a formatting token\n                    chunks.push({ token: match[3] });\n                }\n                else if (match[5]) { // an unenclosed literal string\n                    chunks.push.apply(chunks, // append\n                        splitStringLiteral(match[5])\n                    );\n                }\n            }\n\n            return chunks;\n        }\n\n        /*\n         Potentially splits a literal-text string into multiple parts. For special cases.\n         */\n        function splitStringLiteral(s) {\n            if (s === '. ') {\n                return [ '.', ' ' ]; // for locales with periods bound to the end of each year/month/date\n            }\n            else {\n                return [ s ];\n            }\n        }\n\n        /*\n         Given chunks parsed from a real format string, generate a fake (aka \"intermediate\") format string with special control\n         characters that will eventually be given to moment for formatting, and then post-processed.\n         */\n        function buildFakeFormatString(chunks) {\n            var parts = [];\n            var i, chunk;\n\n            for (i = 0; i < chunks.length; i++) {\n                chunk = chunks[i];\n\n                if (typeof chunk === 'string') {\n                    parts.push('[' + chunk + ']');\n                }\n                else if (chunk.token) {\n                    if (chunk.token in specialTokens) {\n                        parts.push(\n                            SPECIAL_TOKEN_MARKER + // useful during post-processing\n                            '[' + chunk.token + ']' // preserve as literal text\n                        );\n                    }\n                    else {\n                        parts.push(chunk.token); // unprotected text implies a format string\n                    }\n                }\n                else if (chunk.maybe) {\n                    parts.push(\n                        MAYBE_MARKER + // useful during post-processing\n                        buildFakeFormatString(chunk.maybe) +\n                        MAYBE_MARKER\n                    );\n                }\n            }\n\n            return parts.join(PART_SEPARATOR);\n        }\n\n        /*\n         Given parsed chunks from a real formatting string, generates an array of unit strings (like \"day\") that indicate\n         in which regard two dates must be similar in order to share range formatting text.\n         The `chunks` can be nested (because of \"maybe\" chunks), however, the returned array will be flat.\n         */\n        function buildSameUnits(chunks) {\n            var units = [];\n            var i, chunk;\n            var tokenInfo;\n\n            for (i = 0; i < chunks.length; i++) {\n                chunk = chunks[i];\n\n                if (chunk.token) {\n                    tokenInfo = largeTokenMap[chunk.token.charAt(0)];\n                    units.push(tokenInfo ? tokenInfo.unit : 'second'); // default to a very strict same-second\n                }\n                else if (chunk.maybe) {\n                    units.push.apply(units, // append\n                        buildSameUnits(chunk.maybe)\n                    );\n                }\n                else {\n                    units.push(null);\n                }\n            }\n\n            return units;\n        }\n\n\n// Rendering to text\n// ---------------------------------------------------------------------------------------------------------------------\n\n        /*\n         Formats a date with a fake format string, post-processes the control characters, then returns.\n         */\n        function renderFakeFormatString(fakeFormatString, date) {\n            return processMaybeMarkers(\n                renderFakeFormatStringParts(fakeFormatString, date).join('')\n            );\n        }\n\n        /*\n         Formats a date into parts that will have been post-processed, EXCEPT for the \"maybe\" markers.\n         */\n        function renderFakeFormatStringParts(fakeFormatString, date) {\n            var parts = [];\n            var fakeRender = oldMomentFormat(date, fakeFormatString);\n            var fakeParts = fakeRender.split(PART_SEPARATOR);\n            var i, fakePart;\n\n            for (i = 0; i < fakeParts.length; i++) {\n                fakePart = fakeParts[i];\n\n                if (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {\n                    parts.push(\n                        // the literal string IS the token's name.\n                        // call special token's registered function.\n                        specialTokens[fakePart.substring(1)](date)\n                    );\n                }\n                else {\n                    parts.push(fakePart);\n                }\n            }\n\n            return parts;\n        }\n\n        /*\n         Accepts an almost-finally-formatted string and processes the \"maybe\" control characters, returning a new string.\n         */\n        function processMaybeMarkers(s) {\n            return s.replace(MAYBE_REGEXP, function(m0, m1) { // regex assumed to have 'g' flag\n                if (m1.match(/[1-9]/)) { // any non-zero numeric characters?\n                    return m1;\n                }\n                else {\n                    return '';\n                }\n            });\n        }\n\n\n// Misc Utils\n// -------------------------------------------------------------------------------------------------\n\n        /*\n         Returns a unit string, either 'year', 'month', 'day', or null for the most granular formatting token in the string.\n         */\n        function queryMostGranularFormatUnit(formatStr) {\n            var chunks = chunkFormatString(formatStr);\n            var i, chunk;\n            var candidate;\n            var best;\n\n            for (i = 0; i < chunks.length; i++) {\n                chunk = chunks[i];\n\n                if (chunk.token) {\n                    candidate = largeTokenMap[chunk.token.charAt(0)];\n                    if (candidate) {\n                        if (!best || candidate.value > best.value) {\n                            best = candidate;\n                        }\n                    }\n                }\n            }\n\n            if (best) {\n                return best.unit;\n            }\n\n            return null;\n        };\n\n    })();\n\n// quick local references\n    var formatDate = FC.formatDate;\n    var formatRange = FC.formatRange;\n    var oldMomentFormat = FC.oldMomentFormat;\n\n    ;;\n\n    FC.Class = Class; // export\n\n// Class that all other classes will inherit from\n    function Class() { }\n\n\n// Called on a class to create a subclass.\n// Last argument contains instance methods. Any argument before the last are considered mixins.\n    Class.extend = function() {\n        var len = arguments.length;\n        var i;\n        var members;\n\n        for (i = 0; i < len; i++) {\n            members = arguments[i];\n            if (i < len - 1) { // not the last argument?\n                mixIntoClass(this, members);\n            }\n        }\n\n        return extendClass(this, members || {}); // members will be undefined if no arguments\n    };\n\n\n// Adds new member variables/methods to the class's prototype.\n// Can be called with another class, or a plain object hash containing new members.\n    Class.mixin = function(members) {\n        mixIntoClass(this, members);\n    };\n\n\n    function extendClass(superClass, members) {\n        var subClass;\n\n        // ensure a constructor for the subclass, forwarding all arguments to the super-constructor if it doesn't exist\n        if (hasOwnProp(members, 'constructor')) {\n            subClass = members.constructor;\n        }\n        if (typeof subClass !== 'function') {\n            subClass = members.constructor = function() {\n                superClass.apply(this, arguments);\n            };\n        }\n\n        // build the base prototype for the subclass, which is an new object chained to the superclass's prototype\n        subClass.prototype = createObject(superClass.prototype);\n\n        // copy each member variable/method onto the the subclass's prototype\n        copyOwnProps(members, subClass.prototype);\n\n        // copy over all class variables/methods to the subclass, such as `extend` and `mixin`\n        copyOwnProps(superClass, subClass);\n\n        return subClass;\n    }\n\n\n    function mixIntoClass(theClass, members) {\n        copyOwnProps(members, theClass.prototype);\n    }\n    ;;\n\n    var Model = Class.extend(EmitterMixin, ListenerMixin, {\n\n        _props: null,\n        _watchers: null,\n        _globalWatchArgs: null,\n\n        constructor: function() {\n            this._watchers = {};\n            this._props = {};\n            this.applyGlobalWatchers();\n        },\n\n        applyGlobalWatchers: function() {\n            var argSets = this._globalWatchArgs || [];\n            var i;\n\n            for (i = 0; i < argSets.length; i++) {\n                this.watch.apply(this, argSets[i]);\n            }\n        },\n\n        has: function(name) {\n            return name in this._props;\n        },\n\n        get: function(name) {\n            if (name === undefined) {\n                return this._props;\n            }\n\n            return this._props[name];\n        },\n\n        set: function(name, val) {\n            var newProps;\n\n            if (typeof name === 'string') {\n                newProps = {};\n                newProps[name] = val === undefined ? null : val;\n            }\n            else {\n                newProps = name;\n            }\n\n            this.setProps(newProps);\n        },\n\n        reset: function(newProps) {\n            var oldProps = this._props;\n            var changeset = {}; // will have undefined's to signal unsets\n            var name;\n\n            for (name in oldProps) {\n                changeset[name] = undefined;\n            }\n\n            for (name in newProps) {\n                changeset[name] = newProps[name];\n            }\n\n            this.setProps(changeset);\n        },\n\n        unset: function(name) { // accepts a string or array of strings\n            var newProps = {};\n            var names;\n            var i;\n\n            if (typeof name === 'string') {\n                names = [ name ];\n            }\n            else {\n                names = name;\n            }\n\n            for (i = 0; i < names.length; i++) {\n                newProps[names[i]] = undefined;\n            }\n\n            this.setProps(newProps);\n        },\n\n        setProps: function(newProps) {\n            var changedProps = {};\n            var changedCnt = 0;\n            var name, val;\n\n            for (name in newProps) {\n                val = newProps[name];\n\n                // a change in value?\n                // if an object, don't check equality, because might have been mutated internally.\n                // TODO: eventually enforce immutability.\n                if (\n                    typeof val === 'object' ||\n                    val !== this._props[name]\n                ) {\n                    changedProps[name] = val;\n                    changedCnt++;\n                }\n            }\n\n            if (changedCnt) {\n\n                this.trigger('before:batchChange', changedProps);\n\n                for (name in changedProps) {\n                    val = changedProps[name];\n\n                    this.trigger('before:change', name, val);\n                    this.trigger('before:change:' + name, val);\n                }\n\n                for (name in changedProps) {\n                    val = changedProps[name];\n\n                    if (val === undefined) {\n                        delete this._props[name];\n                    }\n                    else {\n                        this._props[name] = val;\n                    }\n\n                    this.trigger('change:' + name, val);\n                    this.trigger('change', name, val);\n                }\n\n                this.trigger('batchChange', changedProps);\n            }\n        },\n\n        watch: function(name, depList, startFunc, stopFunc) {\n            var _this = this;\n\n            this.unwatch(name);\n\n            this._watchers[name] = this._watchDeps(depList, function(deps) {\n                var res = startFunc.call(_this, deps);\n\n                if (res && res.then) {\n                    _this.unset(name); // put in an unset state while resolving\n                    res.then(function(val) {\n                        _this.set(name, val);\n                    });\n                }\n                else {\n                    _this.set(name, res);\n                }\n            }, function() {\n                _this.unset(name);\n\n                if (stopFunc) {\n                    stopFunc.call(_this);\n                }\n            });\n        },\n\n        unwatch: function(name) {\n            var watcher = this._watchers[name];\n\n            if (watcher) {\n                delete this._watchers[name];\n                watcher.teardown();\n            }\n        },\n\n        _watchDeps: function(depList, startFunc, stopFunc) {\n            var _this = this;\n            var queuedChangeCnt = 0;\n            var depCnt = depList.length;\n            var satisfyCnt = 0;\n            var values = {}; // what's passed as the `deps` arguments\n            var bindTuples = []; // array of [ eventName, handlerFunc ] arrays\n            var isCallingStop = false;\n\n            function onBeforeDepChange(depName, val, isOptional) {\n                queuedChangeCnt++;\n                if (queuedChangeCnt === 1) { // first change to cause a \"stop\" ?\n                    if (satisfyCnt === depCnt) { // all deps previously satisfied?\n                        isCallingStop = true;\n                        stopFunc();\n                        isCallingStop = false;\n                    }\n                }\n            }\n\n            function onDepChange(depName, val, isOptional) {\n\n                if (val === undefined) { // unsetting a value?\n\n                    // required dependency that was previously set?\n                    if (!isOptional && values[depName] !== undefined) {\n                        satisfyCnt--;\n                    }\n\n                    delete values[depName];\n                }\n                else { // setting a value?\n\n                    // required dependency that was previously unset?\n                    if (!isOptional && values[depName] === undefined) {\n                        satisfyCnt++;\n                    }\n\n                    values[depName] = val;\n                }\n\n                queuedChangeCnt--;\n                if (!queuedChangeCnt) { // last change to cause a \"start\"?\n\n                    // now finally satisfied or satisfied all along?\n                    if (satisfyCnt === depCnt) {\n\n                        // if the stopFunc initiated another value change, ignore it.\n                        // it will be processed by another change event anyway.\n                        if (!isCallingStop) {\n                            startFunc(values);\n                        }\n                    }\n                }\n            }\n\n            // intercept for .on() that remembers handlers\n            function bind(eventName, handler) {\n                _this.on(eventName, handler);\n                bindTuples.push([ eventName, handler ]);\n            }\n\n            // listen to dependency changes\n            depList.forEach(function(depName) {\n                var isOptional = false;\n\n                if (depName.charAt(0) === '?') { // TODO: more DRY\n                    depName = depName.substring(1);\n                    isOptional = true;\n                }\n\n                bind('before:change:' + depName, function(val) {\n                    onBeforeDepChange(depName, val, isOptional);\n                });\n\n                bind('change:' + depName, function(val) {\n                    onDepChange(depName, val, isOptional);\n                });\n            });\n\n            // process current dependency values\n            depList.forEach(function(depName) {\n                var isOptional = false;\n\n                if (depName.charAt(0) === '?') { // TODO: more DRY\n                    depName = depName.substring(1);\n                    isOptional = true;\n                }\n\n                if (_this.has(depName)) {\n                    values[depName] = _this.get(depName);\n                    satisfyCnt++;\n                }\n                else if (isOptional) {\n                    satisfyCnt++;\n                }\n            });\n\n            // initially satisfied\n            if (satisfyCnt === depCnt) {\n                startFunc(values);\n            }\n\n            return {\n                teardown: function() {\n                    // remove all handlers\n                    for (var i = 0; i < bindTuples.length; i++) {\n                        _this.off(bindTuples[i][0], bindTuples[i][1]);\n                    }\n                    bindTuples = null;\n\n                    // was satisfied, so call stopFunc\n                    if (satisfyCnt === depCnt) {\n                        stopFunc();\n                    }\n                },\n                flash: function() {\n                    if (satisfyCnt === depCnt) {\n                        stopFunc();\n                        startFunc(values);\n                    }\n                }\n            };\n        },\n\n        flash: function(name) {\n            var watcher = this._watchers[name];\n\n            if (watcher) {\n                watcher.flash();\n            }\n        }\n\n    });\n\n\n    Model.watch = function(/* same arguments as this.watch() */) {\n        var proto = this.prototype;\n\n        if (!proto._globalWatchArgs) {\n            proto._globalWatchArgs = [];\n        }\n\n        proto._globalWatchArgs.push(arguments);\n    };\n\n\n    FC.Model = Model;\n\n\n    ;;\n\n    var Promise = {\n\n        construct: function(executor) {\n            var deferred = $.Deferred();\n            var promise = deferred.promise();\n\n            if (typeof executor === 'function') {\n                executor(\n                    function(val) { // resolve\n                        deferred.resolve(val);\n                        attachImmediatelyResolvingThen(promise, val);\n                    },\n                    function() { // reject\n                        deferred.reject();\n                        attachImmediatelyRejectingThen(promise);\n                    }\n                );\n            }\n\n            return promise;\n        },\n\n        resolve: function(val) {\n            var deferred = $.Deferred().resolve(val);\n            var promise = deferred.promise();\n\n            attachImmediatelyResolvingThen(promise, val);\n\n            return promise;\n        },\n\n        reject: function() {\n            var deferred = $.Deferred().reject();\n            var promise = deferred.promise();\n\n            attachImmediatelyRejectingThen(promise);\n\n            return promise;\n        }\n\n    };\n\n\n    function attachImmediatelyResolvingThen(promise, val) {\n        promise.then = function(onResolve) {\n            if (typeof onResolve === 'function') {\n                onResolve(val);\n            }\n            return promise; // for chaining\n        };\n    }\n\n\n    function attachImmediatelyRejectingThen(promise) {\n        promise.then = function(onResolve, onReject) {\n            if (typeof onReject === 'function') {\n                onReject();\n            }\n            return promise; // for chaining\n        };\n    }\n\n\n    FC.Promise = Promise;\n\n    ;;\n\n    var TaskQueue = Class.extend(EmitterMixin, {\n\n        q: null,\n        isPaused: false,\n        isRunning: false,\n\n\n        constructor: function() {\n            this.q = [];\n        },\n\n\n        queue: function(/* taskFunc, taskFunc... */) {\n            this.q.push.apply(this.q, arguments); // append\n            this.tryStart();\n        },\n\n\n        pause: function() {\n            this.isPaused = true;\n        },\n\n\n        resume: function() {\n            this.isPaused = false;\n            this.tryStart();\n        },\n\n\n        tryStart: function() {\n            if (!this.isRunning && this.canRunNext()) {\n                this.isRunning = true;\n                this.trigger('start');\n                this.runNext();\n            }\n        },\n\n\n        canRunNext: function() {\n            return !this.isPaused && this.q.length;\n        },\n\n\n        runNext: function() { // does not check canRunNext\n            this.runTask(this.q.shift());\n        },\n\n\n        runTask: function(task) {\n            this.runTaskFunc(task);\n        },\n\n\n        runTaskFunc: function(taskFunc) {\n            var _this = this;\n            var res = taskFunc();\n\n            if (res && res.then) {\n                res.then(done);\n            }\n            else {\n                done();\n            }\n\n            function done() {\n                if (_this.canRunNext()) {\n                    _this.runNext();\n                }\n                else {\n                    _this.isRunning = false;\n                    _this.trigger('stop');\n                }\n            }\n        }\n\n    });\n\n    FC.TaskQueue = TaskQueue;\n\n    ;;\n\n    var RenderQueue = TaskQueue.extend({\n\n        waitsByNamespace: null,\n        waitNamespace: null,\n        waitId: null,\n\n\n        constructor: function(waitsByNamespace) {\n            TaskQueue.call(this); // super-constructor\n\n            this.waitsByNamespace = waitsByNamespace || {};\n        },\n\n\n        queue: function(taskFunc, namespace, type) {\n            var task = {\n                func: taskFunc,\n                namespace: namespace,\n                type: type\n            };\n            var waitMs;\n\n            if (namespace) {\n                waitMs = this.waitsByNamespace[namespace];\n            }\n\n            if (this.waitNamespace) {\n                if (namespace === this.waitNamespace && waitMs != null) {\n                    this.delayWait(waitMs);\n                }\n                else {\n                    this.clearWait();\n                    this.tryStart();\n                }\n            }\n\n            if (this.compoundTask(task)) { // appended to queue?\n\n                if (!this.waitNamespace && waitMs != null) {\n                    this.startWait(namespace, waitMs);\n                }\n                else {\n                    this.tryStart();\n                }\n            }\n        },\n\n\n        startWait: function(namespace, waitMs) {\n            this.waitNamespace = namespace;\n            this.spawnWait(waitMs);\n        },\n\n\n        delayWait: function(waitMs) {\n            clearTimeout(this.waitId);\n            this.spawnWait(waitMs);\n        },\n\n\n        spawnWait: function(waitMs) {\n            var _this = this;\n\n            this.waitId = setTimeout(function() {\n                _this.waitNamespace = null;\n                _this.tryStart();\n            }, waitMs);\n        },\n\n\n        clearWait: function() {\n            if (this.waitNamespace) {\n                clearTimeout(this.waitId);\n                this.waitId = null;\n                this.waitNamespace = null;\n            }\n        },\n\n\n        canRunNext: function() {\n            if (!TaskQueue.prototype.canRunNext.apply(this, arguments)) {\n                return false;\n            }\n\n            // waiting for a certain namespace to stop receiving tasks?\n            if (this.waitNamespace) {\n\n                // if there was a different namespace task in the meantime,\n                // that forces all previously-waiting tasks to suddenly execute.\n                // TODO: find a way to do this in constant time.\n                for (var q = this.q, i = 0; i < q.length; i++) {\n                    if (q[i].namespace !== this.waitNamespace) {\n                        return true; // allow execution\n                    }\n                }\n\n                return false;\n            }\n\n            return true;\n        },\n\n\n        runTask: function(task) {\n            this.runTaskFunc(task.func);\n        },\n\n\n        compoundTask: function(newTask) {\n            var q = this.q;\n            var shouldAppend = true;\n            var i, task;\n\n            if (newTask.namespace) {\n\n                if (newTask.type === 'destroy' || newTask.type === 'init') {\n\n                    // remove all add/remove ops with same namespace, regardless of order\n                    for (i = q.length - 1; i >= 0; i--) {\n                        task = q[i];\n\n                        if (\n                            task.namespace === newTask.namespace &&\n                            (task.type === 'add' || task.type === 'remove')\n                        ) {\n                            q.splice(i, 1); // remove task\n                        }\n                    }\n\n                    if (newTask.type === 'destroy') {\n                        // eat away final init/destroy operation\n                        if (q.length) {\n                            task = q[q.length - 1]; // last task\n\n                            if (task.namespace === newTask.namespace) {\n\n                                // the init and our destroy cancel each other out\n                                if (task.type === 'init') {\n                                    shouldAppend = false;\n                                    q.pop();\n                                }\n                                // prefer to use the destroy operation that's already present\n                                else if (task.type === 'destroy') {\n                                    shouldAppend = false;\n                                }\n                            }\n                        }\n                    }\n                    else if (newTask.type === 'init') {\n                        // eat away final init operation\n                        if (q.length) {\n                            task = q[q.length - 1]; // last task\n\n                            if (\n                                task.namespace === newTask.namespace &&\n                                task.type === 'init'\n                            ) {\n                                // our init operation takes precedence\n                                q.pop();\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (shouldAppend) {\n                q.push(newTask);\n            }\n\n            return shouldAppend;\n        }\n\n    });\n\n    FC.RenderQueue = RenderQueue;\n\n    ;;\n\n    var EmitterMixin = FC.EmitterMixin = {\n\n        // jQuery-ification via $(this) allows a non-DOM object to have\n        // the same event handling capabilities (including namespaces).\n\n\n        on: function(types, handler) {\n            $(this).on(types, this._prepareIntercept(handler));\n            return this; // for chaining\n        },\n\n\n        one: function(types, handler) {\n            $(this).one(types, this._prepareIntercept(handler));\n            return this; // for chaining\n        },\n\n\n        _prepareIntercept: function(handler) {\n            // handlers are always called with an \"event\" object as their first param.\n            // sneak the `this` context and arguments into the extra parameter object\n            // and forward them on to the original handler.\n            var intercept = function(ev, extra) {\n                return handler.apply(\n                    extra.context || this,\n                    extra.args || []\n                );\n            };\n\n            // mimick jQuery's internal \"proxy\" system (risky, I know)\n            // causing all functions with the same .guid to appear to be the same.\n            // https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448\n            // this is needed for calling .off with the original non-intercept handler.\n            if (!handler.guid) {\n                handler.guid = $.guid++;\n            }\n            intercept.guid = handler.guid;\n\n            return intercept;\n        },\n\n\n        off: function(types, handler) {\n            $(this).off(types, handler);\n\n            return this; // for chaining\n        },\n\n\n        trigger: function(types) {\n            var args = Array.prototype.slice.call(arguments, 1); // arguments after the first\n\n            // pass in \"extra\" info to the intercept\n            $(this).triggerHandler(types, { args: args });\n\n            return this; // for chaining\n        },\n\n\n        triggerWith: function(types, context, args) {\n\n            // `triggerHandler` is less reliant on the DOM compared to `trigger`.\n            // pass in \"extra\" info to the intercept.\n            $(this).triggerHandler(types, { context: context, args: args });\n\n            return this; // for chaining\n        }\n\n    };\n\n    ;;\n\n    /*\n     Utility methods for easily listening to events on another object,\n     and more importantly, easily unlistening from them.\n     */\n    var ListenerMixin = FC.ListenerMixin = (function() {\n        var guid = 0;\n        var ListenerMixin = {\n\n            listenerId: null,\n\n            /*\n             Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.\n             The `callback` will be called with the `this` context of the object that .listenTo is being called on.\n             Can be called:\n             .listenTo(other, eventName, callback)\n             OR\n             .listenTo(other, {\n             eventName1: callback1,\n             eventName2: callback2\n             })\n             */\n            listenTo: function(other, arg, callback) {\n                if (typeof arg === 'object') { // given dictionary of callbacks\n                    for (var eventName in arg) {\n                        if (arg.hasOwnProperty(eventName)) {\n                            this.listenTo(other, eventName, arg[eventName]);\n                        }\n                    }\n                }\n                else if (typeof arg === 'string') {\n                    other.on(\n                        arg + '.' + this.getListenerNamespace(), // use event namespacing to identify this object\n                        $.proxy(callback, this) // always use `this` context\n                        // the usually-undesired jQuery guid behavior doesn't matter,\n                        // because we always unbind via namespace\n                    );\n                }\n            },\n\n            /*\n             Causes the current object to stop listening to events on the `other` object.\n             `eventName` is optional. If omitted, will stop listening to ALL events on `other`.\n             */\n            stopListeningTo: function(other, eventName) {\n                other.off((eventName || '') + '.' + this.getListenerNamespace());\n            },\n\n            /*\n             Returns a string, unique to this object, to be used for event namespacing\n             */\n            getListenerNamespace: function() {\n                if (this.listenerId == null) {\n                    this.listenerId = guid++;\n                }\n                return '_listener' + this.listenerId;\n            }\n\n        };\n        return ListenerMixin;\n    })();\n    ;;\n\n    /* A rectangular panel that is absolutely positioned over other content\n     ------------------------------------------------------------------------------------------------------------------------\n     Options:\n     - className (string)\n     - content (HTML string or jQuery element set)\n     - parentEl\n     - top\n     - left\n     - right (the x coord of where the right edge should be. not a \"CSS\" right)\n     - autoHide (boolean)\n     - show (callback)\n     - hide (callback)\n     */\n\n    var Popover = Class.extend(ListenerMixin, {\n\n        isHidden: true,\n        options: null,\n        el: null, // the container element for the popover. generated by this object\n        margin: 10, // the space required between the popover and the edges of the scroll container\n\n\n        constructor: function(options) {\n            this.options = options || {};\n        },\n\n\n        // Shows the popover on the specified position. Renders it if not already\n        show: function() {\n            if (this.isHidden) {\n                if (!this.el) {\n                    this.render();\n                }\n                this.el.show();\n                this.position();\n                this.isHidden = false;\n                this.trigger('show');\n            }\n        },\n\n\n        // Hides the popover, through CSS, but does not remove it from the DOM\n        hide: function() {\n            if (!this.isHidden) {\n                this.el.hide();\n                this.isHidden = true;\n                this.trigger('hide');\n            }\n        },\n\n\n        // Creates `this.el` and renders content inside of it\n        render: function() {\n            var _this = this;\n            var options = this.options;\n\n            this.el = $('<div class=\"fc-popover\"/>')\n                .addClass(options.className || '')\n                .css({\n                    // position initially to the top left to avoid creating scrollbars\n                    top: 0,\n                    left: 0\n                })\n                .append(options.content)\n                .appendTo(options.parentEl);\n\n            // when a click happens on anything inside with a 'fc-close' className, hide the popover\n            this.el.on('click', '.fc-close', function() {\n                _this.hide();\n            });\n\n            if (options.autoHide) {\n                this.listenTo($(document), 'mousedown', this.documentMousedown);\n            }\n        },\n\n\n        // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n        documentMousedown: function(ev) {\n            // only hide the popover if the click happened outside the popover\n            if (this.el && !$(ev.target).closest(this.el).length) {\n                this.hide();\n            }\n        },\n\n\n        // Hides and unregisters any handlers\n        removeElement: function() {\n            this.hide();\n\n            if (this.el) {\n                this.el.remove();\n                this.el = null;\n            }\n\n            this.stopListeningTo($(document), 'mousedown');\n        },\n\n\n        // Positions the popover optimally, using the top/left/right options\n        position: function() {\n            var options = this.options;\n            var origin = this.el.offsetParent().offset();\n            var width = this.el.outerWidth();\n            var height = this.el.outerHeight();\n            var windowEl = $(window);\n            var viewportEl = getScrollParent(this.el);\n            var viewportTop;\n            var viewportLeft;\n            var viewportOffset;\n            var top; // the \"position\" (not \"offset\") values for the popover\n            var left; //\n\n            // compute top and left\n            top = options.top || 0;\n            if (options.left !== undefined) {\n                left = options.left;\n            }\n            else if (options.right !== undefined) {\n                left = options.right - width; // derive the left value from the right value\n            }\n            else {\n                left = 0;\n            }\n\n            if (viewportEl.is(window) || viewportEl.is(document)) { // normalize getScrollParent's result\n                viewportEl = windowEl;\n                viewportTop = 0; // the window is always at the top left\n                viewportLeft = 0; // (and .offset() won't work if called here)\n            }\n            else {\n                viewportOffset = viewportEl.offset();\n                viewportTop = viewportOffset.top;\n                viewportLeft = viewportOffset.left;\n            }\n\n            // if the window is scrolled, it causes the visible area to be further down\n            viewportTop += windowEl.scrollTop();\n            viewportLeft += windowEl.scrollLeft();\n\n            // constrain to the view port. if constrained by two edges, give precedence to top/left\n            if (options.viewportConstrain !== false) {\n                top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);\n                top = Math.max(top, viewportTop + this.margin);\n                left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);\n                left = Math.max(left, viewportLeft + this.margin);\n            }\n\n            this.el.css({\n                top: top - origin.top,\n                left: left - origin.left\n            });\n        },\n\n\n        // Triggers a callback. Calls a function in the option hash of the same name.\n        // Arguments beyond the first `name` are forwarded on.\n        // TODO: better code reuse for this. Repeat code\n        trigger: function(name) {\n            if (this.options[name]) {\n                this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\n            }\n        }\n\n    });\n\n    ;;\n\n    /*\n     A cache for the left/right/top/bottom/width/height values for one or more elements.\n     Works with both offset (from topleft document) and position (from offsetParent).\n\n     options:\n     - els\n     - isHorizontal\n     - isVertical\n     */\n    var CoordCache = FC.CoordCache = Class.extend({\n\n        els: null, // jQuery set (assumed to be siblings)\n        forcedOffsetParentEl: null, // options can override the natural offsetParent\n        origin: null, // {left,top} position of offsetParent of els\n        boundingRect: null, // constrain cordinates to this rectangle. {left,right,top,bottom} or null\n        isHorizontal: false, // whether to query for left/right/width\n        isVertical: false, // whether to query for top/bottom/height\n\n        // arrays of coordinates (offsets from topleft of document)\n        lefts: null,\n        rights: null,\n        tops: null,\n        bottoms: null,\n\n\n        constructor: function(options) {\n            this.els = $(options.els);\n            this.isHorizontal = options.isHorizontal;\n            this.isVertical = options.isVertical;\n            this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;\n        },\n\n\n        // Queries the els for coordinates and stores them.\n        // Call this method before using and of the get* methods below.\n        build: function() {\n            var offsetParentEl = this.forcedOffsetParentEl;\n            if (!offsetParentEl && this.els.length > 0) {\n                offsetParentEl = this.els.eq(0).offsetParent();\n            }\n\n            this.origin = offsetParentEl ?\n                offsetParentEl.offset() :\n                null;\n\n            this.boundingRect = this.queryBoundingRect();\n\n            if (this.isHorizontal) {\n                this.buildElHorizontals();\n            }\n            if (this.isVertical) {\n                this.buildElVerticals();\n            }\n        },\n\n\n        // Destroys all internal data about coordinates, freeing memory\n        clear: function() {\n            this.origin = null;\n            this.boundingRect = null;\n            this.lefts = null;\n            this.rights = null;\n            this.tops = null;\n            this.bottoms = null;\n        },\n\n\n        // When called, if coord caches aren't built, builds them\n        ensureBuilt: function() {\n            if (!this.origin) {\n                this.build();\n            }\n        },\n\n\n        // Populates the left/right internal coordinate arrays\n        buildElHorizontals: function() {\n            var lefts = [];\n            var rights = [];\n\n            this.els.each(function(i, node) {\n                var el = $(node);\n                var left = el.offset().left;\n                var width = el.outerWidth();\n\n                lefts.push(left);\n                rights.push(left + width);\n            });\n\n            this.lefts = lefts;\n            this.rights = rights;\n        },\n\n\n        // Populates the top/bottom internal coordinate arrays\n        buildElVerticals: function() {\n            var tops = [];\n            var bottoms = [];\n\n            this.els.each(function(i, node) {\n                var el = $(node);\n                var top = el.offset().top;\n                var height = el.outerHeight();\n\n                tops.push(top);\n                bottoms.push(top + height);\n            });\n\n            this.tops = tops;\n            this.bottoms = bottoms;\n        },\n\n\n        // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n        // If no intersection is made, returns undefined.\n        getHorizontalIndex: function(leftOffset) {\n            this.ensureBuilt();\n\n            var lefts = this.lefts;\n            var rights = this.rights;\n            var len = lefts.length;\n            var i;\n\n            for (i = 0; i < len; i++) {\n                if (leftOffset >= lefts[i] && leftOffset < rights[i]) {\n                    return i;\n                }\n            }\n        },\n\n\n        // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n        // If no intersection is made, returns undefined.\n        getVerticalIndex: function(topOffset) {\n            this.ensureBuilt();\n\n            var tops = this.tops;\n            var bottoms = this.bottoms;\n            var len = tops.length;\n            var i;\n\n            for (i = 0; i < len; i++) {\n                if (topOffset >= tops[i] && topOffset < bottoms[i]) {\n                    return i;\n                }\n            }\n        },\n\n\n        // Gets the left offset (from document left) of the element at the given index\n        getLeftOffset: function(leftIndex) {\n            this.ensureBuilt();\n            return this.lefts[leftIndex];\n        },\n\n\n        // Gets the left position (from offsetParent left) of the element at the given index\n        getLeftPosition: function(leftIndex) {\n            this.ensureBuilt();\n            return this.lefts[leftIndex] - this.origin.left;\n        },\n\n\n        // Gets the right offset (from document left) of the element at the given index.\n        // This value is NOT relative to the document's right edge, like the CSS concept of \"right\" would be.\n        getRightOffset: function(leftIndex) {\n            this.ensureBuilt();\n            return this.rights[leftIndex];\n        },\n\n\n        // Gets the right position (from offsetParent left) of the element at the given index.\n        // This value is NOT relative to the offsetParent's right edge, like the CSS concept of \"right\" would be.\n        getRightPosition: function(leftIndex) {\n            this.ensureBuilt();\n            return this.rights[leftIndex] - this.origin.left;\n        },\n\n\n        // Gets the width of the element at the given index\n        getWidth: function(leftIndex) {\n            this.ensureBuilt();\n            return this.rights[leftIndex] - this.lefts[leftIndex];\n        },\n\n\n        // Gets the top offset (from document top) of the element at the given index\n        getTopOffset: function(topIndex) {\n            this.ensureBuilt();\n            return this.tops[topIndex];\n        },\n\n\n        // Gets the top position (from offsetParent top) of the element at the given position\n        getTopPosition: function(topIndex) {\n            this.ensureBuilt();\n            return this.tops[topIndex] - this.origin.top;\n        },\n\n        // Gets the bottom offset (from the document top) of the element at the given index.\n        // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \"bottom\" would be.\n        getBottomOffset: function(topIndex) {\n            this.ensureBuilt();\n            return this.bottoms[topIndex];\n        },\n\n\n        // Gets the bottom position (from the offsetParent top) of the element at the given index.\n        // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \"bottom\" would be.\n        getBottomPosition: function(topIndex) {\n            this.ensureBuilt();\n            return this.bottoms[topIndex] - this.origin.top;\n        },\n\n\n        // Gets the height of the element at the given index\n        getHeight: function(topIndex) {\n            this.ensureBuilt();\n            return this.bottoms[topIndex] - this.tops[topIndex];\n        },\n\n\n        // Bounding Rect\n        // TODO: decouple this from CoordCache\n\n        // Compute and return what the elements' bounding rectangle is, from the user's perspective.\n        // Right now, only returns a rectangle if constrained by an overflow:scroll element.\n        // Returns null if there are no elements\n        queryBoundingRect: function() {\n            var scrollParentEl;\n\n            if (this.els.length > 0) {\n                scrollParentEl = getScrollParent(this.els.eq(0));\n\n                if (!scrollParentEl.is(document)) {\n                    return getClientRect(scrollParentEl);\n                }\n            }\n\n            return null;\n        },\n\n        isPointInBounds: function(leftOffset, topOffset) {\n            return this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);\n        },\n\n        isLeftInBounds: function(leftOffset) {\n            return !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);\n        },\n\n        isTopInBounds: function(topOffset) {\n            return !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);\n        }\n\n    });\n\n    ;;\n\n    /* Tracks a drag's mouse movement, firing various handlers\n     ----------------------------------------------------------------------------------------------------------------------*/\n// TODO: use Emitter\n\n    var DragListener = FC.DragListener = Class.extend(ListenerMixin, {\n\n        options: null,\n        subjectEl: null,\n\n        // coordinates of the initial mousedown\n        originX: null,\n        originY: null,\n\n        // the wrapping element that scrolls, or MIGHT scroll if there's overflow.\n        // TODO: do this for wrappers that have overflow:hidden as well.\n        scrollEl: null,\n\n        isInteracting: false,\n        isDistanceSurpassed: false,\n        isDelayEnded: false,\n        isDragging: false,\n        isTouch: false,\n        isGeneric: false, // initiated by 'dragstart' (jqui)\n\n        delay: null,\n        delayTimeoutId: null,\n        minDistance: null,\n\n        shouldCancelTouchScroll: true,\n        scrollAlwaysKills: false,\n\n\n        constructor: function(options) {\n            this.options = options || {};\n        },\n\n\n        // Interaction (high-level)\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        startInteraction: function(ev, extraOptions) {\n\n            if (ev.type === 'mousedown') {\n                if (GlobalEmitter.get().shouldIgnoreMouse()) {\n                    return;\n                }\n                else if (!isPrimaryMouseButton(ev)) {\n                    return;\n                }\n                else {\n                    ev.preventDefault(); // prevents native selection in most browsers\n                }\n            }\n\n            if (!this.isInteracting) {\n\n                // process options\n                extraOptions = extraOptions || {};\n                this.delay = firstDefined(extraOptions.delay, this.options.delay, 0);\n                this.minDistance = firstDefined(extraOptions.distance, this.options.distance, 0);\n                this.subjectEl = this.options.subjectEl;\n\n                preventSelection($('body'));\n\n                this.isInteracting = true;\n                this.isTouch = getEvIsTouch(ev);\n                this.isGeneric = ev.type === 'dragstart';\n                this.isDelayEnded = false;\n                this.isDistanceSurpassed = false;\n\n                this.originX = getEvX(ev);\n                this.originY = getEvY(ev);\n                this.scrollEl = getScrollParent($(ev.target));\n\n                this.bindHandlers();\n                this.initAutoScroll();\n                this.handleInteractionStart(ev);\n                this.startDelay(ev);\n\n                if (!this.minDistance) {\n                    this.handleDistanceSurpassed(ev);\n                }\n            }\n        },\n\n\n        handleInteractionStart: function(ev) {\n            this.trigger('interactionStart', ev);\n        },\n\n\n        endInteraction: function(ev, isCancelled) {\n            if (this.isInteracting) {\n                this.endDrag(ev);\n\n                if (this.delayTimeoutId) {\n                    clearTimeout(this.delayTimeoutId);\n                    this.delayTimeoutId = null;\n                }\n\n                this.destroyAutoScroll();\n                this.unbindHandlers();\n\n                this.isInteracting = false;\n                this.handleInteractionEnd(ev, isCancelled);\n\n                allowSelection($('body'));\n            }\n        },\n\n\n        handleInteractionEnd: function(ev, isCancelled) {\n            this.trigger('interactionEnd', ev, isCancelled || false);\n        },\n\n\n        // Binding To DOM\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        bindHandlers: function() {\n            // some browsers (Safari in iOS 10) don't allow preventDefault on touch events that are bound after touchstart,\n            // so listen to the GlobalEmitter singleton, which is always bound, instead of the document directly.\n            var globalEmitter = GlobalEmitter.get();\n\n            if (this.isGeneric) {\n                this.listenTo($(document), { // might only work on iOS because of GlobalEmitter's bind :(\n                    drag: this.handleMove,\n                    dragstop: this.endInteraction\n                });\n            }\n            else if (this.isTouch) {\n                this.listenTo(globalEmitter, {\n                    touchmove: this.handleTouchMove,\n                    touchend: this.endInteraction,\n                    scroll: this.handleTouchScroll\n                });\n            }\n            else {\n                this.listenTo(globalEmitter, {\n                    mousemove: this.handleMouseMove,\n                    mouseup: this.endInteraction\n                });\n            }\n\n            this.listenTo(globalEmitter, {\n                selectstart: preventDefault, // don't allow selection while dragging\n                contextmenu: preventDefault // long taps would open menu on Chrome dev tools\n            });\n        },\n\n\n        unbindHandlers: function() {\n            this.stopListeningTo(GlobalEmitter.get());\n            this.stopListeningTo($(document)); // for isGeneric\n        },\n\n\n        // Drag (high-level)\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        // extraOptions ignored if drag already started\n        startDrag: function(ev, extraOptions) {\n            this.startInteraction(ev, extraOptions); // ensure interaction began\n\n            if (!this.isDragging) {\n                this.isDragging = true;\n                this.handleDragStart(ev);\n            }\n        },\n\n\n        handleDragStart: function(ev) {\n            this.trigger('dragStart', ev);\n        },\n\n\n        handleMove: function(ev) {\n            var dx = getEvX(ev) - this.originX;\n            var dy = getEvY(ev) - this.originY;\n            var minDistance = this.minDistance;\n            var distanceSq; // current distance from the origin, squared\n\n            if (!this.isDistanceSurpassed) {\n                distanceSq = dx * dx + dy * dy;\n                if (distanceSq >= minDistance * minDistance) { // use pythagorean theorem\n                    this.handleDistanceSurpassed(ev);\n                }\n            }\n\n            if (this.isDragging) {\n                this.handleDrag(dx, dy, ev);\n            }\n        },\n\n\n        // Called while the mouse is being moved and when we know a legitimate drag is taking place\n        handleDrag: function(dx, dy, ev) {\n            this.trigger('drag', dx, dy, ev);\n            this.updateAutoScroll(ev); // will possibly cause scrolling\n        },\n\n\n        endDrag: function(ev) {\n            if (this.isDragging) {\n                this.isDragging = false;\n                this.handleDragEnd(ev);\n            }\n        },\n\n\n        handleDragEnd: function(ev) {\n            this.trigger('dragEnd', ev);\n        },\n\n\n        // Delay\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        startDelay: function(initialEv) {\n            var _this = this;\n\n            if (this.delay) {\n                this.delayTimeoutId = setTimeout(function() {\n                    _this.handleDelayEnd(initialEv);\n                }, this.delay);\n            }\n            else {\n                this.handleDelayEnd(initialEv);\n            }\n        },\n\n\n        handleDelayEnd: function(initialEv) {\n            this.isDelayEnded = true;\n\n            if (this.isDistanceSurpassed) {\n                this.startDrag(initialEv);\n            }\n        },\n\n\n        // Distance\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        handleDistanceSurpassed: function(ev) {\n            this.isDistanceSurpassed = true;\n\n            if (this.isDelayEnded) {\n                this.startDrag(ev);\n            }\n        },\n\n\n        // Mouse / Touch\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        handleTouchMove: function(ev) {\n\n            // prevent inertia and touchmove-scrolling while dragging\n            if (this.isDragging && this.shouldCancelTouchScroll) {\n                ev.preventDefault();\n            }\n\n            this.handleMove(ev);\n        },\n\n\n        handleMouseMove: function(ev) {\n            this.handleMove(ev);\n        },\n\n\n        // Scrolling (unrelated to auto-scroll)\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        handleTouchScroll: function(ev) {\n            // if the drag is being initiated by touch, but a scroll happens before\n            // the drag-initiating delay is over, cancel the drag\n            if (!this.isDragging || this.scrollAlwaysKills) {\n                this.endInteraction(ev, true); // isCancelled=true\n            }\n        },\n\n\n        // Utils\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        // Triggers a callback. Calls a function in the option hash of the same name.\n        // Arguments beyond the first `name` are forwarded on.\n        trigger: function(name) {\n            if (this.options[name]) {\n                this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\n            }\n            // makes _methods callable by event name. TODO: kill this\n            if (this['_' + name]) {\n                this['_' + name].apply(this, Array.prototype.slice.call(arguments, 1));\n            }\n        }\n\n\n    });\n\n    ;;\n    /*\n     this.scrollEl is set in DragListener\n     */\n    DragListener.mixin({\n\n        isAutoScroll: false,\n\n        scrollBounds: null, // { top, bottom, left, right }\n        scrollTopVel: null, // pixels per second\n        scrollLeftVel: null, // pixels per second\n        scrollIntervalId: null, // ID of setTimeout for scrolling animation loop\n\n        // defaults\n        scrollSensitivity: 30, // pixels from edge for scrolling to start\n        scrollSpeed: 200, // pixels per second, at maximum speed\n        scrollIntervalMs: 50, // millisecond wait between scroll increment\n\n\n        initAutoScroll: function() {\n            var scrollEl = this.scrollEl;\n\n            this.isAutoScroll =\n                this.options.scroll &&\n                scrollEl &&\n                !scrollEl.is(window) &&\n                !scrollEl.is(document);\n\n            if (this.isAutoScroll) {\n                // debounce makes sure rapid calls don't happen\n                this.listenTo(scrollEl, 'scroll', debounce(this.handleDebouncedScroll, 100));\n            }\n        },\n\n\n        destroyAutoScroll: function() {\n            this.endAutoScroll(); // kill any animation loop\n\n            // remove the scroll handler if there is a scrollEl\n            if (this.isAutoScroll) {\n                this.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(\n            }\n        },\n\n\n        // Computes and stores the bounding rectangle of scrollEl\n        computeScrollBounds: function() {\n            if (this.isAutoScroll) {\n                this.scrollBounds = getOuterRect(this.scrollEl);\n                // TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars\n            }\n        },\n\n\n        // Called when the dragging is in progress and scrolling should be updated\n        updateAutoScroll: function(ev) {\n            var sensitivity = this.scrollSensitivity;\n            var bounds = this.scrollBounds;\n            var topCloseness, bottomCloseness;\n            var leftCloseness, rightCloseness;\n            var topVel = 0;\n            var leftVel = 0;\n\n            if (bounds) { // only scroll if scrollEl exists\n\n                // compute closeness to edges. valid range is from 0.0 - 1.0\n                topCloseness = (sensitivity - (getEvY(ev) - bounds.top)) / sensitivity;\n                bottomCloseness = (sensitivity - (bounds.bottom - getEvY(ev))) / sensitivity;\n                leftCloseness = (sensitivity - (getEvX(ev) - bounds.left)) / sensitivity;\n                rightCloseness = (sensitivity - (bounds.right - getEvX(ev))) / sensitivity;\n\n                // translate vertical closeness into velocity.\n                // mouse must be completely in bounds for velocity to happen.\n                if (topCloseness >= 0 && topCloseness <= 1) {\n                    topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up\n                }\n                else if (bottomCloseness >= 0 && bottomCloseness <= 1) {\n                    topVel = bottomCloseness * this.scrollSpeed;\n                }\n\n                // translate horizontal closeness into velocity\n                if (leftCloseness >= 0 && leftCloseness <= 1) {\n                    leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left\n                }\n                else if (rightCloseness >= 0 && rightCloseness <= 1) {\n                    leftVel = rightCloseness * this.scrollSpeed;\n                }\n            }\n\n            this.setScrollVel(topVel, leftVel);\n        },\n\n\n        // Sets the speed-of-scrolling for the scrollEl\n        setScrollVel: function(topVel, leftVel) {\n\n            this.scrollTopVel = topVel;\n            this.scrollLeftVel = leftVel;\n\n            this.constrainScrollVel(); // massages into realistic values\n\n            // if there is non-zero velocity, and an animation loop hasn't already started, then START\n            if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {\n                this.scrollIntervalId = setInterval(\n                    proxy(this, 'scrollIntervalFunc'), // scope to `this`\n                    this.scrollIntervalMs\n                );\n            }\n        },\n\n\n        // Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way\n        constrainScrollVel: function() {\n            var el = this.scrollEl;\n\n            if (this.scrollTopVel < 0) { // scrolling up?\n                if (el.scrollTop() <= 0) { // already scrolled all the way up?\n                    this.scrollTopVel = 0;\n                }\n            }\n            else if (this.scrollTopVel > 0) { // scrolling down?\n                if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) { // already scrolled all the way down?\n                    this.scrollTopVel = 0;\n                }\n            }\n\n            if (this.scrollLeftVel < 0) { // scrolling left?\n                if (el.scrollLeft() <= 0) { // already scrolled all the left?\n                    this.scrollLeftVel = 0;\n                }\n            }\n            else if (this.scrollLeftVel > 0) { // scrolling right?\n                if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) { // already scrolled all the way right?\n                    this.scrollLeftVel = 0;\n                }\n            }\n        },\n\n\n        // This function gets called during every iteration of the scrolling animation loop\n        scrollIntervalFunc: function() {\n            var el = this.scrollEl;\n            var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by\n\n            // change the value of scrollEl's scroll\n            if (this.scrollTopVel) {\n                el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);\n            }\n            if (this.scrollLeftVel) {\n                el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);\n            }\n\n            this.constrainScrollVel(); // since the scroll values changed, recompute the velocities\n\n            // if scrolled all the way, which causes the vels to be zero, stop the animation loop\n            if (!this.scrollTopVel && !this.scrollLeftVel) {\n                this.endAutoScroll();\n            }\n        },\n\n\n        // Kills any existing scrolling animation loop\n        endAutoScroll: function() {\n            if (this.scrollIntervalId) {\n                clearInterval(this.scrollIntervalId);\n                this.scrollIntervalId = null;\n\n                this.handleScrollEnd();\n            }\n        },\n\n\n        // Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)\n        handleDebouncedScroll: function() {\n            // recompute all coordinates, but *only* if this is *not* part of our scrolling animation\n            if (!this.scrollIntervalId) {\n                this.handleScrollEnd();\n            }\n        },\n\n\n        // Called when scrolling has stopped, whether through auto scroll, or the user scrolling\n        handleScrollEnd: function() {\n        }\n\n    });\n    ;;\n\n    /* Tracks mouse movements over a component and raises events about which hit the mouse is over.\n     ------------------------------------------------------------------------------------------------------------------------\n     options:\n     - subjectEl\n     - subjectCenter\n     */\n\n    var HitDragListener = DragListener.extend({\n\n        component: null, // converts coordinates to hits\n        // methods: hitsNeeded, hitsNotNeeded, queryHit\n\n        origHit: null, // the hit the mouse was over when listening started\n        hit: null, // the hit the mouse is over\n        coordAdjust: null, // delta that will be added to the mouse coordinates when computing collisions\n\n\n        constructor: function(component, options) {\n            DragListener.call(this, options); // call the super-constructor\n\n            this.component = component;\n        },\n\n\n        // Called when drag listening starts (but a real drag has not necessarily began).\n        // ev might be undefined if dragging was started manually.\n        handleInteractionStart: function(ev) {\n            var subjectEl = this.subjectEl;\n            var subjectRect;\n            var origPoint;\n            var point;\n\n            this.component.hitsNeeded();\n            this.computeScrollBounds(); // for autoscroll\n\n            if (ev) {\n                origPoint = { left: getEvX(ev), top: getEvY(ev) };\n                point = origPoint;\n\n                // constrain the point to bounds of the element being dragged\n                if (subjectEl) {\n                    subjectRect = getOuterRect(subjectEl); // used for centering as well\n                    point = constrainPoint(point, subjectRect);\n                }\n\n                this.origHit = this.queryHit(point.left, point.top);\n\n                // treat the center of the subject as the collision point?\n                if (subjectEl && this.options.subjectCenter) {\n\n                    // only consider the area the subject overlaps the hit. best for large subjects.\n                    // TODO: skip this if hit didn't supply left/right/top/bottom\n                    if (this.origHit) {\n                        subjectRect = intersectRects(this.origHit, subjectRect) ||\n                            subjectRect; // in case there is no intersection\n                    }\n\n                    point = getRectCenter(subjectRect);\n                }\n\n                this.coordAdjust = diffPoints(point, origPoint); // point - origPoint\n            }\n            else {\n                this.origHit = null;\n                this.coordAdjust = null;\n            }\n\n            // call the super-method. do it after origHit has been computed\n            DragListener.prototype.handleInteractionStart.apply(this, arguments);\n        },\n\n\n        // Called when the actual drag has started\n        handleDragStart: function(ev) {\n            var hit;\n\n            DragListener.prototype.handleDragStart.apply(this, arguments); // call the super-method\n\n            // might be different from this.origHit if the min-distance is large\n            hit = this.queryHit(getEvX(ev), getEvY(ev));\n\n            // report the initial hit the mouse is over\n            // especially important if no min-distance and drag starts immediately\n            if (hit) {\n                this.handleHitOver(hit);\n            }\n        },\n\n\n        // Called when the drag moves\n        handleDrag: function(dx, dy, ev) {\n            var hit;\n\n            DragListener.prototype.handleDrag.apply(this, arguments); // call the super-method\n\n            hit = this.queryHit(getEvX(ev), getEvY(ev));\n\n            if (!isHitsEqual(hit, this.hit)) { // a different hit than before?\n                if (this.hit) {\n                    this.handleHitOut();\n                }\n                if (hit) {\n                    this.handleHitOver(hit);\n                }\n            }\n        },\n\n\n        // Called when dragging has been stopped\n        handleDragEnd: function() {\n            this.handleHitDone();\n            DragListener.prototype.handleDragEnd.apply(this, arguments); // call the super-method\n        },\n\n\n        // Called when a the mouse has just moved over a new hit\n        handleHitOver: function(hit) {\n            var isOrig = isHitsEqual(hit, this.origHit);\n\n            this.hit = hit;\n\n            this.trigger('hitOver', this.hit, isOrig, this.origHit);\n        },\n\n\n        // Called when the mouse has just moved out of a hit\n        handleHitOut: function() {\n            if (this.hit) {\n                this.trigger('hitOut', this.hit);\n                this.handleHitDone();\n                this.hit = null;\n            }\n        },\n\n\n        // Called after a hitOut. Also called before a dragStop\n        handleHitDone: function() {\n            if (this.hit) {\n                this.trigger('hitDone', this.hit);\n            }\n        },\n\n\n        // Called when the interaction ends, whether there was a real drag or not\n        handleInteractionEnd: function() {\n            DragListener.prototype.handleInteractionEnd.apply(this, arguments); // call the super-method\n\n            this.origHit = null;\n            this.hit = null;\n\n            this.component.hitsNotNeeded();\n        },\n\n\n        // Called when scrolling has stopped, whether through auto scroll, or the user scrolling\n        handleScrollEnd: function() {\n            DragListener.prototype.handleScrollEnd.apply(this, arguments); // call the super-method\n\n            // hits' absolute positions will be in new places after a user's scroll.\n            // HACK for recomputing.\n            if (this.isDragging) {\n                this.component.releaseHits();\n                this.component.prepareHits();\n            }\n        },\n\n\n        // Gets the hit underneath the coordinates for the given mouse event\n        queryHit: function(left, top) {\n\n            if (this.coordAdjust) {\n                left += this.coordAdjust.left;\n                top += this.coordAdjust.top;\n            }\n\n            return this.component.queryHit(left, top);\n        }\n\n    });\n\n\n// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.\n// Two null values will be considered equal, as two \"out of the component\" states are the same.\n    function isHitsEqual(hit0, hit1) {\n\n        if (!hit0 && !hit1) {\n            return true;\n        }\n\n        if (hit0 && hit1) {\n            return hit0.component === hit1.component &&\n                isHitPropsWithin(hit0, hit1) &&\n                isHitPropsWithin(hit1, hit0); // ensures all props are identical\n        }\n\n        return false;\n    }\n\n\n// Returns true if all of subHit's non-standard properties are within superHit\n    function isHitPropsWithin(subHit, superHit) {\n        for (var propName in subHit) {\n            if (!/^(component|left|right|top|bottom)$/.test(propName)) {\n                if (subHit[propName] !== superHit[propName]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    ;;\n\n    /*\n     Listens to document and window-level user-interaction events, like touch events and mouse events,\n     and fires these events as-is to whoever is observing a GlobalEmitter.\n     Best when used as a singleton via GlobalEmitter.get()\n\n     Normalizes mouse/touch events. For examples:\n     - ignores the the simulated mouse events that happen after a quick tap: mousemove+mousedown+mouseup+click\n     - compensates for various buggy scenarios where a touchend does not fire\n     */\n\n    FC.touchMouseIgnoreWait = 500;\n\n    var GlobalEmitter = Class.extend(ListenerMixin, EmitterMixin, {\n\n        isTouching: false,\n        mouseIgnoreDepth: 0,\n        handleScrollProxy: null,\n\n\n        bind: function() {\n            var _this = this;\n\n            this.listenTo($(document), {\n                touchstart: this.handleTouchStart,\n                touchcancel: this.handleTouchCancel,\n                touchend: this.handleTouchEnd,\n                mousedown: this.handleMouseDown,\n                mousemove: this.handleMouseMove,\n                mouseup: this.handleMouseUp,\n                click: this.handleClick,\n                selectstart: this.handleSelectStart,\n                contextmenu: this.handleContextMenu\n            });\n\n            // because we need to call preventDefault\n            // because https://www.chromestatus.com/features/5093566007214080\n            // TODO: investigate performance because this is a global handler\n            window.addEventListener(\n                'touchmove',\n                this.handleTouchMoveProxy = function(ev) {\n                    _this.handleTouchMove($.Event(ev));\n                },\n                { passive: false } // allows preventDefault()\n            );\n\n            // attach a handler to get called when ANY scroll action happens on the page.\n            // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\n            // http://stackoverflow.com/a/32954565/96342\n            window.addEventListener(\n                'scroll',\n                this.handleScrollProxy = function(ev) {\n                    _this.handleScroll($.Event(ev));\n                },\n                true // useCapture\n            );\n        },\n\n        unbind: function() {\n            this.stopListeningTo($(document));\n\n            window.removeEventListener(\n                'touchmove',\n                this.handleTouchMoveProxy\n            );\n\n            window.removeEventListener(\n                'scroll',\n                this.handleScrollProxy,\n                true // useCapture\n            );\n        },\n\n\n        // Touch Handlers\n        // -----------------------------------------------------------------------------------------------------------------\n\n        handleTouchStart: function(ev) {\n\n            // if a previous touch interaction never ended with a touchend, then implicitly end it,\n            // but since a new touch interaction is about to begin, don't start the mouse ignore period.\n            this.stopTouch(ev, true); // skipMouseIgnore=true\n\n            this.isTouching = true;\n            this.trigger('touchstart', ev);\n        },\n\n        handleTouchMove: function(ev) {\n            if (this.isTouching) {\n                this.trigger('touchmove', ev);\n            }\n        },\n\n        handleTouchCancel: function(ev) {\n            if (this.isTouching) {\n                this.trigger('touchcancel', ev);\n\n                // Have touchcancel fire an artificial touchend. That way, handlers won't need to listen to both.\n                // If touchend fires later, it won't have any effect b/c isTouching will be false.\n                this.stopTouch(ev);\n            }\n        },\n\n        handleTouchEnd: function(ev) {\n            this.stopTouch(ev);\n        },\n\n\n        // Mouse Handlers\n        // -----------------------------------------------------------------------------------------------------------------\n\n        handleMouseDown: function(ev) {\n            if (!this.shouldIgnoreMouse()) {\n                this.trigger('mousedown', ev);\n            }\n        },\n\n        handleMouseMove: function(ev) {\n            if (!this.shouldIgnoreMouse()) {\n                this.trigger('mousemove', ev);\n            }\n        },\n\n        handleMouseUp: function(ev) {\n            if (!this.shouldIgnoreMouse()) {\n                this.trigger('mouseup', ev);\n            }\n        },\n\n        handleClick: function(ev) {\n            if (!this.shouldIgnoreMouse()) {\n                this.trigger('click', ev);\n            }\n        },\n\n\n        // Misc Handlers\n        // -----------------------------------------------------------------------------------------------------------------\n\n        handleSelectStart: function(ev) {\n            this.trigger('selectstart', ev);\n        },\n\n        handleContextMenu: function(ev) {\n            this.trigger('contextmenu', ev);\n        },\n\n        handleScroll: function(ev) {\n            this.trigger('scroll', ev);\n        },\n\n\n        // Utils\n        // -----------------------------------------------------------------------------------------------------------------\n\n        stopTouch: function(ev, skipMouseIgnore) {\n            if (this.isTouching) {\n                this.isTouching = false;\n                this.trigger('touchend', ev);\n\n                if (!skipMouseIgnore) {\n                    this.startTouchMouseIgnore();\n                }\n            }\n        },\n\n        startTouchMouseIgnore: function() {\n            var _this = this;\n            var wait = FC.touchMouseIgnoreWait;\n\n            if (wait) {\n                this.mouseIgnoreDepth++;\n                setTimeout(function() {\n                    _this.mouseIgnoreDepth--;\n                }, wait);\n            }\n        },\n\n        shouldIgnoreMouse: function() {\n            return this.isTouching || Boolean(this.mouseIgnoreDepth);\n        }\n\n    });\n\n\n// Singleton\n// ---------------------------------------------------------------------------------------------------------------------\n\n    (function() {\n        var globalEmitter = null;\n        var neededCount = 0;\n\n\n        // gets the singleton\n        GlobalEmitter.get = function() {\n\n            if (!globalEmitter) {\n                globalEmitter = new GlobalEmitter();\n                globalEmitter.bind();\n            }\n\n            return globalEmitter;\n        };\n\n\n        // called when an object knows it will need a GlobalEmitter in the near future.\n        GlobalEmitter.needed = function() {\n            GlobalEmitter.get(); // ensures globalEmitter\n            neededCount++;\n        };\n\n\n        // called when the object that originally called needed() doesn't need a GlobalEmitter anymore.\n        GlobalEmitter.unneeded = function() {\n            neededCount--;\n\n            if (!neededCount) { // nobody else needs it\n                globalEmitter.unbind();\n                globalEmitter = null;\n            }\n        };\n\n    })();\n\n    ;;\n\n    /* Creates a clone of an element and lets it track the mouse as it moves\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n    var MouseFollower = Class.extend(ListenerMixin, {\n\n        options: null,\n\n        sourceEl: null, // the element that will be cloned and made to look like it is dragging\n        el: null, // the clone of `sourceEl` that will track the mouse\n        parentEl: null, // the element that `el` (the clone) will be attached to\n\n        // the initial position of el, relative to the offset parent. made to match the initial offset of sourceEl\n        top0: null,\n        left0: null,\n\n        // the absolute coordinates of the initiating touch/mouse action\n        y0: null,\n        x0: null,\n\n        // the number of pixels the mouse has moved from its initial position\n        topDelta: null,\n        leftDelta: null,\n\n        isFollowing: false,\n        isHidden: false,\n        isAnimating: false, // doing the revert animation?\n\n        constructor: function(sourceEl, options) {\n            this.options = options = options || {};\n            this.sourceEl = sourceEl;\n            this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent\n        },\n\n\n        // Causes the element to start following the mouse\n        start: function(ev) {\n            if (!this.isFollowing) {\n                this.isFollowing = true;\n\n                this.y0 = getEvY(ev);\n                this.x0 = getEvX(ev);\n                this.topDelta = 0;\n                this.leftDelta = 0;\n\n                if (!this.isHidden) {\n                    this.updatePosition();\n                }\n\n                if (getEvIsTouch(ev)) {\n                    this.listenTo($(document), 'touchmove', this.handleMove);\n                }\n                else {\n                    this.listenTo($(document), 'mousemove', this.handleMove);\n                }\n            }\n        },\n\n\n        // Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.\n        // `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.\n        stop: function(shouldRevert, callback) {\n            var _this = this;\n            var revertDuration = this.options.revertDuration;\n\n            function complete() { // might be called by .animate(), which might change `this` context\n                _this.isAnimating = false;\n                _this.removeElement();\n\n                _this.top0 = _this.left0 = null; // reset state for future updatePosition calls\n\n                if (callback) {\n                    callback();\n                }\n            }\n\n            if (this.isFollowing && !this.isAnimating) { // disallow more than one stop animation at a time\n                this.isFollowing = false;\n\n                this.stopListeningTo($(document));\n\n                if (shouldRevert && revertDuration && !this.isHidden) { // do a revert animation?\n                    this.isAnimating = true;\n                    this.el.animate({\n                        top: this.top0,\n                        left: this.left0\n                    }, {\n                        duration: revertDuration,\n                        complete: complete\n                    });\n                }\n                else {\n                    complete();\n                }\n            }\n        },\n\n\n        // Gets the tracking element. Create it if necessary\n        getEl: function() {\n            var el = this.el;\n\n            if (!el) {\n                el = this.el = this.sourceEl.clone()\n                    .addClass(this.options.additionalClass || '')\n                    .css({\n                        position: 'absolute',\n                        visibility: '', // in case original element was hidden (commonly through hideEvents())\n                        display: this.isHidden ? 'none' : '', // for when initially hidden\n                        margin: 0,\n                        right: 'auto', // erase and set width instead\n                        bottom: 'auto', // erase and set height instead\n                        width: this.sourceEl.width(), // explicit height in case there was a 'right' value\n                        height: this.sourceEl.height(), // explicit width in case there was a 'bottom' value\n                        opacity: this.options.opacity || '',\n                        zIndex: this.options.zIndex\n                    });\n\n                // we don't want long taps or any mouse interaction causing selection/menus.\n                // would use preventSelection(), but that prevents selectstart, causing problems.\n                el.addClass('fc-unselectable');\n\n                el.appendTo(this.parentEl);\n            }\n\n            return el;\n        },\n\n\n        // Removes the tracking element if it has already been created\n        removeElement: function() {\n            if (this.el) {\n                this.el.remove();\n                this.el = null;\n            }\n        },\n\n\n        // Update the CSS position of the tracking element\n        updatePosition: function() {\n            var sourceOffset;\n            var origin;\n\n            this.getEl(); // ensure this.el\n\n            // make sure origin info was computed\n            if (this.top0 === null) {\n                sourceOffset = this.sourceEl.offset();\n                origin = this.el.offsetParent().offset();\n                this.top0 = sourceOffset.top - origin.top;\n                this.left0 = sourceOffset.left - origin.left;\n            }\n\n            this.el.css({\n                top: this.top0 + this.topDelta,\n                left: this.left0 + this.leftDelta\n            });\n        },\n\n\n        // Gets called when the user moves the mouse\n        handleMove: function(ev) {\n            this.topDelta = getEvY(ev) - this.y0;\n            this.leftDelta = getEvX(ev) - this.x0;\n\n            if (!this.isHidden) {\n                this.updatePosition();\n            }\n        },\n\n\n        // Temporarily makes the tracking element invisible. Can be called before following starts\n        hide: function() {\n            if (!this.isHidden) {\n                this.isHidden = true;\n                if (this.el) {\n                    this.el.hide();\n                }\n            }\n        },\n\n\n        // Show the tracking element after it has been temporarily hidden\n        show: function() {\n            if (this.isHidden) {\n                this.isHidden = false;\n                this.updatePosition();\n                this.getEl().show();\n            }\n        }\n\n    });\n\n    ;;\n\n    /* An abstract class comprised of a \"grid\" of areas that each represent a specific datetime\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n    var Grid = FC.Grid = Class.extend(ListenerMixin, {\n\n        // self-config, overridable by subclasses\n        hasDayInteractions: true, // can user click/select ranges of time?\n\n        view: null, // a View object\n        isRTL: null, // shortcut to the view's isRTL option\n\n        start: null,\n        end: null,\n\n        el: null, // the containing element\n        elsByFill: null, // a hash of jQuery element sets used for rendering each fill. Keyed by fill name.\n\n        // derived from options\n        eventTimeFormat: null,\n        displayEventTime: null,\n        displayEventEnd: null,\n\n        minResizeDuration: null, // TODO: hack. set by subclasses. minumum event resize duration\n\n        // if defined, holds the unit identified (ex: \"year\" or \"month\") that determines the level of granularity\n        // of the date areas. if not defined, assumes to be day and time granularity.\n        // TODO: port isTimeScale into same system?\n        largeUnit: null,\n\n        dayClickListener: null,\n        daySelectListener: null,\n        segDragListener: null,\n        segResizeListener: null,\n        externalDragListener: null,\n\n\n        constructor: function(view) {\n            this.view = view;\n            this.isRTL = view.opt('isRTL');\n            this.elsByFill = {};\n\n            this.dayClickListener = this.buildDayClickListener();\n            this.daySelectListener = this.buildDaySelectListener();\n        },\n\n\n        /* Options\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Generates the format string used for event time text, if not explicitly defined by 'timeFormat'\n        computeEventTimeFormat: function() {\n            return this.view.opt('smallTimeFormat');\n        },\n\n\n        // Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventTime'.\n        // Only applies to non-all-day events.\n        computeDisplayEventTime: function() {\n            return true;\n        },\n\n\n        // Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventEnd'\n        computeDisplayEventEnd: function() {\n            return true;\n        },\n\n\n        /* Dates\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Tells the grid about what period of time to display.\n        // Any date-related internal data should be generated.\n        setRange: function(range) {\n            this.start = range.start.clone();\n            this.end = range.end.clone();\n\n            this.rangeUpdated();\n            this.processRangeOptions();\n        },\n\n\n        // Called when internal variables that rely on the range should be updated\n        rangeUpdated: function() {\n        },\n\n\n        // Updates values that rely on options and also relate to range\n        processRangeOptions: function() {\n            var view = this.view;\n            var displayEventTime;\n            var displayEventEnd;\n\n            this.eventTimeFormat =\n                view.opt('eventTimeFormat') ||\n                view.opt('timeFormat') || // deprecated\n                this.computeEventTimeFormat();\n\n            displayEventTime = view.opt('displayEventTime');\n            if (displayEventTime == null) {\n                displayEventTime = this.computeDisplayEventTime(); // might be based off of range\n            }\n\n            displayEventEnd = view.opt('displayEventEnd');\n            if (displayEventEnd == null) {\n                displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range\n            }\n\n            this.displayEventTime = displayEventTime;\n            this.displayEventEnd = displayEventEnd;\n        },\n\n\n        // Converts a span (has unzoned start/end and any other grid-specific location information)\n        // into an array of segments (pieces of events whose format is decided by the grid).\n        spanToSegs: function(span) {\n            // subclasses must implement\n        },\n\n\n        // Diffs the two dates, returning a duration, based on granularity of the grid\n        // TODO: port isTimeScale into this system?\n        diffDates: function(a, b) {\n            if (this.largeUnit) {\n                return diffByUnit(a, b, this.largeUnit);\n            }\n            else {\n                return diffDayTime(a, b);\n            }\n        },\n\n\n        /* Hit Area\n         ------------------------------------------------------------------------------------------------------------------*/\n\n        hitsNeededDepth: 0, // necessary because multiple callers might need the same hits\n\n        hitsNeeded: function() {\n            if (!(this.hitsNeededDepth++)) {\n                this.prepareHits();\n            }\n        },\n\n        hitsNotNeeded: function() {\n            if (this.hitsNeededDepth && !(--this.hitsNeededDepth)) {\n                this.releaseHits();\n            }\n        },\n\n\n        // Called before one or more queryHit calls might happen. Should prepare any cached coordinates for queryHit\n        prepareHits: function() {\n        },\n\n\n        // Called when queryHit calls have subsided. Good place to clear any coordinate caches.\n        releaseHits: function() {\n        },\n\n\n        // Given coordinates from the topleft of the document, return data about the date-related area underneath.\n        // Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).\n        // Must have a `grid` property, a reference to this current grid. TODO: avoid this\n        // The returned object will be processed by getHitSpan and getHitEl.\n        queryHit: function(leftOffset, topOffset) {\n        },\n\n\n        // like getHitSpan, but returns null if the resulting span's range is invalid\n        getSafeHitSpan: function(hit) {\n            var hitSpan = this.getHitSpan(hit);\n\n            if (!isRangeWithinRange(hitSpan, this.view.activeRange)) {\n                return null;\n            }\n\n            return hitSpan;\n        },\n\n\n        // Given position-level information about a date-related area within the grid,\n        // should return an object with at least a start/end date. Can provide other information as well.\n        getHitSpan: function(hit) {\n        },\n\n\n        // Given position-level information about a date-related area within the grid,\n        // should return a jQuery element that best represents it. passed to dayClick callback.\n        getHitEl: function(hit) {\n        },\n\n\n        /* Rendering\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Sets the container element that the grid should render inside of.\n        // Does other DOM-related initializations.\n        setElement: function(el) {\n            this.el = el;\n\n            if (this.hasDayInteractions) {\n                preventSelection(el);\n\n                this.bindDayHandler('touchstart', this.dayTouchStart);\n                this.bindDayHandler('mousedown', this.dayMousedown);\n            }\n\n            // attach event-element-related handlers. in Grid.events\n            // same garbage collection note as above.\n            this.bindSegHandlers();\n\n            this.bindGlobalHandlers();\n        },\n\n\n        bindDayHandler: function(name, handler) {\n            var _this = this;\n\n            // attach a handler to the grid's root element.\n            // jQuery will take care of unregistering them when removeElement gets called.\n            this.el.on(name, function(ev) {\n                if (\n                    !$(ev.target).is(\n                        _this.segSelector + ',' + // directly on an event element\n                        _this.segSelector + ' *,' + // within an event element\n                        '.fc-more,' + // a \"more..\" link\n                        'a[data-goto]' // a clickable nav link\n                    )\n                ) {\n                    return handler.call(_this, ev);\n                }\n            });\n        },\n\n\n        // Removes the grid's container element from the DOM. Undoes any other DOM-related attachments.\n        // DOES NOT remove any content beforehand (doesn't clear events or call unrenderDates), unlike View\n        removeElement: function() {\n            this.unbindGlobalHandlers();\n            this.clearDragListeners();\n\n            this.el.remove();\n\n            // NOTE: we don't null-out this.el for the same reasons we don't do it within View::removeElement\n        },\n\n\n        // Renders the basic structure of grid view before any content is rendered\n        renderSkeleton: function() {\n            // subclasses should implement\n        },\n\n\n        // Renders the grid's date-related content (like areas that represent days/times).\n        // Assumes setRange has already been called and the skeleton has already been rendered.\n        renderDates: function() {\n            // subclasses should implement\n        },\n\n\n        // Unrenders the grid's date-related content\n        unrenderDates: function() {\n            // subclasses should implement\n        },\n\n\n        /* Handlers\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Binds DOM handlers to elements that reside outside the grid, such as the document\n        bindGlobalHandlers: function() {\n            this.listenTo($(document), {\n                dragstart: this.externalDragStart, // jqui\n                sortstart: this.externalDragStart // jqui\n            });\n        },\n\n\n        // Unbinds DOM handlers from elements that reside outside the grid\n        unbindGlobalHandlers: function() {\n            this.stopListeningTo($(document));\n        },\n\n\n        // Process a mousedown on an element that represents a day. For day clicking and selecting.\n        dayMousedown: function(ev) {\n            var view = this.view;\n\n            // HACK\n            // This will still work even though bindDayHandler doesn't use GlobalEmitter.\n            if (GlobalEmitter.get().shouldIgnoreMouse()) {\n                return;\n            }\n\n            this.dayClickListener.startInteraction(ev);\n\n            if (view.opt('selectable')) {\n                this.daySelectListener.startInteraction(ev, {\n                    distance: view.opt('selectMinDistance')\n                });\n            }\n        },\n\n\n        dayTouchStart: function(ev) {\n            var view = this.view;\n            var selectLongPressDelay;\n\n            // On iOS (and Android?) when a new selection is initiated overtop another selection,\n            // the touchend never fires because the elements gets removed mid-touch-interaction (my theory).\n            // HACK: simply don't allow this to happen.\n            // ALSO: prevent selection when an *event* is already raised.\n            if (view.isSelected || view.selectedEvent) {\n                return;\n            }\n\n            selectLongPressDelay = view.opt('selectLongPressDelay');\n            if (selectLongPressDelay == null) {\n                selectLongPressDelay = view.opt('longPressDelay'); // fallback\n            }\n\n            this.dayClickListener.startInteraction(ev);\n\n            if (view.opt('selectable')) {\n                this.daySelectListener.startInteraction(ev, {\n                    delay: selectLongPressDelay\n                });\n            }\n        },\n\n\n        // Creates a listener that tracks the user's drag across day elements, for day clicking.\n        buildDayClickListener: function() {\n            var _this = this;\n            var view = this.view;\n            var dayClickHit; // null if invalid dayClick\n\n            var dragListener = new HitDragListener(this, {\n                scroll: view.opt('dragScroll'),\n                interactionStart: function() {\n                    dayClickHit = dragListener.origHit;\n                },\n                hitOver: function(hit, isOrig, origHit) {\n                    // if user dragged to another cell at any point, it can no longer be a dayClick\n                    if (!isOrig) {\n                        dayClickHit = null;\n                    }\n                },\n                hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits\n                    dayClickHit = null;\n                },\n                interactionEnd: function(ev, isCancelled) {\n                    var hitSpan;\n\n                    if (!isCancelled && dayClickHit) {\n                        hitSpan = _this.getSafeHitSpan(dayClickHit);\n\n                        if (hitSpan) {\n                            view.triggerDayClick(hitSpan, _this.getHitEl(dayClickHit), ev);\n                        }\n                    }\n                }\n            });\n\n            // because dayClickListener won't be called with any time delay, \"dragging\" will begin immediately,\n            // which will kill any touchmoving/scrolling. Prevent this.\n            dragListener.shouldCancelTouchScroll = false;\n\n            dragListener.scrollAlwaysKills = true;\n\n            return dragListener;\n        },\n\n\n        // Creates a listener that tracks the user's drag across day elements, for day selecting.\n        buildDaySelectListener: function() {\n            var _this = this;\n            var view = this.view;\n            var selectionSpan; // null if invalid selection\n\n            var dragListener = new HitDragListener(this, {\n                scroll: view.opt('dragScroll'),\n                interactionStart: function() {\n                    selectionSpan = null;\n                },\n                dragStart: function() {\n                    view.unselect(); // since we could be rendering a new selection, we want to clear any old one\n                },\n                hitOver: function(hit, isOrig, origHit) {\n                    var origHitSpan;\n                    var hitSpan;\n\n                    if (origHit) { // click needs to have started on a hit\n\n                        origHitSpan = _this.getSafeHitSpan(origHit);\n                        hitSpan = _this.getSafeHitSpan(hit);\n\n                        if (origHitSpan && hitSpan) {\n                            selectionSpan = _this.computeSelection(origHitSpan, hitSpan);\n                        }\n                        else {\n                            selectionSpan = null;\n                        }\n\n                        if (selectionSpan) {\n                            _this.renderSelection(selectionSpan);\n                        }\n                        else if (selectionSpan === false) {\n                            disableCursor();\n                        }\n                    }\n                },\n                hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits\n                    selectionSpan = null;\n                    _this.unrenderSelection();\n                },\n                hitDone: function() { // called after a hitOut OR before a dragEnd\n                    enableCursor();\n                },\n                interactionEnd: function(ev, isCancelled) {\n                    if (!isCancelled && selectionSpan) {\n                        // the selection will already have been rendered. just report it\n                        view.reportSelection(selectionSpan, ev);\n                    }\n                }\n            });\n\n            return dragListener;\n        },\n\n\n        // Kills all in-progress dragging.\n        // Useful for when public API methods that result in re-rendering are invoked during a drag.\n        // Also useful for when touch devices misbehave and don't fire their touchend.\n        clearDragListeners: function() {\n            this.dayClickListener.endInteraction();\n            this.daySelectListener.endInteraction();\n\n            if (this.segDragListener) {\n                this.segDragListener.endInteraction(); // will clear this.segDragListener\n            }\n            if (this.segResizeListener) {\n                this.segResizeListener.endInteraction(); // will clear this.segResizeListener\n            }\n            if (this.externalDragListener) {\n                this.externalDragListener.endInteraction(); // will clear this.externalDragListener\n            }\n        },\n\n\n        /* Event Helper\n         ------------------------------------------------------------------------------------------------------------------*/\n        // TODO: should probably move this to Grid.events, like we did event dragging / resizing\n\n\n        // Renders a mock event at the given event location, which contains zoned start/end properties.\n        // Returns all mock event elements.\n        renderEventLocationHelper: function(eventLocation, sourceSeg) {\n            var fakeEvent = this.fabricateHelperEvent(eventLocation, sourceSeg);\n\n            return this.renderHelper(fakeEvent, sourceSeg); // do the actual rendering\n        },\n\n\n        // Builds a fake event given zoned event date properties and a segment is should be inspired from.\n        // The range's end can be null, in which case the mock event that is rendered will have a null end time.\n        // `sourceSeg` is the internal segment object involved in the drag. If null, something external is dragging.\n        fabricateHelperEvent: function(eventLocation, sourceSeg) {\n            var fakeEvent = sourceSeg ? createObject(sourceSeg.event) : {}; // mask the original event object if possible\n\n            fakeEvent.start = eventLocation.start.clone();\n            fakeEvent.end = eventLocation.end ? eventLocation.end.clone() : null;\n            fakeEvent.allDay = null; // force it to be freshly computed by normalizeEventDates\n            this.view.calendar.normalizeEventDates(fakeEvent);\n\n            // this extra className will be useful for differentiating real events from mock events in CSS\n            fakeEvent.className = (fakeEvent.className || []).concat('fc-helper');\n\n            // if something external is being dragged in, don't render a resizer\n            if (!sourceSeg) {\n                fakeEvent.editable = false;\n            }\n\n            return fakeEvent;\n        },\n\n\n        // Renders a mock event. Given zoned event date properties.\n        // Must return all mock event elements.\n        renderHelper: function(eventLocation, sourceSeg) {\n            // subclasses must implement\n        },\n\n\n        // Unrenders a mock event\n        unrenderHelper: function() {\n            // subclasses must implement\n        },\n\n\n        /* Selection\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders a visual indication of a selection. Will highlight by default but can be overridden by subclasses.\n        // Given a span (unzoned start/end and other misc data)\n        renderSelection: function(span) {\n            this.renderHighlight(span);\n        },\n\n\n        // Unrenders any visual indications of a selection. Will unrender a highlight by default.\n        unrenderSelection: function() {\n            this.unrenderHighlight();\n        },\n\n\n        // Given the first and last date-spans of a selection, returns another date-span object.\n        // Subclasses can override and provide additional data in the span object. Will be passed to renderSelection().\n        // Will return false if the selection is invalid and this should be indicated to the user.\n        // Will return null/undefined if a selection invalid but no error should be reported.\n        computeSelection: function(span0, span1) {\n            var span = this.computeSelectionSpan(span0, span1);\n\n            if (span && !this.view.calendar.isSelectionSpanAllowed(span)) {\n                return false;\n            }\n\n            return span;\n        },\n\n\n        // Given two spans, must return the combination of the two.\n        // TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.\n        computeSelectionSpan: function(span0, span1) {\n            var dates = [ span0.start, span0.end, span1.start, span1.end ];\n\n            dates.sort(compareNumbers); // sorts chronologically. works with Moments\n\n            return { start: dates[0].clone(), end: dates[3].clone() };\n        },\n\n\n        /* Highlight\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)\n        renderHighlight: function(span) {\n            this.renderFill('highlight', this.spanToSegs(span));\n        },\n\n\n        // Unrenders the emphasis on a date range\n        unrenderHighlight: function() {\n            this.unrenderFill('highlight');\n        },\n\n\n        // Generates an array of classNames for rendering the highlight. Used by the fill system.\n        highlightSegClasses: function() {\n            return [ 'fc-highlight' ];\n        },\n\n\n        /* Business Hours\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        renderBusinessHours: function() {\n        },\n\n\n        unrenderBusinessHours: function() {\n        },\n\n\n        /* Now Indicator\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        getNowIndicatorUnit: function() {\n        },\n\n\n        renderNowIndicator: function(date) {\n        },\n\n\n        unrenderNowIndicator: function() {\n        },\n\n\n        /* Fill System (highlight, background events, business hours)\n         --------------------------------------------------------------------------------------------------------------------\n         TODO: remove this system. like we did in TimeGrid\n         */\n\n\n        // Renders a set of rectangles over the given segments of time.\n        // MUST RETURN a subset of segs, the segs that were actually rendered.\n        // Responsible for populating this.elsByFill. TODO: better API for expressing this requirement\n        renderFill: function(type, segs) {\n            // subclasses must implement\n        },\n\n\n        // Unrenders a specific type of fill that is currently rendered on the grid\n        unrenderFill: function(type) {\n            var el = this.elsByFill[type];\n\n            if (el) {\n                el.remove();\n                delete this.elsByFill[type];\n            }\n        },\n\n\n        // Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.\n        // Only returns segments that successfully rendered.\n        // To be harnessed by renderFill (implemented by subclasses).\n        // Analagous to renderFgSegEls.\n        renderFillSegEls: function(type, segs) {\n            var _this = this;\n            var segElMethod = this[type + 'SegEl'];\n            var html = '';\n            var renderedSegs = [];\n            var i;\n\n            if (segs.length) {\n\n                // build a large concatenation of segment HTML\n                for (i = 0; i < segs.length; i++) {\n                    html += this.fillSegHtml(type, segs[i]);\n                }\n\n                // Grab individual elements from the combined HTML string. Use each as the default rendering.\n                // Then, compute the 'el' for each segment.\n                $(html).each(function(i, node) {\n                    var seg = segs[i];\n                    var el = $(node);\n\n                    // allow custom filter methods per-type\n                    if (segElMethod) {\n                        el = segElMethod.call(_this, seg, el);\n                    }\n\n                    if (el) { // custom filters did not cancel the render\n                        el = $(el); // allow custom filter to return raw DOM node\n\n                        // correct element type? (would be bad if a non-TD were inserted into a table for example)\n                        if (el.is(_this.fillSegTag)) {\n                            seg.el = el;\n                            renderedSegs.push(seg);\n                        }\n                    }\n                });\n            }\n\n            return renderedSegs;\n        },\n\n\n        fillSegTag: 'div', // subclasses can override\n\n\n        // Builds the HTML needed for one fill segment. Generic enough to work with different types.\n        fillSegHtml: function(type, seg) {\n\n            // custom hooks per-type\n            var classesMethod = this[type + 'SegClasses'];\n            var cssMethod = this[type + 'SegCss'];\n\n            var classes = classesMethod ? classesMethod.call(this, seg) : [];\n            var css = cssToStr(cssMethod ? cssMethod.call(this, seg) : {});\n\n            return '<' + this.fillSegTag +\n                (classes.length ? ' class=\"' + classes.join(' ') + '\"' : '') +\n                (css ? ' style=\"' + css + '\"' : '') +\n                ' />';\n        },\n\n\n\n        /* Generic rendering utilities for subclasses\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Computes HTML classNames for a single-day element\n        getDayClasses: function(date, noThemeHighlight) {\n            var view = this.view;\n            var classes = [];\n            var today;\n\n            if (!isDateWithinRange(date, view.activeRange)) {\n                classes.push('fc-disabled-day'); // TODO: jQuery UI theme?\n            }\n            else {\n                classes.push('fc-' + dayIDs[date.day()]);\n\n                if (\n                    view.currentRangeAs('months') == 1 && // TODO: somehow get into MonthView\n                    date.month() != view.currentRange.start.month()\n                ) {\n                    classes.push('fc-other-month');\n                }\n\n                today = view.calendar.getNow();\n\n                if (date.isSame(today, 'day')) {\n                    classes.push('fc-today');\n\n                    if (noThemeHighlight !== true) {\n                        classes.push(view.highlightStateClass);\n                    }\n                }\n                else if (date < today) {\n                    classes.push('fc-past');\n                }\n                else {\n                    classes.push('fc-future');\n                }\n            }\n\n            return classes;\n        }\n\n    });\n\n    ;;\n\n    /* Event-rendering and event-interaction methods for the abstract Grid class\n     ----------------------------------------------------------------------------------------------------------------------\n\n     Data Types:\n     event - { title, id, start, (end), whatever }\n     location - { start, (end), allDay }\n     rawEventRange - { start, end }\n     eventRange - { start, end, isStart, isEnd }\n     eventSpan - { start, end, isStart, isEnd, whatever }\n     eventSeg - { event, whatever }\n     seg - { whatever }\n     */\n\n    Grid.mixin({\n\n        // self-config, overridable by subclasses\n        segSelector: '.fc-event-container > *', // what constitutes an event element?\n\n        mousedOverSeg: null, // the segment object the user's mouse is over. null if over nothing\n        isDraggingSeg: false, // is a segment being dragged? boolean\n        isResizingSeg: false, // is a segment being resized? boolean\n        isDraggingExternal: false, // jqui-dragging an external element? boolean\n        segs: null, // the *event* segments currently rendered in the grid. TODO: rename to `eventSegs`\n\n\n        // Renders the given events onto the grid\n        renderEvents: function(events) {\n            var bgEvents = [];\n            var fgEvents = [];\n            var i;\n\n            for (i = 0; i < events.length; i++) {\n                (isBgEvent(events[i]) ? bgEvents : fgEvents).push(events[i]);\n            }\n\n            this.segs = [].concat( // record all segs\n                this.renderBgEvents(bgEvents),\n                this.renderFgEvents(fgEvents)\n            );\n        },\n\n\n        renderBgEvents: function(events) {\n            var segs = this.eventsToSegs(events);\n\n            // renderBgSegs might return a subset of segs, segs that were actually rendered\n            return this.renderBgSegs(segs) || segs;\n        },\n\n\n        renderFgEvents: function(events) {\n            var segs = this.eventsToSegs(events);\n\n            // renderFgSegs might return a subset of segs, segs that were actually rendered\n            return this.renderFgSegs(segs) || segs;\n        },\n\n\n        // Unrenders all events currently rendered on the grid\n        unrenderEvents: function() {\n            this.handleSegMouseout(); // trigger an eventMouseout if user's mouse is over an event\n            this.clearDragListeners();\n\n            this.unrenderFgSegs();\n            this.unrenderBgSegs();\n\n            this.segs = null;\n        },\n\n\n        // Retrieves all rendered segment objects currently rendered on the grid\n        getEventSegs: function() {\n            return this.segs || [];\n        },\n\n\n        /* Foreground Segment Rendering\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders foreground event segments onto the grid. May return a subset of segs that were rendered.\n        renderFgSegs: function(segs) {\n            // subclasses must implement\n        },\n\n\n        // Unrenders all currently rendered foreground segments\n        unrenderFgSegs: function() {\n            // subclasses must implement\n        },\n\n\n        // Renders and assigns an `el` property for each foreground event segment.\n        // Only returns segments that successfully rendered.\n        // A utility that subclasses may use.\n        renderFgSegEls: function(segs, disableResizing) {\n            var view = this.view;\n            var html = '';\n            var renderedSegs = [];\n            var i;\n\n            if (segs.length) { // don't build an empty html string\n\n                // build a large concatenation of event segment HTML\n                for (i = 0; i < segs.length; i++) {\n                    html += this.fgSegHtml(segs[i], disableResizing);\n                }\n\n                // Grab individual elements from the combined HTML string. Use each as the default rendering.\n                // Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.\n                $(html).each(function(i, node) {\n                    var seg = segs[i];\n                    var el = view.resolveEventEl(seg.event, $(node));\n\n                    if (el) {\n                        el.data('fc-seg', seg); // used by handlers\n                        seg.el = el;\n                        renderedSegs.push(seg);\n                    }\n                });\n            }\n\n            return renderedSegs;\n        },\n\n\n        // Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()\n        fgSegHtml: function(seg, disableResizing) {\n            // subclasses should implement\n        },\n\n\n        /* Background Segment Rendering\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders the given background event segments onto the grid.\n        // Returns a subset of the segs that were actually rendered.\n        renderBgSegs: function(segs) {\n            return this.renderFill('bgEvent', segs);\n        },\n\n\n        // Unrenders all the currently rendered background event segments\n        unrenderBgSegs: function() {\n            this.unrenderFill('bgEvent');\n        },\n\n\n        // Renders a background event element, given the default rendering. Called by the fill system.\n        bgEventSegEl: function(seg, el) {\n            return this.view.resolveEventEl(seg.event, el); // will filter through eventRender\n        },\n\n\n        // Generates an array of classNames to be used for the default rendering of a background event.\n        // Called by fillSegHtml.\n        bgEventSegClasses: function(seg) {\n            var event = seg.event;\n            var source = event.source || {};\n\n            return [ 'fc-bgevent' ].concat(\n                event.className,\n                source.className || []\n            );\n        },\n\n\n        // Generates a semicolon-separated CSS string to be used for the default rendering of a background event.\n        // Called by fillSegHtml.\n        bgEventSegCss: function(seg) {\n            return {\n                'background-color': this.getSegSkinCss(seg)['background-color']\n            };\n        },\n\n\n        // Generates an array of classNames to be used for the rendering business hours overlay. Called by the fill system.\n        // Called by fillSegHtml.\n        businessHoursSegClasses: function(seg) {\n            return [ 'fc-nonbusiness', 'fc-bgevent' ];\n        },\n\n\n        /* Business Hours\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Compute business hour segs for the grid's current date range.\n        // Caller must ask if whole-day business hours are needed.\n        // If no `businessHours` configuration value is specified, assumes the calendar default.\n        buildBusinessHourSegs: function(wholeDay, businessHours) {\n            return this.eventsToSegs(\n                this.buildBusinessHourEvents(wholeDay, businessHours)\n            );\n        },\n\n\n        // Compute business hour *events* for the grid's current date range.\n        // Caller must ask if whole-day business hours are needed.\n        // If no `businessHours` configuration value is specified, assumes the calendar default.\n        buildBusinessHourEvents: function(wholeDay, businessHours) {\n            var calendar = this.view.calendar;\n            var events;\n\n            if (businessHours == null) {\n                // fallback\n                // access from calendawr. don't access from view. doesn't update with dynamic options.\n                businessHours = calendar.opt('businessHours');\n            }\n\n            events = calendar.computeBusinessHourEvents(wholeDay, businessHours);\n\n            // HACK. Eventually refactor business hours \"events\" system.\n            // If no events are given, but businessHours is activated, this means the entire visible range should be\n            // marked as *not* business-hours, via inverse-background rendering.\n            if (!events.length && businessHours) {\n                events = [\n                    $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, {\n                        start: this.view.activeRange.end, // guaranteed out-of-range\n                        end: this.view.activeRange.end,   // \"\n                        dow: null\n                    })\n                ];\n            }\n\n            return events;\n        },\n\n\n        /* Handlers\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Attaches event-element-related handlers for *all* rendered event segments of the view.\n        bindSegHandlers: function() {\n            this.bindSegHandlersToEl(this.el);\n        },\n\n\n        // Attaches event-element-related handlers to an arbitrary container element. leverages bubbling.\n        bindSegHandlersToEl: function(el) {\n            this.bindSegHandlerToEl(el, 'touchstart', this.handleSegTouchStart);\n            this.bindSegHandlerToEl(el, 'mouseenter', this.handleSegMouseover);\n            this.bindSegHandlerToEl(el, 'mouseleave', this.handleSegMouseout);\n            this.bindSegHandlerToEl(el, 'mousedown', this.handleSegMousedown);\n            this.bindSegHandlerToEl(el, 'click', this.handleSegClick);\n        },\n\n\n        // Executes a handler for any a user-interaction on a segment.\n        // Handler gets called with (seg, ev), and with the `this` context of the Grid\n        bindSegHandlerToEl: function(el, name, handler) {\n            var _this = this;\n\n            el.on(name, this.segSelector, function(ev) {\n                var seg = $(this).data('fc-seg'); // grab segment data. put there by View::renderEvents\n\n                // only call the handlers if there is not a drag/resize in progress\n                if (seg && !_this.isDraggingSeg && !_this.isResizingSeg) {\n                    return handler.call(_this, seg, ev); // context will be the Grid\n                }\n            });\n        },\n\n\n        handleSegClick: function(seg, ev) {\n            var res = this.view.publiclyTrigger('eventClick', seg.el[0], seg.event, ev); // can return `false` to cancel\n            if (res === false) {\n                ev.preventDefault();\n            }\n        },\n\n\n        // Updates internal state and triggers handlers for when an event element is moused over\n        handleSegMouseover: function(seg, ev) {\n            if (\n                !GlobalEmitter.get().shouldIgnoreMouse() &&\n                !this.mousedOverSeg\n            ) {\n                this.mousedOverSeg = seg;\n                if (this.view.isEventResizable(seg.event)) {\n                    seg.el.addClass('fc-allow-mouse-resize');\n                }\n                this.view.publiclyTrigger('eventMouseover', seg.el[0], seg.event, ev);\n            }\n        },\n\n\n        // Updates internal state and triggers handlers for when an event element is moused out.\n        // Can be given no arguments, in which case it will mouseout the segment that was previously moused over.\n        handleSegMouseout: function(seg, ev) {\n            ev = ev || {}; // if given no args, make a mock mouse event\n\n            if (this.mousedOverSeg) {\n                seg = seg || this.mousedOverSeg; // if given no args, use the currently moused-over segment\n                this.mousedOverSeg = null;\n                if (this.view.isEventResizable(seg.event)) {\n                    seg.el.removeClass('fc-allow-mouse-resize');\n                }\n                this.view.publiclyTrigger('eventMouseout', seg.el[0], seg.event, ev);\n            }\n        },\n\n\n        handleSegMousedown: function(seg, ev) {\n            var isResizing = this.startSegResize(seg, ev, { distance: 5 });\n\n            if (!isResizing && this.view.isEventDraggable(seg.event)) {\n                this.buildSegDragListener(seg)\n                    .startInteraction(ev, {\n                        distance: 5\n                    });\n            }\n        },\n\n\n        handleSegTouchStart: function(seg, ev) {\n            var view = this.view;\n            var event = seg.event;\n            var isSelected = view.isEventSelected(event);\n            var isDraggable = view.isEventDraggable(event);\n            var isResizable = view.isEventResizable(event);\n            var isResizing = false;\n            var dragListener;\n            var eventLongPressDelay;\n\n            if (isSelected && isResizable) {\n                // only allow resizing of the event is selected\n                isResizing = this.startSegResize(seg, ev);\n            }\n\n            if (!isResizing && (isDraggable || isResizable)) { // allowed to be selected?\n\n                eventLongPressDelay = view.opt('eventLongPressDelay');\n                if (eventLongPressDelay == null) {\n                    eventLongPressDelay = view.opt('longPressDelay'); // fallback\n                }\n\n                dragListener = isDraggable ?\n                    this.buildSegDragListener(seg) :\n                    this.buildSegSelectListener(seg); // seg isn't draggable, but still needs to be selected\n\n                dragListener.startInteraction(ev, { // won't start if already started\n                    delay: isSelected ? 0 : eventLongPressDelay // do delay if not already selected\n                });\n            }\n        },\n\n\n        // returns boolean whether resizing actually started or not.\n        // assumes the seg allows resizing.\n        // `dragOptions` are optional.\n        startSegResize: function(seg, ev, dragOptions) {\n            if ($(ev.target).is('.fc-resizer')) {\n                this.buildSegResizeListener(seg, $(ev.target).is('.fc-start-resizer'))\n                    .startInteraction(ev, dragOptions);\n                return true;\n            }\n            return false;\n        },\n\n\n\n        /* Event Dragging\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Builds a listener that will track user-dragging on an event segment.\n        // Generic enough to work with any type of Grid.\n        // Has side effect of setting/unsetting `segDragListener`\n        buildSegDragListener: function(seg) {\n            var _this = this;\n            var view = this.view;\n            var el = seg.el;\n            var event = seg.event;\n            var isDragging;\n            var mouseFollower; // A clone of the original element that will move with the mouse\n            var dropLocation; // zoned event date properties\n\n            if (this.segDragListener) {\n                return this.segDragListener;\n            }\n\n            // Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents\n            // of the view.\n            var dragListener = this.segDragListener = new HitDragListener(view, {\n                scroll: view.opt('dragScroll'),\n                subjectEl: el,\n                subjectCenter: true,\n                interactionStart: function(ev) {\n                    seg.component = _this; // for renderDrag\n                    isDragging = false;\n                    mouseFollower = new MouseFollower(seg.el, {\n                        additionalClass: 'fc-dragging',\n                        parentEl: view.el,\n                        opacity: dragListener.isTouch ? null : view.opt('dragOpacity'),\n                        revertDuration: view.opt('dragRevertDuration'),\n                        zIndex: 2 // one above the .fc-view\n                    });\n                    mouseFollower.hide(); // don't show until we know this is a real drag\n                    mouseFollower.start(ev);\n                },\n                dragStart: function(ev) {\n                    if (dragListener.isTouch && !view.isEventSelected(event)) {\n                        // if not previously selected, will fire after a delay. then, select the event\n                        view.selectEvent(event);\n                    }\n                    isDragging = true;\n                    _this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported\n                    _this.segDragStart(seg, ev);\n                    view.hideEvent(event); // hide all event segments. our mouseFollower will take over\n                },\n                hitOver: function(hit, isOrig, origHit) {\n                    var isAllowed = true;\n                    var origHitSpan;\n                    var hitSpan;\n                    var dragHelperEls;\n\n                    // starting hit could be forced (DayGrid.limit)\n                    if (seg.hit) {\n                        origHit = seg.hit;\n                    }\n\n                    // hit might not belong to this grid, so query origin grid\n                    origHitSpan = origHit.component.getSafeHitSpan(origHit);\n                    hitSpan = hit.component.getSafeHitSpan(hit);\n\n                    if (origHitSpan && hitSpan) {\n                        dropLocation = _this.computeEventDrop(origHitSpan, hitSpan, event);\n                        isAllowed = dropLocation && _this.isEventLocationAllowed(dropLocation, event);\n                    }\n                    else {\n                        isAllowed = false;\n                    }\n\n                    if (!isAllowed) {\n                        dropLocation = null;\n                        disableCursor();\n                    }\n\n                    // if a valid drop location, have the subclass render a visual indication\n                    if (dropLocation && (dragHelperEls = view.renderDrag(dropLocation, seg))) {\n\n                        dragHelperEls.addClass('fc-dragging');\n                        if (!dragListener.isTouch) {\n                            _this.applyDragOpacity(dragHelperEls);\n                        }\n\n                        mouseFollower.hide(); // if the subclass is already using a mock event \"helper\", hide our own\n                    }\n                    else {\n                        mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)\n                    }\n\n                    if (isOrig) {\n                        dropLocation = null; // needs to have moved hits to be a valid drop\n                    }\n                },\n                hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits\n                    view.unrenderDrag(); // unrender whatever was done in renderDrag\n                    mouseFollower.show(); // show in case we are moving out of all hits\n                    dropLocation = null;\n                },\n                hitDone: function() { // Called after a hitOut OR before a dragEnd\n                    enableCursor();\n                },\n                interactionEnd: function(ev) {\n                    delete seg.component; // prevent side effects\n\n                    // do revert animation if hasn't changed. calls a callback when finished (whether animation or not)\n                    mouseFollower.stop(!dropLocation, function() {\n                        if (isDragging) {\n                            view.unrenderDrag();\n                            _this.segDragStop(seg, ev);\n                        }\n\n                        if (dropLocation) {\n                            // no need to re-show original, will rerender all anyways. esp important if eventRenderWait\n                            view.reportSegDrop(seg, dropLocation, _this.largeUnit, el, ev);\n                        }\n                        else {\n                            view.showEvent(event);\n                        }\n                    });\n                    _this.segDragListener = null;\n                }\n            });\n\n            return dragListener;\n        },\n\n\n        // seg isn't draggable, but let's use a generic DragListener\n        // simply for the delay, so it can be selected.\n        // Has side effect of setting/unsetting `segDragListener`\n        buildSegSelectListener: function(seg) {\n            var _this = this;\n            var view = this.view;\n            var event = seg.event;\n\n            if (this.segDragListener) {\n                return this.segDragListener;\n            }\n\n            var dragListener = this.segDragListener = new DragListener({\n                dragStart: function(ev) {\n                    if (dragListener.isTouch && !view.isEventSelected(event)) {\n                        // if not previously selected, will fire after a delay. then, select the event\n                        view.selectEvent(event);\n                    }\n                },\n                interactionEnd: function(ev) {\n                    _this.segDragListener = null;\n                }\n            });\n\n            return dragListener;\n        },\n\n\n        // Called before event segment dragging starts\n        segDragStart: function(seg, ev) {\n            this.isDraggingSeg = true;\n            this.view.publiclyTrigger('eventDragStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\n        },\n\n\n        // Called after event segment dragging stops\n        segDragStop: function(seg, ev) {\n            this.isDraggingSeg = false;\n            this.view.publiclyTrigger('eventDragStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\n        },\n\n\n        // Given the spans an event drag began, and the span event was dropped, calculates the new zoned start/end/allDay\n        // values for the event. Subclasses may override and set additional properties to be used by renderDrag.\n        // A falsy returned value indicates an invalid drop.\n        // DOES NOT consider overlap/constraint.\n        computeEventDrop: function(startSpan, endSpan, event) {\n            var calendar = this.view.calendar;\n            var dragStart = startSpan.start;\n            var dragEnd = endSpan.start;\n            var delta;\n            var dropLocation; // zoned event date properties\n\n            if (dragStart.hasTime() === dragEnd.hasTime()) {\n                delta = this.diffDates(dragEnd, dragStart);\n\n                // if an all-day event was in a timed area and it was dragged to a different time,\n                // guarantee an end and adjust start/end to have times\n                if (event.allDay && durationHasTime(delta)) {\n                    dropLocation = {\n                        start: event.start.clone(),\n                        end: calendar.getEventEnd(event), // will be an ambig day\n                        allDay: false // for normalizeEventTimes\n                    };\n                    calendar.normalizeEventTimes(dropLocation);\n                }\n                // othewise, work off existing values\n                else {\n                    dropLocation = pluckEventDateProps(event);\n                }\n\n                dropLocation.start.add(delta);\n                if (dropLocation.end) {\n                    dropLocation.end.add(delta);\n                }\n            }\n            else {\n                // if switching from day <-> timed, start should be reset to the dropped date, and the end cleared\n                dropLocation = {\n                    start: dragEnd.clone(),\n                    end: null, // end should be cleared\n                    allDay: !dragEnd.hasTime()\n                };\n            }\n\n            return dropLocation;\n        },\n\n\n        // Utility for apply dragOpacity to a jQuery set\n        applyDragOpacity: function(els) {\n            var opacity = this.view.opt('dragOpacity');\n\n            if (opacity != null) {\n                els.css('opacity', opacity);\n            }\n        },\n\n\n        /* External Element Dragging\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Called when a jQuery UI drag is initiated anywhere in the DOM\n        externalDragStart: function(ev, ui) {\n            var view = this.view;\n            var el;\n            var accept;\n\n            if (view.opt('droppable')) { // only listen if this setting is on\n                el = $((ui ? ui.item : null) || ev.target);\n\n                // Test that the dragged element passes the dropAccept selector or filter function.\n                // FYI, the default is \"*\" (matches all)\n                accept = view.opt('dropAccept');\n                if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {\n                    if (!this.isDraggingExternal) { // prevent double-listening if fired twice\n                        this.listenToExternalDrag(el, ev, ui);\n                    }\n                }\n            }\n        },\n\n\n        // Called when a jQuery UI drag starts and it needs to be monitored for dropping\n        listenToExternalDrag: function(el, ev, ui) {\n            var _this = this;\n            var view = this.view;\n            var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create\n            var dropLocation; // a null value signals an unsuccessful drag\n\n            // listener that tracks mouse movement over date-associated pixel regions\n            var dragListener = _this.externalDragListener = new HitDragListener(this, {\n                interactionStart: function() {\n                    _this.isDraggingExternal = true;\n                },\n                hitOver: function(hit) {\n                    var isAllowed = true;\n                    var hitSpan = hit.component.getSafeHitSpan(hit); // hit might not belong to this grid\n\n                    if (hitSpan) {\n                        dropLocation = _this.computeExternalDrop(hitSpan, meta);\n                        isAllowed = dropLocation && _this.isExternalLocationAllowed(dropLocation, meta.eventProps);\n                    }\n                    else {\n                        isAllowed = false;\n                    }\n\n                    if (!isAllowed) {\n                        dropLocation = null;\n                        disableCursor();\n                    }\n\n                    if (dropLocation) {\n                        _this.renderDrag(dropLocation); // called without a seg parameter\n                    }\n                },\n                hitOut: function() {\n                    dropLocation = null; // signal unsuccessful\n                },\n                hitDone: function() { // Called after a hitOut OR before a dragEnd\n                    enableCursor();\n                    _this.unrenderDrag();\n                },\n                interactionEnd: function(ev) {\n                    if (dropLocation) { // element was dropped on a valid hit\n                        view.reportExternalDrop(meta, dropLocation, el, ev, ui);\n                    }\n                    _this.isDraggingExternal = false;\n                    _this.externalDragListener = null;\n                }\n            });\n\n            dragListener.startDrag(ev); // start listening immediately\n        },\n\n\n        // Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),\n        // returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.\n        // Returning a null value signals an invalid drop hit.\n        // DOES NOT consider overlap/constraint.\n        computeExternalDrop: function(span, meta) {\n            var calendar = this.view.calendar;\n            var dropLocation = {\n                start: calendar.applyTimezone(span.start), // simulate a zoned event start date\n                end: null\n            };\n\n            // if dropped on an all-day span, and element's metadata specified a time, set it\n            if (meta.startTime && !dropLocation.start.hasTime()) {\n                dropLocation.start.time(meta.startTime);\n            }\n\n            if (meta.duration) {\n                dropLocation.end = dropLocation.start.clone().add(meta.duration);\n            }\n\n            return dropLocation;\n        },\n\n\n\n        /* Drag Rendering (for both events and an external elements)\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders a visual indication of an event or external element being dragged.\n        // `dropLocation` contains hypothetical start/end/allDay values the event would have if dropped. end can be null.\n        // `seg` is the internal segment object that is being dragged. If dragging an external element, `seg` is null.\n        // A truthy returned value indicates this method has rendered a helper element.\n        // Must return elements used for any mock events.\n        renderDrag: function(dropLocation, seg) {\n            // subclasses must implement\n        },\n\n\n        // Unrenders a visual indication of an event or external element being dragged\n        unrenderDrag: function() {\n            // subclasses must implement\n        },\n\n\n        /* Resizing\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Creates a listener that tracks the user as they resize an event segment.\n        // Generic enough to work with any type of Grid.\n        buildSegResizeListener: function(seg, isStart) {\n            var _this = this;\n            var view = this.view;\n            var calendar = view.calendar;\n            var el = seg.el;\n            var event = seg.event;\n            var eventEnd = calendar.getEventEnd(event);\n            var isDragging;\n            var resizeLocation; // zoned event date properties. falsy if invalid resize\n\n            // Tracks mouse movement over the *grid's* coordinate map\n            var dragListener = this.segResizeListener = new HitDragListener(this, {\n                scroll: view.opt('dragScroll'),\n                subjectEl: el,\n                interactionStart: function() {\n                    isDragging = false;\n                },\n                dragStart: function(ev) {\n                    isDragging = true;\n                    _this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported\n                    _this.segResizeStart(seg, ev);\n                },\n                hitOver: function(hit, isOrig, origHit) {\n                    var isAllowed = true;\n                    var origHitSpan = _this.getSafeHitSpan(origHit);\n                    var hitSpan = _this.getSafeHitSpan(hit);\n\n                    if (origHitSpan && hitSpan) {\n                        resizeLocation = isStart ?\n                            _this.computeEventStartResize(origHitSpan, hitSpan, event) :\n                            _this.computeEventEndResize(origHitSpan, hitSpan, event);\n\n                        isAllowed = resizeLocation && _this.isEventLocationAllowed(resizeLocation, event);\n                    }\n                    else {\n                        isAllowed = false;\n                    }\n\n                    if (!isAllowed) {\n                        resizeLocation = null;\n                        disableCursor();\n                    }\n                    else {\n                        if (\n                            resizeLocation.start.isSame(event.start.clone().stripZone()) &&\n                            resizeLocation.end.isSame(eventEnd.clone().stripZone())\n                        ) {\n                            // no change. (FYI, event dates might have zones)\n                            resizeLocation = null;\n                        }\n                    }\n\n                    if (resizeLocation) {\n                        view.hideEvent(event);\n                        _this.renderEventResize(resizeLocation, seg);\n                    }\n                },\n                hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits\n                    resizeLocation = null;\n                    view.showEvent(event); // for when out-of-bounds. show original\n                },\n                hitDone: function() { // resets the rendering to show the original event\n                    _this.unrenderEventResize();\n                    enableCursor();\n                },\n                interactionEnd: function(ev) {\n                    if (isDragging) {\n                        _this.segResizeStop(seg, ev);\n                    }\n\n                    if (resizeLocation) { // valid date to resize to?\n                        // no need to re-show original, will rerender all anyways. esp important if eventRenderWait\n                        view.reportSegResize(seg, resizeLocation, _this.largeUnit, el, ev);\n                    }\n                    else {\n                        view.showEvent(event);\n                    }\n                    _this.segResizeListener = null;\n                }\n            });\n\n            return dragListener;\n        },\n\n\n        // Called before event segment resizing starts\n        segResizeStart: function(seg, ev) {\n            this.isResizingSeg = true;\n            this.view.publiclyTrigger('eventResizeStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\n        },\n\n\n        // Called after event segment resizing stops\n        segResizeStop: function(seg, ev) {\n            this.isResizingSeg = false;\n            this.view.publiclyTrigger('eventResizeStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\n        },\n\n\n        // Returns new date-information for an event segment being resized from its start\n        computeEventStartResize: function(startSpan, endSpan, event) {\n            return this.computeEventResize('start', startSpan, endSpan, event);\n        },\n\n\n        // Returns new date-information for an event segment being resized from its end\n        computeEventEndResize: function(startSpan, endSpan, event) {\n            return this.computeEventResize('end', startSpan, endSpan, event);\n        },\n\n\n        // Returns new zoned date information for an event segment being resized from its start OR end\n        // `type` is either 'start' or 'end'.\n        // DOES NOT consider overlap/constraint.\n        computeEventResize: function(type, startSpan, endSpan, event) {\n            var calendar = this.view.calendar;\n            var delta = this.diffDates(endSpan[type], startSpan[type]);\n            var resizeLocation; // zoned event date properties\n            var defaultDuration;\n\n            // build original values to work from, guaranteeing a start and end\n            resizeLocation = {\n                start: event.start.clone(),\n                end: calendar.getEventEnd(event),\n                allDay: event.allDay\n            };\n\n            // if an all-day event was in a timed area and was resized to a time, adjust start/end to have times\n            if (resizeLocation.allDay && durationHasTime(delta)) {\n                resizeLocation.allDay = false;\n                calendar.normalizeEventTimes(resizeLocation);\n            }\n\n            resizeLocation[type].add(delta); // apply delta to start or end\n\n            // if the event was compressed too small, find a new reasonable duration for it\n            if (!resizeLocation.start.isBefore(resizeLocation.end)) {\n\n                defaultDuration =\n                    this.minResizeDuration || // TODO: hack\n                    (event.allDay ?\n                        calendar.defaultAllDayEventDuration :\n                        calendar.defaultTimedEventDuration);\n\n                if (type == 'start') { // resizing the start?\n                    resizeLocation.start = resizeLocation.end.clone().subtract(defaultDuration);\n                }\n                else { // resizing the end?\n                    resizeLocation.end = resizeLocation.start.clone().add(defaultDuration);\n                }\n            }\n\n            return resizeLocation;\n        },\n\n\n        // Renders a visual indication of an event being resized.\n        // `range` has the updated dates of the event. `seg` is the original segment object involved in the drag.\n        // Must return elements used for any mock events.\n        renderEventResize: function(range, seg) {\n            // subclasses must implement\n        },\n\n\n        // Unrenders a visual indication of an event being resized.\n        unrenderEventResize: function() {\n            // subclasses must implement\n        },\n\n\n        /* Rendering Utils\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Compute the text that should be displayed on an event's element.\n        // `range` can be the Event object itself, or something range-like, with at least a `start`.\n        // If event times are disabled, or the event has no time, will return a blank string.\n        // If not specified, formatStr will default to the eventTimeFormat setting,\n        // and displayEnd will default to the displayEventEnd setting.\n        getEventTimeText: function(range, formatStr, displayEnd) {\n\n            if (formatStr == null) {\n                formatStr = this.eventTimeFormat;\n            }\n\n            if (displayEnd == null) {\n                displayEnd = this.displayEventEnd;\n            }\n\n            if (this.displayEventTime && range.start.hasTime()) {\n                if (displayEnd && range.end) {\n                    return this.view.formatRange(range, formatStr);\n                }\n                else {\n                    return range.start.format(formatStr);\n                }\n            }\n\n            return '';\n        },\n\n\n        // Generic utility for generating the HTML classNames for an event segment's element\n        getSegClasses: function(seg, isDraggable, isResizable) {\n            var view = this.view;\n            var classes = [\n                'fc-event',\n                seg.isStart ? 'fc-start' : 'fc-not-start',\n                seg.isEnd ? 'fc-end' : 'fc-not-end'\n            ].concat(this.getSegCustomClasses(seg));\n\n            if (isDraggable) {\n                classes.push('fc-draggable');\n            }\n            if (isResizable) {\n                classes.push('fc-resizable');\n            }\n\n            // event is currently selected? attach a className.\n            if (view.isEventSelected(seg.event)) {\n                classes.push('fc-selected');\n            }\n\n            return classes;\n        },\n\n\n        // List of classes that were defined by the caller of the API in some way\n        getSegCustomClasses: function(seg) {\n            var event = seg.event;\n\n            return [].concat(\n                event.className, // guaranteed to be an array\n                event.source ? event.source.className : []\n            );\n        },\n\n\n        // Utility for generating event skin-related CSS properties\n        getSegSkinCss: function(seg) {\n            return {\n                'background-color': this.getSegBackgroundColor(seg),\n                'border-color': this.getSegBorderColor(seg),\n                color: this.getSegTextColor(seg)\n            };\n        },\n\n\n        // Queries for caller-specified color, then falls back to default\n        getSegBackgroundColor: function(seg) {\n            return seg.event.backgroundColor ||\n                seg.event.color ||\n                this.getSegDefaultBackgroundColor(seg);\n        },\n\n\n        getSegDefaultBackgroundColor: function(seg) {\n            var source = seg.event.source || {};\n\n            return source.backgroundColor ||\n                source.color ||\n                this.view.opt('eventBackgroundColor') ||\n                this.view.opt('eventColor');\n        },\n\n\n        // Queries for caller-specified color, then falls back to default\n        getSegBorderColor: function(seg) {\n            return seg.event.borderColor ||\n                seg.event.color ||\n                this.getSegDefaultBorderColor(seg);\n        },\n\n\n        getSegDefaultBorderColor: function(seg) {\n            var source = seg.event.source || {};\n\n            return source.borderColor ||\n                source.color ||\n                this.view.opt('eventBorderColor') ||\n                this.view.opt('eventColor');\n        },\n\n\n        // Queries for caller-specified color, then falls back to default\n        getSegTextColor: function(seg) {\n            return seg.event.textColor ||\n                this.getSegDefaultTextColor(seg);\n        },\n\n\n        getSegDefaultTextColor: function(seg) {\n            var source = seg.event.source || {};\n\n            return source.textColor ||\n                this.view.opt('eventTextColor');\n        },\n\n\n        /* Event Location Validation\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        isEventLocationAllowed: function(eventLocation, event) {\n            if (this.isEventLocationInRange(eventLocation)) {\n                var calendar = this.view.calendar;\n                var eventSpans = this.eventToSpans(eventLocation);\n                var i;\n\n                if (eventSpans.length) {\n                    for (i = 0; i < eventSpans.length; i++) {\n                        if (!calendar.isEventSpanAllowed(eventSpans[i], event)) {\n                            return false;\n                        }\n                    }\n\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n\n        isExternalLocationAllowed: function(eventLocation, metaProps) { // FOR the external element\n            if (this.isEventLocationInRange(eventLocation)) {\n                var calendar = this.view.calendar;\n                var eventSpans = this.eventToSpans(eventLocation);\n                var i;\n\n                if (eventSpans.length) {\n                    for (i = 0; i < eventSpans.length; i++) {\n                        if (!calendar.isExternalSpanAllowed(eventSpans[i], eventLocation, metaProps)) {\n                            return false;\n                        }\n                    }\n\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n\n        isEventLocationInRange: function(eventLocation) {\n            return isRangeWithinRange(\n                this.eventToRawRange(eventLocation),\n                this.view.validRange\n            );\n        },\n\n\n        /* Converting events -> eventRange -> eventSpan -> eventSegs\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Generates an array of segments for the given single event\n        // Can accept an event \"location\" as well (which only has start/end and no allDay)\n        eventToSegs: function(event) {\n            return this.eventsToSegs([ event ]);\n        },\n\n\n        // Generates spans (always unzoned) for the given event.\n        // Does not do any inverting for inverse-background events.\n        // Can accept an event \"location\" as well (which only has start/end and no allDay)\n        eventToSpans: function(event) {\n            var eventRange = this.eventToRange(event); // { start, end, isStart, isEnd }\n\n            if (eventRange) {\n                return this.eventRangeToSpans(eventRange, event);\n            }\n            else { // out of view's valid range\n                return [];\n            }\n        },\n\n\n\n        // Converts an array of event objects into an array of event segment objects.\n        // A custom `segSliceFunc` may be given for arbitrarily slicing up events.\n        // Doesn't guarantee an order for the resulting array.\n        eventsToSegs: function(allEvents, segSliceFunc) {\n            var _this = this;\n            var eventsById = groupEventsById(allEvents);\n            var segs = [];\n\n            $.each(eventsById, function(id, events) {\n                var visibleEvents = [];\n                var eventRanges = [];\n                var eventRange; // { start, end, isStart, isEnd }\n                var i;\n\n                for (i = 0; i < events.length; i++) {\n                    eventRange = _this.eventToRange(events[i]); // might be null if completely out of range\n\n                    if (eventRange) {\n                        eventRanges.push(eventRange);\n                        visibleEvents.push(events[i]);\n                    }\n                }\n\n                // inverse-background events (utilize only the first event in calculations)\n                if (isInverseBgEvent(events[0])) {\n                    eventRanges = _this.invertRanges(eventRanges); // will lose isStart/isEnd\n\n                    for (i = 0; i < eventRanges.length; i++) {\n                        segs.push.apply(segs, // append to\n                            _this.eventRangeToSegs(eventRanges[i], events[0], segSliceFunc)\n                        );\n                    }\n                }\n                // normal event ranges\n                else {\n                    for (i = 0; i < eventRanges.length; i++) {\n                        segs.push.apply(segs, // append to\n                            _this.eventRangeToSegs(eventRanges[i], visibleEvents[i], segSliceFunc)\n                        );\n                    }\n                }\n            });\n\n            return segs;\n        },\n\n\n        // Generates the unzoned start/end dates an event appears to occupy\n        // Can accept an event \"location\" as well (which only has start/end and no allDay)\n        // returns { start, end, isStart, isEnd }\n        // If the event is completely outside of the grid's valid range, will return undefined.\n        eventToRange: function(event) {\n            return this.refineRawEventRange(\n                this.eventToRawRange(event)\n            );\n        },\n\n\n        // Ensures the given range is within the view's activeRange and is correctly localized.\n        // Always returns a result\n        refineRawEventRange: function(rawRange) {\n            var view = this.view;\n            var calendar = view.calendar;\n            var range = intersectRanges(rawRange, view.activeRange);\n\n            if (range) { // otherwise, event doesn't have valid range\n\n                // hack: dynamic locale change forgets to upate stored event localed\n                calendar.localizeMoment(range.start);\n                calendar.localizeMoment(range.end);\n\n                return range;\n            }\n        },\n\n\n        // not constrained to valid dates\n        // not given localizeMoment hack\n        eventToRawRange: function(event) {\n            var calendar = this.view.calendar;\n            var start = event.start.clone().stripZone();\n            var end = (\n                event.end ?\n                    event.end.clone() :\n                    // derive the end from the start and allDay. compute allDay if necessary\n                    calendar.getDefaultEventEnd(\n                        event.allDay != null ?\n                            event.allDay :\n                            !event.start.hasTime(),\n                        event.start\n                    )\n            ).stripZone();\n\n            return { start: start, end: end };\n        },\n\n\n        // Given an event's range (unzoned start/end), and the event itself,\n        // slice into segments (using the segSliceFunc function if specified)\n        // eventRange - { start, end, isStart, isEnd }\n        eventRangeToSegs: function(eventRange, event, segSliceFunc) {\n            var eventSpans = this.eventRangeToSpans(eventRange, event);\n            var segs = [];\n            var i;\n\n            for (i = 0; i < eventSpans.length; i++) {\n                segs.push.apply(segs, // append to\n                    this.eventSpanToSegs(eventSpans[i], event, segSliceFunc)\n                );\n            }\n\n            return segs;\n        },\n\n\n        // Given an event's unzoned date range, return an array of eventSpan objects.\n        // eventSpan - { start, end, isStart, isEnd, otherthings... }\n        // Subclasses can override.\n        // Subclasses are obligated to forward eventRange.isStart/isEnd to the resulting spans.\n        eventRangeToSpans: function(eventRange, event) {\n            return [ $.extend({}, eventRange) ]; // copy into a single-item array\n        },\n\n\n        // Given an event's span (unzoned start/end and other misc data), and the event itself,\n        // slices into segments and attaches event-derived properties to them.\n        // eventSpan - { start, end, isStart, isEnd, otherthings... }\n        eventSpanToSegs: function(eventSpan, event, segSliceFunc) {\n            var segs = segSliceFunc ? segSliceFunc(eventSpan) : this.spanToSegs(eventSpan);\n            var i, seg;\n\n            for (i = 0; i < segs.length; i++) {\n                seg = segs[i];\n\n                // the eventSpan's isStart/isEnd takes precedence over the seg's\n                if (!eventSpan.isStart) {\n                    seg.isStart = false;\n                }\n                if (!eventSpan.isEnd) {\n                    seg.isEnd = false;\n                }\n\n                seg.event = event;\n                seg.eventStartMS = +eventSpan.start; // TODO: not the best name after making spans unzoned\n                seg.eventDurationMS = eventSpan.end - eventSpan.start;\n            }\n\n            return segs;\n        },\n\n\n        // Produces a new array of range objects that will cover all the time NOT covered by the given ranges.\n        // SIDE EFFECT: will mutate the given array and will use its date references.\n        invertRanges: function(ranges) {\n            var view = this.view;\n            var viewStart = view.activeRange.start.clone(); // need a copy\n            var viewEnd = view.activeRange.end.clone(); // need a copy\n            var inverseRanges = [];\n            var start = viewStart; // the end of the previous range. the start of the new range\n            var i, range;\n\n            // ranges need to be in order. required for our date-walking algorithm\n            ranges.sort(compareRanges);\n\n            for (i = 0; i < ranges.length; i++) {\n                range = ranges[i];\n\n                // add the span of time before the event (if there is any)\n                if (range.start > start) { // compare millisecond time (skip any ambig logic)\n                    inverseRanges.push({\n                        start: start,\n                        end: range.start\n                    });\n                }\n\n                if (range.end > start) {\n                    start = range.end;\n                }\n            }\n\n            // add the span of time after the last event (if there is any)\n            if (start < viewEnd) { // compare millisecond time (skip any ambig logic)\n                inverseRanges.push({\n                    start: start,\n                    end: viewEnd\n                });\n            }\n\n            return inverseRanges;\n        },\n\n\n        sortEventSegs: function(segs) {\n            segs.sort(proxy(this, 'compareEventSegs'));\n        },\n\n\n        // A cmp function for determining which segments should take visual priority\n        compareEventSegs: function(seg1, seg2) {\n            return seg1.eventStartMS - seg2.eventStartMS || // earlier events go first\n                seg2.eventDurationMS - seg1.eventDurationMS || // tie? longer events go first\n                seg2.event.allDay - seg1.event.allDay || // tie? put all-day events first (booleans cast to 0/1)\n                compareByFieldSpecs(seg1.event, seg2.event, this.view.eventOrderSpecs);\n        }\n\n    });\n\n\n    /* Utilities\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n\n    function pluckEventDateProps(event) {\n        return {\n            start: event.start.clone(),\n            end: event.end ? event.end.clone() : null,\n            allDay: event.allDay // keep it the same\n        };\n    }\n    FC.pluckEventDateProps = pluckEventDateProps;\n\n\n    function isBgEvent(event) { // returns true if background OR inverse-background\n        var rendering = getEventRendering(event);\n        return rendering === 'background' || rendering === 'inverse-background';\n    }\n    FC.isBgEvent = isBgEvent; // export\n\n\n    function isInverseBgEvent(event) {\n        return getEventRendering(event) === 'inverse-background';\n    }\n\n\n    function getEventRendering(event) {\n        return firstDefined((event.source || {}).rendering, event.rendering);\n    }\n\n\n    function groupEventsById(events) {\n        var eventsById = {};\n        var i, event;\n\n        for (i = 0; i < events.length; i++) {\n            event = events[i];\n            (eventsById[event._id] || (eventsById[event._id] = [])).push(event);\n        }\n\n        return eventsById;\n    }\n\n\n// A cmp function for determining which non-inverted \"ranges\" (see above) happen earlier\n    function compareRanges(range1, range2) {\n        return range1.start - range2.start; // earlier ranges go first\n    }\n\n\n    /* External-Dragging-Element Data\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.\n// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.\n    FC.dataAttrPrefix = '';\n\n// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure\n// to be used for Event Object creation.\n// A defined `.eventProps`, even when empty, indicates that an event should be created.\n    function getDraggedElMeta(el) {\n        var prefix = FC.dataAttrPrefix;\n        var eventProps; // properties for creating the event, not related to date/time\n        var startTime; // a Duration\n        var duration;\n        var stick;\n\n        if (prefix) { prefix += '-'; }\n        eventProps = el.data(prefix + 'event') || null;\n\n        if (eventProps) {\n            if (typeof eventProps === 'object') {\n                eventProps = $.extend({}, eventProps); // make a copy\n            }\n            else { // something like 1 or true. still signal event creation\n                eventProps = {};\n            }\n\n            // pluck special-cased date/time properties\n            startTime = eventProps.start;\n            if (startTime == null) { startTime = eventProps.time; } // accept 'time' as well\n            duration = eventProps.duration;\n            stick = eventProps.stick;\n            delete eventProps.start;\n            delete eventProps.time;\n            delete eventProps.duration;\n            delete eventProps.stick;\n        }\n\n        // fallback to standalone attribute values for each of the date/time properties\n        if (startTime == null) { startTime = el.data(prefix + 'start'); }\n        if (startTime == null) { startTime = el.data(prefix + 'time'); } // accept 'time' as well\n        if (duration == null) { duration = el.data(prefix + 'duration'); }\n        if (stick == null) { stick = el.data(prefix + 'stick'); }\n\n        // massage into correct data types\n        startTime = startTime != null ? moment.duration(startTime) : null;\n        duration = duration != null ? moment.duration(duration) : null;\n        stick = Boolean(stick);\n\n        return { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };\n    }\n\n\n    ;;\n\n    /*\n     A set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.\n     Prerequisite: the object being mixed into needs to be a *Grid*\n     */\n    var DayTableMixin = FC.DayTableMixin = {\n\n        breakOnWeeks: false, // should create a new row for each week?\n        dayDates: null, // whole-day dates for each column. left to right\n        dayIndices: null, // for each day from start, the offset\n        daysPerRow: null,\n        rowCnt: null,\n        colCnt: null,\n        colHeadFormat: null,\n\n\n        // Populates internal variables used for date calculation and rendering\n        updateDayTable: function() {\n            var view = this.view;\n            var date = this.start.clone();\n            var dayIndex = -1;\n            var dayIndices = [];\n            var dayDates = [];\n            var daysPerRow;\n            var firstDay;\n            var rowCnt;\n\n            while (date.isBefore(this.end)) { // loop each day from start to end\n                if (view.isHiddenDay(date)) {\n                    dayIndices.push(dayIndex + 0.5); // mark that it's between indices\n                }\n                else {\n                    dayIndex++;\n                    dayIndices.push(dayIndex);\n                    dayDates.push(date.clone());\n                }\n                date.add(1, 'days');\n            }\n\n            if (this.breakOnWeeks) {\n                // count columns until the day-of-week repeats\n                firstDay = dayDates[0].day();\n                for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {\n                    if (dayDates[daysPerRow].day() == firstDay) {\n                        break;\n                    }\n                }\n                rowCnt = Math.ceil(dayDates.length / daysPerRow);\n            }\n            else {\n                rowCnt = 1;\n                daysPerRow = dayDates.length;\n            }\n\n            this.dayDates = dayDates;\n            this.dayIndices = dayIndices;\n            this.daysPerRow = daysPerRow;\n            this.rowCnt = rowCnt;\n\n            this.updateDayTableCols();\n        },\n\n\n        // Computes and assigned the colCnt property and updates any options that may be computed from it\n        updateDayTableCols: function() {\n            this.colCnt = this.computeColCnt();\n            this.colHeadFormat = this.view.opt('columnFormat') || this.computeColHeadFormat();\n        },\n\n\n        // Determines how many columns there should be in the table\n        computeColCnt: function() {\n            return this.daysPerRow;\n        },\n\n\n        // Computes the ambiguously-timed moment for the given cell\n        getCellDate: function(row, col) {\n            return this.dayDates[\n                this.getCellDayIndex(row, col)\n                ].clone();\n        },\n\n\n        // Computes the ambiguously-timed date range for the given cell\n        getCellRange: function(row, col) {\n            var start = this.getCellDate(row, col);\n            var end = start.clone().add(1, 'days');\n\n            return { start: start, end: end };\n        },\n\n\n        // Returns the number of day cells, chronologically, from the first of the grid (0-based)\n        getCellDayIndex: function(row, col) {\n            return row * this.daysPerRow + this.getColDayIndex(col);\n        },\n\n\n        // Returns the numner of day cells, chronologically, from the first cell in *any given row*\n        getColDayIndex: function(col) {\n            if (this.isRTL) {\n                return this.colCnt - 1 - col;\n            }\n            else {\n                return col;\n            }\n        },\n\n\n        // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n        // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n        // If before the first offset, returns a negative number.\n        // If after the last offset, returns an offset past the last cell offset.\n        // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n        getDateDayIndex: function(date) {\n            var dayIndices = this.dayIndices;\n            var dayOffset = date.diff(this.start, 'days');\n\n            if (dayOffset < 0) {\n                return dayIndices[0] - 1;\n            }\n            else if (dayOffset >= dayIndices.length) {\n                return dayIndices[dayIndices.length - 1] + 1;\n            }\n            else {\n                return dayIndices[dayOffset];\n            }\n        },\n\n\n        /* Options\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Computes a default column header formatting string if `colFormat` is not explicitly defined\n        computeColHeadFormat: function() {\n            // if more than one week row, or if there are a lot of columns with not much space,\n            // put just the day numbers will be in each cell\n            if (this.rowCnt > 1 || this.colCnt > 10) {\n                return 'ddd'; // \"Sat\"\n            }\n            // multiple days, so full single date string WON'T be in title text\n            else if (this.colCnt > 1) {\n                return this.view.opt('dayOfMonthFormat'); // \"Sat 12/10\"\n            }\n            // single day, so full single date string will probably be in title text\n            else {\n                return 'dddd'; // \"Saturday\"\n            }\n        },\n\n\n        /* Slicing\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Slices up a date range into a segment for every week-row it intersects with\n        sliceRangeByRow: function(range) {\n            var daysPerRow = this.daysPerRow;\n            var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold\n            var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\n            var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\n            var segs = [];\n            var row;\n            var rowFirst, rowLast; // inclusive day-index range for current row\n            var segFirst, segLast; // inclusive day-index range for segment\n\n            for (row = 0; row < this.rowCnt; row++) {\n                rowFirst = row * daysPerRow;\n                rowLast = rowFirst + daysPerRow - 1;\n\n                // intersect segment's offset range with the row's\n                segFirst = Math.max(rangeFirst, rowFirst);\n                segLast = Math.min(rangeLast, rowLast);\n\n                // deal with in-between indices\n                segFirst = Math.ceil(segFirst); // in-between starts round to next cell\n                segLast = Math.floor(segLast); // in-between ends round to prev cell\n\n                if (segFirst <= segLast) { // was there any intersection with the current row?\n                    segs.push({\n                        row: row,\n\n                        // normalize to start of row\n                        firstRowDayIndex: segFirst - rowFirst,\n                        lastRowDayIndex: segLast - rowFirst,\n\n                        // must be matching integers to be the segment's start/end\n                        isStart: segFirst === rangeFirst,\n                        isEnd: segLast === rangeLast\n                    });\n                }\n            }\n\n            return segs;\n        },\n\n\n        // Slices up a date range into a segment for every day-cell it intersects with.\n        // TODO: make more DRY with sliceRangeByRow somehow.\n        sliceRangeByDay: function(range) {\n            var daysPerRow = this.daysPerRow;\n            var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold\n            var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\n            var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\n            var segs = [];\n            var row;\n            var rowFirst, rowLast; // inclusive day-index range for current row\n            var i;\n            var segFirst, segLast; // inclusive day-index range for segment\n\n            for (row = 0; row < this.rowCnt; row++) {\n                rowFirst = row * daysPerRow;\n                rowLast = rowFirst + daysPerRow - 1;\n\n                for (i = rowFirst; i <= rowLast; i++) {\n\n                    // intersect segment's offset range with the row's\n                    segFirst = Math.max(rangeFirst, i);\n                    segLast = Math.min(rangeLast, i);\n\n                    // deal with in-between indices\n                    segFirst = Math.ceil(segFirst); // in-between starts round to next cell\n                    segLast = Math.floor(segLast); // in-between ends round to prev cell\n\n                    if (segFirst <= segLast) { // was there any intersection with the current row?\n                        segs.push({\n                            row: row,\n\n                            // normalize to start of row\n                            firstRowDayIndex: segFirst - rowFirst,\n                            lastRowDayIndex: segLast - rowFirst,\n\n                            // must be matching integers to be the segment's start/end\n                            isStart: segFirst === rangeFirst,\n                            isEnd: segLast === rangeLast\n                        });\n                    }\n                }\n            }\n\n            return segs;\n        },\n\n\n        /* Header Rendering\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        renderHeadHtml: function() {\n            var view = this.view;\n\n            return '' +\n                '<div class=\"fc-row ' + view.widgetHeaderClass + '\">' +\n                '<table>' +\n                '<thead>' +\n                this.renderHeadTrHtml() +\n                '</thead>' +\n                '</table>' +\n                '</div>';\n        },\n\n\n        renderHeadIntroHtml: function() {\n            return this.renderIntroHtml(); // fall back to generic\n        },\n\n\n        renderHeadTrHtml: function() {\n            return '' +\n                '<tr>' +\n                (this.isRTL ? '' : this.renderHeadIntroHtml()) +\n                this.renderHeadDateCellsHtml() +\n                (this.isRTL ? this.renderHeadIntroHtml() : '') +\n                '</tr>';\n        },\n\n\n        renderHeadDateCellsHtml: function() {\n            var htmls = [];\n            var col, date;\n\n            for (col = 0; col < this.colCnt; col++) {\n                date = this.getCellDate(0, col);\n                htmls.push(this.renderHeadDateCellHtml(date));\n            }\n\n            return htmls.join('');\n        },\n\n\n        // TODO: when internalApiVersion, accept an object for HTML attributes\n        // (colspan should be no different)\n        renderHeadDateCellHtml: function(date, colspan, otherAttrs) {\n            var view = this.view;\n            var isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.\n            var classNames = [\n                'fc-day-header',\n                view.widgetHeaderClass\n            ];\n            var innerHtml = htmlEscape(date.format(this.colHeadFormat));\n\n            // if only one row of days, the classNames on the header can represent the specific days beneath\n            if (this.rowCnt === 1) {\n                classNames = classNames.concat(\n                    // includes the day-of-week class\n                    // noThemeHighlight=true (don't highlight the header)\n                    this.getDayClasses(date, true)\n                );\n            }\n            else {\n                classNames.push('fc-' + dayIDs[date.day()]); // only add the day-of-week class\n            }\n\n            return '' +\n                '<th class=\"' + classNames.join(' ') + '\"' +\n                ((isDateValid && this.rowCnt) === 1 ?\n                    ' data-date=\"' + date.format('YYYY-MM-DD') + '\"' :\n                    '') +\n                (colspan > 1 ?\n                    ' colspan=\"' + colspan + '\"' :\n                    '') +\n                (otherAttrs ?\n                    ' ' + otherAttrs :\n                    '') +\n                '>' +\n                (isDateValid ?\n                        // don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)\n                        view.buildGotoAnchorHtml(\n                            { date: date, forceOff: this.rowCnt > 1 || this.colCnt === 1 },\n                            innerHtml\n                        ) :\n                        // if not valid, display text, but no link\n                        innerHtml\n                ) +\n                '</th>';\n        },\n\n\n        /* Background Rendering\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        renderBgTrHtml: function(row) {\n            return '' +\n                '<tr>' +\n                (this.isRTL ? '' : this.renderBgIntroHtml(row)) +\n                this.renderBgCellsHtml(row) +\n                (this.isRTL ? this.renderBgIntroHtml(row) : '') +\n                '</tr>';\n        },\n\n\n        renderBgIntroHtml: function(row) {\n            return this.renderIntroHtml(); // fall back to generic\n        },\n\n\n        renderBgCellsHtml: function(row) {\n            var htmls = [];\n            var col, date;\n\n            for (col = 0; col < this.colCnt; col++) {\n                date = this.getCellDate(row, col);\n                htmls.push(this.renderBgCellHtml(date));\n            }\n\n            return htmls.join('');\n        },\n\n\n        renderBgCellHtml: function(date, otherAttrs) {\n            var view = this.view;\n            var isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.\n            var classes = this.getDayClasses(date);\n\n            classes.unshift('fc-day', view.widgetContentClass);\n\n            return '<td class=\"' + classes.join(' ') + '\"' +\n                (isDateValid ?\n                    ' data-date=\"' + date.format('YYYY-MM-DD') + '\"' : // if date has a time, won't format it\n                    '') +\n                (otherAttrs ?\n                    ' ' + otherAttrs :\n                    '') +\n                '></td>';\n        },\n\n\n        /* Generic\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Generates the default HTML intro for any row. User classes should override\n        renderIntroHtml: function() {\n        },\n\n\n        // TODO: a generic method for dealing with <tr>, RTL, intro\n        // when increment internalApiVersion\n        // wrapTr (scheduler)\n\n\n        /* Utils\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Applies the generic \"intro\" and \"outro\" HTML to the given cells.\n        // Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.\n        bookendCells: function(trEl) {\n            var introHtml = this.renderIntroHtml();\n\n            if (introHtml) {\n                if (this.isRTL) {\n                    trEl.append(introHtml);\n                }\n                else {\n                    trEl.prepend(introHtml);\n                }\n            }\n        }\n\n    };\n\n    ;;\n\n    /* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n    var DayGrid = FC.DayGrid = Grid.extend(DayTableMixin, {\n\n        numbersVisible: false, // should render a row for day/week numbers? set by outside view. TODO: make internal\n        bottomCoordPadding: 0, // hack for extending the hit area for the last row of the coordinate grid\n\n        rowEls: null, // set of fake row elements\n        cellEls: null, // set of whole-day elements comprising the row's background\n        helperEls: null, // set of cell skeleton elements for rendering the mock event \"helper\"\n\n        rowCoordCache: null,\n        colCoordCache: null,\n\n\n        // Renders the rows and columns into the component's `this.el`, which should already be assigned.\n        // isRigid determins whether the individual rows should ignore the contents and be a constant height.\n        // Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.\n        renderDates: function(isRigid) {\n            var view = this.view;\n            var rowCnt = this.rowCnt;\n            var colCnt = this.colCnt;\n            var html = '';\n            var row;\n            var col;\n\n            for (row = 0; row < rowCnt; row++) {\n                html += this.renderDayRowHtml(row, isRigid);\n            }\n            this.el.html(html);\n\n            this.rowEls = this.el.find('.fc-row');\n            this.cellEls = this.el.find('.fc-day, .fc-disabled-day');\n\n            this.rowCoordCache = new CoordCache({\n                els: this.rowEls,\n                isVertical: true\n            });\n            this.colCoordCache = new CoordCache({\n                els: this.cellEls.slice(0, this.colCnt), // only the first row\n                isHorizontal: true\n            });\n\n            // trigger dayRender with each cell's element\n            for (row = 0; row < rowCnt; row++) {\n                for (col = 0; col < colCnt; col++) {\n                    view.publiclyTrigger(\n                        'dayRender',\n                        null,\n                        this.getCellDate(row, col),\n                        this.getCellEl(row, col)\n                    );\n                }\n            }\n        },\n\n\n        unrenderDates: function() {\n            this.removeSegPopover();\n        },\n\n\n        renderBusinessHours: function() {\n            var segs = this.buildBusinessHourSegs(true); // wholeDay=true\n            this.renderFill('businessHours', segs, 'bgevent');\n        },\n\n\n        unrenderBusinessHours: function() {\n            this.unrenderFill('businessHours');\n        },\n\n\n        // Generates the HTML for a single row, which is a div that wraps a table.\n        // `row` is the row number.\n        renderDayRowHtml: function(row, isRigid) {\n            var view = this.view;\n            var classes = [ 'fc-row', 'fc-week', view.widgetContentClass ];\n\n            if (isRigid) {\n                classes.push('fc-rigid');\n            }\n\n            return '' +\n                '<div class=\"' + classes.join(' ') + '\">' +\n                '<div class=\"fc-bg\">' +\n                '<table>' +\n                this.renderBgTrHtml(row) +\n                '</table>' +\n                '</div>' +\n                '<div class=\"fc-content-skeleton\">' +\n                '<table>' +\n                (this.numbersVisible ?\n                        '<thead>' +\n                        this.renderNumberTrHtml(row) +\n                        '</thead>' :\n                        ''\n                ) +\n                '</table>' +\n                '</div>' +\n                '</div>';\n        },\n\n\n        /* Grid Number Rendering\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        renderNumberTrHtml: function(row) {\n            return '' +\n                '<tr>' +\n                (this.isRTL ? '' : this.renderNumberIntroHtml(row)) +\n                this.renderNumberCellsHtml(row) +\n                (this.isRTL ? this.renderNumberIntroHtml(row) : '') +\n                '</tr>';\n        },\n\n\n        renderNumberIntroHtml: function(row) {\n            return this.renderIntroHtml();\n        },\n\n\n        renderNumberCellsHtml: function(row) {\n            var htmls = [];\n            var col, date;\n\n            for (col = 0; col < this.colCnt; col++) {\n                date = this.getCellDate(row, col);\n                htmls.push(this.renderNumberCellHtml(date));\n            }\n\n            return htmls.join('');\n        },\n\n\n        // Generates the HTML for the <td>s of the \"number\" row in the DayGrid's content skeleton.\n        // The number row will only exist if either day numbers or week numbers are turned on.\n        renderNumberCellHtml: function(date) {\n            var view = this.view;\n            var html = '';\n            var isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.\n            var isDayNumberVisible = view.dayNumbersVisible && isDateValid;\n            var classes;\n            var weekCalcFirstDoW;\n\n            if (!isDayNumberVisible && !view.cellWeekNumbersVisible) {\n                // no numbers in day cell (week number must be along the side)\n                return '<td/>'; //  will create an empty space above events :(\n            }\n\n            classes = this.getDayClasses(date);\n            classes.unshift('fc-day-top');\n\n            if (view.cellWeekNumbersVisible) {\n                // To determine the day of week number change under ISO, we cannot\n                // rely on moment.js methods such as firstDayOfWeek() or weekday(),\n                // because they rely on the locale's dow (possibly overridden by\n                // our firstDay option), which may not be Monday. We cannot change\n                // dow, because that would affect the calendar start day as well.\n                if (date._locale._fullCalendar_weekCalc === 'ISO') {\n                    weekCalcFirstDoW = 1;  // Monday by ISO 8601 definition\n                }\n                else {\n                    weekCalcFirstDoW = date._locale.firstDayOfWeek();\n                }\n            }\n\n            html += '<td class=\"' + classes.join(' ') + '\"' +\n                (isDateValid ?\n                        ' data-date=\"' + date.format() + '\"' :\n                        ''\n                ) +\n                '>';\n\n            if (view.cellWeekNumbersVisible && (date.day() == weekCalcFirstDoW)) {\n                html += view.buildGotoAnchorHtml(\n                    { date: date, type: 'week' },\n                    { 'class': 'fc-week-number' },\n                    date.format('w') // inner HTML\n                );\n            }\n\n            if (isDayNumberVisible) {\n                html += view.buildGotoAnchorHtml(\n                    date,\n                    { 'class': 'fc-day-number' },\n                    date.date() // inner HTML\n                );\n            }\n\n            html += '</td>';\n\n            return html;\n        },\n\n\n        /* Options\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Computes a default event time formatting string if `timeFormat` is not explicitly defined\n        computeEventTimeFormat: function() {\n            return this.view.opt('extraSmallTimeFormat'); // like \"6p\" or \"6:30p\"\n        },\n\n\n        // Computes a default `displayEventEnd` value if one is not expliclty defined\n        computeDisplayEventEnd: function() {\n            return this.colCnt == 1; // we'll likely have space if there's only one day\n        },\n\n\n        /* Dates\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        rangeUpdated: function() {\n            this.updateDayTable();\n        },\n\n\n        // Slices up the given span (unzoned start/end with other misc data) into an array of segments\n        spanToSegs: function(span) {\n            var segs = this.sliceRangeByRow(span);\n            var i, seg;\n\n            for (i = 0; i < segs.length; i++) {\n                seg = segs[i];\n                if (this.isRTL) {\n                    seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;\n                    seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;\n                }\n                else {\n                    seg.leftCol = seg.firstRowDayIndex;\n                    seg.rightCol = seg.lastRowDayIndex;\n                }\n            }\n\n            return segs;\n        },\n\n\n        /* Hit System\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        prepareHits: function() {\n            this.colCoordCache.build();\n            this.rowCoordCache.build();\n            this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack\n        },\n\n\n        releaseHits: function() {\n            this.colCoordCache.clear();\n            this.rowCoordCache.clear();\n        },\n\n\n        queryHit: function(leftOffset, topOffset) {\n            if (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {\n                var col = this.colCoordCache.getHorizontalIndex(leftOffset);\n                var row = this.rowCoordCache.getVerticalIndex(topOffset);\n\n                if (row != null && col != null) {\n                    return this.getCellHit(row, col);\n                }\n            }\n        },\n\n\n        getHitSpan: function(hit) {\n            return this.getCellRange(hit.row, hit.col);\n        },\n\n\n        getHitEl: function(hit) {\n            return this.getCellEl(hit.row, hit.col);\n        },\n\n\n        /* Cell System\n         ------------------------------------------------------------------------------------------------------------------*/\n        // FYI: the first column is the leftmost column, regardless of date\n\n\n        getCellHit: function(row, col) {\n            return {\n                row: row,\n                col: col,\n                component: this, // needed unfortunately :(\n                left: this.colCoordCache.getLeftOffset(col),\n                right: this.colCoordCache.getRightOffset(col),\n                top: this.rowCoordCache.getTopOffset(row),\n                bottom: this.rowCoordCache.getBottomOffset(row)\n            };\n        },\n\n\n        getCellEl: function(row, col) {\n            return this.cellEls.eq(row * this.colCnt + col);\n        },\n\n\n        /* Event Drag Visualization\n         ------------------------------------------------------------------------------------------------------------------*/\n        // TODO: move to DayGrid.event, similar to what we did with Grid's drag methods\n\n\n        // Renders a visual indication of an event or external element being dragged.\n        // `eventLocation` has zoned start and end (optional)\n        renderDrag: function(eventLocation, seg) {\n            var eventSpans = this.eventToSpans(eventLocation);\n            var i;\n\n            // always render a highlight underneath\n            for (i = 0; i < eventSpans.length; i++) {\n                this.renderHighlight(eventSpans[i]);\n            }\n\n            // if a segment from the same calendar but another component is being dragged, render a helper event\n            if (seg && seg.component !== this) {\n                return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements\n            }\n        },\n\n\n        // Unrenders any visual indication of a hovering event\n        unrenderDrag: function() {\n            this.unrenderHighlight();\n            this.unrenderHelper();\n        },\n\n\n        /* Event Resize Visualization\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders a visual indication of an event being resized\n        renderEventResize: function(eventLocation, seg) {\n            var eventSpans = this.eventToSpans(eventLocation);\n            var i;\n\n            for (i = 0; i < eventSpans.length; i++) {\n                this.renderHighlight(eventSpans[i]);\n            }\n\n            return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements\n        },\n\n\n        // Unrenders a visual indication of an event being resized\n        unrenderEventResize: function() {\n            this.unrenderHighlight();\n            this.unrenderHelper();\n        },\n\n\n        /* Event Helper\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders a mock \"helper\" event. `sourceSeg` is the associated internal segment object. It can be null.\n        renderHelper: function(event, sourceSeg) {\n            var helperNodes = [];\n            var segs = this.eventToSegs(event);\n            var rowStructs;\n\n            segs = this.renderFgSegEls(segs); // assigns each seg's el and returns a subset of segs that were rendered\n            rowStructs = this.renderSegRows(segs);\n\n            // inject each new event skeleton into each associated row\n            this.rowEls.each(function(row, rowNode) {\n                var rowEl = $(rowNode); // the .fc-row\n                var skeletonEl = $('<div class=\"fc-helper-skeleton\"><table/></div>'); // will be absolutely positioned\n                var skeletonTop;\n\n                // If there is an original segment, match the top position. Otherwise, put it at the row's top level\n                if (sourceSeg && sourceSeg.row === row) {\n                    skeletonTop = sourceSeg.el.position().top;\n                }\n                else {\n                    skeletonTop = rowEl.find('.fc-content-skeleton tbody').position().top;\n                }\n\n                skeletonEl.css('top', skeletonTop)\n                    .find('table')\n                    .append(rowStructs[row].tbodyEl);\n\n                rowEl.append(skeletonEl);\n                helperNodes.push(skeletonEl[0]);\n            });\n\n            return ( // must return the elements rendered\n                this.helperEls = $(helperNodes) // array -> jQuery set\n            );\n        },\n\n\n        // Unrenders any visual indication of a mock helper event\n        unrenderHelper: function() {\n            if (this.helperEls) {\n                this.helperEls.remove();\n                this.helperEls = null;\n            }\n        },\n\n\n        /* Fill System (highlight, background events, business hours)\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        fillSegTag: 'td', // override the default tag name\n\n\n        // Renders a set of rectangles over the given segments of days.\n        // Only returns segments that successfully rendered.\n        renderFill: function(type, segs, className) {\n            var nodes = [];\n            var i, seg;\n            var skeletonEl;\n\n            segs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs\n\n            for (i = 0; i < segs.length; i++) {\n                seg = segs[i];\n                skeletonEl = this.renderFillRow(type, seg, className);\n                this.rowEls.eq(seg.row).append(skeletonEl);\n                nodes.push(skeletonEl[0]);\n            }\n\n            this.elsByFill[type] = $(nodes);\n\n            return segs;\n        },\n\n\n        // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.\n        renderFillRow: function(type, seg, className) {\n            var colCnt = this.colCnt;\n            var startCol = seg.leftCol;\n            var endCol = seg.rightCol + 1;\n            var skeletonEl;\n            var trEl;\n\n            className = className || type.toLowerCase();\n\n            skeletonEl = $(\n                '<div class=\"fc-' + className + '-skeleton\">' +\n                '<table><tr/></table>' +\n                '</div>'\n            );\n            trEl = skeletonEl.find('tr');\n\n            if (startCol > 0) {\n                trEl.append('<td colspan=\"' + startCol + '\"/>');\n            }\n\n            trEl.append(\n                seg.el.attr('colspan', endCol - startCol)\n            );\n\n            if (endCol < colCnt) {\n                trEl.append('<td colspan=\"' + (colCnt - endCol) + '\"/>');\n            }\n\n            this.bookendCells(trEl);\n\n            return skeletonEl;\n        }\n\n    });\n\n    ;;\n\n    /* Event-rendering methods for the DayGrid class\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n    DayGrid.mixin({\n\n        rowStructs: null, // an array of objects, each holding information about a row's foreground event-rendering\n\n\n        // Unrenders all events currently rendered on the grid\n        unrenderEvents: function() {\n            this.removeSegPopover(); // removes the \"more..\" events popover\n            Grid.prototype.unrenderEvents.apply(this, arguments); // calls the super-method\n        },\n\n\n        // Retrieves all rendered segment objects currently rendered on the grid\n        getEventSegs: function() {\n            return Grid.prototype.getEventSegs.call(this) // get the segments from the super-method\n                .concat(this.popoverSegs || []); // append the segments from the \"more...\" popover\n        },\n\n\n        // Renders the given background event segments onto the grid\n        renderBgSegs: function(segs) {\n\n            // don't render timed background events\n            var allDaySegs = $.grep(segs, function(seg) {\n                return seg.event.allDay;\n            });\n\n            return Grid.prototype.renderBgSegs.call(this, allDaySegs); // call the super-method\n        },\n\n\n        // Renders the given foreground event segments onto the grid\n        renderFgSegs: function(segs) {\n            var rowStructs;\n\n            // render an `.el` on each seg\n            // returns a subset of the segs. segs that were actually rendered\n            segs = this.renderFgSegEls(segs);\n\n            rowStructs = this.rowStructs = this.renderSegRows(segs);\n\n            // append to each row's content skeleton\n            this.rowEls.each(function(i, rowNode) {\n                $(rowNode).find('.fc-content-skeleton > table').append(\n                    rowStructs[i].tbodyEl\n                );\n            });\n\n            return segs; // return only the segs that were actually rendered\n        },\n\n\n        // Unrenders all currently rendered foreground event segments\n        unrenderFgSegs: function() {\n            var rowStructs = this.rowStructs || [];\n            var rowStruct;\n\n            while ((rowStruct = rowStructs.pop())) {\n                rowStruct.tbodyEl.remove();\n            }\n\n            this.rowStructs = null;\n        },\n\n\n        // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.\n        // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).\n        // PRECONDITION: each segment shoud already have a rendered and assigned `.el`\n        renderSegRows: function(segs) {\n            var rowStructs = [];\n            var segRows;\n            var row;\n\n            segRows = this.groupSegRows(segs); // group into nested arrays\n\n            // iterate each row of segment groupings\n            for (row = 0; row < segRows.length; row++) {\n                rowStructs.push(\n                    this.renderSegRow(row, segRows[row])\n                );\n            }\n\n            return rowStructs;\n        },\n\n\n        // Builds the HTML to be used for the default element for an individual segment\n        fgSegHtml: function(seg, disableResizing) {\n            var view = this.view;\n            var event = seg.event;\n            var isDraggable = view.isEventDraggable(event);\n            var isResizableFromStart = !disableResizing && event.allDay &&\n                seg.isStart && view.isEventResizableFromStart(event);\n            var isResizableFromEnd = !disableResizing && event.allDay &&\n                seg.isEnd && view.isEventResizableFromEnd(event);\n            var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\n            var skinCss = cssToStr(this.getSegSkinCss(seg));\n            var timeHtml = '';\n            var timeText;\n            var titleHtml;\n\n            classes.unshift('fc-day-grid-event', 'fc-h-event');\n\n            // Only display a timed events time if it is the starting segment\n            if (seg.isStart) {\n                timeText = this.getEventTimeText(event);\n                if (timeText) {\n                    timeHtml = '<span class=\"fc-time\">' + htmlEscape(timeText) + '</span>';\n                }\n            }\n\n            titleHtml =\n                '<span class=\"fc-title\">' +\n                (htmlEscape(event.title || '') || '&nbsp;') + // we always want one line of height\n                '</span>';\n\n            return '<a class=\"' + classes.join(' ') + '\"' +\n                (event.url ?\n                        ' href=\"' + htmlEscape(event.url) + '\"' :\n                        ''\n                ) +\n                (skinCss ?\n                        ' style=\"' + skinCss + '\"' :\n                        ''\n                ) +\n                '>' +\n                '<div class=\"fc-content\">' +\n                (this.isRTL ?\n                        titleHtml + ' ' + timeHtml : // put a natural space in between\n                        timeHtml + ' ' + titleHtml   //\n                ) +\n                '</div>' +\n                (isResizableFromStart ?\n                        '<div class=\"fc-resizer fc-start-resizer\" />' :\n                        ''\n                ) +\n                (isResizableFromEnd ?\n                        '<div class=\"fc-resizer fc-end-resizer\" />' :\n                        ''\n                ) +\n                '</a>';\n        },\n\n\n        // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains\n        // the segments. Returns object with a bunch of internal data about how the render was calculated.\n        // NOTE: modifies rowSegs\n        renderSegRow: function(row, rowSegs) {\n            var colCnt = this.colCnt;\n            var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels\n            var levelCnt = Math.max(1, segLevels.length); // ensure at least one level\n            var tbody = $('<tbody/>');\n            var segMatrix = []; // lookup for which segments are rendered into which level+col cells\n            var cellMatrix = []; // lookup for all <td> elements of the level+col matrix\n            var loneCellMatrix = []; // lookup for <td> elements that only take up a single column\n            var i, levelSegs;\n            var col;\n            var tr;\n            var j, seg;\n            var td;\n\n            // populates empty cells from the current column (`col`) to `endCol`\n            function emptyCellsUntil(endCol) {\n                while (col < endCol) {\n                    // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell\n                    td = (loneCellMatrix[i - 1] || [])[col];\n                    if (td) {\n                        td.attr(\n                            'rowspan',\n                            parseInt(td.attr('rowspan') || 1, 10) + 1\n                        );\n                    }\n                    else {\n                        td = $('<td/>');\n                        tr.append(td);\n                    }\n                    cellMatrix[i][col] = td;\n                    loneCellMatrix[i][col] = td;\n                    col++;\n                }\n            }\n\n            for (i = 0; i < levelCnt; i++) { // iterate through all levels\n                levelSegs = segLevels[i];\n                col = 0;\n                tr = $('<tr/>');\n\n                segMatrix.push([]);\n                cellMatrix.push([]);\n                loneCellMatrix.push([]);\n\n                // levelCnt might be 1 even though there are no actual levels. protect against this.\n                // this single empty row is useful for styling.\n                if (levelSegs) {\n                    for (j = 0; j < levelSegs.length; j++) { // iterate through segments in level\n                        seg = levelSegs[j];\n\n                        emptyCellsUntil(seg.leftCol);\n\n                        // create a container that occupies or more columns. append the event element.\n                        td = $('<td class=\"fc-event-container\"/>').append(seg.el);\n                        if (seg.leftCol != seg.rightCol) {\n                            td.attr('colspan', seg.rightCol - seg.leftCol + 1);\n                        }\n                        else { // a single-column segment\n                            loneCellMatrix[i][col] = td;\n                        }\n\n                        while (col <= seg.rightCol) {\n                            cellMatrix[i][col] = td;\n                            segMatrix[i][col] = seg;\n                            col++;\n                        }\n\n                        tr.append(td);\n                    }\n                }\n\n                emptyCellsUntil(colCnt); // finish off the row\n                this.bookendCells(tr);\n                tbody.append(tr);\n            }\n\n            return { // a \"rowStruct\"\n                row: row, // the row number\n                tbodyEl: tbody,\n                cellMatrix: cellMatrix,\n                segMatrix: segMatrix,\n                segLevels: segLevels,\n                segs: rowSegs\n            };\n        },\n\n\n        // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.\n        // NOTE: modifies segs\n        buildSegLevels: function(segs) {\n            var levels = [];\n            var i, seg;\n            var j;\n\n            // Give preference to elements with certain criteria, so they have\n            // a chance to be closer to the top.\n            this.sortEventSegs(segs);\n\n            for (i = 0; i < segs.length; i++) {\n                seg = segs[i];\n\n                // loop through levels, starting with the topmost, until the segment doesn't collide with other segments\n                for (j = 0; j < levels.length; j++) {\n                    if (!isDaySegCollision(seg, levels[j])) {\n                        break;\n                    }\n                }\n                // `j` now holds the desired subrow index\n                seg.level = j;\n\n                // create new level array if needed and append segment\n                (levels[j] || (levels[j] = [])).push(seg);\n            }\n\n            // order segments left-to-right. very important if calendar is RTL\n            for (j = 0; j < levels.length; j++) {\n                levels[j].sort(compareDaySegCols);\n            }\n\n            return levels;\n        },\n\n\n        // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row\n        groupSegRows: function(segs) {\n            var segRows = [];\n            var i;\n\n            for (i = 0; i < this.rowCnt; i++) {\n                segRows.push([]);\n            }\n\n            for (i = 0; i < segs.length; i++) {\n                segRows[segs[i].row].push(segs[i]);\n            }\n\n            return segRows;\n        }\n\n    });\n\n\n// Computes whether two segments' columns collide. They are assumed to be in the same row.\n    function isDaySegCollision(seg, otherSegs) {\n        var i, otherSeg;\n\n        for (i = 0; i < otherSegs.length; i++) {\n            otherSeg = otherSegs[i];\n\n            if (\n                otherSeg.leftCol <= seg.rightCol &&\n                otherSeg.rightCol >= seg.leftCol\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n\n// A cmp function for determining the leftmost event\n    function compareDaySegCols(a, b) {\n        return a.leftCol - b.leftCol;\n    }\n\n    ;;\n\n    /* Methods relate to limiting the number events for a given day on a DayGrid\n     ----------------------------------------------------------------------------------------------------------------------*/\n// NOTE: all the segs being passed around in here are foreground segs\n\n    DayGrid.mixin({\n\n        segPopover: null, // the Popover that holds events that can't fit in a cell. null when not visible\n        popoverSegs: null, // an array of segment objects that the segPopover holds. null when not visible\n\n\n        removeSegPopover: function() {\n            if (this.segPopover) {\n                this.segPopover.hide(); // in handler, will call segPopover's removeElement\n            }\n        },\n\n\n        // Limits the number of \"levels\" (vertically stacking layers of events) for each row of the grid.\n        // `levelLimit` can be false (don't limit), a number, or true (should be computed).\n        limitRows: function(levelLimit) {\n            var rowStructs = this.rowStructs || [];\n            var row; // row #\n            var rowLevelLimit;\n\n            for (row = 0; row < rowStructs.length; row++) {\n                this.unlimitRow(row);\n\n                if (!levelLimit) {\n                    rowLevelLimit = false;\n                }\n                else if (typeof levelLimit === 'number') {\n                    rowLevelLimit = levelLimit;\n                }\n                else {\n                    rowLevelLimit = this.computeRowLevelLimit(row);\n                }\n\n                if (rowLevelLimit !== false) {\n                    this.limitRow(row, rowLevelLimit);\n                }\n            }\n        },\n\n\n        // Computes the number of levels a row will accomodate without going outside its bounds.\n        // Assumes the row is \"rigid\" (maintains a constant height regardless of what is inside).\n        // `row` is the row number.\n        computeRowLevelLimit: function(row) {\n            var rowEl = this.rowEls.eq(row); // the containing \"fake\" row div\n            var rowHeight = rowEl.height(); // TODO: cache somehow?\n            var trEls = this.rowStructs[row].tbodyEl.children();\n            var i, trEl;\n            var trHeight;\n\n            function iterInnerHeights(i, childNode) {\n                trHeight = Math.max(trHeight, $(childNode).outerHeight());\n            }\n\n            // Reveal one level <tr> at a time and stop when we find one out of bounds\n            for (i = 0; i < trEls.length; i++) {\n                trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)\n\n                // with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,\n                // so instead, find the tallest inner content element.\n                trHeight = 0;\n                trEl.find('> td > :first-child').each(iterInnerHeights);\n\n                if (trEl.position().top + trHeight > rowHeight) {\n                    return i;\n                }\n            }\n\n            return false; // should not limit at all\n        },\n\n\n        // Limits the given grid row to the maximum number of levels and injects \"more\" links if necessary.\n        // `row` is the row number.\n        // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.\n        limitRow: function(row, levelLimit) {\n            var _this = this;\n            var rowStruct = this.rowStructs[row];\n            var moreNodes = []; // array of \"more\" <a> links and <td> DOM nodes\n            var col = 0; // col #, left-to-right (not chronologically)\n            var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right\n            var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row\n            var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes\n            var i, seg;\n            var segsBelow; // array of segment objects below `seg` in the current `col`\n            var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies\n            var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)\n            var td, rowspan;\n            var segMoreNodes; // array of \"more\" <td> cells that will stand-in for the current seg's cell\n            var j;\n            var moreTd, moreWrap, moreLink;\n\n            // Iterates through empty level cells and places \"more\" links inside if need be\n            function emptyCellsUntil(endCol) { // goes from current `col` to `endCol`\n                while (col < endCol) {\n                    segsBelow = _this.getCellSegs(row, col, levelLimit);\n                    if (segsBelow.length) {\n                        td = cellMatrix[levelLimit - 1][col];\n                        moreLink = _this.renderMoreLink(row, col, segsBelow);\n                        moreWrap = $('<div/>').append(moreLink);\n                        td.append(moreWrap);\n                        moreNodes.push(moreWrap[0]);\n                    }\n                    col++;\n                }\n            }\n\n            if (levelLimit && levelLimit < rowStruct.segLevels.length) { // is it actually over the limit?\n                levelSegs = rowStruct.segLevels[levelLimit - 1];\n                cellMatrix = rowStruct.cellMatrix;\n\n                limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit\n                    .addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array\n\n                // iterate though segments in the last allowable level\n                for (i = 0; i < levelSegs.length; i++) {\n                    seg = levelSegs[i];\n                    emptyCellsUntil(seg.leftCol); // process empty cells before the segment\n\n                    // determine *all* segments below `seg` that occupy the same columns\n                    colSegsBelow = [];\n                    totalSegsBelow = 0;\n                    while (col <= seg.rightCol) {\n                        segsBelow = this.getCellSegs(row, col, levelLimit);\n                        colSegsBelow.push(segsBelow);\n                        totalSegsBelow += segsBelow.length;\n                        col++;\n                    }\n\n                    if (totalSegsBelow) { // do we need to replace this segment with one or many \"more\" links?\n                        td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell\n                        rowspan = td.attr('rowspan') || 1;\n                        segMoreNodes = [];\n\n                        // make a replacement <td> for each column the segment occupies. will be one for each colspan\n                        for (j = 0; j < colSegsBelow.length; j++) {\n                            moreTd = $('<td class=\"fc-more-cell\"/>').attr('rowspan', rowspan);\n                            segsBelow = colSegsBelow[j];\n                            moreLink = this.renderMoreLink(\n                                row,\n                                seg.leftCol + j,\n                                [ seg ].concat(segsBelow) // count seg as hidden too\n                            );\n                            moreWrap = $('<div/>').append(moreLink);\n                            moreTd.append(moreWrap);\n                            segMoreNodes.push(moreTd[0]);\n                            moreNodes.push(moreTd[0]);\n                        }\n\n                        td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements\n                        limitedNodes.push(td[0]);\n                    }\n                }\n\n                emptyCellsUntil(this.colCnt); // finish off the level\n                rowStruct.moreEls = $(moreNodes); // for easy undoing later\n                rowStruct.limitedEls = $(limitedNodes); // for easy undoing later\n            }\n        },\n\n\n        // Reveals all levels and removes all \"more\"-related elements for a grid's row.\n        // `row` is a row number.\n        unlimitRow: function(row) {\n            var rowStruct = this.rowStructs[row];\n\n            if (rowStruct.moreEls) {\n                rowStruct.moreEls.remove();\n                rowStruct.moreEls = null;\n            }\n\n            if (rowStruct.limitedEls) {\n                rowStruct.limitedEls.removeClass('fc-limited');\n                rowStruct.limitedEls = null;\n            }\n        },\n\n\n        // Renders an <a> element that represents hidden event element for a cell.\n        // Responsible for attaching click handler as well.\n        renderMoreLink: function(row, col, hiddenSegs) {\n            var _this = this;\n            var view = this.view;\n\n            return $('<a class=\"fc-more\"/>')\n                .text(\n                    this.getMoreLinkText(hiddenSegs.length)\n                )\n                .on('click', function(ev) {\n                    var clickOption = view.opt('eventLimitClick');\n                    var date = _this.getCellDate(row, col);\n                    var moreEl = $(this);\n                    var dayEl = _this.getCellEl(row, col);\n                    var allSegs = _this.getCellSegs(row, col);\n\n                    // rescope the segments to be within the cell's date\n                    var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);\n                    var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);\n\n                    if (typeof clickOption === 'function') {\n                        // the returned value can be an atomic option\n                        clickOption = view.publiclyTrigger('eventLimitClick', null, {\n                            date: date,\n                            dayEl: dayEl,\n                            moreEl: moreEl,\n                            segs: reslicedAllSegs,\n                            hiddenSegs: reslicedHiddenSegs\n                        }, ev);\n                    }\n\n                    if (clickOption === 'popover') {\n                        _this.showSegPopover(row, col, moreEl, reslicedAllSegs);\n                    }\n                    else if (typeof clickOption === 'string') { // a view name\n                        view.calendar.zoomTo(date, clickOption);\n                    }\n                });\n        },\n\n\n        // Reveals the popover that displays all events within a cell\n        showSegPopover: function(row, col, moreLink, segs) {\n            var _this = this;\n            var view = this.view;\n            var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>\n            var topEl; // the element we want to match the top coordinate of\n            var options;\n\n            if (this.rowCnt == 1) {\n                topEl = view.el; // will cause the popover to cover any sort of header\n            }\n            else {\n                topEl = this.rowEls.eq(row); // will align with top of row\n            }\n\n            options = {\n                className: 'fc-more-popover',\n                content: this.renderSegPopoverContent(row, col, segs),\n                parentEl: this.view.el, // attach to root of view. guarantees outside of scrollbars.\n                top: topEl.offset().top,\n                autoHide: true, // when the user clicks elsewhere, hide the popover\n                viewportConstrain: view.opt('popoverViewportConstrain'),\n                hide: function() {\n                    // kill everything when the popover is hidden\n                    // notify events to be removed\n                    if (_this.popoverSegs) {\n                        var seg;\n                        for (var i = 0; i < _this.popoverSegs.length; ++i) {\n                            seg = _this.popoverSegs[i];\n                            view.publiclyTrigger('eventDestroy', seg.event, seg.event, seg.el);\n                        }\n                    }\n                    _this.segPopover.removeElement();\n                    _this.segPopover = null;\n                    _this.popoverSegs = null;\n                }\n            };\n\n            // Determine horizontal coordinate.\n            // We use the moreWrap instead of the <td> to avoid border confusion.\n            if (this.isRTL) {\n                options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border\n            }\n            else {\n                options.left = moreWrap.offset().left - 1; // -1 to be over cell border\n            }\n\n            this.segPopover = new Popover(options);\n            this.segPopover.show();\n\n            // the popover doesn't live within the grid's container element, and thus won't get the event\n            // delegated-handlers for free. attach event-related handlers to the popover.\n            this.bindSegHandlersToEl(this.segPopover.el);\n        },\n\n\n        // Builds the inner DOM contents of the segment popover\n        renderSegPopoverContent: function(row, col, segs) {\n            var view = this.view;\n            var isTheme = view.opt('theme');\n            var title = this.getCellDate(row, col).format(view.opt('dayPopoverFormat'));\n            var content = $(\n                '<div class=\"fc-header ' + view.widgetHeaderClass + '\">' +\n                '<span class=\"fc-close ' +\n                (isTheme ? 'ui-icon ui-icon-closethick' : 'fc-icon fc-icon-x') +\n                '\"></span>' +\n                '<span class=\"fc-title\">' +\n                htmlEscape(title) +\n                '</span>' +\n                '<div class=\"fc-clear\"/>' +\n                '</div>' +\n                '<div class=\"fc-body ' + view.widgetContentClass + '\">' +\n                '<div class=\"fc-event-container\"></div>' +\n                '</div>'\n            );\n            var segContainer = content.find('.fc-event-container');\n            var i;\n\n            // render each seg's `el` and only return the visible segs\n            segs = this.renderFgSegEls(segs, true); // disableResizing=true\n            this.popoverSegs = segs;\n\n            for (i = 0; i < segs.length; i++) {\n\n                // because segments in the popover are not part of a grid coordinate system, provide a hint to any\n                // grids that want to do drag-n-drop about which cell it came from\n                this.hitsNeeded();\n                segs[i].hit = this.getCellHit(row, col);\n                this.hitsNotNeeded();\n\n                segContainer.append(segs[i].el);\n            }\n\n            return content;\n        },\n\n\n        // Given the events within an array of segment objects, reslice them to be in a single day\n        resliceDaySegs: function(segs, dayDate) {\n\n            // build an array of the original events\n            var events = $.map(segs, function(seg) {\n                return seg.event;\n            });\n\n            var dayStart = dayDate.clone();\n            var dayEnd = dayStart.clone().add(1, 'days');\n            var dayRange = { start: dayStart, end: dayEnd };\n\n            // slice the events with a custom slicing function\n            segs = this.eventsToSegs(\n                events,\n                function(range) {\n                    var seg = intersectRanges(range, dayRange); // undefind if no intersection\n                    return seg ? [ seg ] : []; // must return an array of segments\n                }\n            );\n\n            // force an order because eventsToSegs doesn't guarantee one\n            this.sortEventSegs(segs);\n\n            return segs;\n        },\n\n\n        // Generates the text that should be inside a \"more\" link, given the number of events it represents\n        getMoreLinkText: function(num) {\n            var opt = this.view.opt('eventLimitText');\n\n            if (typeof opt === 'function') {\n                return opt(num);\n            }\n            else {\n                return '+' + num + ' ' + opt;\n            }\n        },\n\n\n        // Returns segments within a given cell.\n        // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.\n        getCellSegs: function(row, col, startLevel) {\n            var segMatrix = this.rowStructs[row].segMatrix;\n            var level = startLevel || 0;\n            var segs = [];\n            var seg;\n\n            while (level < segMatrix.length) {\n                seg = segMatrix[level][col];\n                if (seg) {\n                    segs.push(seg);\n                }\n                level++;\n            }\n\n            return segs;\n        }\n\n    });\n\n    ;;\n\n    /* A component that renders one or more columns of vertical time slots\n     ----------------------------------------------------------------------------------------------------------------------*/\n// We mixin DayTable, even though there is only a single row of days\n\n    var TimeGrid = FC.TimeGrid = Grid.extend(DayTableMixin, {\n\n        slotDuration: null, // duration of a \"slot\", a distinct time segment on given day, visualized by lines\n        snapDuration: null, // granularity of time for dragging and selecting\n        snapsPerSlot: null,\n        labelFormat: null, // formatting string for times running along vertical axis\n        labelInterval: null, // duration of how often a label should be displayed for a slot\n\n        colEls: null, // cells elements in the day-row background\n        slatContainerEl: null, // div that wraps all the slat rows\n        slatEls: null, // elements running horizontally across all columns\n        nowIndicatorEls: null,\n\n        colCoordCache: null,\n        slatCoordCache: null,\n\n\n        constructor: function() {\n            Grid.apply(this, arguments); // call the super-constructor\n\n            this.processOptions();\n        },\n\n\n        // Renders the time grid into `this.el`, which should already be assigned.\n        // Relies on the view's colCnt. In the future, this component should probably be self-sufficient.\n        renderDates: function() {\n            this.el.html(this.renderHtml());\n            this.colEls = this.el.find('.fc-day, .fc-disabled-day');\n            this.slatContainerEl = this.el.find('.fc-slats');\n            this.slatEls = this.slatContainerEl.find('tr');\n\n            this.colCoordCache = new CoordCache({\n                els: this.colEls,\n                isHorizontal: true\n            });\n            this.slatCoordCache = new CoordCache({\n                els: this.slatEls,\n                isVertical: true\n            });\n\n            this.renderContentSkeleton();\n        },\n\n\n        // Renders the basic HTML skeleton for the grid\n        renderHtml: function() {\n            return '' +\n                '<div class=\"fc-bg\">' +\n                '<table>' +\n                this.renderBgTrHtml(0) + // row=0\n                '</table>' +\n                '</div>' +\n                '<div class=\"fc-slats\">' +\n                '<table>' +\n                this.renderSlatRowHtml() +\n                '</table>' +\n                '</div>';\n        },\n\n\n        // Generates the HTML for the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n        renderSlatRowHtml: function() {\n            var view = this.view;\n            var isRTL = this.isRTL;\n            var html = '';\n            var slotTime = moment.duration(+this.view.minTime); // wish there was .clone() for durations\n            var slotDate; // will be on the view's first day, but we only care about its time\n            var isLabeled;\n            var axisHtml;\n\n            // Calculate the time for each slot\n            while (slotTime < this.view.maxTime) {\n                slotDate = this.start.clone().time(slotTime);\n                isLabeled = isInt(divideDurationByDuration(slotTime, this.labelInterval));\n\n                axisHtml =\n                    '<td class=\"fc-axis fc-time ' + view.widgetContentClass + '\" ' + view.axisStyleAttr() + '>' +\n                    (isLabeled ?\n                            '<span>' + // for matchCellWidths\n                            htmlEscape(slotDate.format(this.labelFormat)) +\n                            '</span>' :\n                            ''\n                    ) +\n                    '</td>';\n\n                html +=\n                    '<tr data-time=\"' + slotDate.format('HH:mm:ss') + '\"' +\n                    (isLabeled ? '' : ' class=\"fc-minor\"') +\n                    '>' +\n                    (!isRTL ? axisHtml : '') +\n                    '<td class=\"' + view.widgetContentClass + '\"/>' +\n                    (isRTL ? axisHtml : '') +\n                    \"</tr>\";\n\n                slotTime.add(this.slotDuration);\n            }\n\n            return html;\n        },\n\n\n        /* Options\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Parses various options into properties of this object\n        processOptions: function() {\n            var view = this.view;\n            var slotDuration = view.opt('slotDuration');\n            var snapDuration = view.opt('snapDuration');\n            var input;\n\n            slotDuration = moment.duration(slotDuration);\n            snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;\n\n            this.slotDuration = slotDuration;\n            this.snapDuration = snapDuration;\n            this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?\n\n            this.minResizeDuration = snapDuration; // hack\n\n            // might be an array value (for TimelineView).\n            // if so, getting the most granular entry (the last one probably).\n            input = view.opt('slotLabelFormat');\n            if ($.isArray(input)) {\n                input = input[input.length - 1];\n            }\n\n            this.labelFormat =\n                input ||\n                view.opt('smallTimeFormat'); // the computed default\n\n            input = view.opt('slotLabelInterval');\n            this.labelInterval = input ?\n                moment.duration(input) :\n                this.computeLabelInterval(slotDuration);\n        },\n\n\n        // Computes an automatic value for slotLabelInterval\n        computeLabelInterval: function(slotDuration) {\n            var i;\n            var labelInterval;\n            var slotsPerLabel;\n\n            // find the smallest stock label interval that results in more than one slots-per-label\n            for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {\n                labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);\n                slotsPerLabel = divideDurationByDuration(labelInterval, slotDuration);\n                if (isInt(slotsPerLabel) && slotsPerLabel > 1) {\n                    return labelInterval;\n                }\n            }\n\n            return moment.duration(slotDuration); // fall back. clone\n        },\n\n\n        // Computes a default event time formatting string if `timeFormat` is not explicitly defined\n        computeEventTimeFormat: function() {\n            return this.view.opt('noMeridiemTimeFormat'); // like \"6:30\" (no AM/PM)\n        },\n\n\n        // Computes a default `displayEventEnd` value if one is not expliclty defined\n        computeDisplayEventEnd: function() {\n            return true;\n        },\n\n\n        /* Hit System\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        prepareHits: function() {\n            this.colCoordCache.build();\n            this.slatCoordCache.build();\n        },\n\n\n        releaseHits: function() {\n            this.colCoordCache.clear();\n            // NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop\n        },\n\n\n        queryHit: function(leftOffset, topOffset) {\n            var snapsPerSlot = this.snapsPerSlot;\n            var colCoordCache = this.colCoordCache;\n            var slatCoordCache = this.slatCoordCache;\n\n            if (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {\n                var colIndex = colCoordCache.getHorizontalIndex(leftOffset);\n                var slatIndex = slatCoordCache.getVerticalIndex(topOffset);\n\n                if (colIndex != null && slatIndex != null) {\n                    var slatTop = slatCoordCache.getTopOffset(slatIndex);\n                    var slatHeight = slatCoordCache.getHeight(slatIndex);\n                    var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1\n                    var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n                    var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n                    var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;\n                    var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;\n\n                    return {\n                        col: colIndex,\n                        snap: snapIndex,\n                        component: this, // needed unfortunately :(\n                        left: colCoordCache.getLeftOffset(colIndex),\n                        right: colCoordCache.getRightOffset(colIndex),\n                        top: snapTop,\n                        bottom: snapBottom\n                    };\n                }\n            }\n        },\n\n\n        getHitSpan: function(hit) {\n            var start = this.getCellDate(0, hit.col); // row=0\n            var time = this.computeSnapTime(hit.snap); // pass in the snap-index\n            var end;\n\n            start.time(time);\n            end = start.clone().add(this.snapDuration);\n\n            return { start: start, end: end };\n        },\n\n\n        getHitEl: function(hit) {\n            return this.colEls.eq(hit.col);\n        },\n\n\n        /* Dates\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        rangeUpdated: function() {\n            this.updateDayTable();\n        },\n\n\n        // Given a row number of the grid, representing a \"snap\", returns a time (Duration) from its start-of-day\n        computeSnapTime: function(snapIndex) {\n            return moment.duration(this.view.minTime + this.snapDuration * snapIndex);\n        },\n\n\n        // Slices up the given span (unzoned start/end with other misc data) into an array of segments\n        spanToSegs: function(span) {\n            var segs = this.sliceRangeByTimes(span);\n            var i;\n\n            for (i = 0; i < segs.length; i++) {\n                if (this.isRTL) {\n                    segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;\n                }\n                else {\n                    segs[i].col = segs[i].dayIndex;\n                }\n            }\n\n            return segs;\n        },\n\n\n        sliceRangeByTimes: function(range) {\n            var segs = [];\n            var seg;\n            var dayIndex;\n            var dayDate;\n            var dayRange;\n\n            for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {\n                dayDate = this.dayDates[dayIndex].clone().time(0); // TODO: better API for this?\n                dayRange = {\n                    start: dayDate.clone().add(this.view.minTime), // don't use .time() because it sux with negatives\n                    end: dayDate.clone().add(this.view.maxTime)\n                };\n                seg = intersectRanges(range, dayRange); // both will be ambig timezone\n                if (seg) {\n                    seg.dayIndex = dayIndex;\n                    segs.push(seg);\n                }\n            }\n\n            return segs;\n        },\n\n\n        /* Coordinates\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        updateSize: function(isResize) { // NOT a standard Grid method\n            this.slatCoordCache.build();\n\n            if (isResize) {\n                this.updateSegVerticals(\n                    [].concat(this.fgSegs || [], this.bgSegs || [], this.businessSegs || [])\n                );\n            }\n        },\n\n\n        getTotalSlatHeight: function() {\n            return this.slatContainerEl.outerHeight();\n        },\n\n\n        // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n        // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n        computeDateTop: function(date, startOfDayDate) {\n            return this.computeTimeTop(\n                moment.duration(\n                    date - startOfDayDate.clone().stripTime()\n                )\n            );\n        },\n\n\n        // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n        computeTimeTop: function(time) {\n            var len = this.slatEls.length;\n            var slatCoverage = (time - this.view.minTime) / this.slotDuration; // floating-point value of # of slots covered\n            var slatIndex;\n            var slatRemainder;\n\n            // compute a floating-point number for how many slats should be progressed through.\n            // from 0 to number of slats (inclusive)\n            // constrained because minTime/maxTime might be customized.\n            slatCoverage = Math.max(0, slatCoverage);\n            slatCoverage = Math.min(len, slatCoverage);\n\n            // an integer index of the furthest whole slat\n            // from 0 to number slats (*exclusive*, so len-1)\n            slatIndex = Math.floor(slatCoverage);\n            slatIndex = Math.min(slatIndex, len - 1);\n\n            // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n            // could be 1.0 if slatCoverage is covering *all* the slots\n            slatRemainder = slatCoverage - slatIndex;\n\n            return this.slatCoordCache.getTopPosition(slatIndex) +\n                this.slatCoordCache.getHeight(slatIndex) * slatRemainder;\n        },\n\n\n\n        /* Event Drag Visualization\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders a visual indication of an event being dragged over the specified date(s).\n        // A returned value of `true` signals that a mock \"helper\" event has been rendered.\n        renderDrag: function(eventLocation, seg) {\n            var eventSpans;\n            var i;\n\n            if (seg) { // if there is event information for this drag, render a helper event\n\n                // returns mock event elements\n                // signal that a helper has been rendered\n                return this.renderEventLocationHelper(eventLocation, seg);\n            }\n            else { // otherwise, just render a highlight\n                eventSpans = this.eventToSpans(eventLocation);\n\n                for (i = 0; i < eventSpans.length; i++) {\n                    this.renderHighlight(eventSpans[i]);\n                }\n            }\n        },\n\n\n        // Unrenders any visual indication of an event being dragged\n        unrenderDrag: function() {\n            this.unrenderHelper();\n            this.unrenderHighlight();\n        },\n\n\n        /* Event Resize Visualization\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders a visual indication of an event being resized\n        renderEventResize: function(eventLocation, seg) {\n            return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements\n        },\n\n\n        // Unrenders any visual indication of an event being resized\n        unrenderEventResize: function() {\n            this.unrenderHelper();\n        },\n\n\n        /* Event Helper\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders a mock \"helper\" event. `sourceSeg` is the original segment object and might be null (an external drag)\n        renderHelper: function(event, sourceSeg) {\n            return this.renderHelperSegs(this.eventToSegs(event), sourceSeg); // returns mock event elements\n        },\n\n\n        // Unrenders any mock helper event\n        unrenderHelper: function() {\n            this.unrenderHelperSegs();\n        },\n\n\n        /* Business Hours\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        renderBusinessHours: function() {\n            this.renderBusinessSegs(\n                this.buildBusinessHourSegs()\n            );\n        },\n\n\n        unrenderBusinessHours: function() {\n            this.unrenderBusinessSegs();\n        },\n\n\n        /* Now Indicator\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        getNowIndicatorUnit: function() {\n            return 'minute'; // will refresh on the minute\n        },\n\n\n        renderNowIndicator: function(date) {\n            // seg system might be overkill, but it handles scenario where line needs to be rendered\n            //  more than once because of columns with the same date (resources columns for example)\n            var segs = this.spanToSegs({ start: date, end: date });\n            var top = this.computeDateTop(date, date);\n            var nodes = [];\n            var i;\n\n            // render lines within the columns\n            for (i = 0; i < segs.length; i++) {\n                nodes.push($('<div class=\"fc-now-indicator fc-now-indicator-line\"></div>')\n                    .css('top', top)\n                    .appendTo(this.colContainerEls.eq(segs[i].col))[0]);\n            }\n\n            // render an arrow over the axis\n            if (segs.length > 0) { // is the current time in view?\n                nodes.push($('<div class=\"fc-now-indicator fc-now-indicator-arrow\"></div>')\n                    .css('top', top)\n                    .appendTo(this.el.find('.fc-content-skeleton'))[0]);\n            }\n\n            this.nowIndicatorEls = $(nodes);\n        },\n\n\n        unrenderNowIndicator: function() {\n            if (this.nowIndicatorEls) {\n                this.nowIndicatorEls.remove();\n                this.nowIndicatorEls = null;\n            }\n        },\n\n\n        /* Selection\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.\n        renderSelection: function(span) {\n            if (this.view.opt('selectHelper')) { // this setting signals that a mock helper event should be rendered\n\n                // normally acceps an eventLocation, span has a start/end, which is good enough\n                this.renderEventLocationHelper(span);\n            }\n            else {\n                this.renderHighlight(span);\n            }\n        },\n\n\n        // Unrenders any visual indication of a selection\n        unrenderSelection: function() {\n            this.unrenderHelper();\n            this.unrenderHighlight();\n        },\n\n\n        /* Highlight\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        renderHighlight: function(span) {\n            this.renderHighlightSegs(this.spanToSegs(span));\n        },\n\n\n        unrenderHighlight: function() {\n            this.unrenderHighlightSegs();\n        }\n\n    });\n\n    ;;\n\n    /* Methods for rendering SEGMENTS, pieces of content that live on the view\n     ( this file is no longer just for events )\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n    TimeGrid.mixin({\n\n        colContainerEls: null, // containers for each column\n\n        // inner-containers for each column where different types of segs live\n        fgContainerEls: null,\n        bgContainerEls: null,\n        helperContainerEls: null,\n        highlightContainerEls: null,\n        businessContainerEls: null,\n\n        // arrays of different types of displayed segments\n        fgSegs: null,\n        bgSegs: null,\n        helperSegs: null,\n        highlightSegs: null,\n        businessSegs: null,\n\n\n        // Renders the DOM that the view's content will live in\n        renderContentSkeleton: function() {\n            var cellHtml = '';\n            var i;\n            var skeletonEl;\n\n            for (i = 0; i < this.colCnt; i++) {\n                cellHtml +=\n                    '<td>' +\n                    '<div class=\"fc-content-col\">' +\n                    '<div class=\"fc-event-container fc-helper-container\"></div>' +\n                    '<div class=\"fc-event-container\"></div>' +\n                    '<div class=\"fc-highlight-container\"></div>' +\n                    '<div class=\"fc-bgevent-container\"></div>' +\n                    '<div class=\"fc-business-container\"></div>' +\n                    '</div>' +\n                    '</td>';\n            }\n\n            skeletonEl = $(\n                '<div class=\"fc-content-skeleton\">' +\n                '<table>' +\n                '<tr>' + cellHtml + '</tr>' +\n                '</table>' +\n                '</div>'\n            );\n\n            this.colContainerEls = skeletonEl.find('.fc-content-col');\n            this.helperContainerEls = skeletonEl.find('.fc-helper-container');\n            this.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');\n            this.bgContainerEls = skeletonEl.find('.fc-bgevent-container');\n            this.highlightContainerEls = skeletonEl.find('.fc-highlight-container');\n            this.businessContainerEls = skeletonEl.find('.fc-business-container');\n\n            this.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level\n            this.el.append(skeletonEl);\n        },\n\n\n        /* Foreground Events\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        renderFgSegs: function(segs) {\n            segs = this.renderFgSegsIntoContainers(segs, this.fgContainerEls);\n            this.fgSegs = segs;\n            return segs; // needed for Grid::renderEvents\n        },\n\n\n        unrenderFgSegs: function() {\n            this.unrenderNamedSegs('fgSegs');\n        },\n\n\n        /* Foreground Helper Events\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        renderHelperSegs: function(segs, sourceSeg) {\n            var helperEls = [];\n            var i, seg;\n            var sourceEl;\n\n            segs = this.renderFgSegsIntoContainers(segs, this.helperContainerEls);\n\n            // Try to make the segment that is in the same row as sourceSeg look the same\n            for (i = 0; i < segs.length; i++) {\n                seg = segs[i];\n                if (sourceSeg && sourceSeg.col === seg.col) {\n                    sourceEl = sourceSeg.el;\n                    seg.el.css({\n                        left: sourceEl.css('left'),\n                        right: sourceEl.css('right'),\n                        'margin-left': sourceEl.css('margin-left'),\n                        'margin-right': sourceEl.css('margin-right')\n                    });\n                }\n                helperEls.push(seg.el[0]);\n            }\n\n            this.helperSegs = segs;\n\n            return $(helperEls); // must return rendered helpers\n        },\n\n\n        unrenderHelperSegs: function() {\n            this.unrenderNamedSegs('helperSegs');\n        },\n\n\n        /* Background Events\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        renderBgSegs: function(segs) {\n            segs = this.renderFillSegEls('bgEvent', segs); // TODO: old fill system\n            this.updateSegVerticals(segs);\n            this.attachSegsByCol(this.groupSegsByCol(segs), this.bgContainerEls);\n            this.bgSegs = segs;\n            return segs; // needed for Grid::renderEvents\n        },\n\n\n        unrenderBgSegs: function() {\n            this.unrenderNamedSegs('bgSegs');\n        },\n\n\n        /* Highlight\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        renderHighlightSegs: function(segs) {\n            segs = this.renderFillSegEls('highlight', segs); // TODO: old fill system\n            this.updateSegVerticals(segs);\n            this.attachSegsByCol(this.groupSegsByCol(segs), this.highlightContainerEls);\n            this.highlightSegs = segs;\n        },\n\n\n        unrenderHighlightSegs: function() {\n            this.unrenderNamedSegs('highlightSegs');\n        },\n\n\n        /* Business Hours\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        renderBusinessSegs: function(segs) {\n            segs = this.renderFillSegEls('businessHours', segs); // TODO: old fill system\n            this.updateSegVerticals(segs);\n            this.attachSegsByCol(this.groupSegsByCol(segs), this.businessContainerEls);\n            this.businessSegs = segs;\n        },\n\n\n        unrenderBusinessSegs: function() {\n            this.unrenderNamedSegs('businessSegs');\n        },\n\n\n        /* Seg Rendering Utils\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col\n        groupSegsByCol: function(segs) {\n            var segsByCol = [];\n            var i;\n\n            for (i = 0; i < this.colCnt; i++) {\n                segsByCol.push([]);\n            }\n\n            for (i = 0; i < segs.length; i++) {\n                segsByCol[segs[i].col].push(segs[i]);\n            }\n\n            return segsByCol;\n        },\n\n\n        // Given segments grouped by column, insert the segments' elements into a parallel array of container\n        // elements, each living within a column.\n        attachSegsByCol: function(segsByCol, containerEls) {\n            var col;\n            var segs;\n            var i;\n\n            for (col = 0; col < this.colCnt; col++) { // iterate each column grouping\n                segs = segsByCol[col];\n\n                for (i = 0; i < segs.length; i++) {\n                    containerEls.eq(col).append(segs[i].el);\n                }\n            }\n        },\n\n\n        // Given the name of a property of `this` object, assumed to be an array of segments,\n        // loops through each segment and removes from DOM. Will null-out the property afterwards.\n        unrenderNamedSegs: function(propName) {\n            var segs = this[propName];\n            var i;\n\n            if (segs) {\n                for (i = 0; i < segs.length; i++) {\n                    segs[i].el.remove();\n                }\n                this[propName] = null;\n            }\n        },\n\n\n\n        /* Foreground Event Rendering Utils\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Given an array of foreground segments, render a DOM element for each, computes position,\n        // and attaches to the column inner-container elements.\n        renderFgSegsIntoContainers: function(segs, containerEls) {\n            var segsByCol;\n            var col;\n\n            segs = this.renderFgSegEls(segs); // will call fgSegHtml\n            segsByCol = this.groupSegsByCol(segs);\n\n            for (col = 0; col < this.colCnt; col++) {\n                this.updateFgSegCoords(segsByCol[col]);\n            }\n\n            this.attachSegsByCol(segsByCol, containerEls);\n\n            return segs;\n        },\n\n\n        // Renders the HTML for a single event segment's default rendering\n        fgSegHtml: function(seg, disableResizing) {\n            var view = this.view;\n            var event = seg.event;\n            var isDraggable = view.isEventDraggable(event);\n            var isResizableFromStart = !disableResizing && seg.isStart && view.isEventResizableFromStart(event);\n            var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventResizableFromEnd(event);\n            var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\n            var skinCss = cssToStr(this.getSegSkinCss(seg));\n            var timeText;\n            var fullTimeText; // more verbose time text. for the print stylesheet\n            var startTimeText; // just the start time text\n\n            classes.unshift('fc-time-grid-event', 'fc-v-event');\n\n            if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day...\n                // Don't display time text on segments that run entirely through a day.\n                // That would appear as midnight-midnight and would look dumb.\n                // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)\n                if (seg.isStart || seg.isEnd) {\n                    timeText = this.getEventTimeText(seg);\n                    fullTimeText = this.getEventTimeText(seg, 'LT');\n                    startTimeText = this.getEventTimeText(seg, null, false); // displayEnd=false\n                }\n            } else {\n                // Display the normal time text for the *event's* times\n                timeText = this.getEventTimeText(event);\n                fullTimeText = this.getEventTimeText(event, 'LT');\n                startTimeText = this.getEventTimeText(event, null, false); // displayEnd=false\n            }\n\n            return '<a class=\"' + classes.join(' ') + '\"' +\n                (event.url ?\n                        ' href=\"' + htmlEscape(event.url) + '\"' :\n                        ''\n                ) +\n                (skinCss ?\n                        ' style=\"' + skinCss + '\"' :\n                        ''\n                ) +\n                '>' +\n                '<div class=\"fc-content\">' +\n                (timeText ?\n                        '<div class=\"fc-time\"' +\n                        ' data-start=\"' + htmlEscape(startTimeText) + '\"' +\n                        ' data-full=\"' + htmlEscape(fullTimeText) + '\"' +\n                        '>' +\n                        '<span>' + htmlEscape(timeText) + '</span>' +\n                        '</div>' :\n                        ''\n                ) +\n                (event.title ?\n                        '<div class=\"fc-title\">' +\n                        htmlEscape(event.title) +\n                        '</div>' :\n                        ''\n                ) +\n                '</div>' +\n                '<div class=\"fc-bg\"/>' +\n                /* TODO: write CSS for this\n                 (isResizableFromStart ?\n                 '<div class=\"fc-resizer fc-start-resizer\" />' :\n                 ''\n                 ) +\n                 */\n                (isResizableFromEnd ?\n                        '<div class=\"fc-resizer fc-end-resizer\" />' :\n                        ''\n                ) +\n                '</a>';\n        },\n\n\n        /* Seg Position Utils\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Refreshes the CSS top/bottom coordinates for each segment element.\n        // Works when called after initial render, after a window resize/zoom for example.\n        updateSegVerticals: function(segs) {\n            this.computeSegVerticals(segs);\n            this.assignSegVerticals(segs);\n        },\n\n\n        // For each segment in an array, computes and assigns its top and bottom properties\n        computeSegVerticals: function(segs) {\n            var i, seg;\n            var dayDate;\n\n            for (i = 0; i < segs.length; i++) {\n                seg = segs[i];\n                dayDate = this.dayDates[seg.dayIndex];\n\n                seg.top = this.computeDateTop(seg.start, dayDate);\n                seg.bottom = this.computeDateTop(seg.end, dayDate);\n            }\n        },\n\n\n        // Given segments that already have their top/bottom properties computed, applies those values to\n        // the segments' elements.\n        assignSegVerticals: function(segs) {\n            var i, seg;\n\n            for (i = 0; i < segs.length; i++) {\n                seg = segs[i];\n                seg.el.css(this.generateSegVerticalCss(seg));\n            }\n        },\n\n\n        // Generates an object with CSS properties for the top/bottom coordinates of a segment element\n        generateSegVerticalCss: function(seg) {\n            return {\n                top: seg.top,\n                bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container\n            };\n        },\n\n\n        /* Foreground Event Positioning Utils\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Given segments that are assumed to all live in the *same column*,\n        // compute their verical/horizontal coordinates and assign to their elements.\n        updateFgSegCoords: function(segs) {\n            this.computeSegVerticals(segs); // horizontals relies on this\n            this.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array\n            this.assignSegVerticals(segs);\n            this.assignFgSegHorizontals(segs);\n        },\n\n\n        // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.\n        // NOTE: Also reorders the given array by date!\n        computeFgSegHorizontals: function(segs) {\n            var levels;\n            var level0;\n            var i;\n\n            this.sortEventSegs(segs); // order by certain criteria\n            levels = buildSlotSegLevels(segs);\n            computeForwardSlotSegs(levels);\n\n            if ((level0 = levels[0])) {\n\n                for (i = 0; i < level0.length; i++) {\n                    computeSlotSegPressures(level0[i]);\n                }\n\n                for (i = 0; i < level0.length; i++) {\n                    this.computeFgSegForwardBack(level0[i], 0, 0);\n                }\n            }\n        },\n\n\n        // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range\n        // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to \"left\" and\n        // seg.forwardCoord maps to \"right\" (via percentage). Vice-versa if the calendar is right-to-left.\n        //\n        // The segment might be part of a \"series\", which means consecutive segments with the same pressure\n        // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of\n        // segments behind this one in the current series, and `seriesBackwardCoord` is the starting\n        // coordinate of the first segment in the series.\n        computeFgSegForwardBack: function(seg, seriesBackwardPressure, seriesBackwardCoord) {\n            var forwardSegs = seg.forwardSegs;\n            var i;\n\n            if (seg.forwardCoord === undefined) { // not already computed\n\n                if (!forwardSegs.length) {\n\n                    // if there are no forward segments, this segment should butt up against the edge\n                    seg.forwardCoord = 1;\n                }\n                else {\n\n                    // sort highest pressure first\n                    this.sortForwardSegs(forwardSegs);\n\n                    // this segment's forwardCoord will be calculated from the backwardCoord of the\n                    // highest-pressure forward segment.\n                    this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);\n                    seg.forwardCoord = forwardSegs[0].backwardCoord;\n                }\n\n                // calculate the backwardCoord from the forwardCoord. consider the series\n                seg.backwardCoord = seg.forwardCoord -\n                    (seg.forwardCoord - seriesBackwardCoord) / // available width for series\n                    (seriesBackwardPressure + 1); // # of segments in the series\n\n                // use this segment's coordinates to computed the coordinates of the less-pressurized\n                // forward segments\n                for (i=0; i<forwardSegs.length; i++) {\n                    this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);\n                }\n            }\n        },\n\n\n        sortForwardSegs: function(forwardSegs) {\n            forwardSegs.sort(proxy(this, 'compareForwardSegs'));\n        },\n\n\n        // A cmp function for determining which forward segment to rely on more when computing coordinates.\n        compareForwardSegs: function(seg1, seg2) {\n            // put higher-pressure first\n            return seg2.forwardPressure - seg1.forwardPressure ||\n                // put segments that are closer to initial edge first (and favor ones with no coords yet)\n                (seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||\n                // do normal sorting...\n                this.compareEventSegs(seg1, seg2);\n        },\n\n\n        // Given foreground event segments that have already had their position coordinates computed,\n        // assigns position-related CSS values to their elements.\n        assignFgSegHorizontals: function(segs) {\n            var i, seg;\n\n            for (i = 0; i < segs.length; i++) {\n                seg = segs[i];\n                seg.el.css(this.generateFgSegHorizontalCss(seg));\n\n                // if the height is short, add a className for alternate styling\n                if (seg.bottom - seg.top < 30) {\n                    seg.el.addClass('fc-short');\n                }\n            }\n        },\n\n\n        // Generates an object with CSS properties/values that should be applied to an event segment element.\n        // Contains important positioning-related properties that should be applied to any event element, customized or not.\n        generateFgSegHorizontalCss: function(seg) {\n            var shouldOverlap = this.view.opt('slotEventOverlap');\n            var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point\n            var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point\n            var props = this.generateSegVerticalCss(seg); // get top/bottom first\n            var left; // amount of space from left edge, a fraction of the total width\n            var right; // amount of space from right edge, a fraction of the total width\n\n            if (shouldOverlap) {\n                // double the width, but don't go beyond the maximum forward coordinate (1.0)\n                forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);\n            }\n\n            if (this.isRTL) {\n                left = 1 - forwardCoord;\n                right = backwardCoord;\n            }\n            else {\n                left = backwardCoord;\n                right = 1 - forwardCoord;\n            }\n\n            props.zIndex = seg.level + 1; // convert from 0-base to 1-based\n            props.left = left * 100 + '%';\n            props.right = right * 100 + '%';\n\n            if (shouldOverlap && seg.forwardPressure) {\n                // add padding to the edge so that forward stacked events don't cover the resizer's icon\n                props[this.isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n            }\n\n            return props;\n        }\n\n    });\n\n\n// Builds an array of segments \"levels\". The first level will be the leftmost tier of segments if the calendar is\n// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.\n    function buildSlotSegLevels(segs) {\n        var levels = [];\n        var i, seg;\n        var j;\n\n        for (i=0; i<segs.length; i++) {\n            seg = segs[i];\n\n            // go through all the levels and stop on the first level where there are no collisions\n            for (j=0; j<levels.length; j++) {\n                if (!computeSlotSegCollisions(seg, levels[j]).length) {\n                    break;\n                }\n            }\n\n            seg.level = j;\n\n            (levels[j] || (levels[j] = [])).push(seg);\n        }\n\n        return levels;\n    }\n\n\n// For every segment, figure out the other segments that are in subsequent\n// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs\n    function computeForwardSlotSegs(levels) {\n        var i, level;\n        var j, seg;\n        var k;\n\n        for (i=0; i<levels.length; i++) {\n            level = levels[i];\n\n            for (j=0; j<level.length; j++) {\n                seg = level[j];\n\n                seg.forwardSegs = [];\n                for (k=i+1; k<levels.length; k++) {\n                    computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);\n                }\n            }\n        }\n    }\n\n\n// Figure out which path forward (via seg.forwardSegs) results in the longest path until\n// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure\n    function computeSlotSegPressures(seg) {\n        var forwardSegs = seg.forwardSegs;\n        var forwardPressure = 0;\n        var i, forwardSeg;\n\n        if (seg.forwardPressure === undefined) { // not already computed\n\n            for (i=0; i<forwardSegs.length; i++) {\n                forwardSeg = forwardSegs[i];\n\n                // figure out the child's maximum forward path\n                computeSlotSegPressures(forwardSeg);\n\n                // either use the existing maximum, or use the child's forward pressure\n                // plus one (for the forwardSeg itself)\n                forwardPressure = Math.max(\n                    forwardPressure,\n                    1 + forwardSeg.forwardPressure\n                );\n            }\n\n            seg.forwardPressure = forwardPressure;\n        }\n    }\n\n\n// Find all the segments in `otherSegs` that vertically collide with `seg`.\n// Append into an optionally-supplied `results` array and return.\n    function computeSlotSegCollisions(seg, otherSegs, results) {\n        results = results || [];\n\n        for (var i=0; i<otherSegs.length; i++) {\n            if (isSlotSegCollision(seg, otherSegs[i])) {\n                results.push(otherSegs[i]);\n            }\n        }\n\n        return results;\n    }\n\n\n// Do these segments occupy the same vertical space?\n    function isSlotSegCollision(seg1, seg2) {\n        return seg1.bottom > seg2.top && seg1.top < seg2.bottom;\n    }\n\n    ;;\n\n    /* An abstract class from which other views inherit from\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n    var View = FC.View = Model.extend({\n\n        type: null, // subclass' view name (string)\n        name: null, // deprecated. use `type` instead\n        title: null, // the text that will be displayed in the header's title\n\n        calendar: null, // owner Calendar object\n        viewSpec: null,\n        options: null, // hash containing all options. already merged with view-specific-options\n        el: null, // the view's containing element. set by Calendar\n\n        renderQueue: null,\n        batchRenderDepth: 0,\n        isDatesRendered: false,\n        isEventsRendered: false,\n        isBaseRendered: false, // related to viewRender/viewDestroy triggers\n\n        queuedScroll: null,\n\n        isRTL: false,\n        isSelected: false, // boolean whether a range of time is user-selected or not\n        selectedEvent: null,\n\n        eventOrderSpecs: null, // criteria for ordering events when they have same date/time\n\n        // classNames styled by jqui themes\n        widgetHeaderClass: null,\n        widgetContentClass: null,\n        highlightStateClass: null,\n\n        // for date utils, computed from options\n        nextDayThreshold: null,\n        isHiddenDayHash: null,\n\n        // now indicator\n        isNowIndicatorRendered: null,\n        initialNowDate: null, // result first getNow call\n        initialNowQueriedMs: null, // ms time the getNow was called\n        nowIndicatorTimeoutID: null, // for refresh timing of now indicator\n        nowIndicatorIntervalID: null, // \"\n\n\n        constructor: function(calendar, viewSpec) {\n            Model.prototype.constructor.call(this);\n\n            this.calendar = calendar;\n            this.viewSpec = viewSpec;\n\n            // shortcuts\n            this.type = viewSpec.type;\n            this.options = viewSpec.options;\n\n            // .name is deprecated\n            this.name = this.type;\n\n            this.nextDayThreshold = moment.duration(this.opt('nextDayThreshold'));\n            this.initThemingProps();\n            this.initHiddenDays();\n            this.isRTL = this.opt('isRTL');\n\n            this.eventOrderSpecs = parseFieldSpecs(this.opt('eventOrder'));\n\n            this.renderQueue = this.buildRenderQueue();\n            this.initAutoBatchRender();\n\n            this.initialize();\n        },\n\n\n        buildRenderQueue: function() {\n            var _this = this;\n            var renderQueue = new RenderQueue({\n                event: this.opt('eventRenderWait')\n            });\n\n            renderQueue.on('start', function() {\n                _this.freezeHeight();\n                _this.addScroll(_this.queryScroll());\n            });\n\n            renderQueue.on('stop', function() {\n                _this.thawHeight();\n                _this.popScroll();\n            });\n\n            return renderQueue;\n        },\n\n\n        initAutoBatchRender: function() {\n            var _this = this;\n\n            this.on('before:change', function() {\n                _this.startBatchRender();\n            });\n\n            this.on('change', function() {\n                _this.stopBatchRender();\n            });\n        },\n\n\n        startBatchRender: function() {\n            if (!(this.batchRenderDepth++)) {\n                this.renderQueue.pause();\n            }\n        },\n\n\n        stopBatchRender: function() {\n            if (!(--this.batchRenderDepth)) {\n                this.renderQueue.resume();\n            }\n        },\n\n\n        // A good place for subclasses to initialize member variables\n        initialize: function() {\n            // subclasses can implement\n        },\n\n\n        // Retrieves an option with the given name\n        opt: function(name) {\n            return this.options[name];\n        },\n\n\n        // Triggers handlers that are view-related. Modifies args before passing to calendar.\n        publiclyTrigger: function(name, thisObj) { // arguments beyond thisObj are passed along\n            var calendar = this.calendar;\n\n            return calendar.publiclyTrigger.apply(\n                calendar,\n                [name, thisObj || this].concat(\n                    Array.prototype.slice.call(arguments, 2), // arguments beyond thisObj\n                    [ this ] // always make the last argument a reference to the view. TODO: deprecate\n                )\n            );\n        },\n\n\n        /* Title and Date Formatting\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Sets the view's title property to the most updated computed value\n        updateTitle: function() {\n            this.title = this.computeTitle();\n            this.calendar.setToolbarsTitle(this.title);\n        },\n\n\n        // Computes what the title at the top of the calendar should be for this view\n        computeTitle: function() {\n            var range;\n\n            // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n            if (/^(year|month)$/.test(this.currentRangeUnit)) {\n                range = this.currentRange;\n            }\n            else { // for day units or smaller, use the actual day range\n                range = this.activeRange;\n            }\n\n            return this.formatRange(\n                {\n                    // in case currentRange has a time, make sure timezone is correct\n                    start: this.calendar.applyTimezone(range.start),\n                    end: this.calendar.applyTimezone(range.end)\n                },\n                this.opt('titleFormat') || this.computeTitleFormat(),\n                this.opt('titleRangeSeparator')\n            );\n        },\n\n\n        // Generates the format string that should be used to generate the title for the current date range.\n        // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\n        computeTitleFormat: function() {\n            if (this.currentRangeUnit == 'year') {\n                return 'YYYY';\n            }\n            else if (this.currentRangeUnit == 'month') {\n                return this.opt('monthYearFormat'); // like \"September 2014\"\n            }\n            else if (this.currentRangeAs('days') > 1) {\n                return 'll'; // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n            }\n            else {\n                return 'LL'; // one day. longer, like \"September 9 2014\"\n            }\n        },\n\n\n        // Utility for formatting a range. Accepts a range object, formatting string, and optional separator.\n        // Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.\n        // The timezones of the dates within `range` will be respected.\n        formatRange: function(range, formatStr, separator) {\n            var end = range.end;\n\n            if (!end.hasTime()) { // all-day?\n                end = end.clone().subtract(1); // convert to inclusive. last ms of previous day\n            }\n\n            return formatRange(range.start, end, formatStr, separator, this.opt('isRTL'));\n        },\n\n\n        getAllDayHtml: function() {\n            return this.opt('allDayHtml') || htmlEscape(this.opt('allDayText'));\n        },\n\n\n        /* Navigation\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Generates HTML for an anchor to another view into the calendar.\n        // Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.\n        // `gotoOptions` can either be a moment input, or an object with the form:\n        // { date, type, forceOff }\n        // `type` is a view-type like \"day\" or \"week\". default value is \"day\".\n        // `attrs` and `innerHtml` are use to generate the rest of the HTML tag.\n        buildGotoAnchorHtml: function(gotoOptions, attrs, innerHtml) {\n            var date, type, forceOff;\n            var finalOptions;\n\n            if ($.isPlainObject(gotoOptions)) {\n                date = gotoOptions.date;\n                type = gotoOptions.type;\n                forceOff = gotoOptions.forceOff;\n            }\n            else {\n                date = gotoOptions; // a single moment input\n            }\n            date = FC.moment(date); // if a string, parse it\n\n            finalOptions = { // for serialization into the link\n                date: date.format('YYYY-MM-DD'),\n                type: type || 'day'\n            };\n\n            if (typeof attrs === 'string') {\n                innerHtml = attrs;\n                attrs = null;\n            }\n\n            attrs = attrs ? ' ' + attrsToStr(attrs) : ''; // will have a leading space\n            innerHtml = innerHtml || '';\n\n            if (!forceOff && this.opt('navLinks')) {\n                return '<a' + attrs +\n                    ' data-goto=\"' + htmlEscape(JSON.stringify(finalOptions)) + '\">' +\n                    innerHtml +\n                    '</a>';\n            }\n            else {\n                return '<span' + attrs + '>' +\n                    innerHtml +\n                    '</span>';\n            }\n        },\n\n\n        // Rendering Non-date-related Content\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        // Sets the container element that the view should render inside of, does global DOM-related initializations,\n        // and renders all the non-date-related content inside.\n        setElement: function(el) {\n            this.el = el;\n            this.bindGlobalHandlers();\n            this.bindBaseRenderHandlers();\n            this.renderSkeleton();\n        },\n\n\n        // Removes the view's container element from the DOM, clearing any content beforehand.\n        // Undoes any other DOM-related attachments.\n        removeElement: function() {\n            this.unsetDate();\n            this.unrenderSkeleton();\n\n            this.unbindGlobalHandlers();\n            this.unbindBaseRenderHandlers();\n\n            this.el.remove();\n            // NOTE: don't null-out this.el in case the View was destroyed within an API callback.\n            // We don't null-out the View's other jQuery element references upon destroy,\n            //  so we shouldn't kill this.el either.\n        },\n\n\n        // Renders the basic structure of the view before any content is rendered\n        renderSkeleton: function() {\n            // subclasses should implement\n        },\n\n\n        // Unrenders the basic structure of the view\n        unrenderSkeleton: function() {\n            // subclasses should implement\n        },\n\n\n        // Date Setting/Unsetting\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        setDate: function(date) {\n            var currentDateProfile = this.get('dateProfile');\n            var newDateProfile = this.buildDateProfile(date, null, true); // forceToValid=true\n\n            if (\n                !currentDateProfile ||\n                !isRangesEqual(currentDateProfile.activeRange, newDateProfile.activeRange)\n            ) {\n                this.set('dateProfile', newDateProfile);\n            }\n\n            return newDateProfile.date;\n        },\n\n\n        unsetDate: function() {\n            this.unset('dateProfile');\n        },\n\n\n        // Date Rendering\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        requestDateRender: function(dateProfile) {\n            var _this = this;\n\n            this.renderQueue.queue(function() {\n                _this.executeDateRender(dateProfile);\n            }, 'date', 'init');\n        },\n\n\n        requestDateUnrender: function() {\n            var _this = this;\n\n            this.renderQueue.queue(function() {\n                _this.executeDateUnrender();\n            }, 'date', 'destroy');\n        },\n\n\n        // Event Data\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        fetchInitialEvents: function(dateProfile) {\n            return this.calendar.requestEvents(\n                dateProfile.activeRange.start,\n                dateProfile.activeRange.end\n            );\n        },\n\n\n        bindEventChanges: function() {\n            this.listenTo(this.calendar, 'eventsReset', this.resetEvents);\n        },\n\n\n        unbindEventChanges: function() {\n            this.stopListeningTo(this.calendar, 'eventsReset');\n        },\n\n\n        setEvents: function(events) {\n            this.set('currentEvents', events);\n            this.set('hasEvents', true);\n        },\n\n\n        unsetEvents: function() {\n            this.unset('currentEvents');\n            this.unset('hasEvents');\n        },\n\n\n        resetEvents: function(events) {\n            this.startBatchRender();\n            this.unsetEvents();\n            this.setEvents(events);\n            this.stopBatchRender();\n        },\n\n\n        // Event Rendering\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        requestEventsRender: function(events) {\n            var _this = this;\n\n            this.renderQueue.queue(function() {\n                _this.executeEventsRender(events);\n            }, 'event', 'init');\n        },\n\n\n        requestEventsUnrender: function() {\n            var _this = this;\n\n            this.renderQueue.queue(function() {\n                _this.executeEventsUnrender();\n            }, 'event', 'destroy');\n        },\n\n\n        // Date High-level Rendering\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        // if dateProfile not specified, uses current\n        executeDateRender: function(dateProfile, skipScroll) {\n\n            this.setDateProfileForRendering(dateProfile);\n            this.updateTitle();\n            this.calendar.updateToolbarButtons();\n\n            if (this.render) {\n                this.render(); // TODO: deprecate\n            }\n\n            this.renderDates();\n            this.updateSize();\n            this.renderBusinessHours(); // might need coordinates, so should go after updateSize()\n            this.startNowIndicator();\n\n            if (!skipScroll) {\n                this.addScroll(this.computeInitialDateScroll());\n            }\n\n            this.isDatesRendered = true;\n            this.trigger('datesRendered');\n        },\n\n\n        executeDateUnrender: function() {\n\n            this.unselect();\n            this.stopNowIndicator();\n\n            this.trigger('before:datesUnrendered');\n\n            this.unrenderBusinessHours();\n            this.unrenderDates();\n\n            if (this.destroy) {\n                this.destroy(); // TODO: deprecate\n            }\n\n            this.isDatesRendered = false;\n        },\n\n\n        // Date Low-level Rendering\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        // date-cell content only\n        renderDates: function() {\n            // subclasses should implement\n        },\n\n\n        // date-cell content only\n        unrenderDates: function() {\n            // subclasses should override\n        },\n\n\n        // Determing when the \"meat\" of the view is rendered (aka the base)\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        bindBaseRenderHandlers: function() {\n            var _this = this;\n\n            this.on('datesRendered.baseHandler', function() {\n                _this.onBaseRender();\n            });\n\n            this.on('before:datesUnrendered.baseHandler', function() {\n                _this.onBeforeBaseUnrender();\n            });\n        },\n\n\n        unbindBaseRenderHandlers: function() {\n            this.off('.baseHandler');\n        },\n\n\n        onBaseRender: function() {\n            this.applyScreenState();\n            this.publiclyTrigger('viewRender', this, this, this.el);\n        },\n\n\n        onBeforeBaseUnrender: function() {\n            this.applyScreenState();\n            this.publiclyTrigger('viewDestroy', this, this, this.el);\n        },\n\n\n        // Misc view rendering utils\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        // Binds DOM handlers to elements that reside outside the view container, such as the document\n        bindGlobalHandlers: function() {\n            this.listenTo(GlobalEmitter.get(), {\n                touchstart: this.processUnselect,\n                mousedown: this.handleDocumentMousedown\n            });\n        },\n\n\n        // Unbinds DOM handlers from elements that reside outside the view container\n        unbindGlobalHandlers: function() {\n            this.stopListeningTo(GlobalEmitter.get());\n        },\n\n\n        // Initializes internal variables related to theming\n        initThemingProps: function() {\n            var tm = this.opt('theme') ? 'ui' : 'fc';\n\n            this.widgetHeaderClass = tm + '-widget-header';\n            this.widgetContentClass = tm + '-widget-content';\n            this.highlightStateClass = tm + '-state-highlight';\n        },\n\n\n        /* Business Hours\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders business-hours onto the view. Assumes updateSize has already been called.\n        renderBusinessHours: function() {\n            // subclasses should implement\n        },\n\n\n        // Unrenders previously-rendered business-hours\n        unrenderBusinessHours: function() {\n            // subclasses should implement\n        },\n\n\n        /* Now Indicator\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Immediately render the current time indicator and begins re-rendering it at an interval,\n        // which is defined by this.getNowIndicatorUnit().\n        // TODO: somehow do this for the current whole day's background too\n        startNowIndicator: function() {\n            var _this = this;\n            var unit;\n            var update;\n            var delay; // ms wait value\n\n            if (this.opt('nowIndicator')) {\n                unit = this.getNowIndicatorUnit();\n                if (unit) {\n                    update = proxy(this, 'updateNowIndicator'); // bind to `this`\n\n                    this.initialNowDate = this.calendar.getNow();\n                    this.initialNowQueriedMs = +new Date();\n                    this.renderNowIndicator(this.initialNowDate);\n                    this.isNowIndicatorRendered = true;\n\n                    // wait until the beginning of the next interval\n                    delay = this.initialNowDate.clone().startOf(unit).add(1, unit) - this.initialNowDate;\n                    this.nowIndicatorTimeoutID = setTimeout(function() {\n                        _this.nowIndicatorTimeoutID = null;\n                        update();\n                        delay = +moment.duration(1, unit);\n                        delay = Math.max(100, delay); // prevent too frequent\n                        _this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval\n                    }, delay);\n                }\n            }\n        },\n\n\n        // rerenders the now indicator, computing the new current time from the amount of time that has passed\n        // since the initial getNow call.\n        updateNowIndicator: function() {\n            if (this.isNowIndicatorRendered) {\n                this.unrenderNowIndicator();\n                this.renderNowIndicator(\n                    this.initialNowDate.clone().add(new Date() - this.initialNowQueriedMs) // add ms\n                );\n            }\n        },\n\n\n        // Immediately unrenders the view's current time indicator and stops any re-rendering timers.\n        // Won't cause side effects if indicator isn't rendered.\n        stopNowIndicator: function() {\n            if (this.isNowIndicatorRendered) {\n\n                if (this.nowIndicatorTimeoutID) {\n                    clearTimeout(this.nowIndicatorTimeoutID);\n                    this.nowIndicatorTimeoutID = null;\n                }\n                if (this.nowIndicatorIntervalID) {\n                    clearTimeout(this.nowIndicatorIntervalID);\n                    this.nowIndicatorIntervalID = null;\n                }\n\n                this.unrenderNowIndicator();\n                this.isNowIndicatorRendered = false;\n            }\n        },\n\n\n        // Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator\n        // should be refreshed. If something falsy is returned, no time indicator is rendered at all.\n        getNowIndicatorUnit: function() {\n            // subclasses should implement\n        },\n\n\n        // Renders a current time indicator at the given datetime\n        renderNowIndicator: function(date) {\n            // subclasses should implement\n        },\n\n\n        // Undoes the rendering actions from renderNowIndicator\n        unrenderNowIndicator: function() {\n            // subclasses should implement\n        },\n\n\n        /* Dimensions\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Refreshes anything dependant upon sizing of the container element of the grid\n        updateSize: function(isResize) {\n            var scroll;\n\n            if (isResize) {\n                scroll = this.queryScroll();\n            }\n\n            this.updateHeight(isResize);\n            this.updateWidth(isResize);\n            this.updateNowIndicator();\n\n            if (isResize) {\n                this.applyScroll(scroll);\n            }\n        },\n\n\n        // Refreshes the horizontal dimensions of the calendar\n        updateWidth: function(isResize) {\n            // subclasses should implement\n        },\n\n\n        // Refreshes the vertical dimensions of the calendar\n        updateHeight: function(isResize) {\n            var calendar = this.calendar; // we poll the calendar for height information\n\n            this.setHeight(\n                calendar.getSuggestedViewHeight(),\n                calendar.isHeightAuto()\n            );\n        },\n\n\n        // Updates the vertical dimensions of the calendar to the specified height.\n        // if `isAuto` is set to true, height becomes merely a suggestion and the view should use its \"natural\" height.\n        setHeight: function(height, isAuto) {\n            // subclasses should implement\n        },\n\n\n        /* Scroller\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        addForcedScroll: function(scroll) {\n            this.addScroll(\n                $.extend(scroll, { isForced: true })\n            );\n        },\n\n\n        addScroll: function(scroll) {\n            var queuedScroll = this.queuedScroll || (this.queuedScroll = {});\n\n            if (!queuedScroll.isForced) {\n                $.extend(queuedScroll, scroll);\n            }\n        },\n\n\n        popScroll: function() {\n            this.applyQueuedScroll();\n            this.queuedScroll = null;\n        },\n\n\n        applyQueuedScroll: function() {\n            if (this.queuedScroll) {\n                this.applyScroll(this.queuedScroll);\n            }\n        },\n\n\n        queryScroll: function() {\n            var scroll = {};\n\n            if (this.isDatesRendered) {\n                $.extend(scroll, this.queryDateScroll());\n            }\n\n            return scroll;\n        },\n\n\n        applyScroll: function(scroll) {\n            if (this.isDatesRendered) {\n                this.applyDateScroll(scroll);\n            }\n        },\n\n\n        computeInitialDateScroll: function() {\n            return {}; // subclasses must implement\n        },\n\n\n        queryDateScroll: function() {\n            return {}; // subclasses must implement\n        },\n\n\n        applyDateScroll: function(scroll) {\n            ; // subclasses must implement\n        },\n\n\n        /* Height Freezing\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        freezeHeight: function() {\n            this.calendar.freezeContentHeight();\n        },\n\n\n        thawHeight: function() {\n            this.calendar.thawContentHeight();\n        },\n\n\n        // Event High-level Rendering\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        executeEventsRender: function(events) {\n            this.renderEvents(events);\n            this.isEventsRendered = true;\n\n            this.onEventsRender();\n        },\n\n\n        executeEventsUnrender: function() {\n            this.onBeforeEventsUnrender();\n\n            if (this.destroyEvents) {\n                this.destroyEvents(); // TODO: deprecate\n            }\n\n            this.unrenderEvents();\n            this.isEventsRendered = false;\n        },\n\n\n        // Event Rendering Triggers\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        // Signals that all events have been rendered\n        onEventsRender: function() {\n            this.applyScreenState();\n\n            this.renderedEventSegEach(function(seg) {\n                this.publiclyTrigger('eventAfterRender', seg.event, seg.event, seg.el);\n            });\n            this.publiclyTrigger('eventAfterAllRender');\n        },\n\n\n        // Signals that all event elements are about to be removed\n        onBeforeEventsUnrender: function() {\n            this.applyScreenState();\n\n            this.renderedEventSegEach(function(seg) {\n                this.publiclyTrigger('eventDestroy', seg.event, seg.event, seg.el);\n            });\n        },\n\n\n        applyScreenState: function() {\n            this.thawHeight();\n            this.freezeHeight();\n            this.applyQueuedScroll();\n        },\n\n\n        // Event Low-level Rendering\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        // Renders the events onto the view.\n        renderEvents: function(events) {\n            // subclasses should implement\n        },\n\n\n        // Removes event elements from the view.\n        unrenderEvents: function() {\n            // subclasses should implement\n        },\n\n\n        // Event Rendering Utils\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        // Given an event and the default element used for rendering, returns the element that should actually be used.\n        // Basically runs events and elements through the eventRender hook.\n        resolveEventEl: function(event, el) {\n            var custom = this.publiclyTrigger('eventRender', event, event, el);\n\n            if (custom === false) { // means don't render at all\n                el = null;\n            }\n            else if (custom && custom !== true) {\n                el = $(custom);\n            }\n\n            return el;\n        },\n\n\n        // Hides all rendered event segments linked to the given event\n        showEvent: function(event) {\n            this.renderedEventSegEach(function(seg) {\n                seg.el.css('visibility', '');\n            }, event);\n        },\n\n\n        // Shows all rendered event segments linked to the given event\n        hideEvent: function(event) {\n            this.renderedEventSegEach(function(seg) {\n                seg.el.css('visibility', 'hidden');\n            }, event);\n        },\n\n\n        // Iterates through event segments that have been rendered (have an el). Goes through all by default.\n        // If the optional `event` argument is specified, only iterates through segments linked to that event.\n        // The `this` value of the callback function will be the view.\n        renderedEventSegEach: function(func, event) {\n            var segs = this.getEventSegs();\n            var i;\n\n            for (i = 0; i < segs.length; i++) {\n                if (!event || segs[i].event._id === event._id) {\n                    if (segs[i].el) {\n                        func.call(this, segs[i]);\n                    }\n                }\n            }\n        },\n\n\n        // Retrieves all the rendered segment objects for the view\n        getEventSegs: function() {\n            // subclasses must implement\n            return [];\n        },\n\n\n        /* Event Drag-n-Drop\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Computes if the given event is allowed to be dragged by the user\n        isEventDraggable: function(event) {\n            return this.isEventStartEditable(event);\n        },\n\n\n        isEventStartEditable: function(event) {\n            return firstDefined(\n                event.startEditable,\n                (event.source || {}).startEditable,\n                this.opt('eventStartEditable'),\n                this.isEventGenerallyEditable(event)\n            );\n        },\n\n\n        isEventGenerallyEditable: function(event) {\n            return firstDefined(\n                event.editable,\n                (event.source || {}).editable,\n                this.opt('editable')\n            );\n        },\n\n\n        // Must be called when an event in the view is dropped onto new location.\n        // `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.\n        reportSegDrop: function(seg, dropLocation, largeUnit, el, ev) {\n            var calendar = this.calendar;\n            var mutateResult = calendar.mutateSeg(seg, dropLocation, largeUnit);\n            var undoFunc = function() {\n                mutateResult.undo();\n                calendar.reportEventChange();\n            };\n\n            this.triggerEventDrop(seg.event, mutateResult.dateDelta, undoFunc, el, ev);\n            calendar.reportEventChange(); // will rerender events\n        },\n\n\n        // Triggers event-drop handlers that have subscribed via the API\n        triggerEventDrop: function(event, dateDelta, undoFunc, el, ev) {\n            this.publiclyTrigger('eventDrop', el[0], event, dateDelta, undoFunc, ev, {}); // {} = jqui dummy\n        },\n\n\n        /* External Element Drag-n-Drop\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Must be called when an external element, via jQuery UI, has been dropped onto the calendar.\n        // `meta` is the parsed data that has been embedded into the dragging event.\n        // `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.\n        reportExternalDrop: function(meta, dropLocation, el, ev, ui) {\n            var eventProps = meta.eventProps;\n            var eventInput;\n            var event;\n\n            // Try to build an event object and render it. TODO: decouple the two\n            if (eventProps) {\n                eventInput = $.extend({}, eventProps, dropLocation);\n                event = this.calendar.renderEvent(eventInput, meta.stick)[0]; // renderEvent returns an array\n            }\n\n            this.triggerExternalDrop(event, dropLocation, el, ev, ui);\n        },\n\n\n        // Triggers external-drop handlers that have subscribed via the API\n        triggerExternalDrop: function(event, dropLocation, el, ev, ui) {\n\n            // trigger 'drop' regardless of whether element represents an event\n            this.publiclyTrigger('drop', el[0], dropLocation.start, ev, ui);\n\n            if (event) {\n                this.publiclyTrigger('eventReceive', null, event); // signal an external event landed\n            }\n        },\n\n\n        /* Drag-n-Drop Rendering (for both events and external elements)\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders a visual indication of a event or external-element drag over the given drop zone.\n        // If an external-element, seg will be `null`.\n        // Must return elements used for any mock events.\n        renderDrag: function(dropLocation, seg) {\n            // subclasses must implement\n        },\n\n\n        // Unrenders a visual indication of an event or external-element being dragged.\n        unrenderDrag: function() {\n            // subclasses must implement\n        },\n\n\n        /* Event Resizing\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Computes if the given event is allowed to be resized from its starting edge\n        isEventResizableFromStart: function(event) {\n            return this.opt('eventResizableFromStart') && this.isEventResizable(event);\n        },\n\n\n        // Computes if the given event is allowed to be resized from its ending edge\n        isEventResizableFromEnd: function(event) {\n            return this.isEventResizable(event);\n        },\n\n\n        // Computes if the given event is allowed to be resized by the user at all\n        isEventResizable: function(event) {\n            var source = event.source || {};\n\n            return firstDefined(\n                event.durationEditable,\n                source.durationEditable,\n                this.opt('eventDurationEditable'),\n                event.editable,\n                source.editable,\n                this.opt('editable')\n            );\n        },\n\n\n        // Must be called when an event in the view has been resized to a new length\n        reportSegResize: function(seg, resizeLocation, largeUnit, el, ev) {\n            var calendar = this.calendar;\n            var mutateResult = calendar.mutateSeg(seg, resizeLocation, largeUnit);\n            var undoFunc = function() {\n                mutateResult.undo();\n                calendar.reportEventChange();\n            };\n\n            this.triggerEventResize(seg.event, mutateResult.durationDelta, undoFunc, el, ev);\n            calendar.reportEventChange(); // will rerender events\n        },\n\n\n        // Triggers event-resize handlers that have subscribed via the API\n        triggerEventResize: function(event, durationDelta, undoFunc, el, ev) {\n            this.publiclyTrigger('eventResize', el[0], event, durationDelta, undoFunc, ev, {}); // {} = jqui dummy\n        },\n\n\n        /* Selection (time range)\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Selects a date span on the view. `start` and `end` are both Moments.\n        // `ev` is the native mouse event that begin the interaction.\n        select: function(span, ev) {\n            this.unselect(ev);\n            this.renderSelection(span);\n            this.reportSelection(span, ev);\n        },\n\n\n        // Renders a visual indication of the selection\n        renderSelection: function(span) {\n            // subclasses should implement\n        },\n\n\n        // Called when a new selection is made. Updates internal state and triggers handlers.\n        reportSelection: function(span, ev) {\n            this.isSelected = true;\n            this.triggerSelect(span, ev);\n        },\n\n\n        // Triggers handlers to 'select'\n        triggerSelect: function(span, ev) {\n            this.publiclyTrigger(\n                'select',\n                null,\n                this.calendar.applyTimezone(span.start), // convert to calendar's tz for external API\n                this.calendar.applyTimezone(span.end), // \"\n                ev\n            );\n        },\n\n\n        // Undoes a selection. updates in the internal state and triggers handlers.\n        // `ev` is the native mouse event that began the interaction.\n        unselect: function(ev) {\n            if (this.isSelected) {\n                this.isSelected = false;\n                if (this.destroySelection) {\n                    this.destroySelection(); // TODO: deprecate\n                }\n                this.unrenderSelection();\n                this.publiclyTrigger('unselect', null, ev);\n            }\n        },\n\n\n        // Unrenders a visual indication of selection\n        unrenderSelection: function() {\n            // subclasses should implement\n        },\n\n\n        /* Event Selection\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        selectEvent: function(event) {\n            if (!this.selectedEvent || this.selectedEvent !== event) {\n                this.unselectEvent();\n                this.renderedEventSegEach(function(seg) {\n                    seg.el.addClass('fc-selected');\n                }, event);\n                this.selectedEvent = event;\n            }\n        },\n\n\n        unselectEvent: function() {\n            if (this.selectedEvent) {\n                this.renderedEventSegEach(function(seg) {\n                    seg.el.removeClass('fc-selected');\n                }, this.selectedEvent);\n                this.selectedEvent = null;\n            }\n        },\n\n\n        isEventSelected: function(event) {\n            // event references might change on refetchEvents(), while selectedEvent doesn't,\n            // so compare IDs\n            return this.selectedEvent && this.selectedEvent._id === event._id;\n        },\n\n\n        /* Mouse / Touch Unselecting (time range & event unselection)\n         ------------------------------------------------------------------------------------------------------------------*/\n        // TODO: move consistently to down/start or up/end?\n        // TODO: don't kill previous selection if touch scrolling\n\n\n        handleDocumentMousedown: function(ev) {\n            if (isPrimaryMouseButton(ev)) {\n                this.processUnselect(ev);\n            }\n        },\n\n\n        processUnselect: function(ev) {\n            this.processRangeUnselect(ev);\n            this.processEventUnselect(ev);\n        },\n\n\n        processRangeUnselect: function(ev) {\n            var ignore;\n\n            // is there a time-range selection?\n            if (this.isSelected && this.opt('unselectAuto')) {\n                // only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element\n                ignore = this.opt('unselectCancel');\n                if (!ignore || !$(ev.target).closest(ignore).length) {\n                    this.unselect(ev);\n                }\n            }\n        },\n\n\n        processEventUnselect: function(ev) {\n            if (this.selectedEvent) {\n                if (!$(ev.target).closest('.fc-selected').length) {\n                    this.unselectEvent();\n                }\n            }\n        },\n\n\n        /* Day Click\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Triggers handlers to 'dayClick'\n        // Span has start/end of the clicked area. Only the start is useful.\n        triggerDayClick: function(span, dayEl, ev) {\n            this.publiclyTrigger(\n                'dayClick',\n                dayEl,\n                this.calendar.applyTimezone(span.start), // convert to calendar's timezone for external API\n                ev\n            );\n        },\n\n\n        /* Date Utils\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Returns the date range of the full days the given range visually appears to occupy.\n        // Returns a new range object.\n        computeDayRange: function(range) {\n            var startDay = range.start.clone().stripTime(); // the beginning of the day the range starts\n            var end = range.end;\n            var endDay = null;\n            var endTimeMS;\n\n            if (end) {\n                endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends\n                endTimeMS = +end.time(); // # of milliseconds into `endDay`\n\n                // If the end time is actually inclusively part of the next day and is equal to or\n                // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n                // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n                if (endTimeMS && endTimeMS >= this.nextDayThreshold) {\n                    endDay.add(1, 'days');\n                }\n            }\n\n            // If no end was specified, or if it is within `startDay` but not past nextDayThreshold,\n            // assign the default duration of one day.\n            if (!end || endDay <= startDay) {\n                endDay = startDay.clone().add(1, 'days');\n            }\n\n            return { start: startDay, end: endDay };\n        },\n\n\n        // Does the given event visually appear to occupy more than one day?\n        isMultiDayEvent: function(event) {\n            var range = this.computeDayRange(event); // event is range-ish\n\n            return range.end.diff(range.start, 'days') > 1;\n        }\n\n    });\n\n\n    View.watch('displayingDates', [ 'dateProfile' ], function(deps) {\n        this.requestDateRender(deps.dateProfile);\n    }, function() {\n        this.requestDateUnrender();\n    });\n\n\n    View.watch('initialEvents', [ 'dateProfile' ], function(deps) {\n        return this.fetchInitialEvents(deps.dateProfile);\n    });\n\n\n    View.watch('bindingEvents', [ 'initialEvents' ], function(deps) {\n        this.setEvents(deps.initialEvents);\n        this.bindEventChanges();\n    }, function() {\n        this.unbindEventChanges();\n        this.unsetEvents();\n    });\n\n\n    View.watch('displayingEvents', [ 'displayingDates', 'hasEvents' ], function() {\n        this.requestEventsRender(this.get('currentEvents')); // if there were event mutations after initialEvents\n    }, function() {\n        this.requestEventsUnrender();\n    });\n\n    ;;\n\n    View.mixin({\n\n        // range the view is formally responsible for.\n        // for example, a month view might have 1st-31st, excluding padded dates\n        currentRange: null,\n        currentRangeUnit: null, // name of largest unit being displayed, like \"month\" or \"week\"\n\n        // date range with a rendered skeleton\n        // includes not-active days that need some sort of DOM\n        renderRange: null,\n\n        // dates that display events and accept drag-n-drop\n        activeRange: null,\n\n        // constraint for where prev/next operations can go and where events can be dragged/resized to.\n        // an object with optional start and end properties.\n        validRange: null,\n\n        // how far the current date will move for a prev/next operation\n        dateIncrement: null,\n\n        minTime: null, // Duration object that denotes the first visible time of any given day\n        maxTime: null, // Duration object that denotes the exclusive visible end time of any given day\n        usesMinMaxTime: false, // whether minTime/maxTime will affect the activeRange. Views must opt-in.\n\n        // DEPRECATED\n        start: null, // use activeRange.start\n        end: null, // use activeRange.end\n        intervalStart: null, // use currentRange.start\n        intervalEnd: null, // use currentRange.end\n\n\n        /* Date Range Computation\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        setDateProfileForRendering: function(dateProfile) {\n            this.currentRange = dateProfile.currentRange;\n            this.currentRangeUnit = dateProfile.currentRangeUnit;\n            this.renderRange = dateProfile.renderRange;\n            this.activeRange = dateProfile.activeRange;\n            this.validRange = dateProfile.validRange;\n            this.dateIncrement = dateProfile.dateIncrement;\n            this.minTime = dateProfile.minTime;\n            this.maxTime = dateProfile.maxTime;\n\n            // DEPRECATED, but we need to keep it updated\n            this.start = dateProfile.activeRange.start;\n            this.end = dateProfile.activeRange.end;\n            this.intervalStart = dateProfile.currentRange.start;\n            this.intervalEnd = dateProfile.currentRange.end;\n        },\n\n\n        // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n        buildPrevDateProfile: function(date) {\n            var prevDate = date.clone().startOf(this.currentRangeUnit).subtract(this.dateIncrement);\n\n            return this.buildDateProfile(prevDate, -1);\n        },\n\n\n        // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n        buildNextDateProfile: function(date) {\n            var nextDate = date.clone().startOf(this.currentRangeUnit).add(this.dateIncrement);\n\n            return this.buildDateProfile(nextDate, 1);\n        },\n\n\n        // Builds a structure holding dates/ranges for rendering around the given date.\n        // Optional direction param indicates whether the date is being incremented/decremented\n        // from its previous value. decremented = -1, incremented = 1 (default).\n        buildDateProfile: function(date, direction, forceToValid) {\n            var validRange = this.buildValidRange();\n            var minTime = null;\n            var maxTime = null;\n            var currentInfo;\n            var renderRange;\n            var activeRange;\n            var isValid;\n\n            if (forceToValid) {\n                date = constrainDate(date, validRange);\n            }\n\n            currentInfo = this.buildCurrentRangeInfo(date, direction);\n            renderRange = this.buildRenderRange(currentInfo.range, currentInfo.unit);\n            activeRange = cloneRange(renderRange);\n\n            if (!this.opt('showNonCurrentDates')) {\n                activeRange = constrainRange(activeRange, currentInfo.range);\n            }\n\n            minTime = moment.duration(this.opt('minTime'));\n            maxTime = moment.duration(this.opt('maxTime'));\n            this.adjustActiveRange(activeRange, minTime, maxTime);\n\n            activeRange = constrainRange(activeRange, validRange);\n            date = constrainDate(date, activeRange);\n\n            // it's invalid if the originally requested date is not contained,\n            // or if the range is completely outside of the valid range.\n            isValid = doRangesIntersect(currentInfo.range, validRange);\n\n            return {\n                validRange: validRange,\n                currentRange: currentInfo.range,\n                currentRangeUnit: currentInfo.unit,\n                activeRange: activeRange,\n                renderRange: renderRange,\n                minTime: minTime,\n                maxTime: maxTime,\n                isValid: isValid,\n                date: date,\n                dateIncrement: this.buildDateIncrement(currentInfo.duration)\n                // pass a fallback (might be null) ^\n            };\n        },\n\n\n        // Builds an object with optional start/end properties.\n        // Indicates the minimum/maximum dates to display.\n        buildValidRange: function() {\n            return this.getRangeOption('validRange', this.calendar.getNow()) || {};\n        },\n\n\n        // Builds a structure with info about the \"current\" range, the range that is\n        // highlighted as being the current month for example.\n        // See buildDateProfile for a description of `direction`.\n        // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n        buildCurrentRangeInfo: function(date, direction) {\n            var duration = null;\n            var unit = null;\n            var range = null;\n            var dayCount;\n\n            if (this.viewSpec.duration) {\n                duration = this.viewSpec.duration;\n                unit = this.viewSpec.durationUnit;\n                range = this.buildRangeFromDuration(date, direction, duration, unit);\n            }\n            else if ((dayCount = this.opt('dayCount'))) {\n                unit = 'day';\n                range = this.buildRangeFromDayCount(date, direction, dayCount);\n            }\n            else if ((range = this.buildCustomVisibleRange(date))) {\n                unit = computeGreatestUnit(range.start, range.end);\n            }\n            else {\n                duration = this.getFallbackDuration();\n                unit = computeGreatestUnit(duration);\n                range = this.buildRangeFromDuration(date, direction, duration, unit);\n            }\n\n            this.normalizeCurrentRange(range, unit); // modifies in-place\n\n            return { duration: duration, unit: unit, range: range };\n        },\n\n\n        getFallbackDuration: function() {\n            return moment.duration({ days: 1 });\n        },\n\n\n        // If the range has day units or larger, remove times. Otherwise, ensure times.\n        normalizeCurrentRange: function(range, unit) {\n\n            if (/^(year|month|week|day)$/.test(unit)) { // whole-days?\n                range.start.stripTime();\n                range.end.stripTime();\n            }\n            else { // needs to have a time?\n                if (!range.start.hasTime()) {\n                    range.start.time(0); // give 00:00 time\n                }\n                if (!range.end.hasTime()) {\n                    range.end.time(0); // give 00:00 time\n                }\n            }\n        },\n\n\n        // Mutates the given activeRange to have time values (un-ambiguate)\n        // if the minTime or maxTime causes the range to expand.\n        // TODO: eventually activeRange should *always* have times.\n        adjustActiveRange: function(range, minTime, maxTime) {\n            var hasSpecialTimes = false;\n\n            if (this.usesMinMaxTime) {\n\n                if (minTime < 0) {\n                    range.start.time(0).add(minTime);\n                    hasSpecialTimes = true;\n                }\n\n                if (maxTime > 24 * 60 * 60 * 1000) { // beyond 24 hours?\n                    range.end.time(maxTime - (24 * 60 * 60 * 1000));\n                    hasSpecialTimes = true;\n                }\n\n                if (hasSpecialTimes) {\n                    if (!range.start.hasTime()) {\n                        range.start.time(0);\n                    }\n                    if (!range.end.hasTime()) {\n                        range.end.time(0);\n                    }\n                }\n            }\n        },\n\n\n        // Builds the \"current\" range when it is specified as an explicit duration.\n        // `unit` is the already-computed computeGreatestUnit value of duration.\n        buildRangeFromDuration: function(date, direction, duration, unit) {\n            var alignment = this.opt('dateAlignment');\n            var start = date.clone();\n            var end;\n            var dateIncrementInput;\n            var dateIncrementDuration;\n\n            // if the view displays a single day or smaller\n            if (duration.as('days') <= 1) {\n                if (this.isHiddenDay(start)) {\n                    start = this.skipHiddenDays(start, direction);\n                    start.startOf('day');\n                }\n            }\n\n            // compute what the alignment should be\n            if (!alignment) {\n                dateIncrementInput = this.opt('dateIncrement');\n\n                if (dateIncrementInput) {\n                    dateIncrementDuration = moment.duration(dateIncrementInput);\n\n                    // use the smaller of the two units\n                    if (dateIncrementDuration < duration) {\n                        alignment = computeDurationGreatestUnit(dateIncrementDuration, dateIncrementInput);\n                    }\n                    else {\n                        alignment = unit;\n                    }\n                }\n                else {\n                    alignment = unit;\n                }\n            }\n\n            start.startOf(alignment);\n            end = start.clone().add(duration);\n\n            return { start: start, end: end };\n        },\n\n\n        // Builds the \"current\" range when a dayCount is specified.\n        buildRangeFromDayCount: function(date, direction, dayCount) {\n            var customAlignment = this.opt('dateAlignment');\n            var runningCount = 0;\n            var start = date.clone();\n            var end;\n\n            if (customAlignment) {\n                start.startOf(customAlignment);\n            }\n\n            start.startOf('day');\n            start = this.skipHiddenDays(start, direction);\n\n            end = start.clone();\n            do {\n                end.add(1, 'day');\n                if (!this.isHiddenDay(end)) {\n                    runningCount++;\n                }\n            } while (runningCount < dayCount);\n\n            return { start: start, end: end };\n        },\n\n\n        // Builds a normalized range object for the \"visible\" range,\n        // which is a way to define the currentRange and activeRange at the same time.\n        buildCustomVisibleRange: function(date) {\n            var visibleRange = this.getRangeOption(\n                'visibleRange',\n                this.calendar.moment(date) // correct zone. also generates new obj that avoids mutations\n            );\n\n            if (visibleRange && (!visibleRange.start || !visibleRange.end)) {\n                return null;\n            }\n\n            return visibleRange;\n        },\n\n\n        // Computes the range that will represent the element/cells for *rendering*,\n        // but which may have voided days/times.\n        buildRenderRange: function(currentRange, currentRangeUnit) {\n            // cut off days in the currentRange that are hidden\n            return this.trimHiddenDays(currentRange);\n        },\n\n\n        // Compute the duration value that should be added/substracted to the current date\n        // when a prev/next operation happens.\n        buildDateIncrement: function(fallback) {\n            var dateIncrementInput = this.opt('dateIncrement');\n            var customAlignment;\n\n            if (dateIncrementInput) {\n                return moment.duration(dateIncrementInput);\n            }\n            else if ((customAlignment = this.opt('dateAlignment'))) {\n                return moment.duration(1, customAlignment);\n            }\n            else if (fallback) {\n                return fallback;\n            }\n            else {\n                return moment.duration({ days: 1 });\n            }\n        },\n\n\n        // Remove days from the beginning and end of the range that are computed as hidden.\n        trimHiddenDays: function(inputRange) {\n            return {\n                start: this.skipHiddenDays(inputRange.start),\n                end: this.skipHiddenDays(inputRange.end, -1, true) // exclusively move backwards\n            };\n        },\n\n\n        // Compute the number of the give units in the \"current\" range.\n        // Will return a floating-point number. Won't round.\n        currentRangeAs: function(unit) {\n            var currentRange = this.currentRange;\n            return currentRange.end.diff(currentRange.start, unit, true);\n        },\n\n\n        // Arguments after name will be forwarded to a hypothetical function value\n        // WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.\n        // Always clone your objects if you fear mutation.\n        getRangeOption: function(name) {\n            var val = this.opt(name);\n\n            if (typeof val === 'function') {\n                val = val.apply(\n                    null,\n                    Array.prototype.slice.call(arguments, 1)\n                );\n            }\n\n            if (val) {\n                return this.calendar.parseRange(val);\n            }\n        },\n\n\n        /* Hidden Days\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Initializes internal variables related to calculating hidden days-of-week\n        initHiddenDays: function() {\n            var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden\n            var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n            var dayCnt = 0;\n            var i;\n\n            if (this.opt('weekends') === false) {\n                hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n            }\n\n            for (i = 0; i < 7; i++) {\n                if (\n                    !(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)\n                ) {\n                    dayCnt++;\n                }\n            }\n\n            if (!dayCnt) {\n                throw 'invalid hiddenDays'; // all days were hidden? bad.\n            }\n\n            this.isHiddenDayHash = isHiddenDayHash;\n        },\n\n\n        // Is the current day hidden?\n        // `day` is a day-of-week index (0-6), or a Moment\n        isHiddenDay: function(day) {\n            if (moment.isMoment(day)) {\n                day = day.day();\n            }\n            return this.isHiddenDayHash[day];\n        },\n\n\n        // Incrementing the current day until it is no longer a hidden day, returning a copy.\n        // DOES NOT CONSIDER validRange!\n        // If the initial value of `date` is not a hidden day, don't do anything.\n        // Pass `isExclusive` as `true` if you are dealing with an end date.\n        // `inc` defaults to `1` (increment one day forward each time)\n        skipHiddenDays: function(date, inc, isExclusive) {\n            var out = date.clone();\n            inc = inc || 1;\n            while (\n                this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]\n                ) {\n                out.add(inc, 'days');\n            }\n            return out;\n        }\n\n    });\n\n    ;;\n\n    /*\n     Embodies a div that has potential scrollbars\n     */\n    var Scroller = FC.Scroller = Class.extend({\n\n        el: null, // the guaranteed outer element\n        scrollEl: null, // the element with the scrollbars\n        overflowX: null,\n        overflowY: null,\n\n\n        constructor: function(options) {\n            options = options || {};\n            this.overflowX = options.overflowX || options.overflow || 'auto';\n            this.overflowY = options.overflowY || options.overflow || 'auto';\n        },\n\n\n        render: function() {\n            this.el = this.renderEl();\n            this.applyOverflow();\n        },\n\n\n        renderEl: function() {\n            return (this.scrollEl = $('<div class=\"fc-scroller\"></div>'));\n        },\n\n\n        // sets to natural height, unlocks overflow\n        clear: function() {\n            this.setHeight('auto');\n            this.applyOverflow();\n        },\n\n\n        destroy: function() {\n            this.el.remove();\n        },\n\n\n        // Overflow\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        applyOverflow: function() {\n            this.scrollEl.css({\n                'overflow-x': this.overflowX,\n                'overflow-y': this.overflowY\n            });\n        },\n\n\n        // Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.\n        // Useful for preserving scrollbar widths regardless of future resizes.\n        // Can pass in scrollbarWidths for optimization.\n        lockOverflow: function(scrollbarWidths) {\n            var overflowX = this.overflowX;\n            var overflowY = this.overflowY;\n\n            scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();\n\n            if (overflowX === 'auto') {\n                overflowX = (\n                    scrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?\n                    // OR scrolling pane with massless scrollbars?\n                    this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth\n                    // subtract 1 because of IE off-by-one issue\n                ) ? 'scroll' : 'hidden';\n            }\n\n            if (overflowY === 'auto') {\n                overflowY = (\n                    scrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?\n                    // OR scrolling pane with massless scrollbars?\n                    this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight\n                    // subtract 1 because of IE off-by-one issue\n                ) ? 'scroll' : 'hidden';\n            }\n\n            this.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });\n        },\n\n\n        // Getters / Setters\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        setHeight: function(height) {\n            this.scrollEl.height(height);\n        },\n\n\n        getScrollTop: function() {\n            return this.scrollEl.scrollTop();\n        },\n\n\n        setScrollTop: function(top) {\n            this.scrollEl.scrollTop(top);\n        },\n\n\n        getClientWidth: function() {\n            return this.scrollEl[0].clientWidth;\n        },\n\n\n        getClientHeight: function() {\n            return this.scrollEl[0].clientHeight;\n        },\n\n\n        getScrollbarWidths: function() {\n            return getScrollbarWidths(this.scrollEl);\n        }\n\n    });\n\n    ;;\n    function Iterator(items) {\n        this.items = items || [];\n    }\n\n\n    /* Calls a method on every item passing the arguments through */\n    Iterator.prototype.proxyCall = function(methodName) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        var results = [];\n\n        this.items.forEach(function(item) {\n            results.push(item[methodName].apply(item, args));\n        });\n\n        return results;\n    };\n\n    ;;\n\n    /* Toolbar with buttons and title\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n    function Toolbar(calendar, toolbarOptions) {\n        var t = this;\n\n        // exports\n        t.setToolbarOptions = setToolbarOptions;\n        t.render = render;\n        t.removeElement = removeElement;\n        t.updateTitle = updateTitle;\n        t.activateButton = activateButton;\n        t.deactivateButton = deactivateButton;\n        t.disableButton = disableButton;\n        t.enableButton = enableButton;\n        t.getViewsWithButtons = getViewsWithButtons;\n        t.el = null; // mirrors local `el`\n\n        // locals\n        var el;\n        var viewsWithButtons = [];\n        var tm;\n\n        // method to update toolbar-specific options, not calendar-wide options\n        function setToolbarOptions(newToolbarOptions) {\n            toolbarOptions = newToolbarOptions;\n        }\n\n        // can be called repeatedly and will rerender\n        function render() {\n            var sections = toolbarOptions.layout;\n\n            tm = calendar.opt('theme') ? 'ui' : 'fc';\n\n            if (sections) {\n                if (!el) {\n                    el = this.el = $(\"<div class='fc-toolbar \"+ toolbarOptions.extraClasses + \"'/>\");\n                }\n                else {\n                    el.empty();\n                }\n                el.append(renderSection('left'))\n                    .append(renderSection('right'))\n                    .append(renderSection('center'))\n                    .append('<div class=\"fc-clear\"/>');\n            }\n            else {\n                removeElement();\n            }\n        }\n\n\n        function removeElement() {\n            if (el) {\n                el.remove();\n                el = t.el = null;\n            }\n        }\n\n\n        function renderSection(position) {\n            var sectionEl = $('<div class=\"fc-' + position + '\"/>');\n            var buttonStr = toolbarOptions.layout[position];\n            var calendarCustomButtons = calendar.opt('customButtons') || {};\n            var calendarButtonText = calendar.opt('buttonText') || {};\n\n            if (buttonStr) {\n                $.each(buttonStr.split(' '), function(i) {\n                    var groupChildren = $();\n                    var isOnlyButtons = true;\n                    var groupEl;\n\n                    $.each(this.split(','), function(j, buttonName) {\n                        var customButtonProps;\n                        var viewSpec;\n                        var buttonClick;\n                        var overrideText; // text explicitly set by calendar's constructor options. overcomes icons\n                        var defaultText;\n                        var themeIcon;\n                        var normalIcon;\n                        var innerHtml;\n                        var classes;\n                        var button; // the element\n\n                        if (buttonName == 'title') {\n                            groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height\n                            isOnlyButtons = false;\n                        }\n                        else {\n                            if ((customButtonProps = calendarCustomButtons[buttonName])) {\n                                buttonClick = function(ev) {\n                                    if (customButtonProps.click) {\n                                        customButtonProps.click.call(button[0], ev);\n                                    }\n                                };\n                                overrideText = ''; // icons will override text\n                                defaultText = customButtonProps.text;\n                            }\n                            else if ((viewSpec = calendar.getViewSpec(buttonName))) {\n                                buttonClick = function() {\n                                    calendar.changeView(buttonName);\n                                };\n                                viewsWithButtons.push(buttonName);\n                                overrideText = viewSpec.buttonTextOverride;\n                                defaultText = viewSpec.buttonTextDefault;\n                            }\n                            else if (calendar[buttonName]) { // a calendar method\n                                buttonClick = function() {\n                                    calendar[buttonName]();\n                                };\n                                overrideText = (calendar.overrides.buttonText || {})[buttonName];\n                                defaultText = calendarButtonText[buttonName]; // everything else is considered default\n                            }\n\n                            if (buttonClick) {\n\n                                themeIcon =\n                                    customButtonProps ?\n                                        customButtonProps.themeIcon :\n                                        calendar.opt('themeButtonIcons')[buttonName];\n\n                                normalIcon =\n                                    customButtonProps ?\n                                        customButtonProps.icon :\n                                        calendar.opt('buttonIcons')[buttonName];\n\n                                if (overrideText) {\n                                    innerHtml = htmlEscape(overrideText);\n                                }\n                                else if (themeIcon && calendar.opt('theme')) {\n                                    innerHtml = \"<span class='ui-icon ui-icon-\" + themeIcon + \"'></span>\";\n                                }\n                                else if (normalIcon && !calendar.opt('theme')) {\n                                    innerHtml = \"<span class='fc-icon fc-icon-\" + normalIcon + \"'></span>\";\n                                }\n                                else {\n                                    innerHtml = htmlEscape(defaultText);\n                                }\n\n                                classes = [\n                                    'fc-' + buttonName + '-button',\n                                    tm + '-button',\n                                    tm + '-state-default'\n                                ];\n\n                                button = $( // type=\"button\" so that it doesn't submit a form\n                                    '<button type=\"button\" class=\"' + classes.join(' ') + '\">' +\n                                    innerHtml +\n                                    '</button>'\n                                )\n                                    .click(function(ev) {\n                                        // don't process clicks for disabled buttons\n                                        if (!button.hasClass(tm + '-state-disabled')) {\n\n                                            buttonClick(ev);\n\n                                            // after the click action, if the button becomes the \"active\" tab, or disabled,\n                                            // it should never have a hover class, so remove it now.\n                                            if (\n                                                button.hasClass(tm + '-state-active') ||\n                                                button.hasClass(tm + '-state-disabled')\n                                            ) {\n                                                button.removeClass(tm + '-state-hover');\n                                            }\n                                        }\n                                    })\n                                    .mousedown(function() {\n                                        // the *down* effect (mouse pressed in).\n                                        // only on buttons that are not the \"active\" tab, or disabled\n                                        button\n                                            .not('.' + tm + '-state-active')\n                                            .not('.' + tm + '-state-disabled')\n                                            .addClass(tm + '-state-down');\n                                    })\n                                    .mouseup(function() {\n                                        // undo the *down* effect\n                                        button.removeClass(tm + '-state-down');\n                                    })\n                                    .hover(\n                                        function() {\n                                            // the *hover* effect.\n                                            // only on buttons that are not the \"active\" tab, or disabled\n                                            button\n                                                .not('.' + tm + '-state-active')\n                                                .not('.' + tm + '-state-disabled')\n                                                .addClass(tm + '-state-hover');\n                                        },\n                                        function() {\n                                            // undo the *hover* effect\n                                            button\n                                                .removeClass(tm + '-state-hover')\n                                                .removeClass(tm + '-state-down'); // if mouseleave happens before mouseup\n                                        }\n                                    );\n\n                                groupChildren = groupChildren.add(button);\n                            }\n                        }\n                    });\n\n                    if (isOnlyButtons) {\n                        groupChildren\n                            .first().addClass(tm + '-corner-left').end()\n                            .last().addClass(tm + '-corner-right').end();\n                    }\n\n                    if (groupChildren.length > 1) {\n                        groupEl = $('<div/>');\n                        if (isOnlyButtons) {\n                            groupEl.addClass('fc-button-group');\n                        }\n                        groupEl.append(groupChildren);\n                        sectionEl.append(groupEl);\n                    }\n                    else {\n                        sectionEl.append(groupChildren); // 1 or 0 children\n                    }\n                });\n            }\n\n            return sectionEl;\n        }\n\n\n        function updateTitle(text) {\n            if (el) {\n                el.find('h2').text(text);\n            }\n        }\n\n\n        function activateButton(buttonName) {\n            if (el) {\n                el.find('.fc-' + buttonName + '-button')\n                    .addClass(tm + '-state-active');\n            }\n        }\n\n\n        function deactivateButton(buttonName) {\n            if (el) {\n                el.find('.fc-' + buttonName + '-button')\n                    .removeClass(tm + '-state-active');\n            }\n        }\n\n\n        function disableButton(buttonName) {\n            if (el) {\n                el.find('.fc-' + buttonName + '-button')\n                    .prop('disabled', true)\n                    .addClass(tm + '-state-disabled');\n            }\n        }\n\n\n        function enableButton(buttonName) {\n            if (el) {\n                el.find('.fc-' + buttonName + '-button')\n                    .prop('disabled', false)\n                    .removeClass(tm + '-state-disabled');\n            }\n        }\n\n\n        function getViewsWithButtons() {\n            return viewsWithButtons;\n        }\n\n    }\n\n    ;;\n\n    var Calendar = FC.Calendar = Class.extend(EmitterMixin, {\n\n        view: null, // current View object\n        viewsByType: null, // holds all instantiated view instances, current or not\n        currentDate: null, // unzoned moment. private (public API should use getDate instead)\n        loadingLevel: 0, // number of simultaneous loading tasks\n\n\n        constructor: function(el, overrides) {\n\n            // declare the current calendar instance relies on GlobalEmitter. needed for garbage collection.\n            // unneeded() is called in destroy.\n            GlobalEmitter.needed();\n\n            this.el = el;\n            this.viewsByType = {};\n            this.viewSpecCache = {};\n\n            this.initOptionsInternals(overrides);\n            this.initMomentInternals(); // needs to happen after options hash initialized\n            this.initCurrentDate();\n\n            EventManager.call(this); // needs options immediately\n            this.initialize();\n        },\n\n\n        // Subclasses can override this for initialization logic after the constructor has been called\n        initialize: function() {\n        },\n\n\n        // Public API\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        getCalendar: function() {\n            return this;\n        },\n\n\n        getView: function() {\n            return this.view;\n        },\n\n\n        publiclyTrigger: function(name, thisObj) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            var optHandler = this.opt(name);\n\n            thisObj = thisObj || this.el[0];\n            this.triggerWith(name, thisObj, args); // Emitter's method\n\n            if (optHandler) {\n                return optHandler.apply(thisObj, args);\n            }\n        },\n\n\n        // View\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        // Given a view name for a custom view or a standard view, creates a ready-to-go View object\n        instantiateView: function(viewType) {\n            var spec = this.getViewSpec(viewType);\n\n            return new spec['class'](this, spec);\n        },\n\n\n        // Returns a boolean about whether the view is okay to instantiate at some point\n        isValidViewType: function(viewType) {\n            return Boolean(this.getViewSpec(viewType));\n        },\n\n\n        changeView: function(viewName, dateOrRange) {\n\n            if (dateOrRange) {\n\n                if (dateOrRange.start && dateOrRange.end) { // a range\n                    this.recordOptionOverrides({ // will not rerender\n                        visibleRange: dateOrRange\n                    });\n                }\n                else { // a date\n                    this.currentDate = this.moment(dateOrRange).stripZone(); // just like gotoDate\n                }\n            }\n\n            this.renderView(viewName);\n        },\n\n\n        // Forces navigation to a view for the given date.\n        // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n        zoomTo: function(newDate, viewType) {\n            var spec;\n\n            viewType = viewType || 'day'; // day is default zoom\n            spec = this.getViewSpec(viewType) || this.getUnitViewSpec(viewType);\n\n            this.currentDate = newDate.clone();\n            this.renderView(spec ? spec.type : null);\n        },\n\n\n        // Current Date\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        initCurrentDate: function() {\n            var defaultDateInput = this.opt('defaultDate');\n\n            // compute the initial ambig-timezone date\n            if (defaultDateInput != null) {\n                this.currentDate = this.moment(defaultDateInput).stripZone();\n            }\n            else {\n                this.currentDate = this.getNow(); // getNow already returns unzoned\n            }\n        },\n\n\n        prev: function() {\n            var prevInfo = this.view.buildPrevDateProfile(this.currentDate);\n\n            if (prevInfo.isValid) {\n                this.currentDate = prevInfo.date;\n                this.renderView();\n            }\n        },\n\n\n        next: function() {\n            var nextInfo = this.view.buildNextDateProfile(this.currentDate);\n\n            if (nextInfo.isValid) {\n                this.currentDate = nextInfo.date;\n                this.renderView();\n            }\n        },\n\n\n        prevYear: function() {\n            this.currentDate.add(-1, 'years');\n            this.renderView();\n        },\n\n\n        nextYear: function() {\n            this.currentDate.add(1, 'years');\n            this.renderView();\n        },\n\n\n        today: function() {\n            this.currentDate = this.getNow(); // should deny like prev/next?\n            this.renderView();\n        },\n\n\n        gotoDate: function(zonedDateInput) {\n            this.currentDate = this.moment(zonedDateInput).stripZone();\n            this.renderView();\n        },\n\n\n        incrementDate: function(delta) {\n            this.currentDate.add(moment.duration(delta));\n            this.renderView();\n        },\n\n\n        // for external API\n        getDate: function() {\n            return this.applyTimezone(this.currentDate); // infuse the calendar's timezone\n        },\n\n\n        // Loading Triggering\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        // Should be called when any type of async data fetching begins\n        pushLoading: function() {\n            if (!(this.loadingLevel++)) {\n                this.publiclyTrigger('loading', null, true, this.view);\n            }\n        },\n\n\n        // Should be called when any type of async data fetching completes\n        popLoading: function() {\n            if (!(--this.loadingLevel)) {\n                this.publiclyTrigger('loading', null, false, this.view);\n            }\n        },\n\n\n        // Selection\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        // this public method receives start/end dates in any format, with any timezone\n        select: function(zonedStartInput, zonedEndInput) {\n            this.view.select(\n                this.buildSelectSpan.apply(this, arguments)\n            );\n        },\n\n\n        unselect: function() { // safe to be called before renderView\n            if (this.view) {\n                this.view.unselect();\n            }\n        },\n\n\n        // Given arguments to the select method in the API, returns a span (unzoned start/end and other info)\n        buildSelectSpan: function(zonedStartInput, zonedEndInput) {\n            var start = this.moment(zonedStartInput).stripZone();\n            var end;\n\n            if (zonedEndInput) {\n                end = this.moment(zonedEndInput).stripZone();\n            }\n            else if (start.hasTime()) {\n                end = start.clone().add(this.defaultTimedEventDuration);\n            }\n            else {\n                end = start.clone().add(this.defaultAllDayEventDuration);\n            }\n\n            return { start: start, end: end };\n        },\n\n\n        // Misc\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        // will return `null` if invalid range\n        parseRange: function(rangeInput) {\n            var start = null;\n            var end = null;\n\n            if (rangeInput.start) {\n                start = this.moment(rangeInput.start).stripZone();\n            }\n\n            if (rangeInput.end) {\n                end = this.moment(rangeInput.end).stripZone();\n            }\n\n            if (!start && !end) {\n                return null;\n            }\n\n            if (start && end && end.isBefore(start)) {\n                return null;\n            }\n\n            return { start: start, end: end };\n        },\n\n\n        rerenderEvents: function() { // API method. destroys old events if previously rendered.\n            if (this.elementVisible()) {\n                this.reportEventChange(); // will re-trasmit events to the view, causing a rerender\n            }\n        }\n\n    });\n\n    ;;\n    /*\n     Options binding/triggering system.\n     */\n    Calendar.mixin({\n\n        dirDefaults: null, // option defaults related to LTR or RTL\n        localeDefaults: null, // option defaults related to current locale\n        overrides: null, // option overrides given to the fullCalendar constructor\n        dynamicOverrides: null, // options set with dynamic setter method. higher precedence than view overrides.\n        optionsModel: null, // all defaults combined with overrides\n\n\n        initOptionsInternals: function(overrides) {\n            this.overrides = $.extend({}, overrides); // make a copy\n            this.dynamicOverrides = {};\n            this.optionsModel = new Model();\n\n            this.populateOptionsHash();\n        },\n\n\n        // public getter/setter\n        option: function(name, value) {\n            var newOptionHash;\n\n            if (typeof name === 'string') {\n                if (value === undefined) { // getter\n                    return this.optionsModel.get(name);\n                }\n                else { // setter for individual option\n                    newOptionHash = {};\n                    newOptionHash[name] = value;\n                    this.setOptions(newOptionHash);\n                }\n            }\n            else if (typeof name === 'object') { // compound setter with object input\n                this.setOptions(name);\n            }\n        },\n\n\n        // private getter\n        opt: function(name) {\n            return this.optionsModel.get(name);\n        },\n\n\n        setOptions: function(newOptionHash) {\n            var optionCnt = 0;\n            var optionName;\n\n            this.recordOptionOverrides(newOptionHash);\n\n            for (optionName in newOptionHash) {\n                optionCnt++;\n            }\n\n            // special-case handling of single option change.\n            // if only one option change, `optionName` will be its name.\n            if (optionCnt === 1) {\n                if (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {\n                    this.updateSize(true); // true = allow recalculation of height\n                    return;\n                }\n                else if (optionName === 'defaultDate') {\n                    return; // can't change date this way. use gotoDate instead\n                }\n                else if (optionName === 'businessHours') {\n                    if (this.view) {\n                        this.view.unrenderBusinessHours();\n                        this.view.renderBusinessHours();\n                    }\n                    return;\n                }\n                else if (optionName === 'timezone') {\n                    this.rezoneArrayEventSources();\n                    this.refetchEvents();\n                    return;\n                }\n            }\n\n            // catch-all. rerender the header and footer and rebuild/rerender the current view\n            this.renderHeader();\n            this.renderFooter();\n\n            // even non-current views will be affected by this option change. do before rerender\n            // TODO: detangle\n            this.viewsByType = {};\n\n            this.reinitView();\n        },\n\n\n        // Computes the flattened options hash for the calendar and assigns to `this.options`.\n        // Assumes this.overrides and this.dynamicOverrides have already been initialized.\n        populateOptionsHash: function() {\n            var locale, localeDefaults;\n            var isRTL, dirDefaults;\n            var rawOptions;\n\n            locale = firstDefined( // explicit locale option given?\n                this.dynamicOverrides.locale,\n                this.overrides.locale\n            );\n            localeDefaults = localeOptionHash[locale];\n            if (!localeDefaults) { // explicit locale option not given or invalid?\n                locale = Calendar.defaults.locale;\n                localeDefaults = localeOptionHash[locale] || {};\n            }\n\n            isRTL = firstDefined( // based on options computed so far, is direction RTL?\n                this.dynamicOverrides.isRTL,\n                this.overrides.isRTL,\n                localeDefaults.isRTL,\n                Calendar.defaults.isRTL\n            );\n            dirDefaults = isRTL ? Calendar.rtlDefaults : {};\n\n            this.dirDefaults = dirDefaults;\n            this.localeDefaults = localeDefaults;\n\n            rawOptions = mergeOptions([ // merge defaults and overrides. lowest to highest precedence\n                Calendar.defaults, // global defaults\n                dirDefaults,\n                localeDefaults,\n                this.overrides,\n                this.dynamicOverrides\n            ]);\n            populateInstanceComputableOptions(rawOptions); // fill in gaps with computed options\n\n            this.optionsModel.reset(rawOptions);\n        },\n\n\n        // stores the new options internally, but does not rerender anything.\n        recordOptionOverrides: function(newOptionHash) {\n            var optionName;\n\n            for (optionName in newOptionHash) {\n                this.dynamicOverrides[optionName] = newOptionHash[optionName];\n            }\n\n            this.viewSpecCache = {}; // the dynamic override invalidates the options in this cache, so just clear it\n            this.populateOptionsHash(); // this.options needs to be recomputed after the dynamic override\n        }\n\n    });\n\n    ;;\n\n    Calendar.mixin({\n\n        defaultAllDayEventDuration: null,\n        defaultTimedEventDuration: null,\n        localeData: null,\n\n\n        initMomentInternals: function() {\n            var _this = this;\n\n            this.defaultAllDayEventDuration = moment.duration(this.opt('defaultAllDayEventDuration'));\n            this.defaultTimedEventDuration = moment.duration(this.opt('defaultTimedEventDuration'));\n\n            // Called immediately, and when any of the options change.\n            // Happens before any internal objects rebuild or rerender, because this is very core.\n            this.optionsModel.watch('buildingMomentLocale', [\n                '?locale', '?monthNames', '?monthNamesShort', '?dayNames', '?dayNamesShort',\n                '?firstDay', '?weekNumberCalculation'\n            ], function(opts) {\n                var weekNumberCalculation = opts.weekNumberCalculation;\n                var firstDay = opts.firstDay;\n                var _week;\n\n                // normalize\n                if (weekNumberCalculation === 'iso') {\n                    weekNumberCalculation = 'ISO'; // normalize\n                }\n\n                var localeData = createObject( // make a cheap copy\n                    getMomentLocaleData(opts.locale) // will fall back to en\n                );\n\n                if (opts.monthNames) {\n                    localeData._months = opts.monthNames;\n                }\n                if (opts.monthNamesShort) {\n                    localeData._monthsShort = opts.monthNamesShort;\n                }\n                if (opts.dayNames) {\n                    localeData._weekdays = opts.dayNames;\n                }\n                if (opts.dayNamesShort) {\n                    localeData._weekdaysShort = opts.dayNamesShort;\n                }\n\n                if (firstDay == null && weekNumberCalculation === 'ISO') {\n                    firstDay = 1;\n                }\n                if (firstDay != null) {\n                    _week = createObject(localeData._week); // _week: { dow: # }\n                    _week.dow = firstDay;\n                    localeData._week = _week;\n                }\n\n                if ( // whitelist certain kinds of input\n                weekNumberCalculation === 'ISO' ||\n                weekNumberCalculation === 'local' ||\n                typeof weekNumberCalculation === 'function'\n                ) {\n                    localeData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it\n                }\n\n                _this.localeData = localeData;\n\n                // If the internal current date object already exists, move to new locale.\n                // We do NOT need to do this technique for event dates, because this happens when converting to \"segments\".\n                if (_this.currentDate) {\n                    _this.localizeMoment(_this.currentDate); // sets to localeData\n                }\n            });\n        },\n\n\n        // Builds a moment using the settings of the current calendar: timezone and locale.\n        // Accepts anything the vanilla moment() constructor accepts.\n        moment: function() {\n            var mom;\n\n            if (this.opt('timezone') === 'local') {\n                mom = FC.moment.apply(null, arguments);\n\n                // Force the moment to be local, because FC.moment doesn't guarantee it.\n                if (mom.hasTime()) { // don't give ambiguously-timed moments a local zone\n                    mom.local();\n                }\n            }\n            else if (this.opt('timezone') === 'UTC') {\n                mom = FC.moment.utc.apply(null, arguments); // process as UTC\n            }\n            else {\n                mom = FC.moment.parseZone.apply(null, arguments); // let the input decide the zone\n            }\n\n            this.localizeMoment(mom); // TODO\n\n            return mom;\n        },\n\n\n        // Updates the given moment's locale settings to the current calendar locale settings.\n        localizeMoment: function(mom) {\n            mom._locale = this.localeData;\n        },\n\n\n        // Returns a boolean about whether or not the calendar knows how to calculate\n        // the timezone offset of arbitrary dates in the current timezone.\n        getIsAmbigTimezone: function() {\n            return this.opt('timezone') !== 'local' && this.opt('timezone') !== 'UTC';\n        },\n\n\n        // Returns a copy of the given date in the current timezone. Has no effect on dates without times.\n        applyTimezone: function(date) {\n            if (!date.hasTime()) {\n                return date.clone();\n            }\n\n            var zonedDate = this.moment(date.toArray());\n            var timeAdjust = date.time() - zonedDate.time();\n            var adjustedZonedDate;\n\n            // Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)\n            if (timeAdjust) { // is the time result different than expected?\n                adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds\n                if (date.time() - adjustedZonedDate.time() === 0) { // does it match perfectly now?\n                    zonedDate = adjustedZonedDate;\n                }\n            }\n\n            return zonedDate;\n        },\n\n\n        // Returns a moment for the current date, as defined by the client's computer or from the `now` option.\n        // Will return an moment with an ambiguous timezone.\n        getNow: function() {\n            var now = this.opt('now');\n            if (typeof now === 'function') {\n                now = now();\n            }\n            return this.moment(now).stripZone();\n        },\n\n\n        // Produces a human-readable string for the given duration.\n        // Side-effect: changes the locale of the given duration.\n        humanizeDuration: function(duration) {\n            return duration.locale(this.opt('locale')).humanize();\n        },\n\n\n\n        // Event-Specific Date Utilities. TODO: move\n        // -----------------------------------------------------------------------------------------------------------------\n\n\n        // Get an event's normalized end date. If not present, calculate it from the defaults.\n        getEventEnd: function(event) {\n            if (event.end) {\n                return event.end.clone();\n            }\n            else {\n                return this.getDefaultEventEnd(event.allDay, event.start);\n            }\n        },\n\n\n        // Given an event's allDay status and start date, return what its fallback end date should be.\n        // TODO: rename to computeDefaultEventEnd\n        getDefaultEventEnd: function(allDay, zonedStart) {\n            var end = zonedStart.clone();\n\n            if (allDay) {\n                end.stripTime().add(this.defaultAllDayEventDuration);\n            }\n            else {\n                end.add(this.defaultTimedEventDuration);\n            }\n\n            if (this.getIsAmbigTimezone()) {\n                end.stripZone(); // we don't know what the tzo should be\n            }\n\n            return end;\n        }\n\n    });\n\n    ;;\n\n    Calendar.mixin({\n\n        viewSpecCache: null, // cache of view definitions (initialized in Calendar.js)\n\n\n        // Gets information about how to create a view. Will use a cache.\n        getViewSpec: function(viewType) {\n            var cache = this.viewSpecCache;\n\n            return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));\n        },\n\n\n        // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n        // Preference is given to views that have corresponding buttons.\n        getUnitViewSpec: function(unit) {\n            var viewTypes;\n            var i;\n            var spec;\n\n            if ($.inArray(unit, unitsDesc) != -1) {\n\n                // put views that have buttons first. there will be duplicates, but oh well\n                viewTypes = this.header.getViewsWithButtons(); // TODO: include footer as well?\n                $.each(FC.views, function(viewType) { // all views\n                    viewTypes.push(viewType);\n                });\n\n                for (i = 0; i < viewTypes.length; i++) {\n                    spec = this.getViewSpec(viewTypes[i]);\n                    if (spec) {\n                        if (spec.singleUnit == unit) {\n                            return spec;\n                        }\n                    }\n                }\n            }\n        },\n\n\n        // Builds an object with information on how to create a given view\n        buildViewSpec: function(requestedViewType) {\n            var viewOverrides = this.overrides.views || {};\n            var specChain = []; // for the view. lowest to highest priority\n            var defaultsChain = []; // for the view. lowest to highest priority\n            var overridesChain = []; // for the view. lowest to highest priority\n            var viewType = requestedViewType;\n            var spec; // for the view\n            var overrides; // for the view\n            var durationInput;\n            var duration;\n            var unit;\n\n            // iterate from the specific view definition to a more general one until we hit an actual View class\n            while (viewType) {\n                spec = fcViews[viewType];\n                overrides = viewOverrides[viewType];\n                viewType = null; // clear. might repopulate for another iteration\n\n                if (typeof spec === 'function') { // TODO: deprecate\n                    spec = { 'class': spec };\n                }\n\n                if (spec) {\n                    specChain.unshift(spec);\n                    defaultsChain.unshift(spec.defaults || {});\n                    durationInput = durationInput || spec.duration;\n                    viewType = viewType || spec.type;\n                }\n\n                if (overrides) {\n                    overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level\n                    durationInput = durationInput || overrides.duration;\n                    viewType = viewType || overrides.type;\n                }\n            }\n\n            spec = mergeProps(specChain);\n            spec.type = requestedViewType;\n            if (!spec['class']) {\n                return false;\n            }\n\n            // fall back to top-level `duration` option\n            durationInput = durationInput ||\n                this.dynamicOverrides.duration ||\n                this.overrides.duration;\n\n            if (durationInput) {\n                duration = moment.duration(durationInput);\n\n                if (duration.valueOf()) { // valid?\n\n                    unit = computeDurationGreatestUnit(duration, durationInput);\n\n                    spec.duration = duration;\n                    spec.durationUnit = unit;\n\n                    // view is a single-unit duration, like \"week\" or \"day\"\n                    // incorporate options for this. lowest priority\n                    if (duration.as(unit) === 1) {\n                        spec.singleUnit = unit;\n                        overridesChain.unshift(viewOverrides[unit] || {});\n                    }\n                }\n            }\n\n            spec.defaults = mergeOptions(defaultsChain);\n            spec.overrides = mergeOptions(overridesChain);\n\n            this.buildViewSpecOptions(spec);\n            this.buildViewSpecButtonText(spec, requestedViewType);\n\n            return spec;\n        },\n\n\n        // Builds and assigns a view spec's options object from its already-assigned defaults and overrides\n        buildViewSpecOptions: function(spec) {\n            spec.options = mergeOptions([ // lowest to highest priority\n                Calendar.defaults, // global defaults\n                spec.defaults, // view's defaults (from ViewSubclass.defaults)\n                this.dirDefaults,\n                this.localeDefaults, // locale and dir take precedence over view's defaults!\n                this.overrides, // calendar's overrides (options given to constructor)\n                spec.overrides, // view's overrides (view-specific options)\n                this.dynamicOverrides // dynamically set via setter. highest precedence\n            ]);\n            populateInstanceComputableOptions(spec.options);\n        },\n\n\n        // Computes and assigns a view spec's buttonText-related options\n        buildViewSpecButtonText: function(spec, requestedViewType) {\n\n            // given an options object with a possible `buttonText` hash, lookup the buttonText for the\n            // requested view, falling back to a generic unit entry like \"week\" or \"day\"\n            function queryButtonText(options) {\n                var buttonText = options.buttonText || {};\n                return buttonText[requestedViewType] ||\n                    // view can decide to look up a certain key\n                    (spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||\n                    // a key like \"month\"\n                    (spec.singleUnit ? buttonText[spec.singleUnit] : null);\n            }\n\n            // highest to lowest priority\n            spec.buttonTextOverride =\n                queryButtonText(this.dynamicOverrides) ||\n                queryButtonText(this.overrides) || // constructor-specified buttonText lookup hash takes precedence\n                spec.overrides.buttonText; // `buttonText` for view-specific options is a string\n\n            // highest to lowest priority. mirrors buildViewSpecOptions\n            spec.buttonTextDefault =\n                queryButtonText(this.localeDefaults) ||\n                queryButtonText(this.dirDefaults) ||\n                spec.defaults.buttonText || // a single string. from ViewSubclass.defaults\n                queryButtonText(Calendar.defaults) ||\n                (spec.duration ? this.humanizeDuration(spec.duration) : null) || // like \"3 days\"\n                requestedViewType; // fall back to given view name\n        }\n\n    });\n\n    ;;\n\n    Calendar.mixin({\n\n        el: null,\n        contentEl: null,\n        suggestedViewHeight: null,\n        windowResizeProxy: null,\n        ignoreWindowResize: 0,\n\n\n        render: function() {\n            if (!this.contentEl) {\n                this.initialRender();\n            }\n            else if (this.elementVisible()) {\n                // mainly for the public API\n                this.calcSize();\n                this.renderView();\n            }\n        },\n\n\n        initialRender: function() {\n            var _this = this;\n            var el = this.el;\n\n            el.addClass('fc');\n\n            // event delegation for nav links\n            el.on('click.fc', 'a[data-goto]', function(ev) {\n                var anchorEl = $(this);\n                var gotoOptions = anchorEl.data('goto'); // will automatically parse JSON\n                var date = _this.moment(gotoOptions.date);\n                var viewType = gotoOptions.type;\n\n                // property like \"navLinkDayClick\". might be a string or a function\n                var customAction = _this.view.opt('navLink' + capitaliseFirstLetter(viewType) + 'Click');\n\n                if (typeof customAction === 'function') {\n                    customAction(date, ev);\n                }\n                else {\n                    if (typeof customAction === 'string') {\n                        viewType = customAction;\n                    }\n                    _this.zoomTo(date, viewType);\n                }\n            });\n\n            // called immediately, and upon option change\n            this.optionsModel.watch('applyingThemeClasses', [ '?theme' ], function(opts) {\n                el.toggleClass('ui-widget', opts.theme);\n                el.toggleClass('fc-unthemed', !opts.theme);\n            });\n\n            // called immediately, and upon option change.\n            // HACK: locale often affects isRTL, so we explicitly listen to that too.\n            this.optionsModel.watch('applyingDirClasses', [ '?isRTL', '?locale' ], function(opts) {\n                el.toggleClass('fc-ltr', !opts.isRTL);\n                el.toggleClass('fc-rtl', opts.isRTL);\n            });\n\n            this.contentEl = $(\"<div class='fc-view-container'/>\").prependTo(el);\n\n            this.initToolbars();\n            this.renderHeader();\n            this.renderFooter();\n            this.renderView(this.opt('defaultView'));\n\n            if (this.opt('handleWindowResize')) {\n                $(window).resize(\n                    this.windowResizeProxy = debounce( // prevents rapid calls\n                        this.windowResize.bind(this),\n                        this.opt('windowResizeDelay')\n                    )\n                );\n            }\n        },\n\n\n        destroy: function() {\n\n            if (this.view) {\n                this.view.removeElement();\n\n                // NOTE: don't null-out this.view in case API methods are called after destroy.\n                // It is still the \"current\" view, just not rendered.\n            }\n\n            this.toolbarsManager.proxyCall('removeElement');\n            this.contentEl.remove();\n            this.el.removeClass('fc fc-ltr fc-rtl fc-unthemed ui-widget');\n\n            this.el.off('.fc'); // unbind nav link handlers\n\n            if (this.windowResizeProxy) {\n                $(window).unbind('resize', this.windowResizeProxy);\n                this.windowResizeProxy = null;\n            }\n\n            GlobalEmitter.unneeded();\n        },\n\n\n        elementVisible: function() {\n            return this.el.is(':visible');\n        },\n\n\n\n        // View Rendering\n        // -----------------------------------------------------------------------------------\n\n\n        // Renders a view because of a date change, view-type change, or for the first time.\n        // If not given a viewType, keep the current view but render different dates.\n        // Accepts an optional scroll state to restore to.\n        renderView: function(viewType, forcedScroll) {\n\n            this.ignoreWindowResize++;\n\n            var needsClearView = this.view && viewType && this.view.type !== viewType;\n\n            // if viewType is changing, remove the old view's rendering\n            if (needsClearView) {\n                this.freezeContentHeight(); // prevent a scroll jump when view element is removed\n                this.clearView();\n            }\n\n            // if viewType changed, or the view was never created, create a fresh view\n            if (!this.view && viewType) {\n                this.view =\n                    this.viewsByType[viewType] ||\n                    (this.viewsByType[viewType] = this.instantiateView(viewType));\n\n                this.view.setElement(\n                    $(\"<div class='fc-view fc-\" + viewType + \"-view' />\").appendTo(this.contentEl)\n                );\n                this.toolbarsManager.proxyCall('activateButton', viewType);\n            }\n\n            if (this.view) {\n\n                if (forcedScroll) {\n                    this.view.addForcedScroll(forcedScroll);\n                }\n\n                if (this.elementVisible()) {\n                    this.currentDate = this.view.setDate(this.currentDate);\n                }\n            }\n\n            if (needsClearView) {\n                this.thawContentHeight();\n            }\n\n            this.ignoreWindowResize--;\n        },\n\n\n        // Unrenders the current view and reflects this change in the Header.\n        // Unregsiters the `view`, but does not remove from viewByType hash.\n        clearView: function() {\n            this.toolbarsManager.proxyCall('deactivateButton', this.view.type);\n            this.view.removeElement();\n            this.view = null;\n        },\n\n\n        // Destroys the view, including the view object. Then, re-instantiates it and renders it.\n        // Maintains the same scroll state.\n        // TODO: maintain any other user-manipulated state.\n        reinitView: function() {\n            this.ignoreWindowResize++;\n            this.freezeContentHeight();\n\n            var viewType = this.view.type;\n            var scrollState = this.view.queryScroll();\n            this.clearView();\n            this.calcSize();\n            this.renderView(viewType, scrollState);\n\n            this.thawContentHeight();\n            this.ignoreWindowResize--;\n        },\n\n\n        // Resizing\n        // -----------------------------------------------------------------------------------\n\n\n        getSuggestedViewHeight: function() {\n            if (this.suggestedViewHeight === null) {\n                this.calcSize();\n            }\n            return this.suggestedViewHeight;\n        },\n\n\n        isHeightAuto: function() {\n            return this.opt('contentHeight') === 'auto' || this.opt('height') === 'auto';\n        },\n\n\n        updateSize: function(shouldRecalc) {\n            if (this.elementVisible()) {\n\n                if (shouldRecalc) {\n                    this._calcSize();\n                }\n\n                this.ignoreWindowResize++;\n                this.view.updateSize(true); // isResize=true. will poll getSuggestedViewHeight() and isHeightAuto()\n                this.ignoreWindowResize--;\n\n                return true; // signal success\n            }\n        },\n\n\n        calcSize: function() {\n            if (this.elementVisible()) {\n                this._calcSize();\n            }\n        },\n\n\n        _calcSize: function() { // assumes elementVisible\n            var contentHeightInput = this.opt('contentHeight');\n            var heightInput = this.opt('height');\n\n            if (typeof contentHeightInput === 'number') { // exists and not 'auto'\n                this.suggestedViewHeight = contentHeightInput;\n            }\n            else if (typeof contentHeightInput === 'function') { // exists and is a function\n                this.suggestedViewHeight = contentHeightInput();\n            }\n            else if (typeof heightInput === 'number') { // exists and not 'auto'\n                this.suggestedViewHeight = heightInput - this.queryToolbarsHeight();\n            }\n            else if (typeof heightInput === 'function') { // exists and is a function\n                this.suggestedViewHeight = heightInput() - this.queryToolbarsHeight();\n            }\n            else if (heightInput === 'parent') { // set to height of parent element\n                this.suggestedViewHeight = this.el.parent().height() - this.queryToolbarsHeight();\n            }\n            else {\n                this.suggestedViewHeight = Math.round(\n                    this.contentEl.width() /\n                    Math.max(this.opt('aspectRatio'), .5)\n                );\n            }\n        },\n\n\n        windowResize: function(ev) {\n            if (\n                !this.ignoreWindowResize &&\n                ev.target === window && // so we don't process jqui \"resize\" events that have bubbled up\n                this.view.renderRange // view has already been rendered\n            ) {\n                if (this.updateSize(true)) {\n                    this.view.publiclyTrigger('windowResize', this.el[0]);\n                }\n            }\n        },\n\n\n        /* Height \"Freezing\"\n         -----------------------------------------------------------------------------*/\n\n\n        freezeContentHeight: function() {\n            this.contentEl.css({\n                width: '100%',\n                height: this.contentEl.height(),\n                overflow: 'hidden'\n            });\n        },\n\n\n        thawContentHeight: function() {\n            this.contentEl.css({\n                width: '',\n                height: '',\n                overflow: ''\n            });\n        }\n\n    });\n\n    ;;\n\n    Calendar.mixin({\n\n        header: null,\n        footer: null,\n        toolbarsManager: null,\n\n\n        initToolbars: function() {\n            this.header = new Toolbar(this, this.computeHeaderOptions());\n            this.footer = new Toolbar(this, this.computeFooterOptions());\n            this.toolbarsManager = new Iterator([ this.header, this.footer ]);\n        },\n\n\n        computeHeaderOptions: function() {\n            return {\n                extraClasses: 'fc-header-toolbar',\n                layout: this.opt('header')\n            };\n        },\n\n\n        computeFooterOptions: function() {\n            return {\n                extraClasses: 'fc-footer-toolbar',\n                layout: this.opt('footer')\n            };\n        },\n\n\n        // can be called repeatedly and Header will rerender\n        renderHeader: function() {\n            var header = this.header;\n\n            header.setToolbarOptions(this.computeHeaderOptions());\n            header.render();\n\n            if (header.el) {\n                this.el.prepend(header.el);\n            }\n        },\n\n\n        // can be called repeatedly and Footer will rerender\n        renderFooter: function() {\n            var footer = this.footer;\n\n            footer.setToolbarOptions(this.computeFooterOptions());\n            footer.render();\n\n            if (footer.el) {\n                this.el.append(footer.el);\n            }\n        },\n\n\n        setToolbarsTitle: function(title) {\n            this.toolbarsManager.proxyCall('updateTitle', title);\n        },\n\n\n        updateToolbarButtons: function() {\n            var now = this.getNow();\n            var view = this.view;\n            var todayInfo = view.buildDateProfile(now);\n            var prevInfo = view.buildPrevDateProfile(this.currentDate);\n            var nextInfo = view.buildNextDateProfile(this.currentDate);\n\n            this.toolbarsManager.proxyCall(\n                (todayInfo.isValid && !isDateWithinRange(now, view.currentRange)) ?\n                    'enableButton' :\n                    'disableButton',\n                'today'\n            );\n\n            this.toolbarsManager.proxyCall(\n                prevInfo.isValid ?\n                    'enableButton' :\n                    'disableButton',\n                'prev'\n            );\n\n            this.toolbarsManager.proxyCall(\n                nextInfo.isValid ?\n                    'enableButton' :\n                    'disableButton',\n                'next'\n            );\n        },\n\n\n        queryToolbarsHeight: function() {\n            return this.toolbarsManager.items.reduce(function(accumulator, toolbar) {\n                var toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin\n                return accumulator + toolbarHeight;\n            }, 0);\n        }\n\n    });\n\n    ;;\n\n    Calendar.defaults = {\n\n        titleRangeSeparator: ' \\u2013 ', // en dash\n        monthYearFormat: 'MMMM YYYY', // required for en. other locales rely on datepicker computable option\n\n        defaultTimedEventDuration: '02:00:00',\n        defaultAllDayEventDuration: { days: 1 },\n        forceEventDuration: false,\n        nextDayThreshold: '09:00:00', // 9am\n\n        // display\n        defaultView: 'month',\n        aspectRatio: 1.35,\n        header: {\n            left: 'title',\n            center: '',\n            right: 'today prev,next'\n        },\n        weekends: true,\n        weekNumbers: false,\n\n        weekNumberTitle: 'W',\n        weekNumberCalculation: 'local',\n\n        //editable: false,\n\n        //nowIndicator: false,\n\n        scrollTime: '06:00:00',\n        minTime: '00:00:00',\n        maxTime: '24:00:00',\n        showNonCurrentDates: true,\n\n        // event ajax\n        lazyFetching: true,\n        startParam: 'start',\n        endParam: 'end',\n        timezoneParam: 'timezone',\n\n        timezone: false,\n\n        //allDayDefault: undefined,\n\n        // locale\n        isRTL: false,\n        buttonText: {\n            prev: \"prev\",\n            next: \"next\",\n            prevYear: \"prev year\",\n            nextYear: \"next year\",\n            year: 'year', // TODO: locale files need to specify this\n            today: 'today',\n            month: 'month',\n            week: 'week',\n            day: 'day'\n        },\n\n        buttonIcons: {\n            prev: 'left-single-arrow',\n            next: 'right-single-arrow',\n            prevYear: 'left-double-arrow',\n            nextYear: 'right-double-arrow'\n        },\n\n        allDayText: 'all-day',\n\n        // jquery-ui theming\n        theme: false,\n        themeButtonIcons: {\n            prev: 'circle-triangle-w',\n            next: 'circle-triangle-e',\n            prevYear: 'seek-prev',\n            nextYear: 'seek-next'\n        },\n\n        //eventResizableFromStart: false,\n        dragOpacity: .75,\n        dragRevertDuration: 500,\n        dragScroll: true,\n\n        //selectable: false,\n        unselectAuto: true,\n        //selectMinDistance: 0,\n\n        dropAccept: '*',\n\n        eventOrder: 'title',\n        //eventRenderWait: null,\n\n        eventLimit: false,\n        eventLimitText: 'more',\n        eventLimitClick: 'popover',\n        dayPopoverFormat: 'LL',\n\n        handleWindowResize: true,\n        windowResizeDelay: 100, // milliseconds before an updateSize happens\n\n        longPressDelay: 1000\n\n    };\n\n\n    Calendar.englishDefaults = { // used by locale.js\n        dayPopoverFormat: 'dddd, MMMM D'\n    };\n\n\n    Calendar.rtlDefaults = { // right-to-left defaults\n        header: { // TODO: smarter solution (first/center/last ?)\n            left: 'next,prev today',\n            center: '',\n            right: 'title'\n        },\n        buttonIcons: {\n            prev: 'right-single-arrow',\n            next: 'left-single-arrow',\n            prevYear: 'right-double-arrow',\n            nextYear: 'left-double-arrow'\n        },\n        themeButtonIcons: {\n            prev: 'circle-triangle-e',\n            next: 'circle-triangle-w',\n            nextYear: 'seek-prev',\n            prevYear: 'seek-next'\n        }\n    };\n\n    ;;\n\n    var localeOptionHash = FC.locales = {}; // initialize and expose\n\n\n// TODO: document the structure and ordering of a FullCalendar locale file\n\n\n// Initialize jQuery UI datepicker translations while using some of the translations\n// Will set this as the default locales for datepicker.\n    FC.datepickerLocale = function(localeCode, dpLocaleCode, dpOptions) {\n\n        // get the FullCalendar internal option hash for this locale. create if necessary\n        var fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});\n\n        // transfer some simple options from datepicker to fc\n        fcOptions.isRTL = dpOptions.isRTL;\n        fcOptions.weekNumberTitle = dpOptions.weekHeader;\n\n        // compute some more complex options from datepicker\n        $.each(dpComputableOptions, function(name, func) {\n            fcOptions[name] = func(dpOptions);\n        });\n\n        // is jQuery UI Datepicker is on the page?\n        if ($.datepicker) {\n\n            // Register the locale data.\n            // FullCalendar and MomentJS use locale codes like \"pt-br\" but Datepicker\n            // does it like \"pt-BR\" or if it doesn't have the locale, maybe just \"pt\".\n            // Make an alias so the locale can be referenced either way.\n            $.datepicker.regional[dpLocaleCode] =\n                $.datepicker.regional[localeCode] = // alias\n                    dpOptions;\n\n            // Alias 'en' to the default locale data. Do this every time.\n            $.datepicker.regional.en = $.datepicker.regional[''];\n\n            // Set as Datepicker's global defaults.\n            $.datepicker.setDefaults(dpOptions);\n        }\n    };\n\n\n// Sets FullCalendar-specific translations. Will set the locales as the global default.\n    FC.locale = function(localeCode, newFcOptions) {\n        var fcOptions;\n        var momOptions;\n\n        // get the FullCalendar internal option hash for this locale. create if necessary\n        fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});\n\n        // provided new options for this locales? merge them in\n        if (newFcOptions) {\n            fcOptions = localeOptionHash[localeCode] = mergeOptions([ fcOptions, newFcOptions ]);\n        }\n\n        // compute locale options that weren't defined.\n        // always do this. newFcOptions can be undefined when initializing from i18n file,\n        // so no way to tell if this is an initialization or a default-setting.\n        momOptions = getMomentLocaleData(localeCode); // will fall back to en\n        $.each(momComputableOptions, function(name, func) {\n            if (fcOptions[name] == null) {\n                fcOptions[name] = func(momOptions, fcOptions);\n            }\n        });\n\n        // set it as the default locale for FullCalendar\n        Calendar.defaults.locale = localeCode;\n    };\n\n\n// NOTE: can't guarantee any of these computations will run because not every locale has datepicker\n// configs, so make sure there are English fallbacks for these in the defaults file.\n    var dpComputableOptions = {\n\n        buttonText: function(dpOptions) {\n            return {\n                // the translations sometimes wrongly contain HTML entities\n                prev: stripHtmlEntities(dpOptions.prevText),\n                next: stripHtmlEntities(dpOptions.nextText),\n                today: stripHtmlEntities(dpOptions.currentText)\n            };\n        },\n\n        // Produces format strings like \"MMMM YYYY\" -> \"September 2014\"\n        monthYearFormat: function(dpOptions) {\n            return dpOptions.showMonthAfterYear ?\n                'YYYY[' + dpOptions.yearSuffix + '] MMMM' :\n                'MMMM YYYY[' + dpOptions.yearSuffix + ']';\n        }\n\n    };\n\n    var momComputableOptions = {\n\n        // Produces format strings like \"ddd M/D\" -> \"Fri 9/15\"\n        dayOfMonthFormat: function(momOptions, fcOptions) {\n            var format = momOptions.longDateFormat('l'); // for the format like \"M/D/YYYY\"\n\n            // strip the year off the edge, as well as other misc non-whitespace chars\n            format = format.replace(/^Y+[^\\w\\s]*|[^\\w\\s]*Y+$/g, '');\n\n            if (fcOptions.isRTL) {\n                format += ' ddd'; // for RTL, add day-of-week to end\n            }\n            else {\n                format = 'ddd ' + format; // for LTR, add day-of-week to beginning\n            }\n            return format;\n        },\n\n        // Produces format strings like \"h:mma\" -> \"6:00pm\"\n        mediumTimeFormat: function(momOptions) { // can't be called `timeFormat` because collides with option\n            return momOptions.longDateFormat('LT')\n                .replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\n        },\n\n        // Produces format strings like \"h(:mm)a\" -> \"6pm\" / \"6:30pm\"\n        smallTimeFormat: function(momOptions) {\n            return momOptions.longDateFormat('LT')\n                .replace(':mm', '(:mm)')\n                .replace(/(\\Wmm)$/, '($1)') // like above, but for foreign locales\n                .replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\n        },\n\n        // Produces format strings like \"h(:mm)t\" -> \"6p\" / \"6:30p\"\n        extraSmallTimeFormat: function(momOptions) {\n            return momOptions.longDateFormat('LT')\n                .replace(':mm', '(:mm)')\n                .replace(/(\\Wmm)$/, '($1)') // like above, but for foreign locales\n                .replace(/\\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand\n        },\n\n        // Produces format strings like \"ha\" / \"H\" -> \"6pm\" / \"18\"\n        hourFormat: function(momOptions) {\n            return momOptions.longDateFormat('LT')\n                .replace(':mm', '')\n                .replace(/(\\Wmm)$/, '') // like above, but for foreign locales\n                .replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\n        },\n\n        // Produces format strings like \"h:mm\" -> \"6:30\" (with no AM/PM)\n        noMeridiemTimeFormat: function(momOptions) {\n            return momOptions.longDateFormat('LT')\n                .replace(/\\s*a$/i, ''); // remove trailing AM/PM\n        }\n\n    };\n\n\n// options that should be computed off live calendar options (considers override options)\n// TODO: best place for this? related to locale?\n// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it\n    var instanceComputableOptions = {\n\n        // Produces format strings for results like \"Mo 16\"\n        smallDayDateFormat: function(options) {\n            return options.isRTL ?\n                'D dd' :\n                'dd D';\n        },\n\n        // Produces format strings for results like \"Wk 5\"\n        weekFormat: function(options) {\n            return options.isRTL ?\n                'w[ ' + options.weekNumberTitle + ']' :\n                '[' + options.weekNumberTitle + ' ]w';\n        },\n\n        // Produces format strings for results like \"Wk5\"\n        smallWeekFormat: function(options) {\n            return options.isRTL ?\n                'w[' + options.weekNumberTitle + ']' :\n                '[' + options.weekNumberTitle + ']w';\n        }\n\n    };\n\n// TODO: make these computable properties in optionsModel\n    function populateInstanceComputableOptions(options) {\n        $.each(instanceComputableOptions, function(name, func) {\n            if (options[name] == null) {\n                options[name] = func(options);\n            }\n        });\n    }\n\n\n// Returns moment's internal locale data. If doesn't exist, returns English.\n    function getMomentLocaleData(localeCode) {\n        return moment.localeData(localeCode) || moment.localeData('en');\n    }\n\n\n// Initialize English by forcing computation of moment-derived options.\n// Also, sets it as the default.\n    FC.locale('en', Calendar.englishDefaults);\n\n    ;;\n\n    FC.sourceNormalizers = [];\n    FC.sourceFetchers = [];\n\n    var ajaxDefaults = {\n        dataType: 'json',\n        cache: false\n    };\n\n    var eventGUID = 1;\n\n\n    function EventManager() { // assumed to be a calendar\n        var t = this;\n\n\n        // exports\n        t.requestEvents = requestEvents;\n        t.reportEventChange = reportEventChange;\n        t.isFetchNeeded = isFetchNeeded;\n        t.fetchEvents = fetchEvents;\n        t.fetchEventSources = fetchEventSources;\n        t.refetchEvents = refetchEvents;\n        t.refetchEventSources = refetchEventSources;\n        t.getEventSources = getEventSources;\n        t.getEventSourceById = getEventSourceById;\n        t.addEventSource = addEventSource;\n        t.removeEventSource = removeEventSource;\n        t.removeEventSources = removeEventSources;\n        t.updateEvent = updateEvent;\n        t.updateEvents = updateEvents;\n        t.renderEvent = renderEvent;\n        t.renderEvents = renderEvents;\n        t.removeEvents = removeEvents;\n        t.clientEvents = clientEvents;\n        t.mutateEvent = mutateEvent;\n        t.normalizeEventDates = normalizeEventDates;\n        t.normalizeEventTimes = normalizeEventTimes;\n\n\n        // locals\n        var stickySource = { events: [] };\n        var sources = [ stickySource ];\n        var rangeStart, rangeEnd;\n        var pendingSourceCnt = 0; // outstanding fetch requests, max one per source\n        var cache = []; // holds events that have already been expanded\n        var prunedCache; // like cache, but only events that intersect with rangeStart/rangeEnd\n\n\n        $.each(\n            (t.opt('events') ? [ t.opt('events') ] : []).concat(t.opt('eventSources') || []),\n            function(i, sourceInput) {\n                var source = buildEventSource(sourceInput);\n                if (source) {\n                    sources.push(source);\n                }\n            }\n        );\n\n\n\n        function requestEvents(start, end) {\n            if (!t.opt('lazyFetching') || isFetchNeeded(start, end)) {\n                return fetchEvents(start, end);\n            }\n            else {\n                return Promise.resolve(prunedCache);\n            }\n        }\n\n\n        function reportEventChange() {\n            prunedCache = filterEventsWithinRange(cache);\n            t.trigger('eventsReset', prunedCache);\n        }\n\n\n        function filterEventsWithinRange(events) {\n            var filteredEvents = [];\n            var i, event;\n\n            for (i = 0; i < events.length; i++) {\n                event = events[i];\n\n                if (\n                    event.start.clone().stripZone() < rangeEnd &&\n                    t.getEventEnd(event).stripZone() > rangeStart\n                ) {\n                    filteredEvents.push(event);\n                }\n            }\n\n            return filteredEvents;\n        }\n\n\n        t.getEventCache = function() {\n            return cache;\n        };\n\n\n\n        /* Fetching\n         -----------------------------------------------------------------------------*/\n\n\n        // start and end are assumed to be unzoned\n        function isFetchNeeded(start, end) {\n            return !rangeStart || // nothing has been fetched yet?\n                start < rangeStart || end > rangeEnd; // is part of the new range outside of the old range?\n        }\n\n\n        function fetchEvents(start, end) {\n            rangeStart = start;\n            rangeEnd = end;\n            return refetchEvents();\n        }\n\n\n        // poorly named. fetches all sources with current `rangeStart` and `rangeEnd`.\n        function refetchEvents() {\n            return fetchEventSources(sources, 'reset');\n        }\n\n\n        // poorly named. fetches a subset of event sources.\n        function refetchEventSources(matchInputs) {\n            return fetchEventSources(getEventSourcesByMatchArray(matchInputs));\n        }\n\n\n        // expects an array of event source objects (the originals, not copies)\n        // `specialFetchType` is an optimization parameter that affects purging of the event cache.\n        function fetchEventSources(specificSources, specialFetchType) {\n            var i, source;\n\n            if (specialFetchType === 'reset') {\n                cache = [];\n            }\n            else if (specialFetchType !== 'add') {\n                cache = excludeEventsBySources(cache, specificSources);\n            }\n\n            for (i = 0; i < specificSources.length; i++) {\n                source = specificSources[i];\n\n                // already-pending sources have already been accounted for in pendingSourceCnt\n                if (source._status !== 'pending') {\n                    pendingSourceCnt++;\n                }\n\n                source._fetchId = (source._fetchId || 0) + 1;\n                source._status = 'pending';\n            }\n\n            for (i = 0; i < specificSources.length; i++) {\n                source = specificSources[i];\n                tryFetchEventSource(source, source._fetchId);\n            }\n\n            if (pendingSourceCnt) {\n                return Promise.construct(function(resolve) {\n                    t.one('eventsReceived', resolve); // will send prunedCache\n                });\n            }\n            else { // executed all synchronously, or no sources at all\n                return Promise.resolve(prunedCache);\n            }\n        }\n\n\n        // fetches an event source and processes its result ONLY if it is still the current fetch.\n        // caller is responsible for incrementing pendingSourceCnt first.\n        function tryFetchEventSource(source, fetchId) {\n            _fetchEventSource(source, function(eventInputs) {\n                var isArraySource = $.isArray(source.events);\n                var i, eventInput;\n                var abstractEvent;\n\n                if (\n                    // is this the source's most recent fetch?\n                // if not, rely on an upcoming fetch of this source to decrement pendingSourceCnt\n                fetchId === source._fetchId &&\n                // event source no longer valid?\n                source._status !== 'rejected'\n                ) {\n                    source._status = 'resolved';\n\n                    if (eventInputs) {\n                        for (i = 0; i < eventInputs.length; i++) {\n                            eventInput = eventInputs[i];\n\n                            if (isArraySource) { // array sources have already been convert to Event Objects\n                                abstractEvent = eventInput;\n                            }\n                            else {\n                                abstractEvent = buildEventFromInput(eventInput, source);\n                            }\n\n                            if (abstractEvent) { // not false (an invalid event)\n                                cache.push.apply( // append\n                                    cache,\n                                    expandEvent(abstractEvent) // add individual expanded events to the cache\n                                );\n                            }\n                        }\n                    }\n\n                    decrementPendingSourceCnt();\n                }\n            });\n        }\n\n\n        function rejectEventSource(source) {\n            var wasPending = source._status === 'pending';\n\n            source._status = 'rejected';\n\n            if (wasPending) {\n                decrementPendingSourceCnt();\n            }\n        }\n\n\n        function decrementPendingSourceCnt() {\n            pendingSourceCnt--;\n            if (!pendingSourceCnt) {\n                reportEventChange(cache); // updates prunedCache\n                t.trigger('eventsReceived', prunedCache);\n            }\n        }\n\n\n        function _fetchEventSource(source, callback) {\n            var i;\n            var fetchers = FC.sourceFetchers;\n            var res;\n\n            for (i=0; i<fetchers.length; i++) {\n                res = fetchers[i].call(\n                    t, // this, the Calendar object\n                    source,\n                    rangeStart.clone(),\n                    rangeEnd.clone(),\n                    t.opt('timezone'),\n                    callback\n                );\n\n                if (res === true) {\n                    // the fetcher is in charge. made its own async request\n                    return;\n                }\n                else if (typeof res == 'object') {\n                    // the fetcher returned a new source. process it\n                    _fetchEventSource(res, callback);\n                    return;\n                }\n            }\n\n            var events = source.events;\n            if (events) {\n                if ($.isFunction(events)) {\n                    t.pushLoading();\n                    events.call(\n                        t, // this, the Calendar object\n                        rangeStart.clone(),\n                        rangeEnd.clone(),\n                        t.opt('timezone'),\n                        function(events) {\n                            callback(events);\n                            t.popLoading();\n                        }\n                    );\n                }\n                else if ($.isArray(events)) {\n                    callback(events);\n                }\n                else {\n                    callback();\n                }\n            }else{\n                var url = source.url;\n                if (url) {\n                    var success = source.success;\n                    var error = source.error;\n                    var complete = source.complete;\n\n                    // retrieve any outbound GET/POST $.ajax data from the options\n                    var customData;\n                    if ($.isFunction(source.data)) {\n                        // supplied as a function that returns a key/value object\n                        customData = source.data();\n                    }\n                    else {\n                        // supplied as a straight key/value object\n                        customData = source.data;\n                    }\n\n                    // use a copy of the custom data so we can modify the parameters\n                    // and not affect the passed-in object.\n                    var data = $.extend({}, customData || {});\n\n                    var startParam = firstDefined(source.startParam, t.opt('startParam'));\n                    var endParam = firstDefined(source.endParam, t.opt('endParam'));\n                    var timezoneParam = firstDefined(source.timezoneParam, t.opt('timezoneParam'));\n\n                    if (startParam) {\n                        data[startParam] = rangeStart.format();\n                    }\n                    if (endParam) {\n                        data[endParam] = rangeEnd.format();\n                    }\n                    if (t.opt('timezone') && t.opt('timezone') != 'local') {\n                        data[timezoneParam] = t.opt('timezone');\n                    }\n\n                    t.pushLoading();\n                    $.ajax($.extend({}, ajaxDefaults, source, {\n                        data: data,\n                        success: function(events) {\n                            events = events || [];\n                            var res = applyAll(success, this, arguments);\n                            if ($.isArray(res)) {\n                                events = res;\n                            }\n                            callback(events);\n                        },\n                        error: function() {\n                            applyAll(error, this, arguments);\n                            callback();\n                        },\n                        complete: function() {\n                            applyAll(complete, this, arguments);\n                            t.popLoading();\n                        }\n                    }));\n                }else{\n                    callback();\n                }\n            }\n        }\n\n\n\n        /* Sources\n         -----------------------------------------------------------------------------*/\n\n\n        function addEventSource(sourceInput) {\n            var source = buildEventSource(sourceInput);\n            if (source) {\n                sources.push(source);\n                fetchEventSources([ source ], 'add'); // will eventually call reportEventChange\n            }\n        }\n\n\n        function buildEventSource(sourceInput) { // will return undefined if invalid source\n            var normalizers = FC.sourceNormalizers;\n            var source;\n            var i;\n\n            if ($.isFunction(sourceInput) || $.isArray(sourceInput)) {\n                source = { events: sourceInput };\n            }\n            else if (typeof sourceInput === 'string') {\n                source = { url: sourceInput };\n            }\n            else if (typeof sourceInput === 'object') {\n                source = $.extend({}, sourceInput); // shallow copy\n            }\n\n            if (source) {\n\n                // TODO: repeat code, same code for event classNames\n                if (source.className) {\n                    if (typeof source.className === 'string') {\n                        source.className = source.className.split(/\\s+/);\n                    }\n                    // otherwise, assumed to be an array\n                }\n                else {\n                    source.className = [];\n                }\n\n                // for array sources, we convert to standard Event Objects up front\n                if ($.isArray(source.events)) {\n                    source.origArray = source.events; // for removeEventSource\n                    source.events = $.map(source.events, function(eventInput) {\n                        return buildEventFromInput(eventInput, source);\n                    });\n                }\n\n                for (i=0; i<normalizers.length; i++) {\n                    normalizers[i].call(t, source);\n                }\n\n                return source;\n            }\n        }\n\n\n        function removeEventSource(matchInput) {\n            removeSpecificEventSources(\n                getEventSourcesByMatch(matchInput)\n            );\n        }\n\n\n        // if called with no arguments, removes all.\n        function removeEventSources(matchInputs) {\n            if (matchInputs == null) {\n                removeSpecificEventSources(sources, true); // isAll=true\n            }\n            else {\n                removeSpecificEventSources(\n                    getEventSourcesByMatchArray(matchInputs)\n                );\n            }\n        }\n\n\n        function removeSpecificEventSources(targetSources, isAll) {\n            var i;\n\n            // cancel pending requests\n            for (i = 0; i < targetSources.length; i++) {\n                rejectEventSource(targetSources[i]);\n            }\n\n            if (isAll) { // an optimization\n                sources = [];\n                cache = [];\n            }\n            else {\n                // remove from persisted source list\n                sources = $.grep(sources, function(source) {\n                    for (i = 0; i < targetSources.length; i++) {\n                        if (source === targetSources[i]) {\n                            return false; // exclude\n                        }\n                    }\n                    return true; // include\n                });\n\n                cache = excludeEventsBySources(cache, targetSources);\n            }\n\n            reportEventChange();\n        }\n\n\n        function getEventSources() {\n            return sources.slice(1); // returns a shallow copy of sources with stickySource removed\n        }\n\n\n        function getEventSourceById(id) {\n            return $.grep(sources, function(source) {\n                return source.id && source.id === id;\n            })[0];\n        }\n\n\n        // like getEventSourcesByMatch, but accepts multple match criteria (like multiple IDs)\n        function getEventSourcesByMatchArray(matchInputs) {\n\n            // coerce into an array\n            if (!matchInputs) {\n                matchInputs = [];\n            }\n            else if (!$.isArray(matchInputs)) {\n                matchInputs = [ matchInputs ];\n            }\n\n            var matchingSources = [];\n            var i;\n\n            // resolve raw inputs to real event source objects\n            for (i = 0; i < matchInputs.length; i++) {\n                matchingSources.push.apply( // append\n                    matchingSources,\n                    getEventSourcesByMatch(matchInputs[i])\n                );\n            }\n\n            return matchingSources;\n        }\n\n\n        // matchInput can either by a real event source object, an ID, or the function/URL for the source.\n        // returns an array of matching source objects.\n        function getEventSourcesByMatch(matchInput) {\n            var i, source;\n\n            // given an proper event source object\n            for (i = 0; i < sources.length; i++) {\n                source = sources[i];\n                if (source === matchInput) {\n                    return [ source ];\n                }\n            }\n\n            // an ID match\n            source = getEventSourceById(matchInput);\n            if (source) {\n                return [ source ];\n            }\n\n            return $.grep(sources, function(source) {\n                return isSourcesEquivalent(matchInput, source);\n            });\n        }\n\n\n        function isSourcesEquivalent(source1, source2) {\n            return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);\n        }\n\n\n        function getSourcePrimitive(source) {\n            return (\n                    (typeof source === 'object') ? // a normalized event source?\n                        (source.origArray || source.googleCalendarId || source.url || source.events) : // get the primitive\n                        null\n                ) ||\n                source; // the given argument *is* the primitive\n        }\n\n\n        // util\n        // returns a filtered array without events that are part of any of the given sources\n        function excludeEventsBySources(specificEvents, specificSources) {\n            return $.grep(specificEvents, function(event) {\n                for (var i = 0; i < specificSources.length; i++) {\n                    if (event.source === specificSources[i]) {\n                        return false; // exclude\n                    }\n                }\n                return true; // keep\n            });\n        }\n\n\n\n        /* Manipulation\n         -----------------------------------------------------------------------------*/\n\n\n        // Only ever called from the externally-facing API\n        function updateEvent(event) {\n            updateEvents([ event ]);\n        }\n\n\n        // Only ever called from the externally-facing API\n        function updateEvents(events) {\n            var i, event;\n\n            for (i = 0; i < events.length; i++) {\n                event = events[i];\n\n                // massage start/end values, even if date string values\n                event.start = t.moment(event.start);\n                if (event.end) {\n                    event.end = t.moment(event.end);\n                }\n                else {\n                    event.end = null;\n                }\n\n                mutateEvent(event, getMiscEventProps(event)); // will handle start/end/allDay normalization\n            }\n\n            reportEventChange(); // reports event modifications (so we can redraw)\n        }\n\n\n        // Returns a hash of misc event properties that should be copied over to related events.\n        function getMiscEventProps(event) {\n            var props = {};\n\n            $.each(event, function(name, val) {\n                if (isMiscEventPropName(name)) {\n                    if (val !== undefined && isAtomic(val)) { // a defined non-object\n                        props[name] = val;\n                    }\n                }\n            });\n\n            return props;\n        }\n\n        // non-date-related, non-id-related, non-secret\n        function isMiscEventPropName(name) {\n            return !/^_|^(id|allDay|start|end)$/.test(name);\n        }\n\n\n        // returns the expanded events that were created\n        function renderEvent(eventInput, stick) {\n            return renderEvents([ eventInput ], stick);\n        }\n\n\n        // returns the expanded events that were created\n        function renderEvents(eventInputs, stick) {\n            var renderedEvents = [];\n            var renderableEvents;\n            var abstractEvent;\n            var i, j, event;\n\n            for (i = 0; i < eventInputs.length; i++) {\n                abstractEvent = buildEventFromInput(eventInputs[i]);\n\n                if (abstractEvent) { // not false (a valid input)\n                    renderableEvents = expandEvent(abstractEvent);\n\n                    for (j = 0; j < renderableEvents.length; j++) {\n                        event = renderableEvents[j];\n\n                        if (!event.source) {\n                            if (stick) {\n                                stickySource.events.push(event);\n                                event.source = stickySource;\n                            }\n                            cache.push(event);\n                        }\n                    }\n\n                    renderedEvents = renderedEvents.concat(renderableEvents);\n                }\n            }\n\n            if (renderedEvents.length) { // any new events rendered?\n                reportEventChange();\n            }\n\n            return renderedEvents;\n        }\n\n\n        function removeEvents(filter) {\n            var eventID;\n            var i;\n\n            if (filter == null) { // null or undefined. remove all events\n                filter = function() { return true; }; // will always match\n            }\n            else if (!$.isFunction(filter)) { // an event ID\n                eventID = filter + '';\n                filter = function(event) {\n                    return event._id == eventID;\n                };\n            }\n\n            // Purge event(s) from our local cache\n            cache = $.grep(cache, filter, true); // inverse=true\n\n            // Remove events from array sources.\n            // This works because they have been converted to official Event Objects up front.\n            // (and as a result, event._id has been calculated).\n            for (i=0; i<sources.length; i++) {\n                if ($.isArray(sources[i].events)) {\n                    sources[i].events = $.grep(sources[i].events, filter, true);\n                }\n            }\n\n            reportEventChange();\n        }\n\n\n        function clientEvents(filter) {\n            if ($.isFunction(filter)) {\n                return $.grep(cache, filter);\n            }\n            else if (filter != null) { // not null, not undefined. an event ID\n                filter += '';\n                return $.grep(cache, function(e) {\n                    return e._id == filter;\n                });\n            }\n            return cache; // else, return all\n        }\n\n\n        // Makes sure all array event sources have their internal event objects\n        // converted over to the Calendar's current timezone.\n        t.rezoneArrayEventSources = function() {\n            var i;\n            var events;\n            var j;\n\n            for (i = 0; i < sources.length; i++) {\n                events = sources[i].events;\n                if ($.isArray(events)) {\n\n                    for (j = 0; j < events.length; j++) {\n                        rezoneEventDates(events[j]);\n                    }\n                }\n            }\n        };\n\n        function rezoneEventDates(event) {\n            event.start = t.moment(event.start);\n            if (event.end) {\n                event.end = t.moment(event.end);\n            }\n            backupEventDates(event);\n        }\n\n\n        /* Event Normalization\n         -----------------------------------------------------------------------------*/\n\n\n        // Given a raw object with key/value properties, returns an \"abstract\" Event object.\n        // An \"abstract\" event is an event that, if recurring, will not have been expanded yet.\n        // Will return `false` when input is invalid.\n        // `source` is optional\n        function buildEventFromInput(input, source) {\n            var calendarEventDataTransform = t.opt('eventDataTransform');\n            var out = {};\n            var start, end;\n            var allDay;\n\n            if (calendarEventDataTransform) {\n                input = calendarEventDataTransform(input);\n            }\n            if (source && source.eventDataTransform) {\n                input = source.eventDataTransform(input);\n            }\n\n            // Copy all properties over to the resulting object.\n            // The special-case properties will be copied over afterwards.\n            $.extend(out, input);\n\n            if (source) {\n                out.source = source;\n            }\n\n            out._id = input._id || (input.id === undefined ? '_fc' + eventGUID++ : input.id + '');\n\n            if (input.className) {\n                if (typeof input.className == 'string') {\n                    out.className = input.className.split(/\\s+/);\n                }\n                else { // assumed to be an array\n                    out.className = input.className;\n                }\n            }\n            else {\n                out.className = [];\n            }\n\n            start = input.start || input.date; // \"date\" is an alias for \"start\"\n            end = input.end;\n\n            // parse as a time (Duration) if applicable\n            if (isTimeString(start)) {\n                start = moment.duration(start);\n            }\n            if (isTimeString(end)) {\n                end = moment.duration(end);\n            }\n\n            if (input.dow || moment.isDuration(start) || moment.isDuration(end)) {\n\n                // the event is \"abstract\" (recurring) so don't calculate exact start/end dates just yet\n                out.start = start ? moment.duration(start) : null; // will be a Duration or null\n                out.end = end ? moment.duration(end) : null; // will be a Duration or null\n                out._recurring = true; // our internal marker\n            }\n            else {\n\n                if (start) {\n                    start = t.moment(start);\n                    if (!start.isValid()) {\n                        return false;\n                    }\n                }\n\n                if (end) {\n                    end = t.moment(end);\n                    if (!end.isValid()) {\n                        end = null; // let defaults take over\n                    }\n                }\n\n                allDay = input.allDay;\n                if (allDay === undefined) { // still undefined? fallback to default\n                    allDay = firstDefined(\n                        source ? source.allDayDefault : undefined,\n                        t.opt('allDayDefault')\n                    );\n                    // still undefined? normalizeEventDates will calculate it\n                }\n\n                assignDatesToEvent(start, end, allDay, out);\n            }\n\n            t.normalizeEvent(out); // hook for external use. a prototype method\n\n            return out;\n        }\n        t.buildEventFromInput = buildEventFromInput;\n\n\n        // Normalizes and assigns the given dates to the given partially-formed event object.\n        // NOTE: mutates the given start/end moments. does not make a copy.\n        function assignDatesToEvent(start, end, allDay, event) {\n            event.start = start;\n            event.end = end;\n            event.allDay = allDay;\n            normalizeEventDates(event);\n            backupEventDates(event);\n        }\n\n\n        // Ensures proper values for allDay/start/end. Accepts an Event object, or a plain object with event-ish properties.\n        // NOTE: Will modify the given object.\n        function normalizeEventDates(eventProps) {\n\n            normalizeEventTimes(eventProps);\n\n            if (eventProps.end && !eventProps.end.isAfter(eventProps.start)) {\n                eventProps.end = null;\n            }\n\n            if (!eventProps.end) {\n                if (t.opt('forceEventDuration')) {\n                    eventProps.end = t.getDefaultEventEnd(eventProps.allDay, eventProps.start);\n                }\n                else {\n                    eventProps.end = null;\n                }\n            }\n        }\n\n\n        // Ensures the allDay property exists and the timeliness of the start/end dates are consistent\n        function normalizeEventTimes(eventProps) {\n            if (eventProps.allDay == null) {\n                eventProps.allDay = !(eventProps.start.hasTime() || (eventProps.end && eventProps.end.hasTime()));\n            }\n\n            if (eventProps.allDay) {\n                eventProps.start.stripTime();\n                if (eventProps.end) {\n                    // TODO: consider nextDayThreshold here? If so, will require a lot of testing and adjustment\n                    eventProps.end.stripTime();\n                }\n            }\n            else {\n                if (!eventProps.start.hasTime()) {\n                    eventProps.start = t.applyTimezone(eventProps.start.time(0)); // will assign a 00:00 time\n                }\n                if (eventProps.end && !eventProps.end.hasTime()) {\n                    eventProps.end = t.applyTimezone(eventProps.end.time(0)); // will assign a 00:00 time\n                }\n            }\n        }\n\n\n        // If the given event is a recurring event, break it down into an array of individual instances.\n        // If not a recurring event, return an array with the single original event.\n        // If given a falsy input (probably because of a failed buildEventFromInput call), returns an empty array.\n        // HACK: can override the recurring window by providing custom rangeStart/rangeEnd (for businessHours).\n        function expandEvent(abstractEvent, _rangeStart, _rangeEnd) {\n            var events = [];\n            var dowHash;\n            var dow;\n            var i;\n            var date;\n            var startTime, endTime;\n            var start, end;\n            var event;\n\n            _rangeStart = _rangeStart || rangeStart;\n            _rangeEnd = _rangeEnd || rangeEnd;\n\n            if (abstractEvent) {\n                if (abstractEvent._recurring) {\n\n                    // make a boolean hash as to whether the event occurs on each day-of-week\n                    if ((dow = abstractEvent.dow)) {\n                        dowHash = {};\n                        for (i = 0; i < dow.length; i++) {\n                            dowHash[dow[i]] = true;\n                        }\n                    }\n\n                    // iterate through every day in the current range\n                    date = _rangeStart.clone().stripTime(); // holds the date of the current day\n                    while (date.isBefore(_rangeEnd)) {\n\n                        if (!dowHash || dowHash[date.day()]) { // if everyday, or this particular day-of-week\n\n                            startTime = abstractEvent.start; // the stored start and end properties are times (Durations)\n                            endTime = abstractEvent.end; // \"\n                            start = date.clone();\n                            end = null;\n\n                            if (startTime) {\n                                start = start.time(startTime);\n                            }\n                            if (endTime) {\n                                end = date.clone().time(endTime);\n                            }\n\n                            event = $.extend({}, abstractEvent); // make a copy of the original\n                            assignDatesToEvent(\n                                start, end,\n                                !startTime && !endTime, // allDay?\n                                event\n                            );\n                            events.push(event);\n                        }\n\n                        date.add(1, 'days');\n                    }\n                }\n                else {\n                    events.push(abstractEvent); // return the original event. will be a one-item array\n                }\n            }\n\n            return events;\n        }\n        t.expandEvent = expandEvent;\n\n\n\n        /* Event Modification Math\n         -----------------------------------------------------------------------------------------*/\n\n\n        // Modifies an event and all related events by applying the given properties.\n        // Special date-diffing logic is used for manipulation of dates.\n        // If `props` does not contain start/end dates, the updated values are assumed to be the event's current start/end.\n        // All date comparisons are done against the event's pristine _start and _end dates.\n        // Returns an object with delta information and a function to undo all operations.\n        // For making computations in a granularity greater than day/time, specify largeUnit.\n        // NOTE: The given `newProps` might be mutated for normalization purposes.\n        function mutateEvent(event, newProps, largeUnit) {\n            var miscProps = {};\n            var oldProps;\n            var clearEnd;\n            var startDelta;\n            var endDelta;\n            var durationDelta;\n            var undoFunc;\n\n            // diffs the dates in the appropriate way, returning a duration\n            function diffDates(date1, date0) { // date1 - date0\n                if (largeUnit) {\n                    return diffByUnit(date1, date0, largeUnit);\n                }\n                else if (newProps.allDay) {\n                    return diffDay(date1, date0);\n                }\n                else {\n                    return diffDayTime(date1, date0);\n                }\n            }\n\n            newProps = newProps || {};\n\n            // normalize new date-related properties\n            if (!newProps.start) {\n                newProps.start = event.start.clone();\n            }\n            if (newProps.end === undefined) {\n                newProps.end = event.end ? event.end.clone() : null;\n            }\n            if (newProps.allDay == null) { // is null or undefined?\n                newProps.allDay = event.allDay;\n            }\n            normalizeEventDates(newProps);\n\n            // create normalized versions of the original props to compare against\n            // need a real end value, for diffing\n            oldProps = {\n                start: event._start.clone(),\n                end: event._end ? event._end.clone() : t.getDefaultEventEnd(event._allDay, event._start),\n                allDay: newProps.allDay // normalize the dates in the same regard as the new properties\n            };\n            normalizeEventDates(oldProps);\n\n            // need to clear the end date if explicitly changed to null\n            clearEnd = event._end !== null && newProps.end === null;\n\n            // compute the delta for moving the start date\n            startDelta = diffDates(newProps.start, oldProps.start);\n\n            // compute the delta for moving the end date\n            if (newProps.end) {\n                endDelta = diffDates(newProps.end, oldProps.end);\n                durationDelta = endDelta.subtract(startDelta);\n            }\n            else {\n                durationDelta = null;\n            }\n\n            // gather all non-date-related properties\n            $.each(newProps, function(name, val) {\n                if (isMiscEventPropName(name)) {\n                    if (val !== undefined) {\n                        miscProps[name] = val;\n                    }\n                }\n            });\n\n            // apply the operations to the event and all related events\n            undoFunc = mutateEvents(\n                clientEvents(event._id), // get events with this ID\n                clearEnd,\n                newProps.allDay,\n                startDelta,\n                durationDelta,\n                miscProps\n            );\n\n            return {\n                dateDelta: startDelta,\n                durationDelta: durationDelta,\n                undo: undoFunc\n            };\n        }\n\n\n        // Modifies an array of events in the following ways (operations are in order):\n        // - clear the event's `end`\n        // - convert the event to allDay\n        // - add `dateDelta` to the start and end\n        // - add `durationDelta` to the event's duration\n        // - assign `miscProps` to the event\n        //\n        // Returns a function that can be called to undo all the operations.\n        //\n        // TODO: don't use so many closures. possible memory issues when lots of events with same ID.\n        //\n        function mutateEvents(events, clearEnd, allDay, dateDelta, durationDelta, miscProps) {\n            var isAmbigTimezone = t.getIsAmbigTimezone();\n            var undoFunctions = [];\n\n            // normalize zero-length deltas to be null\n            if (dateDelta && !dateDelta.valueOf()) { dateDelta = null; }\n            if (durationDelta && !durationDelta.valueOf()) { durationDelta = null; }\n\n            $.each(events, function(i, event) {\n                var oldProps;\n                var newProps;\n\n                // build an object holding all the old values, both date-related and misc.\n                // for the undo function.\n                oldProps = {\n                    start: event.start.clone(),\n                    end: event.end ? event.end.clone() : null,\n                    allDay: event.allDay\n                };\n                $.each(miscProps, function(name) {\n                    oldProps[name] = event[name];\n                });\n\n                // new date-related properties. work off the original date snapshot.\n                // ok to use references because they will be thrown away when backupEventDates is called.\n                newProps = {\n                    start: event._start,\n                    end: event._end,\n                    allDay: allDay // normalize the dates in the same regard as the new properties\n                };\n                normalizeEventDates(newProps); // massages start/end/allDay\n\n                // strip or ensure the end date\n                if (clearEnd) {\n                    newProps.end = null;\n                }\n                else if (durationDelta && !newProps.end) { // the duration translation requires an end date\n                    newProps.end = t.getDefaultEventEnd(newProps.allDay, newProps.start);\n                }\n\n                if (dateDelta) {\n                    newProps.start.add(dateDelta);\n                    if (newProps.end) {\n                        newProps.end.add(dateDelta);\n                    }\n                }\n\n                if (durationDelta) {\n                    newProps.end.add(durationDelta); // end already ensured above\n                }\n\n                // if the dates have changed, and we know it is impossible to recompute the\n                // timezone offsets, strip the zone.\n                if (\n                    isAmbigTimezone &&\n                    !newProps.allDay &&\n                    (dateDelta || durationDelta)\n                ) {\n                    newProps.start.stripZone();\n                    if (newProps.end) {\n                        newProps.end.stripZone();\n                    }\n                }\n\n                $.extend(event, miscProps, newProps); // copy over misc props, then date-related props\n                backupEventDates(event); // regenerate internal _start/_end/_allDay\n\n                undoFunctions.push(function() {\n                    $.extend(event, oldProps);\n                    backupEventDates(event); // regenerate internal _start/_end/_allDay\n                });\n            });\n\n            return function() {\n                for (var i = 0; i < undoFunctions.length; i++) {\n                    undoFunctions[i]();\n                }\n            };\n        }\n\n    }\n\n\n// returns an undo function\n    Calendar.prototype.mutateSeg = function(seg, newProps) {\n        return this.mutateEvent(seg.event, newProps);\n    };\n\n\n// hook for external libs to manipulate event properties upon creation.\n// should manipulate the event in-place.\n    Calendar.prototype.normalizeEvent = function(event) {\n    };\n\n\n// Does the given span (start, end, and other location information)\n// fully contain the other?\n    Calendar.prototype.spanContainsSpan = function(outerSpan, innerSpan) {\n        var eventStart = outerSpan.start.clone().stripZone();\n        var eventEnd = this.getEventEnd(outerSpan).stripZone();\n\n        return innerSpan.start >= eventStart && innerSpan.end <= eventEnd;\n    };\n\n\n// Returns a list of events that the given event should be compared against when being considered for a move to\n// the specified span. Attached to the Calendar's prototype because EventManager is a mixin for a Calendar.\n    Calendar.prototype.getPeerEvents = function(span, event) {\n        var cache = this.getEventCache();\n        var peerEvents = [];\n        var i, otherEvent;\n\n        for (i = 0; i < cache.length; i++) {\n            otherEvent = cache[i];\n            if (\n                !event ||\n                event._id !== otherEvent._id // don't compare the event to itself or other related [repeating] events\n            ) {\n                peerEvents.push(otherEvent);\n            }\n        }\n\n        return peerEvents;\n    };\n\n\n// updates the \"backup\" properties, which are preserved in order to compute diffs later on.\n    function backupEventDates(event) {\n        event._allDay = event.allDay;\n        event._start = event.start.clone();\n        event._end = event.end ? event.end.clone() : null;\n    }\n\n\n    /* Overlapping / Constraining\n     -----------------------------------------------------------------------------------------*/\n\n\n// Determines if the given event can be relocated to the given span (unzoned start/end with other misc data)\n    Calendar.prototype.isEventSpanAllowed = function(span, event) {\n        var source = event.source || {};\n        var eventAllowFunc = this.opt('eventAllow');\n\n        var constraint = firstDefined(\n            event.constraint,\n            source.constraint,\n            this.opt('eventConstraint')\n        );\n\n        var overlap = firstDefined(\n            event.overlap,\n            source.overlap,\n            this.opt('eventOverlap')\n        );\n\n        return this.isSpanAllowed(span, constraint, overlap, event) &&\n            (!eventAllowFunc || eventAllowFunc(span, event) !== false);\n    };\n\n\n// Determines if an external event can be relocated to the given span (unzoned start/end with other misc data)\n    Calendar.prototype.isExternalSpanAllowed = function(eventSpan, eventLocation, eventProps) {\n        var eventInput;\n        var event;\n\n        // note: very similar logic is in View's reportExternalDrop\n        if (eventProps) {\n            eventInput = $.extend({}, eventProps, eventLocation);\n            event = this.expandEvent(\n                this.buildEventFromInput(eventInput)\n            )[0];\n        }\n\n        if (event) {\n            return this.isEventSpanAllowed(eventSpan, event);\n        }\n        else { // treat it as a selection\n\n            return this.isSelectionSpanAllowed(eventSpan);\n        }\n    };\n\n\n// Determines the given span (unzoned start/end with other misc data) can be selected.\n    Calendar.prototype.isSelectionSpanAllowed = function(span) {\n        var selectAllowFunc = this.opt('selectAllow');\n\n        return this.isSpanAllowed(span, this.opt('selectConstraint'), this.opt('selectOverlap')) &&\n            (!selectAllowFunc || selectAllowFunc(span) !== false);\n    };\n\n\n// Returns true if the given span (caused by an event drop/resize or a selection) is allowed to exist\n// according to the constraint/overlap settings.\n// `event` is not required if checking a selection.\n    Calendar.prototype.isSpanAllowed = function(span, constraint, overlap, event) {\n        var constraintEvents;\n        var anyContainment;\n        var peerEvents;\n        var i, peerEvent;\n        var peerOverlap;\n\n        // the range must be fully contained by at least one of produced constraint events\n        if (constraint != null) {\n\n            // not treated as an event! intermediate data structure\n            // TODO: use ranges in the future\n            constraintEvents = this.constraintToEvents(constraint);\n            if (constraintEvents) { // not invalid\n\n                anyContainment = false;\n                for (i = 0; i < constraintEvents.length; i++) {\n                    if (this.spanContainsSpan(constraintEvents[i], span)) {\n                        anyContainment = true;\n                        break;\n                    }\n                }\n\n                if (!anyContainment) {\n                    return false;\n                }\n            }\n        }\n\n        peerEvents = this.getPeerEvents(span, event);\n\n        for (i = 0; i < peerEvents.length; i++)  {\n            peerEvent = peerEvents[i];\n\n            // there needs to be an actual intersection before disallowing anything\n            if (this.eventIntersectsRange(peerEvent, span)) {\n\n                // evaluate overlap for the given range and short-circuit if necessary\n                if (overlap === false) {\n                    return false;\n                }\n                // if the event's overlap is a test function, pass the peer event in question as the first param\n                else if (typeof overlap === 'function' && !overlap(peerEvent, event)) {\n                    return false;\n                }\n\n                // if we are computing if the given range is allowable for an event, consider the other event's\n                // EventObject-specific or Source-specific `overlap` property\n                if (event) {\n                    peerOverlap = firstDefined(\n                        peerEvent.overlap,\n                        (peerEvent.source || {}).overlap\n                        // we already considered the global `eventOverlap`\n                    );\n                    if (peerOverlap === false) {\n                        return false;\n                    }\n                    // if the peer event's overlap is a test function, pass the subject event as the first param\n                    if (typeof peerOverlap === 'function' && !peerOverlap(event, peerEvent)) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    };\n\n\n// Given an event input from the API, produces an array of event objects. Possible event inputs:\n// 'businessHours'\n// An event ID (number or string)\n// An object with specific start/end dates or a recurring event (like what businessHours accepts)\n    Calendar.prototype.constraintToEvents = function(constraintInput) {\n\n        if (constraintInput === 'businessHours') {\n            return this.getCurrentBusinessHourEvents();\n        }\n\n        if (typeof constraintInput === 'object') {\n            if (constraintInput.start != null) { // needs to be event-like input\n                return this.expandEvent(this.buildEventFromInput(constraintInput));\n            }\n            else {\n                return null; // invalid\n            }\n        }\n\n        return this.clientEvents(constraintInput); // probably an ID\n    };\n\n\n// Does the event's date range intersect with the given range?\n// start/end already assumed to have stripped zones :(\n    Calendar.prototype.eventIntersectsRange = function(event, range) {\n        var eventStart = event.start.clone().stripZone();\n        var eventEnd = this.getEventEnd(event).stripZone();\n\n        return range.start < eventEnd && range.end > eventStart;\n    };\n\n\n    /* Business Hours\n     -----------------------------------------------------------------------------------------*/\n\n    var BUSINESS_HOUR_EVENT_DEFAULTS = {\n        id: '_fcBusinessHours', // will relate events from different calls to expandEvent\n        start: '09:00',\n        end: '17:00',\n        dow: [ 1, 2, 3, 4, 5 ], // monday - friday\n        rendering: 'inverse-background'\n        // classNames are defined in businessHoursSegClasses\n    };\n\n// Return events objects for business hours within the current view.\n// Abuse of our event system :(\n    Calendar.prototype.getCurrentBusinessHourEvents = function(wholeDay) {\n        return this.computeBusinessHourEvents(wholeDay, this.opt('businessHours'));\n    };\n\n// Given a raw input value from options, return events objects for business hours within the current view.\n    Calendar.prototype.computeBusinessHourEvents = function(wholeDay, input) {\n        if (input === true) {\n            return this.expandBusinessHourEvents(wholeDay, [ {} ]);\n        }\n        else if ($.isPlainObject(input)) {\n            return this.expandBusinessHourEvents(wholeDay, [ input ]);\n        }\n        else if ($.isArray(input)) {\n            return this.expandBusinessHourEvents(wholeDay, input, true);\n        }\n        else {\n            return [];\n        }\n    };\n\n// inputs expected to be an array of objects.\n// if ignoreNoDow is true, will ignore entries that don't specify a day-of-week (dow) key.\n    Calendar.prototype.expandBusinessHourEvents = function(wholeDay, inputs, ignoreNoDow) {\n        var view = this.getView();\n        var events = [];\n        var i, input;\n\n        for (i = 0; i < inputs.length; i++) {\n            input = inputs[i];\n\n            if (ignoreNoDow && !input.dow) {\n                continue;\n            }\n\n            // give defaults. will make a copy\n            input = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, input);\n\n            // if a whole-day series is requested, clear the start/end times\n            if (wholeDay) {\n                input.start = null;\n                input.end = null;\n            }\n\n            events.push.apply(events, // append\n                this.expandEvent(\n                    this.buildEventFromInput(input),\n                    view.activeRange.start,\n                    view.activeRange.end\n                )\n            );\n        }\n\n        return events;\n    };\n\n    ;;\n\n    /* An abstract class for the \"basic\" views, as well as month view. Renders one or more rows of day cells.\n     ----------------------------------------------------------------------------------------------------------------------*/\n// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\n\n    var BasicView = FC.BasicView = View.extend({\n\n        scroller: null,\n\n        dayGridClass: DayGrid, // class the dayGrid will be instantiated from (overridable by subclasses)\n        dayGrid: null, // the main subcomponent that does most of the heavy lifting\n\n        dayNumbersVisible: false, // display day numbers on each day cell?\n        colWeekNumbersVisible: false, // display week numbers along the side?\n        cellWeekNumbersVisible: false, // display week numbers in day cell?\n\n        weekNumberWidth: null, // width of all the week-number cells running down the side\n\n        headContainerEl: null, // div that hold's the dayGrid's rendered date header\n        headRowEl: null, // the fake row element of the day-of-week header\n\n\n        initialize: function() {\n            this.dayGrid = this.instantiateDayGrid();\n\n            this.scroller = new Scroller({\n                overflowX: 'hidden',\n                overflowY: 'auto'\n            });\n        },\n\n\n        // Generates the DayGrid object this view needs. Draws from this.dayGridClass\n        instantiateDayGrid: function() {\n            // generate a subclass on the fly with BasicView-specific behavior\n            // TODO: cache this subclass\n            var subclass = this.dayGridClass.extend(basicDayGridMethods);\n\n            return new subclass(this);\n        },\n\n\n        // Computes the date range that will be rendered.\n        buildRenderRange: function(currentRange, currentRangeUnit) {\n            var renderRange = View.prototype.buildRenderRange.apply(this, arguments);\n\n            // year and month views should be aligned with weeks. this is already done for week\n            if (/^(year|month)$/.test(currentRangeUnit)) {\n                renderRange.start.startOf('week');\n\n                // make end-of-week if not already\n                if (renderRange.end.weekday()) {\n                    renderRange.end.add(1, 'week').startOf('week'); // exclusively move backwards\n                }\n            }\n\n            return this.trimHiddenDays(renderRange);\n        },\n\n\n        // Renders the view into `this.el`, which should already be assigned\n        renderDates: function() {\n\n            this.dayGrid.breakOnWeeks = /year|month|week/.test(this.currentRangeUnit); // do before Grid::setRange\n            this.dayGrid.setRange(this.renderRange);\n\n            this.dayNumbersVisible = this.dayGrid.rowCnt > 1; // TODO: make grid responsible\n            if (this.opt('weekNumbers')) {\n                if (this.opt('weekNumbersWithinDays')) {\n                    this.cellWeekNumbersVisible = true;\n                    this.colWeekNumbersVisible = false;\n                }\n                else {\n                    this.cellWeekNumbersVisible = false;\n                    this.colWeekNumbersVisible = true;\n                };\n            }\n            this.dayGrid.numbersVisible = this.dayNumbersVisible ||\n                this.cellWeekNumbersVisible || this.colWeekNumbersVisible;\n\n            this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());\n            this.renderHead();\n\n            this.scroller.render();\n            var dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');\n            var dayGridEl = $('<div class=\"fc-day-grid\" />').appendTo(dayGridContainerEl);\n            this.el.find('.fc-body > tr > td').append(dayGridContainerEl);\n\n            this.dayGrid.setElement(dayGridEl);\n            this.dayGrid.renderDates(this.hasRigidRows());\n        },\n\n\n        // render the day-of-week headers\n        renderHead: function() {\n            this.headContainerEl =\n                this.el.find('.fc-head-container')\n                    .html(this.dayGrid.renderHeadHtml());\n            this.headRowEl = this.headContainerEl.find('.fc-row');\n        },\n\n\n        // Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,\n        // always completely kill the dayGrid's rendering.\n        unrenderDates: function() {\n            this.dayGrid.unrenderDates();\n            this.dayGrid.removeElement();\n            this.scroller.destroy();\n        },\n\n\n        renderBusinessHours: function() {\n            this.dayGrid.renderBusinessHours();\n        },\n\n\n        unrenderBusinessHours: function() {\n            this.dayGrid.unrenderBusinessHours();\n        },\n\n\n        // Builds the HTML skeleton for the view.\n        // The day-grid component will render inside of a container defined by this HTML.\n        renderSkeletonHtml: function() {\n            return '' +\n                '<table>' +\n                '<thead class=\"fc-head\">' +\n                '<tr>' +\n                '<td class=\"fc-head-container ' + this.widgetHeaderClass + '\"></td>' +\n                '</tr>' +\n                '</thead>' +\n                '<tbody class=\"fc-body\">' +\n                '<tr>' +\n                '<td class=\"' + this.widgetContentClass + '\"></td>' +\n                '</tr>' +\n                '</tbody>' +\n                '</table>';\n        },\n\n\n        // Generates an HTML attribute string for setting the width of the week number column, if it is known\n        weekNumberStyleAttr: function() {\n            if (this.weekNumberWidth !== null) {\n                return 'style=\"width:' + this.weekNumberWidth + 'px\"';\n            }\n            return '';\n        },\n\n\n        // Determines whether each row should have a constant height\n        hasRigidRows: function() {\n            var eventLimit = this.opt('eventLimit');\n            return eventLimit && typeof eventLimit !== 'number';\n        },\n\n\n        /* Dimensions\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Refreshes the horizontal dimensions of the view\n        updateWidth: function() {\n            if (this.colWeekNumbersVisible) {\n                // Make sure all week number cells running down the side have the same width.\n                // Record the width for cells created later.\n                this.weekNumberWidth = matchCellWidths(\n                    this.el.find('.fc-week-number')\n                );\n            }\n        },\n\n\n        // Adjusts the vertical dimensions of the view to the specified values\n        setHeight: function(totalHeight, isAuto) {\n            var eventLimit = this.opt('eventLimit');\n            var scrollerHeight;\n            var scrollbarWidths;\n\n            // reset all heights to be natural\n            this.scroller.clear();\n            uncompensateScroll(this.headRowEl);\n\n            this.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\n\n            // is the event limit a constant level number?\n            if (eventLimit && typeof eventLimit === 'number') {\n                this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after\n            }\n\n            // distribute the height to the rows\n            // (totalHeight is a \"recommended\" value if isAuto)\n            scrollerHeight = this.computeScrollerHeight(totalHeight);\n            this.setGridHeight(scrollerHeight, isAuto);\n\n            // is the event limit dynamically calculated?\n            if (eventLimit && typeof eventLimit !== 'number') {\n                this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set\n            }\n\n            if (!isAuto) { // should we force dimensions of the scroll container?\n\n                this.scroller.setHeight(scrollerHeight);\n                scrollbarWidths = this.scroller.getScrollbarWidths();\n\n                if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?\n\n                    compensateScroll(this.headRowEl, scrollbarWidths);\n\n                    // doing the scrollbar compensation might have created text overflow which created more height. redo\n                    scrollerHeight = this.computeScrollerHeight(totalHeight);\n                    this.scroller.setHeight(scrollerHeight);\n                }\n\n                // guarantees the same scrollbar widths\n                this.scroller.lockOverflow(scrollbarWidths);\n            }\n        },\n\n\n        // given a desired total height of the view, returns what the height of the scroller should be\n        computeScrollerHeight: function(totalHeight) {\n            return totalHeight -\n                subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n        },\n\n\n        // Sets the height of just the DayGrid component in this view\n        setGridHeight: function(height, isAuto) {\n            if (isAuto) {\n                undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding\n            }\n            else {\n                distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows\n            }\n        },\n\n\n        /* Scroll\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        computeInitialDateScroll: function() {\n            return { top: 0 };\n        },\n\n\n        queryDateScroll: function() {\n            return { top: this.scroller.getScrollTop() };\n        },\n\n\n        applyDateScroll: function(scroll) {\n            if (scroll.top !== undefined) {\n                this.scroller.setScrollTop(scroll.top);\n            }\n        },\n\n\n        /* Hit Areas\n         ------------------------------------------------------------------------------------------------------------------*/\n        // forward all hit-related method calls to dayGrid\n\n\n        hitsNeeded: function() {\n            this.dayGrid.hitsNeeded();\n        },\n\n\n        hitsNotNeeded: function() {\n            this.dayGrid.hitsNotNeeded();\n        },\n\n\n        prepareHits: function() {\n            this.dayGrid.prepareHits();\n        },\n\n\n        releaseHits: function() {\n            this.dayGrid.releaseHits();\n        },\n\n\n        queryHit: function(left, top) {\n            return this.dayGrid.queryHit(left, top);\n        },\n\n\n        getHitSpan: function(hit) {\n            return this.dayGrid.getHitSpan(hit);\n        },\n\n\n        getHitEl: function(hit) {\n            return this.dayGrid.getHitEl(hit);\n        },\n\n\n        /* Events\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders the given events onto the view and populates the segments array\n        renderEvents: function(events) {\n            this.dayGrid.renderEvents(events);\n\n            this.updateHeight(); // must compensate for events that overflow the row\n        },\n\n\n        // Retrieves all segment objects that are rendered in the view\n        getEventSegs: function() {\n            return this.dayGrid.getEventSegs();\n        },\n\n\n        // Unrenders all event elements and clears internal segment data\n        unrenderEvents: function() {\n            this.dayGrid.unrenderEvents();\n\n            // we DON'T need to call updateHeight() because\n            // a renderEvents() call always happens after this, which will eventually call updateHeight()\n        },\n\n\n        /* Dragging (for both events and external elements)\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // A returned value of `true` signals that a mock \"helper\" event has been rendered.\n        renderDrag: function(dropLocation, seg) {\n            return this.dayGrid.renderDrag(dropLocation, seg);\n        },\n\n\n        unrenderDrag: function() {\n            this.dayGrid.unrenderDrag();\n        },\n\n\n        /* Selection\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders a visual indication of a selection\n        renderSelection: function(span) {\n            this.dayGrid.renderSelection(span);\n        },\n\n\n        // Unrenders a visual indications of a selection\n        unrenderSelection: function() {\n            this.dayGrid.unrenderSelection();\n        }\n\n    });\n\n\n// Methods that will customize the rendering behavior of the BasicView's dayGrid\n    var basicDayGridMethods = {\n\n\n        // Generates the HTML that will go before the day-of week header cells\n        renderHeadIntroHtml: function() {\n            var view = this.view;\n\n            if (view.colWeekNumbersVisible) {\n                return '' +\n                    '<th class=\"fc-week-number ' + view.widgetHeaderClass + '\" ' + view.weekNumberStyleAttr() + '>' +\n                    '<span>' + // needed for matchCellWidths\n                    htmlEscape(view.opt('weekNumberTitle')) +\n                    '</span>' +\n                    '</th>';\n            }\n\n            return '';\n        },\n\n\n        // Generates the HTML that will go before content-skeleton cells that display the day/week numbers\n        renderNumberIntroHtml: function(row) {\n            var view = this.view;\n            var weekStart = this.getCellDate(row, 0);\n\n            if (view.colWeekNumbersVisible) {\n                return '' +\n                    '<td class=\"fc-week-number\" ' + view.weekNumberStyleAttr() + '>' +\n                    view.buildGotoAnchorHtml( // aside from link, important for matchCellWidths\n                        { date: weekStart, type: 'week', forceOff: this.colCnt === 1 },\n                        weekStart.format('w') // inner HTML\n                    ) +\n                    '</td>';\n            }\n\n            return '';\n        },\n\n\n        // Generates the HTML that goes before the day bg cells for each day-row\n        renderBgIntroHtml: function() {\n            var view = this.view;\n\n            if (view.colWeekNumbersVisible) {\n                return '<td class=\"fc-week-number ' + view.widgetContentClass + '\" ' +\n                    view.weekNumberStyleAttr() + '></td>';\n            }\n\n            return '';\n        },\n\n\n        // Generates the HTML that goes before every other type of row generated by DayGrid.\n        // Affects helper-skeleton and highlight-skeleton rows.\n        renderIntroHtml: function() {\n            var view = this.view;\n\n            if (view.colWeekNumbersVisible) {\n                return '<td class=\"fc-week-number\" ' + view.weekNumberStyleAttr() + '></td>';\n            }\n\n            return '';\n        }\n\n    };\n\n    ;;\n\n    /* A month view with day cells running in rows (one-per-week) and columns\n     ----------------------------------------------------------------------------------------------------------------------*/\n\n    var MonthView = FC.MonthView = BasicView.extend({\n\n\n        // Computes the date range that will be rendered.\n        buildRenderRange: function() {\n            var renderRange = BasicView.prototype.buildRenderRange.apply(this, arguments);\n            var rowCnt;\n\n            // ensure 6 weeks\n            if (this.isFixedWeeks()) {\n                rowCnt = Math.ceil( // could be partial weeks due to hiddenDays\n                    renderRange.end.diff(renderRange.start, 'weeks', true) // dontRound=true\n                );\n                renderRange.end.add(6 - rowCnt, 'weeks');\n            }\n\n            return renderRange;\n        },\n\n\n        // Overrides the default BasicView behavior to have special multi-week auto-height logic\n        setGridHeight: function(height, isAuto) {\n\n            // if auto, make the height of each row the height that it would be if there were 6 weeks\n            if (isAuto) {\n                height *= this.rowCnt / 6;\n            }\n\n            distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows\n        },\n\n\n        isFixedWeeks: function() {\n            return this.opt('fixedWeekCount');\n        }\n\n    });\n\n    ;;\n\n    fcViews.basic = {\n        'class': BasicView\n    };\n\n    fcViews.basicDay = {\n        type: 'basic',\n        duration: { days: 1 }\n    };\n\n    fcViews.basicWeek = {\n        type: 'basic',\n        duration: { weeks: 1 }\n    };\n\n    fcViews.month = {\n        'class': MonthView,\n        duration: { months: 1 }, // important for prev/next\n        defaults: {\n            fixedWeekCount: true\n        }\n    };\n    ;;\n\n    /* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.\n     ----------------------------------------------------------------------------------------------------------------------*/\n// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).\n// Responsible for managing width/height.\n\n    var AgendaView = FC.AgendaView = View.extend({\n\n        scroller: null,\n\n        timeGridClass: TimeGrid, // class used to instantiate the timeGrid. subclasses can override\n        timeGrid: null, // the main time-grid subcomponent of this view\n\n        dayGridClass: DayGrid, // class used to instantiate the dayGrid. subclasses can override\n        dayGrid: null, // the \"all-day\" subcomponent. if all-day is turned off, this will be null\n\n        axisWidth: null, // the width of the time axis running down the side\n\n        headContainerEl: null, // div that hold's the timeGrid's rendered date header\n        noScrollRowEls: null, // set of fake row elements that must compensate when scroller has scrollbars\n\n        // when the time-grid isn't tall enough to occupy the given height, we render an <hr> underneath\n        bottomRuleEl: null,\n\n        // indicates that minTime/maxTime affects rendering\n        usesMinMaxTime: true,\n\n\n        initialize: function() {\n            this.timeGrid = this.instantiateTimeGrid();\n\n            if (this.opt('allDaySlot')) { // should we display the \"all-day\" area?\n                this.dayGrid = this.instantiateDayGrid(); // the all-day subcomponent of this view\n            }\n\n            this.scroller = new Scroller({\n                overflowX: 'hidden',\n                overflowY: 'auto'\n            });\n        },\n\n\n        // Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass\n        instantiateTimeGrid: function() {\n            var subclass = this.timeGridClass.extend(agendaTimeGridMethods);\n\n            return new subclass(this);\n        },\n\n\n        // Instantiates the DayGrid object this view might need. Draws from this.dayGridClass\n        instantiateDayGrid: function() {\n            var subclass = this.dayGridClass.extend(agendaDayGridMethods);\n\n            return new subclass(this);\n        },\n\n\n        /* Rendering\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders the view into `this.el`, which has already been assigned\n        renderDates: function() {\n\n            this.timeGrid.setRange(this.renderRange);\n\n            if (this.dayGrid) {\n                this.dayGrid.setRange(this.renderRange);\n            }\n\n            this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());\n            this.renderHead();\n\n            this.scroller.render();\n            var timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');\n            var timeGridEl = $('<div class=\"fc-time-grid\" />').appendTo(timeGridWrapEl);\n            this.el.find('.fc-body > tr > td').append(timeGridWrapEl);\n\n            this.timeGrid.setElement(timeGridEl);\n            this.timeGrid.renderDates();\n\n            // the <hr> that sometimes displays under the time-grid\n            this.bottomRuleEl = $('<hr class=\"fc-divider ' + this.widgetHeaderClass + '\"/>')\n                .appendTo(this.timeGrid.el); // inject it into the time-grid\n\n            if (this.dayGrid) {\n                this.dayGrid.setElement(this.el.find('.fc-day-grid'));\n                this.dayGrid.renderDates();\n\n                // have the day-grid extend it's coordinate area over the <hr> dividing the two grids\n                this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();\n            }\n\n            this.noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)'); // fake rows not within the scroller\n        },\n\n\n        // render the day-of-week headers\n        renderHead: function() {\n            this.headContainerEl =\n                this.el.find('.fc-head-container')\n                    .html(this.timeGrid.renderHeadHtml());\n        },\n\n\n        // Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,\n        // always completely kill each grid's rendering.\n        unrenderDates: function() {\n            this.timeGrid.unrenderDates();\n            this.timeGrid.removeElement();\n\n            if (this.dayGrid) {\n                this.dayGrid.unrenderDates();\n                this.dayGrid.removeElement();\n            }\n\n            this.scroller.destroy();\n        },\n\n\n        // Builds the HTML skeleton for the view.\n        // The day-grid and time-grid components will render inside containers defined by this HTML.\n        renderSkeletonHtml: function() {\n            return '' +\n                '<table>' +\n                '<thead class=\"fc-head\">' +\n                '<tr>' +\n                '<td class=\"fc-head-container ' + this.widgetHeaderClass + '\"></td>' +\n                '</tr>' +\n                '</thead>' +\n                '<tbody class=\"fc-body\">' +\n                '<tr>' +\n                '<td class=\"' + this.widgetContentClass + '\">' +\n                (this.dayGrid ?\n                        '<div class=\"fc-day-grid\"/>' +\n                        '<hr class=\"fc-divider ' + this.widgetHeaderClass + '\"/>' :\n                        ''\n                ) +\n                '</td>' +\n                '</tr>' +\n                '</tbody>' +\n                '</table>';\n        },\n\n\n        // Generates an HTML attribute string for setting the width of the axis, if it is known\n        axisStyleAttr: function() {\n            if (this.axisWidth !== null) {\n                return 'style=\"width:' + this.axisWidth + 'px\"';\n            }\n            return '';\n        },\n\n\n        /* Business Hours\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        renderBusinessHours: function() {\n            this.timeGrid.renderBusinessHours();\n\n            if (this.dayGrid) {\n                this.dayGrid.renderBusinessHours();\n            }\n        },\n\n\n        unrenderBusinessHours: function() {\n            this.timeGrid.unrenderBusinessHours();\n\n            if (this.dayGrid) {\n                this.dayGrid.unrenderBusinessHours();\n            }\n        },\n\n\n        /* Now Indicator\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        getNowIndicatorUnit: function() {\n            return this.timeGrid.getNowIndicatorUnit();\n        },\n\n\n        renderNowIndicator: function(date) {\n            this.timeGrid.renderNowIndicator(date);\n        },\n\n\n        unrenderNowIndicator: function() {\n            this.timeGrid.unrenderNowIndicator();\n        },\n\n\n        /* Dimensions\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        updateSize: function(isResize) {\n            this.timeGrid.updateSize(isResize);\n\n            View.prototype.updateSize.call(this, isResize); // call the super-method\n        },\n\n\n        // Refreshes the horizontal dimensions of the view\n        updateWidth: function() {\n            // make all axis cells line up, and record the width so newly created axis cells will have it\n            this.axisWidth = matchCellWidths(this.el.find('.fc-axis'));\n        },\n\n\n        // Adjusts the vertical dimensions of the view to the specified values\n        setHeight: function(totalHeight, isAuto) {\n            var eventLimit;\n            var scrollerHeight;\n            var scrollbarWidths;\n\n            // reset all dimensions back to the original state\n            this.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary\n            this.scroller.clear(); // sets height to 'auto' and clears overflow\n            uncompensateScroll(this.noScrollRowEls);\n\n            // limit number of events in the all-day area\n            if (this.dayGrid) {\n                this.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\n\n                eventLimit = this.opt('eventLimit');\n                if (eventLimit && typeof eventLimit !== 'number') {\n                    eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure \"auto\" goes to a real number\n                }\n                if (eventLimit) {\n                    this.dayGrid.limitRows(eventLimit);\n                }\n            }\n\n            if (!isAuto) { // should we force dimensions of the scroll container?\n\n                scrollerHeight = this.computeScrollerHeight(totalHeight);\n                this.scroller.setHeight(scrollerHeight);\n                scrollbarWidths = this.scroller.getScrollbarWidths();\n\n                if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?\n\n                    // make the all-day and header rows lines up\n                    compensateScroll(this.noScrollRowEls, scrollbarWidths);\n\n                    // the scrollbar compensation might have changed text flow, which might affect height, so recalculate\n                    // and reapply the desired height to the scroller.\n                    scrollerHeight = this.computeScrollerHeight(totalHeight);\n                    this.scroller.setHeight(scrollerHeight);\n                }\n\n                // guarantees the same scrollbar widths\n                this.scroller.lockOverflow(scrollbarWidths);\n\n                // if there's any space below the slats, show the horizontal rule.\n                // this won't cause any new overflow, because lockOverflow already called.\n                if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {\n                    this.bottomRuleEl.show();\n                }\n            }\n        },\n\n\n        // given a desired total height of the view, returns what the height of the scroller should be\n        computeScrollerHeight: function(totalHeight) {\n            return totalHeight -\n                subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n        },\n\n\n        /* Scroll\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Computes the initial pre-configured scroll state prior to allowing the user to change it\n        computeInitialDateScroll: function() {\n            var scrollTime = moment.duration(this.opt('scrollTime'));\n            var top = this.timeGrid.computeTimeTop(scrollTime);\n\n            // zoom can give weird floating-point values. rather scroll a little bit further\n            top = Math.ceil(top);\n\n            if (top) {\n                top++; // to overcome top border that slots beyond the first have. looks better\n            }\n\n            return { top: top };\n        },\n\n\n        queryDateScroll: function() {\n            return { top: this.scroller.getScrollTop() };\n        },\n\n\n        applyDateScroll: function(scroll) {\n            if (scroll.top !== undefined) {\n                this.scroller.setScrollTop(scroll.top);\n            }\n        },\n\n\n        /* Hit Areas\n         ------------------------------------------------------------------------------------------------------------------*/\n        // forward all hit-related method calls to the grids (dayGrid might not be defined)\n\n\n        hitsNeeded: function() {\n            this.timeGrid.hitsNeeded();\n            if (this.dayGrid) {\n                this.dayGrid.hitsNeeded();\n            }\n        },\n\n\n        hitsNotNeeded: function() {\n            this.timeGrid.hitsNotNeeded();\n            if (this.dayGrid) {\n                this.dayGrid.hitsNotNeeded();\n            }\n        },\n\n\n        prepareHits: function() {\n            this.timeGrid.prepareHits();\n            if (this.dayGrid) {\n                this.dayGrid.prepareHits();\n            }\n        },\n\n\n        releaseHits: function() {\n            this.timeGrid.releaseHits();\n            if (this.dayGrid) {\n                this.dayGrid.releaseHits();\n            }\n        },\n\n\n        queryHit: function(left, top) {\n            var hit = this.timeGrid.queryHit(left, top);\n\n            if (!hit && this.dayGrid) {\n                hit = this.dayGrid.queryHit(left, top);\n            }\n\n            return hit;\n        },\n\n\n        getHitSpan: function(hit) {\n            // TODO: hit.component is set as a hack to identify where the hit came from\n            return hit.component.getHitSpan(hit);\n        },\n\n\n        getHitEl: function(hit) {\n            // TODO: hit.component is set as a hack to identify where the hit came from\n            return hit.component.getHitEl(hit);\n        },\n\n\n        /* Events\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders events onto the view and populates the View's segment array\n        renderEvents: function(events) {\n            var dayEvents = [];\n            var timedEvents = [];\n            var daySegs = [];\n            var timedSegs;\n            var i;\n\n            // separate the events into all-day and timed\n            for (i = 0; i < events.length; i++) {\n                if (events[i].allDay) {\n                    dayEvents.push(events[i]);\n                }\n                else {\n                    timedEvents.push(events[i]);\n                }\n            }\n\n            // render the events in the subcomponents\n            timedSegs = this.timeGrid.renderEvents(timedEvents);\n            if (this.dayGrid) {\n                daySegs = this.dayGrid.renderEvents(dayEvents);\n            }\n\n            // the all-day area is flexible and might have a lot of events, so shift the height\n            this.updateHeight();\n        },\n\n\n        // Retrieves all segment objects that are rendered in the view\n        getEventSegs: function() {\n            return this.timeGrid.getEventSegs().concat(\n                this.dayGrid ? this.dayGrid.getEventSegs() : []\n            );\n        },\n\n\n        // Unrenders all event elements and clears internal segment data\n        unrenderEvents: function() {\n\n            // unrender the events in the subcomponents\n            this.timeGrid.unrenderEvents();\n            if (this.dayGrid) {\n                this.dayGrid.unrenderEvents();\n            }\n\n            // we DON'T need to call updateHeight() because\n            // a renderEvents() call always happens after this, which will eventually call updateHeight()\n        },\n\n\n        /* Dragging (for events and external elements)\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // A returned value of `true` signals that a mock \"helper\" event has been rendered.\n        renderDrag: function(dropLocation, seg) {\n            if (dropLocation.start.hasTime()) {\n                return this.timeGrid.renderDrag(dropLocation, seg);\n            }\n            else if (this.dayGrid) {\n                return this.dayGrid.renderDrag(dropLocation, seg);\n            }\n        },\n\n\n        unrenderDrag: function() {\n            this.timeGrid.unrenderDrag();\n            if (this.dayGrid) {\n                this.dayGrid.unrenderDrag();\n            }\n        },\n\n\n        /* Selection\n         ------------------------------------------------------------------------------------------------------------------*/\n\n\n        // Renders a visual indication of a selection\n        renderSelection: function(span) {\n            if (span.start.hasTime() || span.end.hasTime()) {\n                this.timeGrid.renderSelection(span);\n            }\n            else if (this.dayGrid) {\n                this.dayGrid.renderSelection(span);\n            }\n        },\n\n\n        // Unrenders a visual indications of a selection\n        unrenderSelection: function() {\n            this.timeGrid.unrenderSelection();\n            if (this.dayGrid) {\n                this.dayGrid.unrenderSelection();\n            }\n        }\n\n    });\n\n\n// Methods that will customize the rendering behavior of the AgendaView's timeGrid\n// TODO: move into TimeGrid\n    var agendaTimeGridMethods = {\n\n\n        // Generates the HTML that will go before the day-of week header cells\n        renderHeadIntroHtml: function() {\n            var view = this.view;\n            var weekText;\n\n            if (view.opt('weekNumbers')) {\n                weekText = this.start.format(view.opt('smallWeekFormat'));\n\n                return '' +\n                    '<th class=\"fc-axis fc-week-number ' + view.widgetHeaderClass + '\" ' + view.axisStyleAttr() + '>' +\n                    view.buildGotoAnchorHtml( // aside from link, important for matchCellWidths\n                        { date: this.start, type: 'week', forceOff: this.colCnt > 1 },\n                        htmlEscape(weekText) // inner HTML\n                    ) +\n                    '</th>';\n            }\n            else {\n                return '<th class=\"fc-axis ' + view.widgetHeaderClass + '\" ' + view.axisStyleAttr() + '></th>';\n            }\n        },\n\n\n        // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.\n        renderBgIntroHtml: function() {\n            var view = this.view;\n\n            return '<td class=\"fc-axis ' + view.widgetContentClass + '\" ' + view.axisStyleAttr() + '></td>';\n        },\n\n\n        // Generates the HTML that goes before all other types of cells.\n        // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\n        renderIntroHtml: function() {\n            var view = this.view;\n\n            return '<td class=\"fc-axis\" ' + view.axisStyleAttr() + '></td>';\n        }\n\n    };\n\n\n// Methods that will customize the rendering behavior of the AgendaView's dayGrid\n    var agendaDayGridMethods = {\n\n\n        // Generates the HTML that goes before the all-day cells\n        renderBgIntroHtml: function() {\n            var view = this.view;\n\n            return '' +\n                '<td class=\"fc-axis ' + view.widgetContentClass + '\" ' + view.axisStyleAttr() + '>' +\n                '<span>' + // needed for matchCellWidths\n                view.getAllDayHtml() +\n                '</span>' +\n                '</td>';\n        },\n\n\n        // Generates the HTML that goes before all other types of cells.\n        // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\n        renderIntroHtml: function() {\n            var view = this.view;\n\n            return '<td class=\"fc-axis\" ' + view.axisStyleAttr() + '></td>';\n        }\n\n    };\n\n    ;;\n\n    var AGENDA_ALL_DAY_EVENT_LIMIT = 5;\n\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\n    var AGENDA_STOCK_SUB_DURATIONS = [\n        { hours: 1 },\n        { minutes: 30 },\n        { minutes: 15 },\n        { seconds: 30 },\n        { seconds: 15 }\n    ];\n\n    fcViews.agenda = {\n        'class': AgendaView,\n        defaults: {\n            allDaySlot: true,\n            slotDuration: '00:30:00',\n            slotEventOverlap: true // a bad name. confused with overlap/constraint system\n        }\n    };\n\n    fcViews.agendaDay = {\n        type: 'agenda',\n        duration: { days: 1 }\n    };\n\n    fcViews.agendaWeek = {\n        type: 'agenda',\n        duration: { weeks: 1 }\n    };\n    ;;\n\n    /*\n     Responsible for the scroller, and forwarding event-related actions into the \"grid\"\n     */\n    var ListView = View.extend({\n\n        grid: null,\n        scroller: null,\n\n        initialize: function() {\n            this.grid = new ListViewGrid(this);\n            this.scroller = new Scroller({\n                overflowX: 'hidden',\n                overflowY: 'auto'\n            });\n        },\n\n        renderSkeleton: function() {\n            this.el.addClass(\n                'fc-list-view ' +\n                this.widgetContentClass\n            );\n\n            this.scroller.render();\n            this.scroller.el.appendTo(this.el);\n\n            this.grid.setElement(this.scroller.scrollEl);\n        },\n\n        unrenderSkeleton: function() {\n            this.scroller.destroy(); // will remove the Grid too\n        },\n\n        setHeight: function(totalHeight, isAuto) {\n            this.scroller.setHeight(this.computeScrollerHeight(totalHeight));\n        },\n\n        computeScrollerHeight: function(totalHeight) {\n            return totalHeight -\n                subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n        },\n\n        renderDates: function() {\n            this.grid.setRange(this.renderRange); // needs to process range-related options\n        },\n\n        renderEvents: function(events) {\n            this.grid.renderEvents(events);\n        },\n\n        unrenderEvents: function() {\n            this.grid.unrenderEvents();\n        },\n\n        isEventResizable: function(event) {\n            return false;\n        },\n\n        isEventDraggable: function(event) {\n            return false;\n        }\n\n    });\n\n    /*\n     Responsible for event rendering and user-interaction.\n     Its \"el\" is the inner-content of the above view's scroller.\n     */\n    var ListViewGrid = Grid.extend({\n\n        segSelector: '.fc-list-item', // which elements accept event actions\n        hasDayInteractions: false, // no day selection or day clicking\n\n        // slices by day\n        spanToSegs: function(span) {\n            var view = this.view;\n            var dayStart = view.renderRange.start.clone().time(0); // timed, so segs get times!\n            var dayIndex = 0;\n            var seg;\n            var segs = [];\n\n            while (dayStart < view.renderRange.end) {\n\n                seg = intersectRanges(span, {\n                    start: dayStart,\n                    end: dayStart.clone().add(1, 'day')\n                });\n\n                if (seg) {\n                    seg.dayIndex = dayIndex;\n                    segs.push(seg);\n                }\n\n                dayStart.add(1, 'day');\n                dayIndex++;\n\n                // detect when span won't go fully into the next day,\n                // and mutate the latest seg to the be the end.\n                if (\n                    seg && !seg.isEnd && span.end.hasTime() &&\n                    span.end < dayStart.clone().add(this.view.nextDayThreshold)\n                ) {\n                    seg.end = span.end.clone();\n                    seg.isEnd = true;\n                    break;\n                }\n            }\n\n            return segs;\n        },\n\n        // like \"4:00am\"\n        computeEventTimeFormat: function() {\n            return this.view.opt('mediumTimeFormat');\n        },\n\n        // for events with a url, the whole <tr> should be clickable,\n        // but it's impossible to wrap with an <a> tag. simulate this.\n        handleSegClick: function(seg, ev) {\n            var url;\n\n            Grid.prototype.handleSegClick.apply(this, arguments); // super. might prevent the default action\n\n            // not clicking on or within an <a> with an href\n            if (!$(ev.target).closest('a[href]').length) {\n                url = seg.event.url;\n                if (url && !ev.isDefaultPrevented()) { // jsEvent not cancelled in handler\n                    window.location.href = url; // simulate link click\n                }\n            }\n        },\n\n        // returns list of foreground segs that were actually rendered\n        renderFgSegs: function(segs) {\n            segs = this.renderFgSegEls(segs); // might filter away hidden events\n\n            if (!segs.length) {\n                this.renderEmptyMessage();\n            }\n            else {\n                this.renderSegList(segs);\n            }\n\n            return segs;\n        },\n\n        renderEmptyMessage: function() {\n            this.el.html(\n                '<div class=\"fc-list-empty-wrap2\">' + // TODO: try less wraps\n                '<div class=\"fc-list-empty-wrap1\">' +\n                '<div class=\"fc-list-empty\">' +\n                htmlEscape(this.view.opt('noEventsMessage')) +\n                '</div>' +\n                '</div>' +\n                '</div>'\n            );\n        },\n\n        // render the event segments in the view\n        renderSegList: function(allSegs) {\n            var segsByDay = this.groupSegsByDay(allSegs); // sparse array\n            var dayIndex;\n            var daySegs;\n            var i;\n            var tableEl = $('<table class=\"fc-list-table\"><tbody/></table>');\n            var tbodyEl = tableEl.find('tbody');\n\n            for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {\n                daySegs = segsByDay[dayIndex];\n                if (daySegs) { // sparse array, so might be undefined\n\n                    // append a day header\n                    tbodyEl.append(this.dayHeaderHtml(\n                        this.view.renderRange.start.clone().add(dayIndex, 'days')\n                    ));\n\n                    this.sortEventSegs(daySegs);\n\n                    for (i = 0; i < daySegs.length; i++) {\n                        tbodyEl.append(daySegs[i].el); // append event row\n                    }\n                }\n            }\n\n            this.el.empty().append(tableEl);\n        },\n\n        // Returns a sparse array of arrays, segs grouped by their dayIndex\n        groupSegsByDay: function(segs) {\n            var segsByDay = []; // sparse array\n            var i, seg;\n\n            for (i = 0; i < segs.length; i++) {\n                seg = segs[i];\n                (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))\n                    .push(seg);\n            }\n\n            return segsByDay;\n        },\n\n        // generates the HTML for the day headers that live amongst the event rows\n        dayHeaderHtml: function(dayDate) {\n            var view = this.view;\n            var mainFormat = view.opt('listDayFormat');\n            var altFormat = view.opt('listDayAltFormat');\n\n            return '<tr class=\"fc-list-heading\" data-date=\"' + dayDate.format('YYYY-MM-DD') + '\">' +\n                '<td class=\"' + view.widgetHeaderClass + '\" colspan=\"3\">' +\n                (mainFormat ?\n                    view.buildGotoAnchorHtml(\n                        dayDate,\n                        { 'class': 'fc-list-heading-main' },\n                        htmlEscape(dayDate.format(mainFormat)) // inner HTML\n                    ) :\n                    '') +\n                (altFormat ?\n                    view.buildGotoAnchorHtml(\n                        dayDate,\n                        { 'class': 'fc-list-heading-alt' },\n                        htmlEscape(dayDate.format(altFormat)) // inner HTML\n                    ) :\n                    '') +\n                '</td>' +\n                '</tr>';\n        },\n\n        // generates the HTML for a single event row\n        fgSegHtml: function(seg) {\n            var view = this.view;\n            var classes = [ 'fc-list-item' ].concat(this.getSegCustomClasses(seg));\n            var bgColor = this.getSegBackgroundColor(seg);\n            var event = seg.event;\n            var url = event.url;\n            var timeHtml;\n\n            if (event.allDay) {\n                timeHtml = view.getAllDayHtml();\n            }\n            else if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day\n                if (seg.isStart || seg.isEnd) { // outer segment that probably lasts part of the day\n                    timeHtml = htmlEscape(this.getEventTimeText(seg));\n                }\n                else { // inner segment that lasts the whole day\n                    timeHtml = view.getAllDayHtml();\n                }\n            }\n            else {\n                // Display the normal time text for the *event's* times\n                timeHtml = htmlEscape(this.getEventTimeText(event));\n            }\n\n            if (url) {\n                classes.push('fc-has-url');\n            }\n\n            return '<tr class=\"' + classes.join(' ') + '\">' +\n                (this.displayEventTime ?\n                    '<td class=\"fc-list-item-time ' + view.widgetContentClass + '\">' +\n                    (timeHtml || '') +\n                    '</td>' :\n                    '') +\n                '<td class=\"fc-list-item-marker ' + view.widgetContentClass + '\">' +\n                '<span class=\"fc-event-dot\"' +\n                (bgColor ?\n                    ' style=\"background-color:' + bgColor + '\"' :\n                    '') +\n                '></span>' +\n                '</td>' +\n                '<td class=\"fc-list-item-title ' + view.widgetContentClass + '\">' +\n                '<a' + (url ? ' href=\"' + htmlEscape(url) + '\"' : '') + '>' +\n                htmlEscape(seg.event.title || '') +\n                '</a>' +\n                '</td>' +\n                '</tr>';\n        }\n\n    });\n\n    ;;\n\n    fcViews.list = {\n        'class': ListView,\n        buttonTextKey: 'list', // what to lookup in locale files\n        defaults: {\n            buttonText: 'list', // text to display for English\n            listDayFormat: 'LL', // like \"January 1, 2016\"\n            noEventsMessage: 'No events to display'\n        }\n    };\n\n    fcViews.listDay = {\n        type: 'list',\n        duration: { days: 1 },\n        defaults: {\n            listDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header\n        }\n    };\n\n    fcViews.listWeek = {\n        type: 'list',\n        duration: { weeks: 1 },\n        defaults: {\n            listDayFormat: 'dddd', // day-of-week is more important\n            listDayAltFormat: 'LL'\n        }\n    };\n\n    fcViews.listMonth = {\n        type: 'list',\n        duration: { month: 1 },\n        defaults: {\n            listDayAltFormat: 'dddd' // day-of-week is nice-to-have\n        }\n    };\n\n    fcViews.listYear = {\n        type: 'list',\n        duration: { year: 1 },\n        defaults: {\n            listDayAltFormat: 'dddd' // day-of-week is nice-to-have\n        }\n    };\n\n    ;;\n\n    return FC; // export for Node/CommonJS\n});","// Language settings\n\nswitch(currentlanguage) {\n    case 'en':\n        var campsiteinventoryurl = \"/en/campsite/offers\";\n        var campsitesearchurl = \"/en/campsite/search\";\n        var provincesurl = \"/en/provinces\";\n        var statesurl = \"/en/states\";\n        var searchOnProvinceUrl = '/en/search-campsite/';\n        var searchpage = '/en/search-campsite';\n        var savecampsiteurl = '/en/campsite-offer/store';\n        var imagesaveurl = '/en/campsite-offer/images/store';\n        var movementsurl = '/en/movements';\n        var savingurl = '/en/save-campsite';\n        var offerurl = '/en/offer-campsite';\n        break;\n    case 'nl':\n        var campsiteinventoryurl = \"/nl/campsite/aanbiedingen\";\n        var campsitesearchurl = \"/nl/campsite/zoek\";\n        var provincesurl = \"/nl/provincies\";\n        var statesurl = \"/nl/gewesten\";\n        var searchOnProvinceUrl = '/nl/campsite-zoeken/';\n        var searchpage = '/nl/campsite-zoeken';\n        var savecampsiteurl = '/nl/campsite-offer/opslaan';\n        var imagesaveurl = '/nl/campsite-offer/afbeeldingen/opslaan';\n        var movementsurl = '/nl/jeugdbewegingen';\n        var savingurl = '/nl/campsite-opslaan';\n        var offerurl = '/nl/campsite-aanbieden';\n        break;\n    case 'fr':\n        var campsiteinventoryurl = \"/fr/campsite/offres\";\n        var campsitesearchurl = \"/fr/campsite/cherche\";\n        var provincesurl = \"/fr/provinces\";\n        var statesurl = \"/fr/régions\";\n        var searchOnProvinceUrl = '/fr/cherche-campsite/';\n        var searchpage = '/fr/cherche-campsite';\n        var savecampsiteurl = '/fr/campsite-offer/store';\n        var imagesaveurl = '/fr/offre-campsite/images/sauve';\n        var movementsurl = '/fr/movements-de-jeunesse';\n        var savingurl = '/fr/sauve-campsite';\n        var offerurl = '/fr/offre-campsite';\n        break;\n    default:\n        var campsiteinventoryurl = \"/en/campsite/offers\";\n        var campsitesearchurl = \"/en/campsite/search\";\n        var provincesurl = \"/en/provinces\";\n        var statesurl = \"/en/states\";\n        var searchOnProvinceUrl = '/en/search-campsite/';\n        var searchpage = '/en/search-campsite';\n        var savecampsiteurl = '/en/campsite-offer/store';\n        var imagesaveurl = '/en/campsite-offer/images/store';\n        var movementsurl = '/en/movements';\n        var savingurl = '/en/save-campsite';\n}\n\n$(document).ready(function(){\n\n\n    $('[data-toggle=\"tooltip\"]').tooltip();\n\n    // Carousel on home page settings\n    $('#owl-carousel-home').owlCarousel({\n        loop:true,\n        margin:40,\n        dots: false,\n        autoplay: true,\n        autoplayTimeout: 5000,\n        autoplayHoverPause: true,\n        responsive:{\n            0:{\n                items:1\n            },\n            600:{\n                items:2\n            },\n            900:{\n                items:3\n            },\n            1440:{\n                items:4\n            }\n        }\n    });\n    // End of carousel home page settings\n\n    // Carousel on campsite page settings\n    $('#owl-carousel-campsite').owlCarousel({\n        loop:true,\n        margin:40,\n        dots: true,\n        addClassActive: true,\n        items: 1\n    });\n\n    $(document).bind('keyup', function(e) {\n        if(e.which == 39){\n            $('.carousel').carousel('next');\n        }\n        else if(e.which == 37){\n            $('.carousel').carousel('prev');\n        }\n    });\n\n    // End of carousel campsite page settings\n\n});"]}