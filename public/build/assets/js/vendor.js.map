{"version":3,"sources":["angular.min.js","angular-animate.js","angular-file-upload.js","angular-filter.js","angular-route.js","angular-sanitize.js","angular-textAngular-sanitize.js","angular-textAngular.js","angular-textAngularSetup.js","angular-toastr.js","angular-tooltips.js","angular-ui-select.js","angular-validation-rule.js","angular-validation.js","angular-vertilize.js","owl.carousel.js","rangy-core.js","base.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1jIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxiEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7zEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChsCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACl/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACj0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACr1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1sGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjgIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"vendor.js","sourcesContent":["/*\n AngularJS v1.6.1\n (c) 2010-2016 Google, Inc. http://angularjs.org\n License: MIT\n*/\n(function(z){'use strict';function M(a,b){b=b||Error;return function(){var d=arguments[0],c;c=\"[\"+(a?a+\":\":\"\")+d+\"] http://errors.angularjs.org/1.6.1/\"+(a?a+\"/\":\"\")+d;for(d=1;d<arguments.length;d++){c=c+(1==d?\"?\":\"&\")+\"p\"+(d-1)+\"=\";var f=encodeURIComponent,e;e=arguments[d];e=\"function\"==typeof e?e.toString().replace(/ \\{[\\s\\S]*$/,\"\"):\"undefined\"==typeof e?\"undefined\":\"string\"!=typeof e?JSON.stringify(e):e;c+=f(e)}return new b(c)}}function ta(a){if(null==a||Wa(a))return!1;if(C(a)||E(a)||D&&a instanceof\nD)return!0;var b=\"length\"in Object(a)&&a.length;return Y(b)&&(0<=b&&(b-1 in a||a instanceof Array)||\"function\"===typeof a.item)}function q(a,b,d){var c,f;if(a)if(y(a))for(c in a)\"prototype\"!==c&&\"length\"!==c&&\"name\"!==c&&a.hasOwnProperty(c)&&b.call(d,a[c],c,a);else if(C(a)||ta(a)){var e=\"object\"!==typeof a;c=0;for(f=a.length;c<f;c++)(e||c in a)&&b.call(d,a[c],c,a)}else if(a.forEach&&a.forEach!==q)a.forEach(b,d,a);else if(Dc(a))for(c in a)b.call(d,a[c],c,a);else if(\"function\"===typeof a.hasOwnProperty)for(c in a)a.hasOwnProperty(c)&&\nb.call(d,a[c],c,a);else for(c in a)va.call(a,c)&&b.call(d,a[c],c,a);return a}function Ec(a,b,d){for(var c=Object.keys(a).sort(),f=0;f<c.length;f++)b.call(d,a[c[f]],c[f]);return c}function Fc(a){return function(b,d){a(d,b)}}function ie(){return++rb}function Sb(a,b,d){for(var c=a.$$hashKey,f=0,e=b.length;f<e;++f){var g=b[f];if(F(g)||y(g))for(var h=Object.keys(g),k=0,l=h.length;k<l;k++){var m=h[k],n=g[m];d&&F(n)?fa(n)?a[m]=new Date(n.valueOf()):Xa(n)?a[m]=new RegExp(n):n.nodeName?a[m]=n.cloneNode(!0):\nTb(n)?a[m]=n.clone():(F(a[m])||(a[m]=C(n)?[]:{}),Sb(a[m],[n],!0)):a[m]=n}}c?a.$$hashKey=c:delete a.$$hashKey;return a}function R(a){return Sb(a,wa.call(arguments,1),!1)}function je(a){return Sb(a,wa.call(arguments,1),!0)}function Z(a){return parseInt(a,10)}function Ub(a,b){return R(Object.create(a),b)}function w(){}function Ya(a){return a}function ma(a){return function(){return a}}function Vb(a){return y(a.toString)&&a.toString!==na}function x(a){return\"undefined\"===typeof a}function v(a){return\"undefined\"!==\ntypeof a}function F(a){return null!==a&&\"object\"===typeof a}function Dc(a){return null!==a&&\"object\"===typeof a&&!Gc(a)}function E(a){return\"string\"===typeof a}function Y(a){return\"number\"===typeof a}function fa(a){return\"[object Date]\"===na.call(a)}function y(a){return\"function\"===typeof a}function Xa(a){return\"[object RegExp]\"===na.call(a)}function Wa(a){return a&&a.window===a}function Za(a){return a&&a.$evalAsync&&a.$watch}function Ia(a){return\"boolean\"===typeof a}function ke(a){return a&&Y(a.length)&&\nle.test(na.call(a))}function Tb(a){return!(!a||!(a.nodeName||a.prop&&a.attr&&a.find))}function me(a){var b={};a=a.split(\",\");var d;for(d=0;d<a.length;d++)b[a[d]]=!0;return b}function xa(a){return P(a.nodeName||a[0]&&a[0].nodeName)}function $a(a,b){var d=a.indexOf(b);0<=d&&a.splice(d,1);return d}function Fa(a,b){function d(a,b){var d=b.$$hashKey,e;if(C(a)){e=0;for(var f=a.length;e<f;e++)b.push(c(a[e]))}else if(Dc(a))for(e in a)b[e]=c(a[e]);else if(a&&\"function\"===typeof a.hasOwnProperty)for(e in a)a.hasOwnProperty(e)&&\n(b[e]=c(a[e]));else for(e in a)va.call(a,e)&&(b[e]=c(a[e]));d?b.$$hashKey=d:delete b.$$hashKey;return b}function c(a){if(!F(a))return a;var b=e.indexOf(a);if(-1!==b)return g[b];if(Wa(a)||Za(a))throw Ga(\"cpws\");var b=!1,c=f(a);void 0===c&&(c=C(a)?[]:Object.create(Gc(a)),b=!0);e.push(a);g.push(c);return b?d(a,c):c}function f(a){switch(na.call(a)){case \"[object Int8Array]\":case \"[object Int16Array]\":case \"[object Int32Array]\":case \"[object Float32Array]\":case \"[object Float64Array]\":case \"[object Uint8Array]\":case \"[object Uint8ClampedArray]\":case \"[object Uint16Array]\":case \"[object Uint32Array]\":return new a.constructor(c(a.buffer),\na.byteOffset,a.length);case \"[object ArrayBuffer]\":if(!a.slice){var b=new ArrayBuffer(a.byteLength);(new Uint8Array(b)).set(new Uint8Array(a));return b}return a.slice(0);case \"[object Boolean]\":case \"[object Number]\":case \"[object String]\":case \"[object Date]\":return new a.constructor(a.valueOf());case \"[object RegExp]\":return b=new RegExp(a.source,a.toString().match(/[^/]*$/)[0]),b.lastIndex=a.lastIndex,b;case \"[object Blob]\":return new a.constructor([a],{type:a.type})}if(y(a.cloneNode))return a.cloneNode(!0)}\nvar e=[],g=[];if(b){if(ke(b)||\"[object ArrayBuffer]\"===na.call(b))throw Ga(\"cpta\");if(a===b)throw Ga(\"cpi\");C(b)?b.length=0:q(b,function(a,d){\"$$hashKey\"!==d&&delete b[d]});e.push(a);g.push(b);return d(a,b)}return c(a)}function qa(a,b){if(a===b)return!0;if(null===a||null===b)return!1;if(a!==a&&b!==b)return!0;var d=typeof a,c;if(d===typeof b&&\"object\"===d)if(C(a)){if(!C(b))return!1;if((d=a.length)===b.length){for(c=0;c<d;c++)if(!qa(a[c],b[c]))return!1;return!0}}else{if(fa(a))return fa(b)?qa(a.getTime(),\nb.getTime()):!1;if(Xa(a))return Xa(b)?a.toString()===b.toString():!1;if(Za(a)||Za(b)||Wa(a)||Wa(b)||C(b)||fa(b)||Xa(b))return!1;d=W();for(c in a)if(\"$\"!==c.charAt(0)&&!y(a[c])){if(!qa(a[c],b[c]))return!1;d[c]=!0}for(c in b)if(!(c in d)&&\"$\"!==c.charAt(0)&&v(b[c])&&!y(b[c]))return!1;return!0}return!1}function ab(a,b,d){return a.concat(wa.call(b,d))}function bb(a,b){var d=2<arguments.length?wa.call(arguments,2):[];return!y(b)||b instanceof RegExp?b:d.length?function(){return arguments.length?b.apply(a,\nab(d,arguments,0)):b.apply(a,d)}:function(){return arguments.length?b.apply(a,arguments):b.call(a)}}function Hc(a,b){var d=b;\"string\"===typeof a&&\"$\"===a.charAt(0)&&\"$\"===a.charAt(1)?d=void 0:Wa(b)?d=\"$WINDOW\":b&&z.document===b?d=\"$DOCUMENT\":Za(b)&&(d=\"$SCOPE\");return d}function cb(a,b){if(!x(a))return Y(b)||(b=b?2:null),JSON.stringify(a,Hc,b)}function Ic(a){return E(a)?JSON.parse(a):a}function Jc(a,b){a=a.replace(ne,\"\");var d=Date.parse(\"Jan 01, 1970 00:00:00 \"+a)/6E4;return ga(d)?b:d}function Wb(a,\nb,d){d=d?-1:1;var c=a.getTimezoneOffset();b=Jc(b,c);d*=b-c;a=new Date(a.getTime());a.setMinutes(a.getMinutes()+d);return a}function ya(a){a=D(a).clone();try{a.empty()}catch(b){}var d=D(\"<div>\").append(a).html();try{return a[0].nodeType===Ja?P(d):d.match(/^(<[^>]+>)/)[1].replace(/^<([\\w-]+)/,function(a,b){return\"<\"+P(b)})}catch(c){return P(d)}}function Kc(a){try{return decodeURIComponent(a)}catch(b){}}function Lc(a){var b={};q((a||\"\").split(\"&\"),function(a){var c,f,e;a&&(f=a=a.replace(/\\+/g,\"%20\"),\nc=a.indexOf(\"=\"),-1!==c&&(f=a.substring(0,c),e=a.substring(c+1)),f=Kc(f),v(f)&&(e=v(e)?Kc(e):!0,va.call(b,f)?C(b[f])?b[f].push(e):b[f]=[b[f],e]:b[f]=e))});return b}function Xb(a){var b=[];q(a,function(a,c){C(a)?q(a,function(a){b.push(ka(c,!0)+(!0===a?\"\":\"=\"+ka(a,!0)))}):b.push(ka(c,!0)+(!0===a?\"\":\"=\"+ka(a,!0)))});return b.length?b.join(\"&\"):\"\"}function db(a){return ka(a,!0).replace(/%26/gi,\"&\").replace(/%3D/gi,\"=\").replace(/%2B/gi,\"+\")}function ka(a,b){return encodeURIComponent(a).replace(/%40/gi,\n\"@\").replace(/%3A/gi,\":\").replace(/%24/g,\"$\").replace(/%2C/gi,\",\").replace(/%3B/gi,\";\").replace(/%20/g,b?\"%20\":\"+\")}function oe(a,b){var d,c,f=Ka.length;for(c=0;c<f;++c)if(d=Ka[c]+b,E(d=a.getAttribute(d)))return d;return null}function pe(a,b){var d,c,f={};q(Ka,function(b){b+=\"app\";!d&&a.hasAttribute&&a.hasAttribute(b)&&(d=a,c=a.getAttribute(b))});q(Ka,function(b){b+=\"app\";var f;!d&&(f=a.querySelector(\"[\"+b.replace(\":\",\"\\\\:\")+\"]\"))&&(d=f,c=f.getAttribute(b))});d&&(qe?(f.strictDi=null!==oe(d,\"strict-di\"),\nb(d,c?[c]:[],f)):z.console.error(\"Angular: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match.\"))}function Mc(a,b,d){F(d)||(d={});d=R({strictDi:!1},d);var c=function(){a=D(a);if(a.injector()){var c=a[0]===z.document?\"document\":ya(a);throw Ga(\"btstrpd\",c.replace(/</,\"&lt;\").replace(/>/,\"&gt;\"));}b=b||[];b.unshift([\"$provide\",function(b){b.value(\"$rootElement\",a)}]);d.debugInfoEnabled&&b.push([\"$compileProvider\",function(a){a.debugInfoEnabled(!0)}]);\nb.unshift(\"ng\");c=eb(b,d.strictDi);c.invoke([\"$rootScope\",\"$rootElement\",\"$compile\",\"$injector\",function(a,b,d,c){a.$apply(function(){b.data(\"$injector\",c);d(b)(a)})}]);return c},f=/^NG_ENABLE_DEBUG_INFO!/,e=/^NG_DEFER_BOOTSTRAP!/;z&&f.test(z.name)&&(d.debugInfoEnabled=!0,z.name=z.name.replace(f,\"\"));if(z&&!e.test(z.name))return c();z.name=z.name.replace(e,\"\");$.resumeBootstrap=function(a){q(a,function(a){b.push(a)});return c()};y($.resumeDeferredBootstrap)&&$.resumeDeferredBootstrap()}function re(){z.name=\n\"NG_ENABLE_DEBUG_INFO!\"+z.name;z.location.reload()}function se(a){a=$.element(a).injector();if(!a)throw Ga(\"test\");return a.get(\"$$testability\")}function Nc(a,b){b=b||\"_\";return a.replace(te,function(a,c){return(c?b:\"\")+a.toLowerCase()})}function ue(){var a;if(!Oc){var b=sb();(oa=x(b)?z.jQuery:b?z[b]:void 0)&&oa.fn.on?(D=oa,R(oa.fn,{scope:Oa.scope,isolateScope:Oa.isolateScope,controller:Oa.controller,injector:Oa.injector,inheritedData:Oa.inheritedData}),a=oa.cleanData,oa.cleanData=function(b){for(var c,\nf=0,e;null!=(e=b[f]);f++)(c=oa._data(e,\"events\"))&&c.$destroy&&oa(e).triggerHandler(\"$destroy\");a(b)}):D=X;$.element=D;Oc=!0}}function fb(a,b,d){if(!a)throw Ga(\"areq\",b||\"?\",d||\"required\");return a}function tb(a,b,d){d&&C(a)&&(a=a[a.length-1]);fb(y(a),b,\"not a function, got \"+(a&&\"object\"===typeof a?a.constructor.name||\"Object\":typeof a));return a}function Pa(a,b){if(\"hasOwnProperty\"===a)throw Ga(\"badname\",b);}function Pc(a,b,d){if(!b)return a;b=b.split(\".\");for(var c,f=a,e=b.length,g=0;g<e;g++)c=\nb[g],a&&(a=(f=a)[c]);return!d&&y(a)?bb(f,a):a}function ub(a){for(var b=a[0],d=a[a.length-1],c,f=1;b!==d&&(b=b.nextSibling);f++)if(c||a[f]!==b)c||(c=D(wa.call(a,0,f))),c.push(b);return c||a}function W(){return Object.create(null)}function Yb(a){if(null==a)return\"\";switch(typeof a){case \"string\":break;case \"number\":a=\"\"+a;break;default:a=!Vb(a)||C(a)||fa(a)?cb(a):a.toString()}return a}function ve(a){function b(a,b,c){return a[b]||(a[b]=c())}var d=M(\"$injector\"),c=M(\"ng\");a=b(a,\"angular\",Object);a.$$minErr=\na.$$minErr||M;return b(a,\"module\",function(){var a={};return function(e,g,h){if(\"hasOwnProperty\"===e)throw c(\"badname\",\"module\");g&&a.hasOwnProperty(e)&&(a[e]=null);return b(a,e,function(){function a(b,d,e,f){f||(f=c);return function(){f[e||\"push\"]([b,d,arguments]);return J}}function b(a,d,f){f||(f=c);return function(b,c){c&&y(c)&&(c.$$moduleName=e);f.push([a,d,arguments]);return J}}if(!g)throw d(\"nomod\",e);var c=[],f=[],p=[],r=a(\"$injector\",\"invoke\",\"push\",f),J={_invokeQueue:c,_configBlocks:f,_runBlocks:p,\nrequires:g,name:e,provider:b(\"$provide\",\"provider\"),factory:b(\"$provide\",\"factory\"),service:b(\"$provide\",\"service\"),value:a(\"$provide\",\"value\"),constant:a(\"$provide\",\"constant\",\"unshift\"),decorator:b(\"$provide\",\"decorator\",f),animation:b(\"$animateProvider\",\"register\"),filter:b(\"$filterProvider\",\"register\"),controller:b(\"$controllerProvider\",\"register\"),directive:b(\"$compileProvider\",\"directive\"),component:b(\"$compileProvider\",\"component\"),config:r,run:function(a){p.push(a);return this}};h&&r(h);return J})}})}\nfunction ra(a,b){if(C(a)){b=b||[];for(var d=0,c=a.length;d<c;d++)b[d]=a[d]}else if(F(a))for(d in b=b||{},a)if(\"$\"!==d.charAt(0)||\"$\"!==d.charAt(1))b[d]=a[d];return b||a}function we(a){var b=[];return JSON.stringify(a,function(a,c){c=Hc(a,c);if(F(c)){if(0<=b.indexOf(c))return\"...\";b.push(c)}return c})}function xe(a){R(a,{bootstrap:Mc,copy:Fa,extend:R,merge:je,equals:qa,element:D,forEach:q,injector:eb,noop:w,bind:bb,toJson:cb,fromJson:Ic,identity:Ya,isUndefined:x,isDefined:v,isString:E,isFunction:y,\nisObject:F,isNumber:Y,isElement:Tb,isArray:C,version:ye,isDate:fa,lowercase:P,uppercase:vb,callbacks:{$$counter:0},getTestability:se,reloadWithDebugInfo:re,$$minErr:M,$$csp:za,$$encodeUriSegment:db,$$encodeUriQuery:ka,$$stringify:Yb});Zb=ve(z);Zb(\"ng\",[\"ngLocale\"],[\"$provide\",function(a){a.provider({$$sanitizeUri:ze});a.provider(\"$compile\",Qc).directive({a:Ae,input:Rc,textarea:Rc,form:Be,script:Ce,select:De,option:Ee,ngBind:Fe,ngBindHtml:Ge,ngBindTemplate:He,ngClass:Ie,ngClassEven:Je,ngClassOdd:Ke,\nngCloak:Le,ngController:Me,ngForm:Ne,ngHide:Oe,ngIf:Pe,ngInclude:Qe,ngInit:Re,ngNonBindable:Se,ngPluralize:Te,ngRepeat:Ue,ngShow:Ve,ngStyle:We,ngSwitch:Xe,ngSwitchWhen:Ye,ngSwitchDefault:Ze,ngOptions:$e,ngTransclude:af,ngModel:bf,ngList:cf,ngChange:df,pattern:Sc,ngPattern:Sc,required:Tc,ngRequired:Tc,minlength:Uc,ngMinlength:Uc,maxlength:Vc,ngMaxlength:Vc,ngValue:ef,ngModelOptions:ff}).directive({ngInclude:gf}).directive(wb).directive(Wc);a.provider({$anchorScroll:hf,$animate:jf,$animateCss:kf,$$animateJs:lf,\n$$animateQueue:mf,$$AnimateRunner:nf,$$animateAsyncRun:of,$browser:pf,$cacheFactory:qf,$controller:rf,$document:sf,$$isDocumentHidden:tf,$exceptionHandler:uf,$filter:Xc,$$forceReflow:vf,$interpolate:wf,$interval:xf,$http:yf,$httpParamSerializer:zf,$httpParamSerializerJQLike:Af,$httpBackend:Bf,$xhrFactory:Cf,$jsonpCallbacks:Df,$location:Ef,$log:Ff,$parse:Gf,$rootScope:Hf,$q:If,$$q:Jf,$sce:Kf,$sceDelegate:Lf,$sniffer:Mf,$templateCache:Nf,$templateRequest:Of,$$testability:Pf,$timeout:Qf,$window:Rf,$$rAF:Sf,\n$$jqLite:Tf,$$HashMap:Uf,$$cookieReader:Vf})}])}function gb(a,b){return b.toUpperCase()}function xb(a){return a.replace(Wf,gb)}function Yc(a){a=a.nodeType;return 1===a||!a||9===a}function Zc(a,b){var d,c,f=b.createDocumentFragment(),e=[];if($b.test(a)){d=f.appendChild(b.createElement(\"div\"));c=(Xf.exec(a)||[\"\",\"\"])[1].toLowerCase();c=ha[c]||ha._default;d.innerHTML=c[1]+a.replace(Yf,\"<$1></$2>\")+c[2];for(c=c[0];c--;)d=d.lastChild;e=ab(e,d.childNodes);d=f.firstChild;d.textContent=\"\"}else e.push(b.createTextNode(a));\nf.textContent=\"\";f.innerHTML=\"\";q(e,function(a){f.appendChild(a)});return f}function X(a){if(a instanceof X)return a;var b;E(a)&&(a=S(a),b=!0);if(!(this instanceof X)){if(b&&\"<\"!==a.charAt(0))throw ac(\"nosel\");return new X(a)}if(b){b=z.document;var d;a=(d=Zf.exec(a))?[b.createElement(d[1])]:(d=Zc(a,b))?d.childNodes:[];bc(this,a)}else y(a)?$c(a):bc(this,a)}function cc(a){return a.cloneNode(!0)}function yb(a,b){b||hb(a);if(a.querySelectorAll)for(var d=a.querySelectorAll(\"*\"),c=0,f=d.length;c<f;c++)hb(d[c])}\nfunction ad(a,b,d,c){if(v(c))throw ac(\"offargs\");var f=(c=zb(a))&&c.events,e=c&&c.handle;if(e)if(b){var g=function(b){var c=f[b];v(d)&&$a(c||[],d);v(d)&&c&&0<c.length||(a.removeEventListener(b,e),delete f[b])};q(b.split(\" \"),function(a){g(a);Ab[a]&&g(Ab[a])})}else for(b in f)\"$destroy\"!==b&&a.removeEventListener(b,e),delete f[b]}function hb(a,b){var d=a.ng339,c=d&&ib[d];c&&(b?delete c.data[b]:(c.handle&&(c.events.$destroy&&c.handle({},\"$destroy\"),ad(a)),delete ib[d],a.ng339=void 0))}function zb(a,\nb){var d=a.ng339,d=d&&ib[d];b&&!d&&(a.ng339=d=++$f,d=ib[d]={events:{},data:{},handle:void 0});return d}function dc(a,b,d){if(Yc(a)){var c,f=v(d),e=!f&&b&&!F(b),g=!b;a=(a=zb(a,!e))&&a.data;if(f)a[xb(b)]=d;else{if(g)return a;if(e)return a&&a[xb(b)];for(c in b)a[xb(c)]=b[c]}}}function Bb(a,b){return a.getAttribute?-1<(\" \"+(a.getAttribute(\"class\")||\"\")+\" \").replace(/[\\n\\t]/g,\" \").indexOf(\" \"+b+\" \"):!1}function Cb(a,b){b&&a.setAttribute&&q(b.split(\" \"),function(b){a.setAttribute(\"class\",S((\" \"+(a.getAttribute(\"class\")||\n\"\")+\" \").replace(/[\\n\\t]/g,\" \").replace(\" \"+S(b)+\" \",\" \")))})}function Db(a,b){if(b&&a.setAttribute){var d=(\" \"+(a.getAttribute(\"class\")||\"\")+\" \").replace(/[\\n\\t]/g,\" \");q(b.split(\" \"),function(a){a=S(a);-1===d.indexOf(\" \"+a+\" \")&&(d+=a+\" \")});a.setAttribute(\"class\",S(d))}}function bc(a,b){if(b)if(b.nodeType)a[a.length++]=b;else{var d=b.length;if(\"number\"===typeof d&&b.window!==b){if(d)for(var c=0;c<d;c++)a[a.length++]=b[c]}else a[a.length++]=b}}function bd(a,b){return Eb(a,\"$\"+(b||\"ngController\")+\n\"Controller\")}function Eb(a,b,d){9===a.nodeType&&(a=a.documentElement);for(b=C(b)?b:[b];a;){for(var c=0,f=b.length;c<f;c++)if(v(d=D.data(a,b[c])))return d;a=a.parentNode||11===a.nodeType&&a.host}}function cd(a){for(yb(a,!0);a.firstChild;)a.removeChild(a.firstChild)}function Fb(a,b){b||yb(a);var d=a.parentNode;d&&d.removeChild(a)}function ag(a,b){b=b||z;if(\"complete\"===b.document.readyState)b.setTimeout(a);else D(b).on(\"load\",a)}function $c(a){function b(){z.document.removeEventListener(\"DOMContentLoaded\",\nb);z.removeEventListener(\"load\",b);a()}\"complete\"===z.document.readyState?z.setTimeout(a):(z.document.addEventListener(\"DOMContentLoaded\",b),z.addEventListener(\"load\",b))}function dd(a,b){var d=Gb[b.toLowerCase()];return d&&ed[xa(a)]&&d}function bg(a,b){var d=function(c,d){c.isDefaultPrevented=function(){return c.defaultPrevented};var e=b[d||c.type],g=e?e.length:0;if(g){if(x(c.immediatePropagationStopped)){var h=c.stopImmediatePropagation;c.stopImmediatePropagation=function(){c.immediatePropagationStopped=\n!0;c.stopPropagation&&c.stopPropagation();h&&h.call(c)}}c.isImmediatePropagationStopped=function(){return!0===c.immediatePropagationStopped};var k=e.specialHandlerWrapper||cg;1<g&&(e=ra(e));for(var l=0;l<g;l++)c.isImmediatePropagationStopped()||k(a,c,e[l])}};d.elem=a;return d}function cg(a,b,d){d.call(a,b)}function dg(a,b,d){var c=b.relatedTarget;c&&(c===a||eg.call(a,c))||d.call(a,b)}function Tf(){this.$get=function(){return R(X,{hasClass:function(a,b){a.attr&&(a=a[0]);return Bb(a,b)},addClass:function(a,\nb){a.attr&&(a=a[0]);return Db(a,b)},removeClass:function(a,b){a.attr&&(a=a[0]);return Cb(a,b)}})}}function la(a,b){var d=a&&a.$$hashKey;if(d)return\"function\"===typeof d&&(d=a.$$hashKey()),d;d=typeof a;return d=\"function\"===d||\"object\"===d&&null!==a?a.$$hashKey=d+\":\"+(b||ie)():d+\":\"+a}function Qa(a,b){if(b){var d=0;this.nextUid=function(){return++d}}q(a,this.put,this)}function fd(a){a=(Function.prototype.toString.call(a)+\" \").replace(fg,\"\");return a.match(gg)||a.match(hg)}function ig(a){return(a=fd(a))?\n\"function(\"+(a[1]||\"\").replace(/[\\s\\r\\n]+/,\" \")+\")\":\"fn\"}function eb(a,b){function d(a){return function(b,c){if(F(b))q(b,Fc(a));else return a(b,c)}}function c(a,b){Pa(a,\"service\");if(y(b)||C(b))b=p.instantiate(b);if(!b.$get)throw da(\"pget\",a);return n[a+\"Provider\"]=b}function f(a,b){return function(){var c=O.invoke(b,this);if(x(c))throw da(\"undef\",a);return c}}function e(a,b,d){return c(a,{$get:!1!==d?f(a,b):b})}function g(a){fb(x(a)||C(a),\"modulesToLoad\",\"not an array\");var b=[],c;q(a,function(a){function d(a){var b,\nc;b=0;for(c=a.length;b<c;b++){var e=a[b],f=p.get(e[0]);f[e[1]].apply(f,e[2])}}if(!m.get(a)){m.put(a,!0);try{E(a)?(c=Zb(a),b=b.concat(g(c.requires)).concat(c._runBlocks),d(c._invokeQueue),d(c._configBlocks)):y(a)?b.push(p.invoke(a)):C(a)?b.push(p.invoke(a)):tb(a,\"module\")}catch(e){throw C(a)&&(a=a[a.length-1]),e.message&&e.stack&&-1===e.stack.indexOf(e.message)&&(e=e.message+\"\\n\"+e.stack),da(\"modulerr\",a,e.stack||e.message||e);}}});return b}function h(a,c){function d(b,e){if(a.hasOwnProperty(b)){if(a[b]===\nk)throw da(\"cdep\",b+\" <- \"+l.join(\" <- \"));return a[b]}try{return l.unshift(b),a[b]=k,a[b]=c(b,e),a[b]}catch(f){throw a[b]===k&&delete a[b],f;}finally{l.shift()}}function e(a,c,f){var g=[];a=eb.$$annotate(a,b,f);for(var h=0,k=a.length;h<k;h++){var l=a[h];if(\"string\"!==typeof l)throw da(\"itkn\",l);g.push(c&&c.hasOwnProperty(l)?c[l]:d(l,f))}return g}return{invoke:function(a,b,c,d){\"string\"===typeof c&&(d=c,c=null);c=e(a,c,d);C(a)&&(a=a[a.length-1]);d=a;if(La||\"function\"!==typeof d)d=!1;else{var f=d.$$ngIsClass;\nIa(f)||(f=d.$$ngIsClass=/^(?:class\\b|constructor\\()/.test(Function.prototype.toString.call(d)+\" \"));d=f}return d?(c.unshift(null),new (Function.prototype.bind.apply(a,c))):a.apply(b,c)},instantiate:function(a,b,c){var d=C(a)?a[a.length-1]:a;a=e(a,b,c);a.unshift(null);return new (Function.prototype.bind.apply(d,a))},get:d,annotate:eb.$$annotate,has:function(b){return n.hasOwnProperty(b+\"Provider\")||a.hasOwnProperty(b)}}}b=!0===b;var k={},l=[],m=new Qa([],!0),n={$provide:{provider:d(c),factory:d(e),\nservice:d(function(a,b){return e(a,[\"$injector\",function(a){return a.instantiate(b)}])}),value:d(function(a,b){return e(a,ma(b),!1)}),constant:d(function(a,b){Pa(a,\"constant\");n[a]=b;r[a]=b}),decorator:function(a,b){var c=p.get(a+\"Provider\"),d=c.$get;c.$get=function(){var a=O.invoke(d,c);return O.invoke(b,null,{$delegate:a})}}}},p=n.$injector=h(n,function(a,b){$.isString(b)&&l.push(b);throw da(\"unpr\",l.join(\" <- \"));}),r={},J=h(r,function(a,b){var c=p.get(a+\"Provider\",b);return O.invoke(c.$get,c,\nvoid 0,a)}),O=J;n.$injectorProvider={$get:ma(J)};var u=g(a),O=J.get(\"$injector\");O.strictDi=b;q(u,function(a){a&&O.invoke(a)});return O}function hf(){var a=!0;this.disableAutoScrolling=function(){a=!1};this.$get=[\"$window\",\"$location\",\"$rootScope\",function(b,d,c){function f(a){var b=null;Array.prototype.some.call(a,function(a){if(\"a\"===xa(a))return b=a,!0});return b}function e(a){if(a){a.scrollIntoView();var c;c=g.yOffset;y(c)?c=c():Tb(c)?(c=c[0],c=\"fixed\"!==b.getComputedStyle(c).position?0:c.getBoundingClientRect().bottom):\nY(c)||(c=0);c&&(a=a.getBoundingClientRect().top,b.scrollBy(0,a-c))}else b.scrollTo(0,0)}function g(a){a=E(a)?a:Y(a)?a.toString():d.hash();var b;a?(b=h.getElementById(a))?e(b):(b=f(h.getElementsByName(a)))?e(b):\"top\"===a&&e(null):e(null)}var h=b.document;a&&c.$watch(function(){return d.hash()},function(a,b){a===b&&\"\"===a||ag(function(){c.$evalAsync(g)})});return g}]}function jb(a,b){if(!a&&!b)return\"\";if(!a)return b;if(!b)return a;C(a)&&(a=a.join(\" \"));C(b)&&(b=b.join(\" \"));return a+\" \"+b}function jg(a){E(a)&&\n(a=a.split(\" \"));var b=W();q(a,function(a){a.length&&(b[a]=!0)});return b}function Aa(a){return F(a)?a:{}}function kg(a,b,d,c){function f(a){try{a.apply(null,wa.call(arguments,1))}finally{if(J--,0===J)for(;O.length;)try{O.pop()()}catch(b){d.error(b)}}}function e(){ia=null;g();h()}function g(){u=A();u=x(u)?null:u;qa(u,B)&&(u=B);B=u}function h(){if(U!==k.url()||H!==u)U=k.url(),H=u,q(K,function(a){a(k.url(),u)})}var k=this,l=a.location,m=a.history,n=a.setTimeout,p=a.clearTimeout,r={};k.isMock=!1;var J=\n0,O=[];k.$$completeOutstandingRequest=f;k.$$incOutstandingRequestCount=function(){J++};k.notifyWhenNoOutstandingRequests=function(a){0===J?a():O.push(a)};var u,H,U=l.href,t=b.find(\"base\"),ia=null,A=c.history?function(){try{return m.state}catch(a){}}:w;g();H=u;k.url=function(b,d,e){x(e)&&(e=null);l!==a.location&&(l=a.location);m!==a.history&&(m=a.history);if(b){var f=H===e;if(U===b&&(!c.history||f))return k;var h=U&&Ba(U)===Ba(b);U=b;H=e;!c.history||h&&f?(h||(ia=b),d?l.replace(b):h?(d=l,e=b.indexOf(\"#\"),\ne=-1===e?\"\":b.substr(e),d.hash=e):l.href=b,l.href!==b&&(ia=b)):(m[d?\"replaceState\":\"pushState\"](e,\"\",b),g(),H=u);ia&&(ia=b);return k}return ia||l.href.replace(/%27/g,\"'\")};k.state=function(){return u};var K=[],I=!1,B=null;k.onUrlChange=function(b){if(!I){if(c.history)D(a).on(\"popstate\",e);D(a).on(\"hashchange\",e);I=!0}K.push(b);return b};k.$$applicationDestroyed=function(){D(a).off(\"hashchange popstate\",e)};k.$$checkUrlChange=h;k.baseHref=function(){var a=t.attr(\"href\");return a?a.replace(/^(https?:)?\\/\\/[^/]*/,\n\"\"):\"\"};k.defer=function(a,b){var c;J++;c=n(function(){delete r[c];f(a)},b||0);r[c]=!0;return c};k.defer.cancel=function(a){return r[a]?(delete r[a],p(a),f(w),!0):!1}}function pf(){this.$get=[\"$window\",\"$log\",\"$sniffer\",\"$document\",function(a,b,d,c){return new kg(a,c,b,d)}]}function qf(){this.$get=function(){function a(a,c){function f(a){a!==n&&(p?p===a&&(p=a.n):p=a,e(a.n,a.p),e(a,n),n=a,n.n=null)}function e(a,b){a!==b&&(a&&(a.p=b),b&&(b.n=a))}if(a in b)throw M(\"$cacheFactory\")(\"iid\",a);var g=0,h=\nR({},c,{id:a}),k=W(),l=c&&c.capacity||Number.MAX_VALUE,m=W(),n=null,p=null;return b[a]={put:function(a,b){if(!x(b)){if(l<Number.MAX_VALUE){var c=m[a]||(m[a]={key:a});f(c)}a in k||g++;k[a]=b;g>l&&this.remove(p.key);return b}},get:function(a){if(l<Number.MAX_VALUE){var b=m[a];if(!b)return;f(b)}return k[a]},remove:function(a){if(l<Number.MAX_VALUE){var b=m[a];if(!b)return;b===n&&(n=b.p);b===p&&(p=b.n);e(b.n,b.p);delete m[a]}a in k&&(delete k[a],g--)},removeAll:function(){k=W();g=0;m=W();n=p=null},destroy:function(){m=\nh=k=null;delete b[a]},info:function(){return R({},h,{size:g})}}}var b={};a.info=function(){var a={};q(b,function(b,f){a[f]=b.info()});return a};a.get=function(a){return b[a]};return a}}function Nf(){this.$get=[\"$cacheFactory\",function(a){return a(\"templates\")}]}function Qc(a,b){function d(a,b,c){var d=/^\\s*([@&<]|=(\\*?))(\\??)\\s*(\\w*)\\s*$/,e=W();q(a,function(a,f){if(a in n)e[f]=n[a];else{var g=a.match(d);if(!g)throw ea(\"iscp\",b,f,a,c?\"controller bindings definition\":\"isolate scope definition\");e[f]=\n{mode:g[1][0],collection:\"*\"===g[2],optional:\"?\"===g[3],attrName:g[4]||f};g[4]&&(n[a]=e[f])}});return e}function c(a){var b=a.charAt(0);if(!b||b!==P(b))throw ea(\"baddir\",a);if(a!==a.trim())throw ea(\"baddir\",a);}function f(a){var b=a.require||a.controller&&a.name;!C(b)&&F(b)&&q(b,function(a,c){var d=a.match(l);a.substring(d[0].length)||(b[c]=d[0]+c)});return b}var e={},g=/^\\s*directive:\\s*([\\w-]+)\\s+(.*)$/,h=/(([\\w-]+)(?::([^;]+))?;?)/,k=me(\"ngSrc,ngSrcset,src,srcset\"),l=/^(?:(\\^\\^?)?(\\?)?(\\^\\^?)?)?/,\nm=/^(on[a-z]+|formaction)$/,n=W();this.directive=function U(b,d){fb(b,\"name\");Pa(b,\"directive\");E(b)?(c(b),fb(d,\"directiveFactory\"),e.hasOwnProperty(b)||(e[b]=[],a.factory(b+\"Directive\",[\"$injector\",\"$exceptionHandler\",function(a,c){var d=[];q(e[b],function(e,g){try{var h=a.invoke(e);y(h)?h={compile:ma(h)}:!h.compile&&h.link&&(h.compile=ma(h.link));h.priority=h.priority||0;h.index=g;h.name=h.name||b;h.require=f(h);var k=h,l=h.restrict;if(l&&(!E(l)||!/[EACM]/.test(l)))throw ea(\"badrestrict\",l,b);k.restrict=\nl||\"EA\";h.$$moduleName=e.$$moduleName;d.push(h)}catch(m){c(m)}});return d}])),e[b].push(d)):q(b,Fc(U));return this};this.component=function(a,b){function c(a){function e(b){return y(b)||C(b)?function(c,d){return a.invoke(b,this,{$element:c,$attrs:d})}:b}var f=b.template||b.templateUrl?b.template:\"\",g={controller:d,controllerAs:lg(b.controller)||b.controllerAs||\"$ctrl\",template:e(f),templateUrl:e(b.templateUrl),transclude:b.transclude,scope:{},bindToController:b.bindings||{},restrict:\"E\",require:b.require};\nq(b,function(a,b){\"$\"===b.charAt(0)&&(g[b]=a)});return g}var d=b.controller||function(){};q(b,function(a,b){\"$\"===b.charAt(0)&&(c[b]=a,y(d)&&(d[b]=a))});c.$inject=[\"$injector\"];return this.directive(a,c)};this.aHrefSanitizationWhitelist=function(a){return v(a)?(b.aHrefSanitizationWhitelist(a),this):b.aHrefSanitizationWhitelist()};this.imgSrcSanitizationWhitelist=function(a){return v(a)?(b.imgSrcSanitizationWhitelist(a),this):b.imgSrcSanitizationWhitelist()};var p=!0;this.debugInfoEnabled=function(a){return v(a)?\n(p=a,this):p};var r=!1;this.preAssignBindingsEnabled=function(a){return v(a)?(r=a,this):r};var J=10;this.onChangesTtl=function(a){return arguments.length?(J=a,this):J};var O=!0;this.commentDirectivesEnabled=function(a){return arguments.length?(O=a,this):O};var u=!0;this.cssClassDirectivesEnabled=function(a){return arguments.length?(u=a,this):u};this.$get=[\"$injector\",\"$interpolate\",\"$exceptionHandler\",\"$templateRequest\",\"$parse\",\"$controller\",\"$rootScope\",\"$sce\",\"$animate\",\"$$sanitizeUri\",function(a,\nb,c,f,n,I,B,L,N,G){function T(){try{if(!--za)throw da=void 0,ea(\"infchng\",J);B.$apply(function(){for(var a=[],b=0,c=da.length;b<c;++b)try{da[b]()}catch(d){a.push(d)}da=void 0;if(a.length)throw a;})}finally{za++}}function s(a,b){if(b){var c=Object.keys(b),d,e,f;d=0;for(e=c.length;d<e;d++)f=c[d],this[f]=b[f]}else this.$attr={};this.$$element=a}function Q(a,b,c){ua.innerHTML=\"<span \"+b+\">\";b=ua.firstChild.attributes;var d=b[0];b.removeNamedItem(d.name);d.value=c;a.attributes.setNamedItem(d)}function Ma(a,\nb){try{a.addClass(b)}catch(c){}}function ba(a,b,c,d,e){a instanceof D||(a=D(a));var f=Na(a,b,a,c,d,e);ba.$$addScopeClass(a);var g=null;return function(b,c,d){if(!a)throw ea(\"multilink\");fb(b,\"scope\");e&&e.needsNewScope&&(b=b.$parent.$new());d=d||{};var h=d.parentBoundTranscludeFn,k=d.transcludeControllers;d=d.futureParentElement;h&&h.$$boundTransclude&&(h=h.$$boundTransclude);g||(g=(d=d&&d[0])?\"foreignobject\"!==xa(d)&&na.call(d).match(/SVG/)?\"svg\":\"html\":\"html\");d=\"html\"!==g?D(ha(g,D(\"<div>\").append(a).html())):\nc?Oa.clone.call(a):a;if(k)for(var l in k)d.data(\"$\"+l+\"Controller\",k[l].instance);ba.$$addScopeInfo(d,b);c&&c(d,b);f&&f(b,d,d,h);c||(a=f=null);return d}}function Na(a,b,c,d,e,f){function g(a,c,d,e){var f,k,l,m,n,p,r;if(K)for(r=Array(c.length),m=0;m<h.length;m+=3)f=h[m],r[f]=c[f];else r=c;m=0;for(n=h.length;m<n;)k=r[h[m++]],c=h[m++],f=h[m++],c?(c.scope?(l=a.$new(),ba.$$addScopeInfo(D(k),l)):l=a,p=c.transcludeOnThisElement?ja(a,c.transclude,e):!c.templateOnThisElement&&e?e:!e&&b?ja(a,b):null,c(f,l,\nk,d,p)):f&&f(a,k.childNodes,void 0,e)}for(var h=[],k=C(a)||a instanceof D,l,m,n,p,K,r=0;r<a.length;r++){l=new s;11===La&&M(a,r,k);m=fc(a[r],[],l,0===r?d:void 0,e);(f=m.length?X(m,a[r],l,b,c,null,[],[],f):null)&&f.scope&&ba.$$addScopeClass(l.$$element);l=f&&f.terminal||!(n=a[r].childNodes)||!n.length?null:Na(n,f?(f.transcludeOnThisElement||!f.templateOnThisElement)&&f.transclude:b);if(f||l)h.push(r,f,l),p=!0,K=K||f;f=null}return p?g:null}function M(a,b,c){var d=a[b],e=d.parentNode,f;if(d.nodeType===\nJa)for(;;){f=e?d.nextSibling:a[b+1];if(!f||f.nodeType!==Ja)break;d.nodeValue+=f.nodeValue;f.parentNode&&f.parentNode.removeChild(f);c&&f===a[b+1]&&a.splice(b+1,1)}}function ja(a,b,c){function d(e,f,g,h,k){e||(e=a.$new(!1,k),e.$$transcluded=!0);return b(e,f,{parentBoundTranscludeFn:c,transcludeControllers:g,futureParentElement:h})}var e=d.$$slots=W(),f;for(f in b.$$slots)e[f]=b.$$slots[f]?ja(a,b.$$slots[f],c):null;return d}function fc(a,b,c,d,e){var f=c.$attr,g;switch(a.nodeType){case 1:g=xa(a);Y(b,\nCa(g),\"E\",d,e);for(var k,l,m,n,p=a.attributes,K=0,r=p&&p.length;K<r;K++){var A=!1,B=!1;k=p[K];l=k.name;m=k.value;k=Ca(l);(n=Ha.test(k))&&(l=l.replace(gd,\"\").substr(8).replace(/_(.)/g,function(a,b){return b.toUpperCase()}));(k=k.match(Ka))&&Z(k[1])&&(A=l,B=l.substr(0,l.length-5)+\"end\",l=l.substr(0,l.length-6));k=Ca(l.toLowerCase());f[k]=l;if(n||!c.hasOwnProperty(k))c[k]=m,dd(a,k)&&(c[k]=!0);ra(a,b,m,k,n);Y(b,k,\"A\",d,e,A,B)}\"input\"===g&&\"hidden\"===a.getAttribute(\"type\")&&a.setAttribute(\"autocomplete\",\n\"off\");if(!Ga)break;f=a.className;F(f)&&(f=f.animVal);if(E(f)&&\"\"!==f)for(;a=h.exec(f);)k=Ca(a[2]),Y(b,k,\"C\",d,e)&&(c[k]=S(a[3])),f=f.substr(a.index+a[0].length);break;case Ja:ma(b,a.nodeValue);break;case 8:if(!Fa)break;kb(a,b,c,d,e)}b.sort(ka);return b}function kb(a,b,c,d,e){try{var f=g.exec(a.nodeValue);if(f){var h=Ca(f[1]);Y(b,h,\"M\",d,e)&&(c[h]=S(f[2]))}}catch(k){}}function hd(a,b,c){var d=[],e=0;if(b&&a.hasAttribute&&a.hasAttribute(b)){do{if(!a)throw ea(\"uterdir\",b,c);1===a.nodeType&&(a.hasAttribute(b)&&\ne++,a.hasAttribute(c)&&e--);d.push(a);a=a.nextSibling}while(0<e)}else d.push(a);return D(d)}function id(a,b,c){return function(d,e,f,g,h){e=hd(e[0],b,c);return a(d,e,f,g,h)}}function gc(a,b,c,d,e,f){var g;return a?ba(b,c,d,e,f):function(){g||(g=ba(b,c,d,e,f),b=c=f=null);return g.apply(this,arguments)}}function X(a,b,d,e,f,g,h,k,l){function m(a,b,c,d){if(a){c&&(a=id(a,c,d));a.require=t.require;a.directiveName=L;if(B===t||t.$$isolateScope)a=sa(a,{isolateScope:!0});h.push(a)}if(b){c&&(b=id(b,c,d));b.require=\nt.require;b.directiveName=L;if(B===t||t.$$isolateScope)b=sa(b,{isolateScope:!0});k.push(b)}}function n(a,e,f,g,l){function m(a,b,c,d){var e;Za(a)||(d=c,c=b,b=a,a=void 0);U&&(e=N);c||(c=U?L.parent():L);if(d){var f=l.$$slots[d];if(f)return f(a,b,e,c,Q);if(x(f))throw ea(\"noslot\",d,ya(L));}else return l(a,b,e,c,Q)}var p,t,u,G,J,N,T,L;b===f?(g=d,L=d.$$element):(L=D(f),g=new s(L,d));J=e;B?G=e.$new(!0):K&&(J=e.$parent);l&&(T=m,T.$$boundTransclude=l,T.isSlotFilled=function(a){return!!l.$$slots[a]});A&&(N=\nca(L,g,T,A,G,e,B));B&&(ba.$$addScopeInfo(L,G,!0,!(I&&(I===B||I===B.$$originalDirective))),ba.$$addScopeClass(L,!0),G.$$isolateBindings=B.$$isolateBindings,t=oa(e,g,G,G.$$isolateBindings,B),t.removeWatches&&G.$on(\"$destroy\",t.removeWatches));for(p in N){t=A[p];u=N[p];var Hb=t.$$bindings.bindToController;if(r){u.bindingInfo=Hb?oa(J,g,u.instance,Hb,t):{};var O=u();O!==u.instance&&(u.instance=O,L.data(\"$\"+t.name+\"Controller\",O),u.bindingInfo.removeWatches&&u.bindingInfo.removeWatches(),u.bindingInfo=\noa(J,g,u.instance,Hb,t))}else u.instance=u(),L.data(\"$\"+t.name+\"Controller\",u.instance),u.bindingInfo=oa(J,g,u.instance,Hb,t)}q(A,function(a,b){var c=a.require;a.bindToController&&!C(c)&&F(c)&&R(N[b].instance,V(b,c,L,N))});q(N,function(a){var b=a.instance;if(y(b.$onChanges))try{b.$onChanges(a.bindingInfo.initialChanges)}catch(d){c(d)}if(y(b.$onInit))try{b.$onInit()}catch(e){c(e)}y(b.$doCheck)&&(J.$watch(function(){b.$doCheck()}),b.$doCheck());y(b.$onDestroy)&&J.$on(\"$destroy\",function(){b.$onDestroy()})});\np=0;for(t=h.length;p<t;p++)u=h[p],ta(u,u.isolateScope?G:e,L,g,u.require&&V(u.directiveName,u.require,L,N),T);var Q=e;B&&(B.template||null===B.templateUrl)&&(Q=G);a&&a(Q,f.childNodes,void 0,l);for(p=k.length-1;0<=p;p--)u=k[p],ta(u,u.isolateScope?G:e,L,g,u.require&&V(u.directiveName,u.require,L,N),T);q(N,function(a){a=a.instance;y(a.$postLink)&&a.$postLink()})}l=l||{};for(var p=-Number.MAX_VALUE,K=l.newScopeDirective,A=l.controllerDirectives,B=l.newIsolateScopeDirective,I=l.templateDirective,u=l.nonTlbTranscludeDirective,\nJ=!1,N=!1,U=l.hasElementTranscludeDirective,G=d.$$element=D(b),t,L,T,O=e,Q,v=!1,Ma=!1,w,z=0,E=a.length;z<E;z++){t=a[z];var Na=t.$$start,M=t.$$end;Na&&(G=hd(b,Na,M));T=void 0;if(p>t.priority)break;if(w=t.scope)t.templateUrl||(F(w)?($(\"new/isolated scope\",B||K,t,G),B=t):$(\"new/isolated scope\",B,t,G)),K=K||t;L=t.name;if(!v&&(t.replace&&(t.templateUrl||t.template)||t.transclude&&!t.$$tlb)){for(w=z+1;v=a[w++];)if(v.transclude&&!v.$$tlb||v.replace&&(v.templateUrl||v.template)){Ma=!0;break}v=!0}!t.templateUrl&&\nt.controller&&(A=A||W(),$(\"'\"+L+\"' controller\",A[L],t,G),A[L]=t);if(w=t.transclude)if(J=!0,t.$$tlb||($(\"transclusion\",u,t,G),u=t),\"element\"===w)U=!0,p=t.priority,T=G,G=d.$$element=D(ba.$$createComment(L,d[L])),b=G[0],la(f,wa.call(T,0),b),T[0].$$parentNode=T[0].parentNode,O=gc(Ma,T,e,p,g&&g.name,{nonTlbTranscludeDirective:u});else{var ja=W();if(F(w)){T=[];var P=W(),kb=W();q(w,function(a,b){var c=\"?\"===a.charAt(0);a=c?a.substring(1):a;P[a]=b;ja[b]=null;kb[b]=c});q(G.contents(),function(a){var b=P[Ca(xa(a))];\nb?(kb[b]=!0,ja[b]=ja[b]||[],ja[b].push(a)):T.push(a)});q(kb,function(a,b){if(!a)throw ea(\"reqslot\",b);});for(var ec in ja)ja[ec]&&(ja[ec]=gc(Ma,ja[ec],e))}else T=D(cc(b)).contents();G.empty();O=gc(Ma,T,e,void 0,void 0,{needsNewScope:t.$$isolateScope||t.$$newScope});O.$$slots=ja}if(t.template)if(N=!0,$(\"template\",I,t,G),I=t,w=y(t.template)?t.template(G,d):t.template,w=Ea(w),t.replace){g=t;T=$b.test(w)?jd(ha(t.templateNamespace,S(w))):[];b=T[0];if(1!==T.length||1!==b.nodeType)throw ea(\"tplrt\",L,\"\");\nla(f,G,b);E={$attr:{}};w=fc(b,[],E);var Y=a.splice(z+1,a.length-(z+1));(B||K)&&aa(w,B,K);a=a.concat(w).concat(Y);fa(d,E);E=a.length}else G.html(w);if(t.templateUrl)N=!0,$(\"template\",I,t,G),I=t,t.replace&&(g=t),n=ga(a.splice(z,a.length-z),G,d,f,J&&O,h,k,{controllerDirectives:A,newScopeDirective:K!==t&&K,newIsolateScopeDirective:B,templateDirective:I,nonTlbTranscludeDirective:u}),E=a.length;else if(t.compile)try{Q=t.compile(G,d,O);var Z=t.$$originalDirective||t;y(Q)?m(null,bb(Z,Q),Na,M):Q&&m(bb(Z,Q.pre),\nbb(Z,Q.post),Na,M)}catch(da){c(da,ya(G))}t.terminal&&(n.terminal=!0,p=Math.max(p,t.priority))}n.scope=K&&!0===K.scope;n.transcludeOnThisElement=J;n.templateOnThisElement=N;n.transclude=O;l.hasElementTranscludeDirective=U;return n}function V(a,b,c,d){var e;if(E(b)){var f=b.match(l);b=b.substring(f[0].length);var g=f[1]||f[3],f=\"?\"===f[2];\"^^\"===g?c=c.parent():e=(e=d&&d[b])&&e.instance;if(!e){var h=\"$\"+b+\"Controller\";e=g?c.inheritedData(h):c.data(h)}if(!e&&!f)throw ea(\"ctreq\",b,a);}else if(C(b))for(e=\n[],g=0,f=b.length;g<f;g++)e[g]=V(a,b[g],c,d);else F(b)&&(e={},q(b,function(b,f){e[f]=V(a,b,c,d)}));return e||null}function ca(a,b,c,d,e,f,g){var h=W(),k;for(k in d){var l=d[k],m={$scope:l===g||l.$$isolateScope?e:f,$element:a,$attrs:b,$transclude:c},n=l.controller;\"@\"===n&&(n=b[l.name]);m=I(n,m,!0,l.controllerAs);h[l.name]=m;a.data(\"$\"+l.name+\"Controller\",m.instance)}return h}function aa(a,b,c){for(var d=0,e=a.length;d<e;d++)a[d]=Ub(a[d],{$$isolateScope:b,$$newScope:c})}function Y(b,c,f,g,h,k,l){if(c===\nh)return null;var m=null;if(e.hasOwnProperty(c)){h=a.get(c+\"Directive\");for(var n=0,p=h.length;n<p;n++)if(c=h[n],(x(g)||g>c.priority)&&-1!==c.restrict.indexOf(f)){k&&(c=Ub(c,{$$start:k,$$end:l}));if(!c.$$bindings){var K=m=c,r=c.name,A={isolateScope:null,bindToController:null};F(K.scope)&&(!0===K.bindToController?(A.bindToController=d(K.scope,r,!0),A.isolateScope={}):A.isolateScope=d(K.scope,r,!1));F(K.bindToController)&&(A.bindToController=d(K.bindToController,r,!0));if(A.bindToController&&!K.controller)throw ea(\"noctrl\",\nr);m=m.$$bindings=A;F(m.isolateScope)&&(c.$$isolateBindings=m.isolateScope)}b.push(c);m=c}}return m}function Z(b){if(e.hasOwnProperty(b))for(var c=a.get(b+\"Directive\"),d=0,f=c.length;d<f;d++)if(b=c[d],b.multiElement)return!0;return!1}function fa(a,b){var c=b.$attr,d=a.$attr;q(a,function(d,e){\"$\"!==e.charAt(0)&&(b[e]&&b[e]!==d&&(d=d.length?d+((\"style\"===e?\";\":\" \")+b[e]):b[e]),a.$set(e,d,!0,c[e]))});q(b,function(b,e){a.hasOwnProperty(e)||\"$\"===e.charAt(0)||(a[e]=b,\"class\"!==e&&\"style\"!==e&&(d[e]=c[e]))})}\nfunction ga(a,b,d,e,g,h,k,l){var m=[],n,p,K=b[0],r=a.shift(),u=Ub(r,{templateUrl:null,transclude:null,replace:null,$$originalDirective:r}),t=y(r.templateUrl)?r.templateUrl(b,d):r.templateUrl,B=r.templateNamespace;b.empty();f(t).then(function(c){var f,A;c=Ea(c);if(r.replace){c=$b.test(c)?jd(ha(B,S(c))):[];f=c[0];if(1!==c.length||1!==f.nodeType)throw ea(\"tplrt\",r.name,t);c={$attr:{}};la(e,b,f);var I=fc(f,[],c);F(r.scope)&&aa(I,!0);a=I.concat(a);fa(d,c)}else f=K,b.html(c);a.unshift(u);n=X(a,f,d,g,b,\nr,h,k,l);q(e,function(a,c){a===f&&(e[c]=b[0])});for(p=Na(b[0].childNodes,g);m.length;){c=m.shift();A=m.shift();var G=m.shift(),J=m.shift(),I=b[0];if(!c.$$destroyed){if(A!==K){var N=A.className;l.hasElementTranscludeDirective&&r.replace||(I=cc(f));la(G,D(A),I);Ma(D(I),N)}A=n.transcludeOnThisElement?ja(c,n.transclude,J):J;n(p,c,I,e,A)}}m=null}).catch(function(a){a instanceof Error&&c(a)}).catch(w);return function(a,b,c,d,e){a=e;b.$$destroyed||(m?m.push(b,c,d,a):(n.transcludeOnThisElement&&(a=ja(b,n.transclude,\ne)),n(p,b,c,d,a)))}}function ka(a,b){var c=b.priority-a.priority;return 0!==c?c:a.name!==b.name?a.name<b.name?-1:1:a.index-b.index}function $(a,b,c,d){function e(a){return a?\" (module: \"+a+\")\":\"\"}if(b)throw ea(\"multidir\",b.name,e(b.$$moduleName),c.name,e(c.$$moduleName),a,ya(d));}function ma(a,c){var d=b(c,!0);d&&a.push({priority:0,compile:function(a){a=a.parent();var b=!!a.length;b&&ba.$$addBindingClass(a);return function(a,c){var e=c.parent();b||ba.$$addBindingClass(e);ba.$$addBindingInfo(e,d.expressions);\na.$watch(d,function(a){c[0].nodeValue=a})}}})}function ha(a,b){a=P(a||\"html\");switch(a){case \"svg\":case \"math\":var c=z.document.createElement(\"div\");c.innerHTML=\"<\"+a+\">\"+b+\"</\"+a+\">\";return c.childNodes[0].childNodes;default:return b}}function pa(a,b){if(\"srcdoc\"===b)return L.HTML;var c=xa(a);if(\"src\"===b||\"ngSrc\"===b){if(-1===[\"img\",\"video\",\"audio\",\"source\",\"track\"].indexOf(c))return L.RESOURCE_URL}else if(\"xlinkHref\"===b||\"form\"===c&&\"action\"===b||\"link\"===c&&\"href\"===b)return L.RESOURCE_URL}function ra(a,\nc,d,e,f){var g=pa(a,e),h=k[e]||f,l=b(d,!f,g,h);if(l){if(\"multiple\"===e&&\"select\"===xa(a))throw ea(\"selmulti\",ya(a));if(m.test(e))throw ea(\"nodomevents\");c.push({priority:100,compile:function(){return{pre:function(a,c,f){c=f.$$observers||(f.$$observers=W());var k=f[e];k!==d&&(l=k&&b(k,!0,g,h),d=k);l&&(f[e]=l(a),(c[e]||(c[e]=[])).$$inter=!0,(f.$$observers&&f.$$observers[e].$$scope||a).$watch(l,function(a,b){\"class\"===e&&a!==b?f.$updateClass(a,b):f.$set(e,a)}))}}}})}}function la(a,b,c){var d=b[0],e=\nb.length,f=d.parentNode,g,h;if(a)for(g=0,h=a.length;g<h;g++)if(a[g]===d){a[g++]=c;h=g+e-1;for(var k=a.length;g<k;g++,h++)h<k?a[g]=a[h]:delete a[g];a.length-=e-1;a.context===d&&(a.context=c);break}f&&f.replaceChild(c,d);a=z.document.createDocumentFragment();for(g=0;g<e;g++)a.appendChild(b[g]);D.hasData(d)&&(D.data(c,D.data(d)),D(d).off(\"$destroy\"));D.cleanData(a.querySelectorAll(\"*\"));for(g=1;g<e;g++)delete b[g];b[0]=c;b.length=1}function sa(a,b){return R(function(){return a.apply(null,arguments)},\na,b)}function ta(a,b,d,e,f,g){try{a(b,d,e,f,g)}catch(h){c(h,ya(d))}}function oa(a,c,d,e,f){function g(b,c,e){!y(d.$onChanges)||c===e||c!==c&&e!==e||(da||(a.$$postDigest(T),da=[]),m||(m={},da.push(h)),m[b]&&(e=m[b].previousValue),m[b]=new Ib(e,c))}function h(){d.$onChanges(m);m=void 0}var k=[],l={},m;q(e,function(e,h){var m=e.attrName,p=e.optional,r,A,u,B;switch(e.mode){case \"@\":p||va.call(c,m)||(d[h]=c[m]=void 0);p=c.$observe(m,function(a){if(E(a)||Ia(a))g(h,a,d[h]),d[h]=a});c.$$observers[m].$$scope=\na;r=c[m];E(r)?d[h]=b(r)(a):Ia(r)&&(d[h]=r);l[h]=new Ib(hc,d[h]);k.push(p);break;case \"=\":if(!va.call(c,m)){if(p)break;c[m]=void 0}if(p&&!c[m])break;A=n(c[m]);B=A.literal?qa:function(a,b){return a===b||a!==a&&b!==b};u=A.assign||function(){r=d[h]=A(a);throw ea(\"nonassign\",c[m],m,f.name);};r=d[h]=A(a);p=function(b){B(b,d[h])||(B(b,r)?u(a,b=d[h]):d[h]=b);return r=b};p.$stateful=!0;p=e.collection?a.$watchCollection(c[m],p):a.$watch(n(c[m],p),null,A.literal);k.push(p);break;case \"<\":if(!va.call(c,m)){if(p)break;\nc[m]=void 0}if(p&&!c[m])break;A=n(c[m]);var I=A.literal,G=d[h]=A(a);l[h]=new Ib(hc,d[h]);p=a.$watch(A,function(a,b){if(b===a){if(b===G||I&&qa(b,G))return;b=G}g(h,a,b);d[h]=a},I);k.push(p);break;case \"&\":A=c.hasOwnProperty(m)?n(c[m]):w;if(A===w&&p)break;d[h]=function(b){return A(a,b)}}});return{initialChanges:l,removeWatches:k.length&&function(){for(var a=0,b=k.length;a<b;++a)k[a]()}}}var Da=/^\\w/,ua=z.document.createElement(\"div\"),Fa=O,Ga=u,za=J,da;s.prototype={$normalize:Ca,$addClass:function(a){a&&\n0<a.length&&N.addClass(this.$$element,a)},$removeClass:function(a){a&&0<a.length&&N.removeClass(this.$$element,a)},$updateClass:function(a,b){var c=kd(a,b);c&&c.length&&N.addClass(this.$$element,c);(c=kd(b,a))&&c.length&&N.removeClass(this.$$element,c)},$set:function(a,b,d,e){var f=dd(this.$$element[0],a),g=ld[a],h=a;f?(this.$$element.prop(a,b),e=f):g&&(this[g]=b,h=g);this[a]=b;e?this.$attr[a]=e:(e=this.$attr[a])||(this.$attr[a]=e=Nc(a,\"-\"));f=xa(this.$$element);if(\"a\"===f&&(\"href\"===a||\"xlinkHref\"===\na)||\"img\"===f&&\"src\"===a)this[a]=b=G(b,\"src\"===a);else if(\"img\"===f&&\"srcset\"===a&&v(b)){for(var f=\"\",g=S(b),k=/(\\s+\\d+x\\s*,|\\s+\\d+w\\s*,|\\s+,|,\\s+)/,k=/\\s/.test(g)?k:/(,)/,g=g.split(k),k=Math.floor(g.length/2),l=0;l<k;l++)var m=2*l,f=f+G(S(g[m]),!0),f=f+(\" \"+S(g[m+1]));g=S(g[2*l]).split(/\\s/);f+=G(S(g[0]),!0);2===g.length&&(f+=\" \"+S(g[1]));this[a]=b=f}!1!==d&&(null===b||x(b)?this.$$element.removeAttr(e):Da.test(e)?this.$$element.attr(e,b):Q(this.$$element[0],e,b));(a=this.$$observers)&&q(a[h],function(a){try{a(b)}catch(d){c(d)}})},\n$observe:function(a,b){var c=this,d=c.$$observers||(c.$$observers=W()),e=d[a]||(d[a]=[]);e.push(b);B.$evalAsync(function(){e.$$inter||!c.hasOwnProperty(a)||x(c[a])||b(c[a])});return function(){$a(e,b)}}};var Aa=b.startSymbol(),Ba=b.endSymbol(),Ea=\"{{\"===Aa&&\"}}\"===Ba?Ya:function(a){return a.replace(/\\{\\{/g,Aa).replace(/}}/g,Ba)},Ha=/^ngAttr[A-Z]/,Ka=/^(.+)Start$/;ba.$$addBindingInfo=p?function(a,b){var c=a.data(\"$binding\")||[];C(b)?c=c.concat(b):c.push(b);a.data(\"$binding\",c)}:w;ba.$$addBindingClass=\np?function(a){Ma(a,\"ng-binding\")}:w;ba.$$addScopeInfo=p?function(a,b,c,d){a.data(c?d?\"$isolateScopeNoTemplate\":\"$isolateScope\":\"$scope\",b)}:w;ba.$$addScopeClass=p?function(a,b){Ma(a,b?\"ng-isolate-scope\":\"ng-scope\")}:w;ba.$$createComment=function(a,b){var c=\"\";p&&(c=\" \"+(a||\"\")+\": \",b&&(c+=b+\" \"));return z.document.createComment(c)};return ba}]}function Ib(a,b){this.previousValue=a;this.currentValue=b}function Ca(a){return a.replace(gd,\"\").replace(mg,gb)}function kd(a,b){var d=\"\",c=a.split(/\\s+/),\nf=b.split(/\\s+/),e=0;a:for(;e<c.length;e++){for(var g=c[e],h=0;h<f.length;h++)if(g===f[h])continue a;d+=(0<d.length?\" \":\"\")+g}return d}function jd(a){a=D(a);var b=a.length;if(1>=b)return a;for(;b--;){var d=a[b];(8===d.nodeType||d.nodeType===Ja&&\"\"===d.nodeValue.trim())&&ng.call(a,b,1)}return a}function lg(a,b){if(b&&E(b))return b;if(E(a)){var d=md.exec(a);if(d)return d[3]}}function rf(){var a={},b=!1;this.has=function(b){return a.hasOwnProperty(b)};this.register=function(b,c){Pa(b,\"controller\");F(b)?\nR(a,b):a[b]=c};this.allowGlobals=function(){b=!0};this.$get=[\"$injector\",\"$window\",function(d,c){function f(a,b,c,d){if(!a||!F(a.$scope))throw M(\"$controller\")(\"noscp\",d,b);a.$scope[b]=c}return function(e,g,h,k){var l,m,n;h=!0===h;k&&E(k)&&(n=k);if(E(e)){k=e.match(md);if(!k)throw nd(\"ctrlfmt\",e);m=k[1];n=n||k[3];e=a.hasOwnProperty(m)?a[m]:Pc(g.$scope,m,!0)||(b?Pc(c,m,!0):void 0);if(!e)throw nd(\"ctrlreg\",m);tb(e,m,!0)}if(h)return h=(C(e)?e[e.length-1]:e).prototype,l=Object.create(h||null),n&&f(g,n,\nl,m||e.name),R(function(){var a=d.invoke(e,l,g,m);a!==l&&(F(a)||y(a))&&(l=a,n&&f(g,n,l,m||e.name));return l},{instance:l,identifier:n});l=d.instantiate(e,g,m);n&&f(g,n,l,m||e.name);return l}}]}function sf(){this.$get=[\"$window\",function(a){return D(a.document)}]}function tf(){this.$get=[\"$document\",\"$rootScope\",function(a,b){function d(){f=c.hidden}var c=a[0],f=c&&c.hidden;a.on(\"visibilitychange\",d);b.$on(\"$destroy\",function(){a.off(\"visibilitychange\",d)});return function(){return f}}]}function uf(){this.$get=\n[\"$log\",function(a){return function(b,d){a.error.apply(a,arguments)}}]}function ic(a){return F(a)?fa(a)?a.toISOString():cb(a):a}function zf(){this.$get=function(){return function(a){if(!a)return\"\";var b=[];Ec(a,function(a,c){null===a||x(a)||(C(a)?q(a,function(a){b.push(ka(c)+\"=\"+ka(ic(a)))}):b.push(ka(c)+\"=\"+ka(ic(a))))});return b.join(\"&\")}}}function Af(){this.$get=function(){return function(a){function b(a,f,e){null===a||x(a)||(C(a)?q(a,function(a,c){b(a,f+\"[\"+(F(a)?c:\"\")+\"]\")}):F(a)&&!fa(a)?Ec(a,\nfunction(a,c){b(a,f+(e?\"\":\"[\")+c+(e?\"\":\"]\"))}):d.push(ka(f)+\"=\"+ka(ic(a))))}if(!a)return\"\";var d=[];b(a,\"\",!0);return d.join(\"&\")}}}function jc(a,b){if(E(a)){var d=a.replace(og,\"\").trim();if(d){var c=b(\"Content-Type\");(c=c&&0===c.indexOf(od))||(c=(c=d.match(pg))&&qg[c[0]].test(d));c&&(a=Ic(d))}}return a}function pd(a){var b=W(),d;E(a)?q(a.split(\"\\n\"),function(a){d=a.indexOf(\":\");var f=P(S(a.substr(0,d)));a=S(a.substr(d+1));f&&(b[f]=b[f]?b[f]+\", \"+a:a)}):F(a)&&q(a,function(a,d){var e=P(d),g=S(a);e&&\n(b[e]=b[e]?b[e]+\", \"+g:g)});return b}function qd(a){var b;return function(d){b||(b=pd(a));return d?(d=b[P(d)],void 0===d&&(d=null),d):b}}function rd(a,b,d,c){if(y(c))return c(a,b,d);q(c,function(c){a=c(a,b,d)});return a}function yf(){var a=this.defaults={transformResponse:[jc],transformRequest:[function(a){return F(a)&&\"[object File]\"!==na.call(a)&&\"[object Blob]\"!==na.call(a)&&\"[object FormData]\"!==na.call(a)?cb(a):a}],headers:{common:{Accept:\"application/json, text/plain, */*\"},post:ra(kc),put:ra(kc),\npatch:ra(kc)},xsrfCookieName:\"XSRF-TOKEN\",xsrfHeaderName:\"X-XSRF-TOKEN\",paramSerializer:\"$httpParamSerializer\",jsonpCallbackParam:\"callback\"},b=!1;this.useApplyAsync=function(a){return v(a)?(b=!!a,this):b};var d=this.interceptors=[];this.$get=[\"$browser\",\"$httpBackend\",\"$$cookieReader\",\"$cacheFactory\",\"$rootScope\",\"$q\",\"$injector\",\"$sce\",function(c,f,e,g,h,k,l,m){function n(b){function d(a,b){for(var c=0,e=b.length;c<e;){var f=b[c++],g=b[c++];a=a.then(f,g)}b.length=0;return a}function e(a,b){var c,\nd={};q(a,function(a,e){y(a)?(c=a(b),null!=c&&(d[e]=c)):d[e]=a});return d}function f(a){var b=R({},a);b.data=rd(a.data,a.headers,a.status,g.transformResponse);a=a.status;return 200<=a&&300>a?b:k.reject(b)}if(!F(b))throw M(\"$http\")(\"badreq\",b);if(!E(m.valueOf(b.url)))throw M(\"$http\")(\"badreq\",b.url);var g=R({method:\"get\",transformRequest:a.transformRequest,transformResponse:a.transformResponse,paramSerializer:a.paramSerializer,jsonpCallbackParam:a.jsonpCallbackParam},b);g.headers=function(b){var c=\na.headers,d=R({},b.headers),f,g,h,c=R({},c.common,c[P(b.method)]);a:for(f in c){g=P(f);for(h in d)if(P(h)===g)continue a;d[f]=c[f]}return e(d,ra(b))}(b);g.method=vb(g.method);g.paramSerializer=E(g.paramSerializer)?l.get(g.paramSerializer):g.paramSerializer;c.$$incOutstandingRequestCount();var h=[],n=[];b=k.resolve(g);q(u,function(a){(a.request||a.requestError)&&h.unshift(a.request,a.requestError);(a.response||a.responseError)&&n.push(a.response,a.responseError)});b=d(b,h);b=b.then(function(b){var c=\nb.headers,d=rd(b.data,qd(c),void 0,b.transformRequest);x(d)&&q(c,function(a,b){\"content-type\"===P(b)&&delete c[b]});x(b.withCredentials)&&!x(a.withCredentials)&&(b.withCredentials=a.withCredentials);return p(b,d).then(f,f)});b=d(b,n);return b=b.finally(function(){c.$$completeOutstandingRequest(w)})}function p(c,d){function g(a){if(a){var c={};q(a,function(a,d){c[d]=function(c){function d(){a(c)}b?h.$applyAsync(d):h.$$phase?d():h.$apply(d)}});return c}}function l(a,c,d,e){function f(){p(c,a,d,e)}N&&\n(200<=a&&300>a?N.put(Q,[a,c,pd(d),e]):N.remove(Q));b?h.$applyAsync(f):(f(),h.$$phase||h.$apply())}function p(a,b,d,e){b=-1<=b?b:0;(200<=b&&300>b?B.resolve:B.reject)({data:a,status:b,headers:qd(d),config:c,statusText:e})}function K(a){p(a.data,a.status,ra(a.headers()),a.statusText)}function u(){var a=n.pendingRequests.indexOf(c);-1!==a&&n.pendingRequests.splice(a,1)}var B=k.defer(),L=B.promise,N,G,T=c.headers,s=\"jsonp\"===P(c.method),Q=c.url;s?Q=m.getTrustedResourceUrl(Q):E(Q)||(Q=m.valueOf(Q));Q=r(Q,\nc.paramSerializer(c.params));s&&(Q=J(Q,c.jsonpCallbackParam));n.pendingRequests.push(c);L.then(u,u);!c.cache&&!a.cache||!1===c.cache||\"GET\"!==c.method&&\"JSONP\"!==c.method||(N=F(c.cache)?c.cache:F(a.cache)?a.cache:O);N&&(G=N.get(Q),v(G)?G&&y(G.then)?G.then(K,K):C(G)?p(G[1],G[0],ra(G[2]),G[3]):p(G,200,{},\"OK\"):N.put(Q,L));x(G)&&((G=sd(c.url)?e()[c.xsrfCookieName||a.xsrfCookieName]:void 0)&&(T[c.xsrfHeaderName||a.xsrfHeaderName]=G),f(c.method,Q,d,l,T,c.timeout,c.withCredentials,c.responseType,g(c.eventHandlers),\ng(c.uploadEventHandlers)));return L}function r(a,b){0<b.length&&(a+=(-1===a.indexOf(\"?\")?\"?\":\"&\")+b);return a}function J(a,b){if(/[&?][^=]+=JSON_CALLBACK/.test(a))throw td(\"badjsonp\",a);if((new RegExp(\"[&?]\"+b+\"=\")).test(a))throw td(\"badjsonp\",b,a);return a+=(-1===a.indexOf(\"?\")?\"?\":\"&\")+b+\"=JSON_CALLBACK\"}var O=g(\"$http\");a.paramSerializer=E(a.paramSerializer)?l.get(a.paramSerializer):a.paramSerializer;var u=[];q(d,function(a){u.unshift(E(a)?l.get(a):l.invoke(a))});n.pendingRequests=[];(function(a){q(arguments,\nfunction(a){n[a]=function(b,c){return n(R({},c||{},{method:a,url:b}))}})})(\"get\",\"delete\",\"head\",\"jsonp\");(function(a){q(arguments,function(a){n[a]=function(b,c,d){return n(R({},d||{},{method:a,url:b,data:c}))}})})(\"post\",\"put\",\"patch\");n.defaults=a;return n}]}function Cf(){this.$get=function(){return function(){return new z.XMLHttpRequest}}}function Bf(){this.$get=[\"$browser\",\"$jsonpCallbacks\",\"$document\",\"$xhrFactory\",function(a,b,d,c){return rg(a,c,a.defer,b,d[0])}]}function rg(a,b,d,c,f){function e(a,\nb,d){a=a.replace(\"JSON_CALLBACK\",b);var e=f.createElement(\"script\"),m=null;e.type=\"text/javascript\";e.src=a;e.async=!0;m=function(a){e.removeEventListener(\"load\",m);e.removeEventListener(\"error\",m);f.body.removeChild(e);e=null;var g=-1,r=\"unknown\";a&&(\"load\"!==a.type||c.wasCalled(b)||(a={type:\"error\"}),r=a.type,g=\"error\"===a.type?404:200);d&&d(g,r)};e.addEventListener(\"load\",m);e.addEventListener(\"error\",m);f.body.appendChild(e);return m}return function(f,h,k,l,m,n,p,r,J,O){function u(){U&&U();t&&\nt.abort()}h=h||a.url();if(\"jsonp\"===P(f))var H=c.createCallback(h),U=e(h,H,function(a,b){var e=200===a&&c.getResponse(H);v(A)&&d.cancel(A);U=t=null;l(a,e,\"\",b);c.removeCallback(H)});else{var t=b(f,h);t.open(f,h,!0);q(m,function(a,b){v(a)&&t.setRequestHeader(b,a)});t.onload=function(){var a=t.statusText||\"\",b=\"response\"in t?t.response:t.responseText,c=1223===t.status?204:t.status;0===c&&(c=b?200:\"file\"===Da(h).protocol?404:0);var e=t.getAllResponseHeaders();v(A)&&d.cancel(A);U=t=null;l(c,b,e,a)};f=\nfunction(){v(A)&&d.cancel(A);U=t=null;l(-1,null,null,\"\")};t.onerror=f;t.onabort=f;t.ontimeout=f;q(J,function(a,b){t.addEventListener(b,a)});q(O,function(a,b){t.upload.addEventListener(b,a)});p&&(t.withCredentials=!0);if(r)try{t.responseType=r}catch(s){if(\"json\"!==r)throw s;}t.send(x(k)?null:k)}if(0<n)var A=d(u,n);else n&&y(n.then)&&n.then(u)}}function wf(){var a=\"{{\",b=\"}}\";this.startSymbol=function(b){return b?(a=b,this):a};this.endSymbol=function(a){return a?(b=a,this):b};this.$get=[\"$parse\",\"$exceptionHandler\",\n\"$sce\",function(d,c,f){function e(a){return\"\\\\\\\\\\\\\"+a}function g(c){return c.replace(n,a).replace(p,b)}function h(a,b,c,d){var e=a.$watch(function(a){e();return d(a)},b,c);return e}function k(e,k,n,p){function H(a){try{var b=a;a=n?f.getTrusted(n,b):f.valueOf(b);return p&&!v(a)?a:Yb(a)}catch(d){c(Ea.interr(e,d))}}if(!e.length||-1===e.indexOf(a)){var q;k||(k=g(e),q=ma(k),q.exp=e,q.expressions=[],q.$$watchDelegate=h);return q}p=!!p;var t,s,A=0,K=[],I=[];q=e.length;for(var B=[],L=[];A<q;)if(-1!==(t=e.indexOf(a,\nA))&&-1!==(s=e.indexOf(b,t+l)))A!==t&&B.push(g(e.substring(A,t))),A=e.substring(t+l,s),K.push(A),I.push(d(A,H)),A=s+m,L.push(B.length),B.push(\"\");else{A!==q&&B.push(g(e.substring(A)));break}n&&1<B.length&&Ea.throwNoconcat(e);if(!k||K.length){var N=function(a){for(var b=0,c=K.length;b<c;b++){if(p&&x(a[b]))return;B[L[b]]=a[b]}return B.join(\"\")};return R(function(a){var b=0,d=K.length,f=Array(d);try{for(;b<d;b++)f[b]=I[b](a);return N(f)}catch(g){c(Ea.interr(e,g))}},{exp:e,expressions:K,$$watchDelegate:function(a,\nb){var c;return a.$watchGroup(I,function(d,e){var f=N(d);y(b)&&b.call(this,f,d!==e?c:f,a);c=f})}})}}var l=a.length,m=b.length,n=new RegExp(a.replace(/./g,e),\"g\"),p=new RegExp(b.replace(/./g,e),\"g\");k.startSymbol=function(){return a};k.endSymbol=function(){return b};return k}]}function xf(){this.$get=[\"$rootScope\",\"$window\",\"$q\",\"$$q\",\"$browser\",function(a,b,d,c,f){function e(e,k,l,m){function n(){p?e.apply(null,r):e(u)}var p=4<arguments.length,r=p?wa.call(arguments,4):[],J=b.setInterval,q=b.clearInterval,\nu=0,H=v(m)&&!m,U=(H?c:d).defer(),t=U.promise;l=v(l)?l:0;t.$$intervalId=J(function(){H?f.defer(n):a.$evalAsync(n);U.notify(u++);0<l&&u>=l&&(U.resolve(u),q(t.$$intervalId),delete g[t.$$intervalId]);H||a.$apply()},k);g[t.$$intervalId]=U;return t}var g={};e.cancel=function(a){return a&&a.$$intervalId in g?(g[a.$$intervalId].promise.catch(w),g[a.$$intervalId].reject(\"canceled\"),b.clearInterval(a.$$intervalId),delete g[a.$$intervalId],!0):!1};return e}]}function lc(a){a=a.split(\"/\");for(var b=a.length;b--;)a[b]=\ndb(a[b]);return a.join(\"/\")}function ud(a,b){var d=Da(a);b.$$protocol=d.protocol;b.$$host=d.hostname;b.$$port=Z(d.port)||sg[d.protocol]||null}function vd(a,b){if(tg.test(a))throw lb(\"badpath\",a);var d=\"/\"!==a.charAt(0);d&&(a=\"/\"+a);var c=Da(a);b.$$path=decodeURIComponent(d&&\"/\"===c.pathname.charAt(0)?c.pathname.substring(1):c.pathname);b.$$search=Lc(c.search);b.$$hash=decodeURIComponent(c.hash);b.$$path&&\"/\"!==b.$$path.charAt(0)&&(b.$$path=\"/\"+b.$$path)}function mc(a,b){return a.slice(0,b.length)===\nb}function sa(a,b){if(mc(b,a))return b.substr(a.length)}function Ba(a){var b=a.indexOf(\"#\");return-1===b?a:a.substr(0,b)}function mb(a){return a.replace(/(#.+)|#$/,\"$1\")}function nc(a,b,d){this.$$html5=!0;d=d||\"\";ud(a,this);this.$$parse=function(a){var d=sa(b,a);if(!E(d))throw lb(\"ipthprfx\",a,b);vd(d,this);this.$$path||(this.$$path=\"/\");this.$$compose()};this.$$compose=function(){var a=Xb(this.$$search),d=this.$$hash?\"#\"+db(this.$$hash):\"\";this.$$url=lc(this.$$path)+(a?\"?\"+a:\"\")+d;this.$$absUrl=b+\nthis.$$url.substr(1)};this.$$parseLinkUrl=function(c,f){if(f&&\"#\"===f[0])return this.hash(f.slice(1)),!0;var e,g;v(e=sa(a,c))?(g=e,g=d&&v(e=sa(d,e))?b+(sa(\"/\",e)||e):a+g):v(e=sa(b,c))?g=b+e:b===c+\"/\"&&(g=b);g&&this.$$parse(g);return!!g}}function oc(a,b,d){ud(a,this);this.$$parse=function(c){var f=sa(a,c)||sa(b,c),e;x(f)||\"#\"!==f.charAt(0)?this.$$html5?e=f:(e=\"\",x(f)&&(a=c,this.replace())):(e=sa(d,f),x(e)&&(e=f));vd(e,this);c=this.$$path;var f=a,g=/^\\/[A-Z]:(\\/.*)/;mc(e,f)&&(e=e.replace(f,\"\"));g.exec(e)||\n(c=(e=g.exec(c))?e[1]:c);this.$$path=c;this.$$compose()};this.$$compose=function(){var b=Xb(this.$$search),f=this.$$hash?\"#\"+db(this.$$hash):\"\";this.$$url=lc(this.$$path)+(b?\"?\"+b:\"\")+f;this.$$absUrl=a+(this.$$url?d+this.$$url:\"\")};this.$$parseLinkUrl=function(b,d){return Ba(a)===Ba(b)?(this.$$parse(b),!0):!1}}function wd(a,b,d){this.$$html5=!0;oc.apply(this,arguments);this.$$parseLinkUrl=function(c,f){if(f&&\"#\"===f[0])return this.hash(f.slice(1)),!0;var e,g;a===Ba(c)?e=c:(g=sa(b,c))?e=a+d+g:b===\nc+\"/\"&&(e=b);e&&this.$$parse(e);return!!e};this.$$compose=function(){var b=Xb(this.$$search),f=this.$$hash?\"#\"+db(this.$$hash):\"\";this.$$url=lc(this.$$path)+(b?\"?\"+b:\"\")+f;this.$$absUrl=a+d+this.$$url}}function Jb(a){return function(){return this[a]}}function xd(a,b){return function(d){if(x(d))return this[a];this[a]=b(d);this.$$compose();return this}}function Ef(){var a=\"!\",b={enabled:!1,requireBase:!0,rewriteLinks:!0};this.hashPrefix=function(b){return v(b)?(a=b,this):a};this.html5Mode=function(a){if(Ia(a))return b.enabled=\na,this;if(F(a)){Ia(a.enabled)&&(b.enabled=a.enabled);Ia(a.requireBase)&&(b.requireBase=a.requireBase);if(Ia(a.rewriteLinks)||E(a.rewriteLinks))b.rewriteLinks=a.rewriteLinks;return this}return b};this.$get=[\"$rootScope\",\"$browser\",\"$sniffer\",\"$rootElement\",\"$window\",function(d,c,f,e,g){function h(a,b,d){var e=l.url(),f=l.$$state;try{c.url(a,b,d),l.$$state=c.state()}catch(g){throw l.url(e),l.$$state=f,g;}}function k(a,b){d.$broadcast(\"$locationChangeSuccess\",l.absUrl(),a,l.$$state,b)}var l,m;m=c.baseHref();\nvar n=c.url(),p;if(b.enabled){if(!m&&b.requireBase)throw lb(\"nobase\");p=n.substring(0,n.indexOf(\"/\",n.indexOf(\"//\")+2))+(m||\"/\");m=f.history?nc:wd}else p=Ba(n),m=oc;var r=p.substr(0,Ba(p).lastIndexOf(\"/\")+1);l=new m(p,r,\"#\"+a);l.$$parseLinkUrl(n,n);l.$$state=c.state();var J=/^\\s*(javascript|mailto):/i;e.on(\"click\",function(a){var f=b.rewriteLinks;if(f&&!a.ctrlKey&&!a.metaKey&&!a.shiftKey&&2!==a.which&&2!==a.button){for(var h=D(a.target);\"a\"!==xa(h[0]);)if(h[0]===e[0]||!(h=h.parent())[0])return;if(!E(f)||\n!x(h.attr(f))){var f=h.prop(\"href\"),k=h.attr(\"href\")||h.attr(\"xlink:href\");F(f)&&\"[object SVGAnimatedString]\"===f.toString()&&(f=Da(f.animVal).href);J.test(f)||!f||h.attr(\"target\")||a.isDefaultPrevented()||!l.$$parseLinkUrl(f,k)||(a.preventDefault(),l.absUrl()!==c.url()&&(d.$apply(),g.angular[\"ff-684208-preventDefault\"]=!0))}}});mb(l.absUrl())!==mb(n)&&c.url(l.absUrl(),!0);var q=!0;c.onUrlChange(function(a,b){mc(a,r)?(d.$evalAsync(function(){var c=l.absUrl(),e=l.$$state,f;a=mb(a);l.$$parse(a);l.$$state=\nb;f=d.$broadcast(\"$locationChangeStart\",a,c,b,e).defaultPrevented;l.absUrl()===a&&(f?(l.$$parse(c),l.$$state=e,h(c,!1,e)):(q=!1,k(c,e)))}),d.$$phase||d.$digest()):g.location.href=a});d.$watch(function(){var a=mb(c.url()),b=mb(l.absUrl()),e=c.state(),g=l.$$replace,m=a!==b||l.$$html5&&f.history&&e!==l.$$state;if(q||m)q=!1,d.$evalAsync(function(){var b=l.absUrl(),c=d.$broadcast(\"$locationChangeStart\",b,a,l.$$state,e).defaultPrevented;l.absUrl()===b&&(c?(l.$$parse(a),l.$$state=e):(m&&h(b,g,e===l.$$state?\nnull:l.$$state),k(a,e)))});l.$$replace=!1});return l}]}function Ff(){var a=!0,b=this;this.debugEnabled=function(b){return v(b)?(a=b,this):a};this.$get=[\"$window\",function(d){function c(a){a instanceof Error&&(a.stack?a=a.message&&-1===a.stack.indexOf(a.message)?\"Error: \"+a.message+\"\\n\"+a.stack:a.stack:a.sourceURL&&(a=a.message+\"\\n\"+a.sourceURL+\":\"+a.line));return a}function f(a){var b=d.console||{},f=b[a]||b.log||w;a=!1;try{a=!!f.apply}catch(k){}return a?function(){var a=[];q(arguments,function(b){a.push(c(b))});\nreturn f.apply(b,a)}:function(a,b){f(a,null==b?\"\":b)}}return{log:f(\"log\"),info:f(\"info\"),warn:f(\"warn\"),error:f(\"error\"),debug:function(){var c=f(\"debug\");return function(){a&&c.apply(b,arguments)}}()}}]}function ug(a){return a+\"\"}function vg(a,b){return\"undefined\"!==typeof a?a:b}function yd(a,b){return\"undefined\"===typeof a?b:\"undefined\"===typeof b?a:a+b}function V(a,b){var d,c,f;switch(a.type){case s.Program:d=!0;q(a.body,function(a){V(a.expression,b);d=d&&a.expression.constant});a.constant=d;break;\ncase s.Literal:a.constant=!0;a.toWatch=[];break;case s.UnaryExpression:V(a.argument,b);a.constant=a.argument.constant;a.toWatch=a.argument.toWatch;break;case s.BinaryExpression:V(a.left,b);V(a.right,b);a.constant=a.left.constant&&a.right.constant;a.toWatch=a.left.toWatch.concat(a.right.toWatch);break;case s.LogicalExpression:V(a.left,b);V(a.right,b);a.constant=a.left.constant&&a.right.constant;a.toWatch=a.constant?[]:[a];break;case s.ConditionalExpression:V(a.test,b);V(a.alternate,b);V(a.consequent,\nb);a.constant=a.test.constant&&a.alternate.constant&&a.consequent.constant;a.toWatch=a.constant?[]:[a];break;case s.Identifier:a.constant=!1;a.toWatch=[a];break;case s.MemberExpression:V(a.object,b);a.computed&&V(a.property,b);a.constant=a.object.constant&&(!a.computed||a.property.constant);a.toWatch=[a];break;case s.CallExpression:d=f=a.filter?!b(a.callee.name).$stateful:!1;c=[];q(a.arguments,function(a){V(a,b);d=d&&a.constant;a.constant||c.push.apply(c,a.toWatch)});a.constant=d;a.toWatch=f?c:[a];\nbreak;case s.AssignmentExpression:V(a.left,b);V(a.right,b);a.constant=a.left.constant&&a.right.constant;a.toWatch=[a];break;case s.ArrayExpression:d=!0;c=[];q(a.elements,function(a){V(a,b);d=d&&a.constant;a.constant||c.push.apply(c,a.toWatch)});a.constant=d;a.toWatch=c;break;case s.ObjectExpression:d=!0;c=[];q(a.properties,function(a){V(a.value,b);d=d&&a.value.constant&&!a.computed;a.value.constant||c.push.apply(c,a.value.toWatch)});a.constant=d;a.toWatch=c;break;case s.ThisExpression:a.constant=\n!1;a.toWatch=[];break;case s.LocalsExpression:a.constant=!1,a.toWatch=[]}}function zd(a){if(1===a.length){a=a[0].expression;var b=a.toWatch;return 1!==b.length?b:b[0]!==a?b:void 0}}function Ad(a){return a.type===s.Identifier||a.type===s.MemberExpression}function Bd(a){if(1===a.body.length&&Ad(a.body[0].expression))return{type:s.AssignmentExpression,left:a.body[0].expression,right:{type:s.NGValueParameter},operator:\"=\"}}function Cd(a){return 0===a.body.length||1===a.body.length&&(a.body[0].expression.type===\ns.Literal||a.body[0].expression.type===s.ArrayExpression||a.body[0].expression.type===s.ObjectExpression)}function Dd(a,b){this.astBuilder=a;this.$filter=b}function Ed(a,b){this.astBuilder=a;this.$filter=b}function pc(a){return y(a.valueOf)?a.valueOf():wg.call(a)}function Gf(){var a=W(),b={\"true\":!0,\"false\":!1,\"null\":null,undefined:void 0},d,c;this.addLiteral=function(a,c){b[a]=c};this.setIdentifierFns=function(a,b){d=a;c=b;return this};this.$get=[\"$filter\",function(f){function e(a,b){return null==\na||null==b?a===b:\"object\"===typeof a&&(a=pc(a),\"object\"===typeof a)?!1:a===b||a!==a&&b!==b}function g(a,b,c,d,f){var g=d.inputs,h;if(1===g.length){var k=e,g=g[0];return a.$watch(function(a){var b=g(a);e(b,k)||(h=d(a,void 0,void 0,[b]),k=b&&pc(b));return h},b,c,f)}for(var l=[],m=[],n=0,I=g.length;n<I;n++)l[n]=e,m[n]=null;return a.$watch(function(a){for(var b=!1,c=0,f=g.length;c<f;c++){var k=g[c](a);if(b||(b=!e(k,l[c])))m[c]=k,l[c]=k&&pc(k)}b&&(h=d(a,void 0,void 0,m));return h},b,c,f)}function h(a,\nb,c,d,e){function f(a){return d(a)}function h(a,c,d){l=a;y(b)&&b(a,c,d);v(a)&&d.$$postDigest(function(){v(l)&&k()})}var k,l;return k=d.inputs?g(a,h,c,d,e):a.$watch(f,h,c)}function k(a,b,c,d){function e(a){var b=!0;q(a,function(a){v(a)||(b=!1)});return b}var f,g;return f=a.$watch(function(a){return d(a)},function(a,c,d){g=a;y(b)&&b(a,c,d);e(a)&&d.$$postDigest(function(){e(g)&&f()})},c)}function l(a,b,c,d){var e=a.$watch(function(a){e();return d(a)},b,c);return e}function m(a,b){if(!b)return a;var c=\na.$$watchDelegate,d=!1,c=c!==k&&c!==h?function(c,e,f,g){f=d&&g?g[0]:a(c,e,f,g);return b(f,c,e)}:function(c,d,e,f){e=a(c,d,e,f);c=b(e,c,d);return v(e)?c:e},d=!a.inputs;a.$$watchDelegate&&a.$$watchDelegate!==g?(c.$$watchDelegate=a.$$watchDelegate,c.inputs=a.inputs):b.$stateful||(c.$$watchDelegate=g,c.inputs=a.inputs?a.inputs:[a]);return c}var n={csp:za().noUnsafeEval,literals:Fa(b),isIdentifierStart:y(d)&&d,isIdentifierContinue:y(c)&&c};return function(b,c){var d,e,u;switch(typeof b){case \"string\":return u=\nb=b.trim(),d=a[u],d||(\":\"===b.charAt(0)&&\":\"===b.charAt(1)&&(e=!0,b=b.substring(2)),d=new qc(n),d=(new rc(d,f,n)).parse(b),d.constant?d.$$watchDelegate=l:e?d.$$watchDelegate=d.literal?k:h:d.inputs&&(d.$$watchDelegate=g),a[u]=d),m(d,c);case \"function\":return m(b,c);default:return m(w,c)}}}]}function If(){var a=!0;this.$get=[\"$rootScope\",\"$exceptionHandler\",function(b,d){return Fd(function(a){b.$evalAsync(a)},d,a)}];this.errorOnUnhandledRejections=function(b){return v(b)?(a=b,this):a}}function Jf(){var a=\n!0;this.$get=[\"$browser\",\"$exceptionHandler\",function(b,d){return Fd(function(a){b.defer(a)},d,a)}];this.errorOnUnhandledRejections=function(b){return v(b)?(a=b,this):a}}function Fd(a,b,d){function c(){return new f}function f(){var a=this.promise=new e;this.resolve=function(b){k(a,b)};this.reject=function(b){m(a,b)};this.notify=function(b){p(a,b)}}function e(){this.$$state={status:0}}function g(){for(;!v&&t.length;){var a=t.shift();if(!a.pur){a.pur=!0;var c=a.value,c=\"Possibly unhandled rejection: \"+\n(\"function\"===typeof c?c.toString().replace(/ \\{[\\s\\S]*$/,\"\"):x(c)?\"undefined\":\"string\"!==typeof c?we(c):c);a.value instanceof Error?b(a.value,c):b(c)}}}function h(b){!d||b.pending||2!==b.status||b.pur||(0===v&&0===t.length&&a(g),t.push(b));!b.processScheduled&&b.pending&&(b.processScheduled=!0,++v,a(function(){var c,e,f;f=b.pending;b.processScheduled=!1;b.pending=void 0;try{for(var h=0,l=f.length;h<l;++h){b.pur=!0;e=f[h][0];c=f[h][b.status];try{y(c)?k(e,c(b.value)):1===b.status?k(e,b.value):m(e,\nb.value)}catch(n){m(e,n)}}}finally{--v,d&&0===v&&a(g)}}))}function k(a,b){a.$$state.status||(b===a?n(a,H(\"qcycle\",b)):l(a,b))}function l(a,b){function c(b){g||(g=!0,l(a,b))}function d(b){g||(g=!0,n(a,b))}function e(b){p(a,b)}var f,g=!1;try{if(F(b)||y(b))f=b.then;y(f)?(a.$$state.status=-1,f.call(b,c,d,e)):(a.$$state.value=b,a.$$state.status=1,h(a.$$state))}catch(k){d(k)}}function m(a,b){a.$$state.status||n(a,b)}function n(a,b){a.$$state.value=b;a.$$state.status=2;h(a.$$state)}function p(c,d){var e=\nc.$$state.pending;0>=c.$$state.status&&e&&e.length&&a(function(){for(var a,c,f=0,g=e.length;f<g;f++){c=e[f][0];a=e[f][3];try{p(c,y(a)?a(d):d)}catch(h){b(h)}}})}function r(a){var b=new e;m(b,a);return b}function J(a,b,c){var d=null;try{y(c)&&(d=c())}catch(e){return r(e)}return d&&y(d.then)?d.then(function(){return b(a)},r):b(a)}function s(a,b,c,d){var f=new e;k(f,a);return f.then(b,c,d)}function u(a){if(!y(a))throw H(\"norslvr\",a);var b=new e;a(function(a){k(b,a)},function(a){m(b,a)});return b}var H=\nM(\"$q\",TypeError),v=0,t=[];R(e.prototype,{then:function(a,b,c){if(x(a)&&x(b)&&x(c))return this;var d=new e;this.$$state.pending=this.$$state.pending||[];this.$$state.pending.push([d,a,b,c]);0<this.$$state.status&&h(this.$$state);return d},\"catch\":function(a){return this.then(null,a)},\"finally\":function(a,b){return this.then(function(b){return J(b,w,a)},function(b){return J(b,r,a)},b)}});var w=s;u.prototype=e.prototype;u.defer=c;u.reject=r;u.when=s;u.resolve=w;u.all=function(a){var b=new e,c=0,d=C(a)?\n[]:{};q(a,function(a,e){c++;s(a).then(function(a){d[e]=a;--c||k(b,d)},function(a){m(b,a)})});0===c&&k(b,d);return b};u.race=function(a){var b=c();q(a,function(a){s(a).then(b.resolve,b.reject)});return b.promise};return u}function Sf(){this.$get=[\"$window\",\"$timeout\",function(a,b){var d=a.requestAnimationFrame||a.webkitRequestAnimationFrame,c=a.cancelAnimationFrame||a.webkitCancelAnimationFrame||a.webkitCancelRequestAnimationFrame,f=!!d,e=f?function(a){var b=d(a);return function(){c(b)}}:function(a){var c=\nb(a,16.66,!1);return function(){b.cancel(c)}};e.supported=f;return e}]}function Hf(){function a(a){function b(){this.$$watchers=this.$$nextSibling=this.$$childHead=this.$$childTail=null;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$id=++rb;this.$$ChildScope=null}b.prototype=a;return b}var b=10,d=M(\"$rootScope\"),c=null,f=null;this.digestTtl=function(a){arguments.length&&(b=a);return b};this.$get=[\"$exceptionHandler\",\"$parse\",\"$browser\",function(e,g,h){function k(a){a.currentScope.$$destroyed=\n!0}function l(a){9===La&&(a.$$childHead&&l(a.$$childHead),a.$$nextSibling&&l(a.$$nextSibling));a.$parent=a.$$nextSibling=a.$$prevSibling=a.$$childHead=a.$$childTail=a.$root=a.$$watchers=null}function m(){this.$id=++rb;this.$$phase=this.$parent=this.$$watchers=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=null;this.$root=this;this.$$destroyed=!1;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$$isolateBindings=null}function n(a){if(H.$$phase)throw d(\"inprog\",\nH.$$phase);H.$$phase=a}function p(a,b){do a.$$watchersCount+=b;while(a=a.$parent)}function r(a,b,c){do a.$$listenerCount[c]-=b,0===a.$$listenerCount[c]&&delete a.$$listenerCount[c];while(a=a.$parent)}function J(){}function s(){for(;ia.length;)try{ia.shift()()}catch(a){e(a)}f=null}function u(){null===f&&(f=h.defer(function(){H.$apply(s)}))}m.prototype={constructor:m,$new:function(b,c){var d;c=c||this;b?(d=new m,d.$root=this.$root):(this.$$ChildScope||(this.$$ChildScope=a(this)),d=new this.$$ChildScope);\nd.$parent=c;d.$$prevSibling=c.$$childTail;c.$$childHead?(c.$$childTail.$$nextSibling=d,c.$$childTail=d):c.$$childHead=c.$$childTail=d;(b||c!==this)&&d.$on(\"$destroy\",k);return d},$watch:function(a,b,d,e){var f=g(a);if(f.$$watchDelegate)return f.$$watchDelegate(this,b,d,f,a);var h=this,k=h.$$watchers,l={fn:b,last:J,get:f,exp:e||a,eq:!!d};c=null;y(b)||(l.fn=w);k||(k=h.$$watchers=[],k.$$digestWatchIndex=-1);k.unshift(l);k.$$digestWatchIndex++;p(this,1);return function(){var a=$a(k,l);0<=a&&(p(h,-1),\na<k.$$digestWatchIndex&&k.$$digestWatchIndex--);c=null}},$watchGroup:function(a,b){function c(){h=!1;k?(k=!1,b(e,e,g)):b(e,d,g)}var d=Array(a.length),e=Array(a.length),f=[],g=this,h=!1,k=!0;if(!a.length){var l=!0;g.$evalAsync(function(){l&&b(e,e,g)});return function(){l=!1}}if(1===a.length)return this.$watch(a[0],function(a,c,f){e[0]=a;d[0]=c;b(e,a===c?e:d,f)});q(a,function(a,b){var k=g.$watch(a,function(a,f){e[b]=a;d[b]=f;h||(h=!0,g.$evalAsync(c))});f.push(k)});return function(){for(;f.length;)f.shift()()}},\n$watchCollection:function(a,b){function c(a){e=a;var b,d,g,h;if(!x(e)){if(F(e))if(ta(e))for(f!==n&&(f=n,u=f.length=0,l++),a=e.length,u!==a&&(l++,f.length=u=a),b=0;b<a;b++)h=f[b],g=e[b],d=h!==h&&g!==g,d||h===g||(l++,f[b]=g);else{f!==p&&(f=p={},u=0,l++);a=0;for(b in e)va.call(e,b)&&(a++,g=e[b],h=f[b],b in f?(d=h!==h&&g!==g,d||h===g||(l++,f[b]=g)):(u++,f[b]=g,l++));if(u>a)for(b in l++,f)va.call(e,b)||(u--,delete f[b])}else f!==e&&(f=e,l++);return l}}c.$stateful=!0;var d=this,e,f,h,k=1<b.length,l=0,m=\ng(a,c),n=[],p={},r=!0,u=0;return this.$watch(m,function(){r?(r=!1,b(e,e,d)):b(e,h,d);if(k)if(F(e))if(ta(e)){h=Array(e.length);for(var a=0;a<e.length;a++)h[a]=e[a]}else for(a in h={},e)va.call(e,a)&&(h[a]=e[a]);else h=e})},$digest:function(){var a,g,k,l,m,p,r,u=b,q,w=[],x,ia;n(\"$digest\");h.$$checkUrlChange();this===H&&null!==f&&(h.defer.cancel(f),s());c=null;do{r=!1;q=this;for(p=0;p<v.length;p++){try{ia=v[p],ia.scope.$eval(ia.expression,ia.locals)}catch(z){e(z)}c=null}v.length=0;a:do{if(p=q.$$watchers)for(p.$$digestWatchIndex=\np.length;p.$$digestWatchIndex--;)try{if(a=p[p.$$digestWatchIndex])if(m=a.get,(g=m(q))!==(k=a.last)&&!(a.eq?qa(g,k):ga(g)&&ga(k)))r=!0,c=a,a.last=a.eq?Fa(g,null):g,l=a.fn,l(g,k===J?g:k,q),5>u&&(x=4-u,w[x]||(w[x]=[]),w[x].push({msg:y(a.exp)?\"fn: \"+(a.exp.name||a.exp.toString()):a.exp,newVal:g,oldVal:k}));else if(a===c){r=!1;break a}}catch(D){e(D)}if(!(p=q.$$watchersCount&&q.$$childHead||q!==this&&q.$$nextSibling))for(;q!==this&&!(p=q.$$nextSibling);)q=q.$parent}while(q=p);if((r||v.length)&&!u--)throw H.$$phase=\nnull,d(\"infdig\",b,w);}while(r||v.length);for(H.$$phase=null;A<t.length;)try{t[A++]()}catch(E){e(E)}t.length=A=0},$destroy:function(){if(!this.$$destroyed){var a=this.$parent;this.$broadcast(\"$destroy\");this.$$destroyed=!0;this===H&&h.$$applicationDestroyed();p(this,-this.$$watchersCount);for(var b in this.$$listenerCount)r(this,this.$$listenerCount[b],b);a&&a.$$childHead===this&&(a.$$childHead=this.$$nextSibling);a&&a.$$childTail===this&&(a.$$childTail=this.$$prevSibling);this.$$prevSibling&&(this.$$prevSibling.$$nextSibling=\nthis.$$nextSibling);this.$$nextSibling&&(this.$$nextSibling.$$prevSibling=this.$$prevSibling);this.$destroy=this.$digest=this.$apply=this.$evalAsync=this.$applyAsync=w;this.$on=this.$watch=this.$watchGroup=function(){return w};this.$$listeners={};this.$$nextSibling=null;l(this)}},$eval:function(a,b){return g(a)(this,b)},$evalAsync:function(a,b){H.$$phase||v.length||h.defer(function(){v.length&&H.$digest()});v.push({scope:this,expression:g(a),locals:b})},$$postDigest:function(a){t.push(a)},$apply:function(a){try{n(\"$apply\");\ntry{return this.$eval(a)}finally{H.$$phase=null}}catch(b){e(b)}finally{try{H.$digest()}catch(c){throw e(c),c;}}},$applyAsync:function(a){function b(){c.$eval(a)}var c=this;a&&ia.push(b);a=g(a);u()},$on:function(a,b){var c=this.$$listeners[a];c||(this.$$listeners[a]=c=[]);c.push(b);var d=this;do d.$$listenerCount[a]||(d.$$listenerCount[a]=0),d.$$listenerCount[a]++;while(d=d.$parent);var e=this;return function(){var d=c.indexOf(b);-1!==d&&(c[d]=null,r(e,1,a))}},$emit:function(a,b){var c=[],d,f=this,\ng=!1,h={name:a,targetScope:f,stopPropagation:function(){g=!0},preventDefault:function(){h.defaultPrevented=!0},defaultPrevented:!1},k=ab([h],arguments,1),l,m;do{d=f.$$listeners[a]||c;h.currentScope=f;l=0;for(m=d.length;l<m;l++)if(d[l])try{d[l].apply(null,k)}catch(n){e(n)}else d.splice(l,1),l--,m--;if(g)return h.currentScope=null,h;f=f.$parent}while(f);h.currentScope=null;return h},$broadcast:function(a,b){var c=this,d=this,f={name:a,targetScope:this,preventDefault:function(){f.defaultPrevented=!0},\ndefaultPrevented:!1};if(!this.$$listenerCount[a])return f;for(var g=ab([f],arguments,1),h,k;c=d;){f.currentScope=c;d=c.$$listeners[a]||[];h=0;for(k=d.length;h<k;h++)if(d[h])try{d[h].apply(null,g)}catch(l){e(l)}else d.splice(h,1),h--,k--;if(!(d=c.$$listenerCount[a]&&c.$$childHead||c!==this&&c.$$nextSibling))for(;c!==this&&!(d=c.$$nextSibling);)c=c.$parent}f.currentScope=null;return f}};var H=new m,v=H.$$asyncQueue=[],t=H.$$postDigestQueue=[],ia=H.$$applyAsyncQueue=[],A=0;return H}]}function ze(){var a=\n/^\\s*(https?|ftp|mailto|tel|file):/,b=/^\\s*((https?|ftp|file|blob):|data:image\\/)/;this.aHrefSanitizationWhitelist=function(b){return v(b)?(a=b,this):a};this.imgSrcSanitizationWhitelist=function(a){return v(a)?(b=a,this):b};this.$get=function(){return function(d,c){var f=c?b:a,e;e=Da(d).href;return\"\"===e||e.match(f)?d:\"unsafe:\"+e}}}function xg(a){if(\"self\"===a)return a;if(E(a)){if(-1<a.indexOf(\"***\"))throw ua(\"iwcard\",a);a=Gd(a).replace(/\\\\\\*\\\\\\*/g,\".*\").replace(/\\\\\\*/g,\"[^:/.?&;]*\");return new RegExp(\"^\"+\na+\"$\")}if(Xa(a))return new RegExp(\"^\"+a.source+\"$\");throw ua(\"imatcher\");}function Hd(a){var b=[];v(a)&&q(a,function(a){b.push(xg(a))});return b}function Lf(){this.SCE_CONTEXTS=pa;var a=[\"self\"],b=[];this.resourceUrlWhitelist=function(b){arguments.length&&(a=Hd(b));return a};this.resourceUrlBlacklist=function(a){arguments.length&&(b=Hd(a));return b};this.$get=[\"$injector\",function(d){function c(a,b){return\"self\"===a?sd(b):!!a.exec(b.href)}function f(a){var b=function(a){this.$$unwrapTrustedValue=\nfunction(){return a}};a&&(b.prototype=new a);b.prototype.valueOf=function(){return this.$$unwrapTrustedValue()};b.prototype.toString=function(){return this.$$unwrapTrustedValue().toString()};return b}var e=function(a){throw ua(\"unsafe\");};d.has(\"$sanitize\")&&(e=d.get(\"$sanitize\"));var g=f(),h={};h[pa.HTML]=f(g);h[pa.CSS]=f(g);h[pa.URL]=f(g);h[pa.JS]=f(g);h[pa.RESOURCE_URL]=f(h[pa.URL]);return{trustAs:function(a,b){var c=h.hasOwnProperty(a)?h[a]:null;if(!c)throw ua(\"icontext\",a,b);if(null===b||x(b)||\n\"\"===b)return b;if(\"string\"!==typeof b)throw ua(\"itype\",a);return new c(b)},getTrusted:function(d,f){if(null===f||x(f)||\"\"===f)return f;var g=h.hasOwnProperty(d)?h[d]:null;if(g&&f instanceof g)return f.$$unwrapTrustedValue();if(d===pa.RESOURCE_URL){var g=Da(f.toString()),n,p,r=!1;n=0;for(p=a.length;n<p;n++)if(c(a[n],g)){r=!0;break}if(r)for(n=0,p=b.length;n<p;n++)if(c(b[n],g)){r=!1;break}if(r)return f;throw ua(\"insecurl\",f.toString());}if(d===pa.HTML)return e(f);throw ua(\"unsafe\");},valueOf:function(a){return a instanceof\ng?a.$$unwrapTrustedValue():a}}}]}function Kf(){var a=!0;this.enabled=function(b){arguments.length&&(a=!!b);return a};this.$get=[\"$parse\",\"$sceDelegate\",function(b,d){if(a&&8>La)throw ua(\"iequirks\");var c=ra(pa);c.isEnabled=function(){return a};c.trustAs=d.trustAs;c.getTrusted=d.getTrusted;c.valueOf=d.valueOf;a||(c.trustAs=c.getTrusted=function(a,b){return b},c.valueOf=Ya);c.parseAs=function(a,d){var e=b(d);return e.literal&&e.constant?e:b(d,function(b){return c.getTrusted(a,b)})};var f=c.parseAs,\ne=c.getTrusted,g=c.trustAs;q(pa,function(a,b){var d=P(b);c[(\"parse_as_\"+d).replace(sc,gb)]=function(b){return f(a,b)};c[(\"get_trusted_\"+d).replace(sc,gb)]=function(b){return e(a,b)};c[(\"trust_as_\"+d).replace(sc,gb)]=function(b){return g(a,b)}});return c}]}function Mf(){this.$get=[\"$window\",\"$document\",function(a,b){var d={},c=!(a.chrome&&(a.chrome.app&&a.chrome.app.runtime||!a.chrome.app&&a.chrome.runtime&&a.chrome.runtime.id))&&a.history&&a.history.pushState,f=Z((/android (\\d+)/.exec(P((a.navigator||\n{}).userAgent))||[])[1]),e=/Boxee/i.test((a.navigator||{}).userAgent),g=b[0]||{},h=g.body&&g.body.style,k=!1,l=!1;h&&(k=!!(\"transition\"in h||\"webkitTransition\"in h),l=!!(\"animation\"in h||\"webkitAnimation\"in h));return{history:!(!c||4>f||e),hasEvent:function(a){if(\"input\"===a&&La)return!1;if(x(d[a])){var b=g.createElement(\"div\");d[a]=\"on\"+a in b}return d[a]},csp:za(),transitions:k,animations:l,android:f}}]}function Of(){var a;this.httpOptions=function(b){return b?(a=b,this):a};this.$get=[\"$exceptionHandler\",\n\"$templateCache\",\"$http\",\"$q\",\"$sce\",function(b,d,c,f,e){function g(h,k){g.totalPendingRequests++;if(!E(h)||x(d.get(h)))h=e.getTrustedResourceUrl(h);var l=c.defaults&&c.defaults.transformResponse;C(l)?l=l.filter(function(a){return a!==jc}):l===jc&&(l=null);return c.get(h,R({cache:d,transformResponse:l},a)).finally(function(){g.totalPendingRequests--}).then(function(a){d.put(h,a.data);return a.data},function(a){k||(a=yg(\"tpload\",h,a.status,a.statusText),b(a));return f.reject(a)})}g.totalPendingRequests=\n0;return g}]}function Pf(){this.$get=[\"$rootScope\",\"$browser\",\"$location\",function(a,b,d){return{findBindings:function(a,b,d){a=a.getElementsByClassName(\"ng-binding\");var g=[];q(a,function(a){var c=$.element(a).data(\"$binding\");c&&q(c,function(c){d?(new RegExp(\"(^|\\\\s)\"+Gd(b)+\"(\\\\s|\\\\||$)\")).test(c)&&g.push(a):-1!==c.indexOf(b)&&g.push(a)})});return g},findModels:function(a,b,d){for(var g=[\"ng-\",\"data-ng-\",\"ng\\\\:\"],h=0;h<g.length;++h){var k=a.querySelectorAll(\"[\"+g[h]+\"model\"+(d?\"=\":\"*=\")+'\"'+b+'\"]');\nif(k.length)return k}},getLocation:function(){return d.url()},setLocation:function(b){b!==d.url()&&(d.url(b),a.$digest())},whenStable:function(a){b.notifyWhenNoOutstandingRequests(a)}}}]}function Qf(){this.$get=[\"$rootScope\",\"$browser\",\"$q\",\"$$q\",\"$exceptionHandler\",function(a,b,d,c,f){function e(e,k,l){y(e)||(l=k,k=e,e=w);var m=wa.call(arguments,3),n=v(l)&&!l,p=(n?c:d).defer(),r=p.promise,q;q=b.defer(function(){try{p.resolve(e.apply(null,m))}catch(b){p.reject(b),f(b)}finally{delete g[r.$$timeoutId]}n||\na.$apply()},k);r.$$timeoutId=q;g[q]=p;return r}var g={};e.cancel=function(a){return a&&a.$$timeoutId in g?(g[a.$$timeoutId].promise.catch(w),g[a.$$timeoutId].reject(\"canceled\"),delete g[a.$$timeoutId],b.defer.cancel(a.$$timeoutId)):!1};return e}]}function Da(a){La&&(ca.setAttribute(\"href\",a),a=ca.href);ca.setAttribute(\"href\",a);return{href:ca.href,protocol:ca.protocol?ca.protocol.replace(/:$/,\"\"):\"\",host:ca.host,search:ca.search?ca.search.replace(/^\\?/,\"\"):\"\",hash:ca.hash?ca.hash.replace(/^#/,\"\"):\n\"\",hostname:ca.hostname,port:ca.port,pathname:\"/\"===ca.pathname.charAt(0)?ca.pathname:\"/\"+ca.pathname}}function sd(a){a=E(a)?Da(a):a;return a.protocol===Id.protocol&&a.host===Id.host}function Rf(){this.$get=ma(z)}function Jd(a){function b(a){try{return decodeURIComponent(a)}catch(b){return a}}var d=a[0]||{},c={},f=\"\";return function(){var a,g,h,k,l;try{a=d.cookie||\"\"}catch(m){a=\"\"}if(a!==f)for(f=a,a=f.split(\"; \"),c={},h=0;h<a.length;h++)g=a[h],k=g.indexOf(\"=\"),0<k&&(l=b(g.substring(0,k)),x(c[l])&&\n(c[l]=b(g.substring(k+1))));return c}}function Vf(){this.$get=Jd}function Xc(a){function b(d,c){if(F(d)){var f={};q(d,function(a,c){f[c]=b(c,a)});return f}return a.factory(d+\"Filter\",c)}this.register=b;this.$get=[\"$injector\",function(a){return function(b){return a.get(b+\"Filter\")}}];b(\"currency\",Kd);b(\"date\",Ld);b(\"filter\",zg);b(\"json\",Ag);b(\"limitTo\",Bg);b(\"lowercase\",Cg);b(\"number\",Md);b(\"orderBy\",Nd);b(\"uppercase\",Dg)}function zg(){return function(a,b,d,c){if(!ta(a)){if(null==a)return a;throw M(\"filter\")(\"notarray\",\na);}c=c||\"$\";var f;switch(tc(b)){case \"function\":break;case \"boolean\":case \"null\":case \"number\":case \"string\":f=!0;case \"object\":b=Eg(b,d,c,f);break;default:return a}return Array.prototype.filter.call(a,b)}}function Eg(a,b,d,c){var f=F(a)&&d in a;!0===b?b=qa:y(b)||(b=function(a,b){if(x(a))return!1;if(null===a||null===b)return a===b;if(F(b)||F(a)&&!Vb(a))return!1;a=P(\"\"+a);b=P(\"\"+b);return-1!==a.indexOf(b)});return function(e){return f&&!F(e)?Ha(e,a[d],b,d,!1):Ha(e,a,b,d,c)}}function Ha(a,b,d,c,f,\ne){var g=tc(a),h=tc(b);if(\"string\"===h&&\"!\"===b.charAt(0))return!Ha(a,b.substring(1),d,c,f);if(C(a))return a.some(function(a){return Ha(a,b,d,c,f)});switch(g){case \"object\":var k;if(f){for(k in a)if(\"$\"!==k.charAt(0)&&Ha(a[k],b,d,c,!0))return!0;return e?!1:Ha(a,b,d,c,!1)}if(\"object\"===h){for(k in b)if(e=b[k],!y(e)&&!x(e)&&(g=k===c,!Ha(g?a:a[k],e,d,c,g,g)))return!1;return!0}return d(a,b);case \"function\":return!1;default:return d(a,b)}}function tc(a){return null===a?\"null\":typeof a}function Kd(a){var b=\na.NUMBER_FORMATS;return function(a,c,f){x(c)&&(c=b.CURRENCY_SYM);x(f)&&(f=b.PATTERNS[1].maxFrac);return null==a?a:Od(a,b.PATTERNS[1],b.GROUP_SEP,b.DECIMAL_SEP,f).replace(/\\u00A4/g,c)}}function Md(a){var b=a.NUMBER_FORMATS;return function(a,c){return null==a?a:Od(a,b.PATTERNS[0],b.GROUP_SEP,b.DECIMAL_SEP,c)}}function Fg(a){var b=0,d,c,f,e,g;-1<(c=a.indexOf(Pd))&&(a=a.replace(Pd,\"\"));0<(f=a.search(/e/i))?(0>c&&(c=f),c+=+a.slice(f+1),a=a.substring(0,f)):0>c&&(c=a.length);for(f=0;a.charAt(f)===uc;f++);\nif(f===(g=a.length))d=[0],c=1;else{for(g--;a.charAt(g)===uc;)g--;c-=f;d=[];for(e=0;f<=g;f++,e++)d[e]=+a.charAt(f)}c>Qd&&(d=d.splice(0,Qd-1),b=c-1,c=1);return{d:d,e:b,i:c}}function Gg(a,b,d,c){var f=a.d,e=f.length-a.i;b=x(b)?Math.min(Math.max(d,e),c):+b;d=b+a.i;c=f[d];if(0<d){f.splice(Math.max(a.i,d));for(var g=d;g<f.length;g++)f[g]=0}else for(e=Math.max(0,e),a.i=1,f.length=Math.max(1,d=b+1),f[0]=0,g=1;g<d;g++)f[g]=0;if(5<=c)if(0>d-1){for(c=0;c>d;c--)f.unshift(0),a.i++;f.unshift(1);a.i++}else f[d-\n1]++;for(;e<Math.max(0,b);e++)f.push(0);if(b=f.reduceRight(function(a,b,c,d){b+=a;d[c]=b%10;return Math.floor(b/10)},0))f.unshift(b),a.i++}function Od(a,b,d,c,f){if(!E(a)&&!Y(a)||isNaN(a))return\"\";var e=!isFinite(a),g=!1,h=Math.abs(a)+\"\",k=\"\";if(e)k=\"\\u221e\";else{g=Fg(h);Gg(g,f,b.minFrac,b.maxFrac);k=g.d;h=g.i;f=g.e;e=[];for(g=k.reduce(function(a,b){return a&&!b},!0);0>h;)k.unshift(0),h++;0<h?e=k.splice(h,k.length):(e=k,k=[0]);h=[];for(k.length>=b.lgSize&&h.unshift(k.splice(-b.lgSize,k.length).join(\"\"));k.length>\nb.gSize;)h.unshift(k.splice(-b.gSize,k.length).join(\"\"));k.length&&h.unshift(k.join(\"\"));k=h.join(d);e.length&&(k+=c+e.join(\"\"));f&&(k+=\"e+\"+f)}return 0>a&&!g?b.negPre+k+b.negSuf:b.posPre+k+b.posSuf}function Kb(a,b,d,c){var f=\"\";if(0>a||c&&0>=a)c?a=-a+1:(a=-a,f=\"-\");for(a=\"\"+a;a.length<b;)a=uc+a;d&&(a=a.substr(a.length-b));return f+a}function aa(a,b,d,c,f){d=d||0;return function(e){e=e[\"get\"+a]();if(0<d||e>-d)e+=d;0===e&&-12===d&&(e=12);return Kb(e,b,c,f)}}function nb(a,b,d){return function(c,f){var e=\nc[\"get\"+a](),g=vb((d?\"STANDALONE\":\"\")+(b?\"SHORT\":\"\")+a);return f[g][e]}}function Rd(a){var b=(new Date(a,0,1)).getDay();return new Date(a,0,(4>=b?5:12)-b)}function Sd(a){return function(b){var d=Rd(b.getFullYear());b=+new Date(b.getFullYear(),b.getMonth(),b.getDate()+(4-b.getDay()))-+d;b=1+Math.round(b/6048E5);return Kb(b,a)}}function vc(a,b){return 0>=a.getFullYear()?b.ERAS[0]:b.ERAS[1]}function Ld(a){function b(a){var b;if(b=a.match(d)){a=new Date(0);var e=0,g=0,h=b[8]?a.setUTCFullYear:a.setFullYear,\nk=b[8]?a.setUTCHours:a.setHours;b[9]&&(e=Z(b[9]+b[10]),g=Z(b[9]+b[11]));h.call(a,Z(b[1]),Z(b[2])-1,Z(b[3]));e=Z(b[4]||0)-e;g=Z(b[5]||0)-g;h=Z(b[6]||0);b=Math.round(1E3*parseFloat(\"0.\"+(b[7]||0)));k.call(a,e,g,h,b)}return a}var d=/^(\\d{4})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d+))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d))?)?$/;return function(c,d,e){var g=\"\",h=[],k,l;d=d||\"mediumDate\";d=a.DATETIME_FORMATS[d]||d;E(c)&&(c=Hg.test(c)?Z(c):b(c));Y(c)&&(c=new Date(c));if(!fa(c)||!isFinite(c.getTime()))return c;\nfor(;d;)(l=Ig.exec(d))?(h=ab(h,l,1),d=h.pop()):(h.push(d),d=null);var m=c.getTimezoneOffset();e&&(m=Jc(e,m),c=Wb(c,e,!0));q(h,function(b){k=Jg[b];g+=k?k(c,a.DATETIME_FORMATS,m):\"''\"===b?\"'\":b.replace(/(^'|'$)/g,\"\").replace(/''/g,\"'\")});return g}}function Ag(){return function(a,b){x(b)&&(b=2);return cb(a,b)}}function Bg(){return function(a,b,d){b=Infinity===Math.abs(Number(b))?Number(b):Z(b);if(ga(b))return a;Y(a)&&(a=a.toString());if(!ta(a))return a;d=!d||isNaN(d)?0:Z(d);d=0>d?Math.max(0,a.length+\nd):d;return 0<=b?wc(a,d,d+b):0===d?wc(a,b,a.length):wc(a,Math.max(0,d+b),d)}}function wc(a,b,d){return E(a)?a.slice(b,d):wa.call(a,b,d)}function Nd(a){function b(b){return b.map(function(b){var c=1,d=Ya;if(y(b))d=b;else if(E(b)){if(\"+\"===b.charAt(0)||\"-\"===b.charAt(0))c=\"-\"===b.charAt(0)?-1:1,b=b.substring(1);if(\"\"!==b&&(d=a(b),d.constant))var f=d(),d=function(a){return a[f]}}return{get:d,descending:c}})}function d(a){switch(typeof a){case \"number\":case \"boolean\":case \"string\":return!0;default:return!1}}\nfunction c(a,b){var c=0,d=a.type,k=b.type;if(d===k){var k=a.value,l=b.value;\"string\"===d?(k=k.toLowerCase(),l=l.toLowerCase()):\"object\"===d&&(F(k)&&(k=a.index),F(l)&&(l=b.index));k!==l&&(c=k<l?-1:1)}else c=d<k?-1:1;return c}return function(a,e,g,h){if(null==a)return a;if(!ta(a))throw M(\"orderBy\")(\"notarray\",a);C(e)||(e=[e]);0===e.length&&(e=[\"+\"]);var k=b(e),l=g?-1:1,m=y(h)?h:c;a=Array.prototype.map.call(a,function(a,b){return{value:a,tieBreaker:{value:b,type:\"number\",index:b},predicateValues:k.map(function(c){var e=\nc.get(a);c=typeof e;if(null===e)c=\"string\",e=\"null\";else if(\"object\"===c)a:{if(y(e.valueOf)&&(e=e.valueOf(),d(e)))break a;Vb(e)&&(e=e.toString(),d(e))}return{value:e,type:c,index:b}})}});a.sort(function(a,b){for(var c=0,d=k.length;c<d;c++){var e=m(a.predicateValues[c],b.predicateValues[c]);if(e)return e*k[c].descending*l}return m(a.tieBreaker,b.tieBreaker)*l});return a=a.map(function(a){return a.value})}}function Ra(a){y(a)&&(a={link:a});a.restrict=a.restrict||\"AC\";return ma(a)}function Lb(a,b,d,\nc,f){this.$$controls=[];this.$error={};this.$$success={};this.$pending=void 0;this.$name=f(b.name||b.ngForm||\"\")(d);this.$dirty=!1;this.$valid=this.$pristine=!0;this.$submitted=this.$invalid=!1;this.$$parentForm=Mb;this.$$element=a;this.$$animate=c;Td(this)}function Td(a){a.$$classCache={};a.$$classCache[Ud]=!(a.$$classCache[ob]=a.$$element.hasClass(ob))}function Vd(a){function b(a,b,c){c&&!a.$$classCache[b]?(a.$$animate.addClass(a.$$element,b),a.$$classCache[b]=!0):!c&&a.$$classCache[b]&&(a.$$animate.removeClass(a.$$element,\nb),a.$$classCache[b]=!1)}function d(a,c,d){c=c?\"-\"+Nc(c,\"-\"):\"\";b(a,ob+c,!0===d);b(a,Ud+c,!1===d)}var c=a.set,f=a.unset;a.clazz.prototype.$setValidity=function(a,g,h){x(g)?(this.$pending||(this.$pending={}),c(this.$pending,a,h)):(this.$pending&&f(this.$pending,a,h),Wd(this.$pending)&&(this.$pending=void 0));Ia(g)?g?(f(this.$error,a,h),c(this.$$success,a,h)):(c(this.$error,a,h),f(this.$$success,a,h)):(f(this.$error,a,h),f(this.$$success,a,h));this.$pending?(b(this,\"ng-pending\",!0),this.$valid=this.$invalid=\nvoid 0,d(this,\"\",null)):(b(this,\"ng-pending\",!1),this.$valid=Wd(this.$error),this.$invalid=!this.$valid,d(this,\"\",this.$valid));g=this.$pending&&this.$pending[a]?void 0:this.$error[a]?!1:this.$$success[a]?!0:null;d(this,a,g);this.$$parentForm.$setValidity(a,g,this)}}function Wd(a){if(a)for(var b in a)if(a.hasOwnProperty(b))return!1;return!0}function xc(a){a.$formatters.push(function(b){return a.$isEmpty(b)?b:b.toString()})}function Sa(a,b,d,c,f,e){var g=P(b[0].type);if(!f.android){var h=!1;b.on(\"compositionstart\",\nfunction(){h=!0});b.on(\"compositionend\",function(){h=!1;l()})}var k,l=function(a){k&&(e.defer.cancel(k),k=null);if(!h){var f=b.val();a=a&&a.type;\"password\"===g||d.ngTrim&&\"false\"===d.ngTrim||(f=S(f));(c.$viewValue!==f||\"\"===f&&c.$$hasNativeValidators)&&c.$setViewValue(f,a)}};if(f.hasEvent(\"input\"))b.on(\"input\",l);else{var m=function(a,b,c){k||(k=e.defer(function(){k=null;b&&b.value===c||l(a)}))};b.on(\"keydown\",function(a){var b=a.keyCode;91===b||15<b&&19>b||37<=b&&40>=b||m(a,this,this.value)});if(f.hasEvent(\"paste\"))b.on(\"paste cut\",\nm)}b.on(\"change\",l);if(Xd[g]&&c.$$hasNativeValidators&&g===d.type)b.on(\"keydown wheel mousedown\",function(a){if(!k){var b=this.validity,c=b.badInput,d=b.typeMismatch;k=e.defer(function(){k=null;b.badInput===c&&b.typeMismatch===d||l(a)})}});c.$render=function(){var a=c.$isEmpty(c.$viewValue)?\"\":c.$viewValue;b.val()!==a&&b.val(a)}}function Nb(a,b){return function(d,c){var f,e;if(fa(d))return d;if(E(d)){'\"'===d.charAt(0)&&'\"'===d.charAt(d.length-1)&&(d=d.substring(1,d.length-1));if(Kg.test(d))return new Date(d);\na.lastIndex=0;if(f=a.exec(d))return f.shift(),e=c?{yyyy:c.getFullYear(),MM:c.getMonth()+1,dd:c.getDate(),HH:c.getHours(),mm:c.getMinutes(),ss:c.getSeconds(),sss:c.getMilliseconds()/1E3}:{yyyy:1970,MM:1,dd:1,HH:0,mm:0,ss:0,sss:0},q(f,function(a,c){c<b.length&&(e[b[c]]=+a)}),new Date(e.yyyy,e.MM-1,e.dd,e.HH,e.mm,e.ss||0,1E3*e.sss||0)}return NaN}}function pb(a,b,d,c){return function(f,e,g,h,k,l,m){function n(a){return a&&!(a.getTime&&a.getTime()!==a.getTime())}function p(a){return v(a)&&!fa(a)?d(a)||\nvoid 0:a}yc(f,e,g,h);Sa(f,e,g,h,k,l);var r=h&&h.$options.getOption(\"timezone\"),q;h.$$parserName=a;h.$parsers.push(function(a){if(h.$isEmpty(a))return null;if(b.test(a))return a=d(a,q),r&&(a=Wb(a,r)),a});h.$formatters.push(function(a){if(a&&!fa(a))throw qb(\"datefmt\",a);if(n(a))return(q=a)&&r&&(q=Wb(q,r,!0)),m(\"date\")(a,c,r);q=null;return\"\"});if(v(g.min)||g.ngMin){var s;h.$validators.min=function(a){return!n(a)||x(s)||d(a)>=s};g.$observe(\"min\",function(a){s=p(a);h.$validate()})}if(v(g.max)||g.ngMax){var u;\nh.$validators.max=function(a){return!n(a)||x(u)||d(a)<=u};g.$observe(\"max\",function(a){u=p(a);h.$validate()})}}}function yc(a,b,d,c){(c.$$hasNativeValidators=F(b[0].validity))&&c.$parsers.push(function(a){var c=b.prop(\"validity\")||{};return c.badInput||c.typeMismatch?void 0:a})}function Yd(a){a.$$parserName=\"number\";a.$parsers.push(function(b){if(a.$isEmpty(b))return null;if(Lg.test(b))return parseFloat(b)});a.$formatters.push(function(b){if(!a.$isEmpty(b)){if(!Y(b))throw qb(\"numfmt\",b);b=b.toString()}return b})}\nfunction Ta(a){v(a)&&!Y(a)&&(a=parseFloat(a));return ga(a)?void 0:a}function zc(a){var b=a.toString(),d=b.indexOf(\".\");return-1===d?-1<a&&1>a&&(a=/e-(\\d+)$/.exec(b))?Number(a[1]):0:b.length-d-1}function Zd(a,b,d){a=Number(a);if((a|0)!==a||(b|0)!==b||(d|0)!==d){var c=Math.max(zc(a),zc(b),zc(d)),c=Math.pow(10,c);a*=c;b*=c;d*=c}return 0===(a-b)%d}function $d(a,b,d,c,f){if(v(c)){a=a(c);if(!a.constant)throw qb(\"constexpr\",d,c);return a(b)}return f}function Ac(a,b){function d(a,b){if(!a||!a.length)return[];\nif(!b||!b.length)return a;var c=[],d=0;a:for(;d<a.length;d++){for(var e=a[d],f=0;f<b.length;f++)if(e===b[f])continue a;c.push(e)}return c}function c(a){var b=a;C(a)?b=a.map(c).join(\" \"):F(a)&&(b=Object.keys(a).filter(function(b){return a[b]}).join(\" \"));return b}function f(a){var b=a;if(C(a))b=a.map(f);else if(F(a)){var c=!1,b=Object.keys(a).filter(function(b){b=a[b];!c&&x(b)&&(c=!0);return b});c&&b.push(void 0)}return b}a=\"ngClass\"+a;var e;return[\"$parse\",function(g){return{restrict:\"AC\",link:function(h,\nk,l){function m(a,b){var c=[];q(a,function(a){if(0<b||H[a])H[a]=(H[a]||0)+b,H[a]===+(0<b)&&c.push(a)});return c.join(\" \")}function n(a){if(a===b){var c=t,c=m(c&&c.split(\" \"),1);l.$addClass(c)}else c=t,c=m(c&&c.split(\" \"),-1),l.$removeClass(c);w=a}function p(a){a=c(a);a!==t&&r(a)}function r(a){if(w===b){var c=t&&t.split(\" \"),e=a&&a.split(\" \"),f=d(c,e),c=d(e,c),f=m(f,-1),c=m(c,1);l.$addClass(c);l.$removeClass(f)}t=a}var s=l[a].trim(),v=\":\"===s.charAt(0)&&\":\"===s.charAt(1),s=g(s,v?f:c),u=v?p:r,H=k.data(\"$classCounts\"),\nw=!0,t;H||(H=W(),k.data(\"$classCounts\",H));\"ngClass\"!==a&&(e||(e=g(\"$index\",function(a){return a&1})),h.$watch(e,n));h.$watch(s,u,v)}}}]}function Ob(a,b,d,c,f,e,g,h,k){this.$modelValue=this.$viewValue=Number.NaN;this.$$rawModelValue=void 0;this.$validators={};this.$asyncValidators={};this.$parsers=[];this.$formatters=[];this.$viewChangeListeners=[];this.$untouched=!0;this.$touched=!1;this.$pristine=!0;this.$dirty=!1;this.$valid=!0;this.$invalid=!1;this.$error={};this.$$success={};this.$pending=void 0;\nthis.$name=k(d.name||\"\",!1)(a);this.$$parentForm=Mb;this.$options=Pb;this.$$parsedNgModel=f(d.ngModel);this.$$parsedNgModelAssign=this.$$parsedNgModel.assign;this.$$ngModelGet=this.$$parsedNgModel;this.$$ngModelSet=this.$$parsedNgModelAssign;this.$$pendingDebounce=null;this.$$parserValid=void 0;this.$$currentValidationRunId=0;this.$$scope=a;this.$$attr=d;this.$$element=c;this.$$animate=e;this.$$timeout=g;this.$$parse=f;this.$$q=h;this.$$exceptionHandler=b;Td(this);Mg(this)}function Mg(a){a.$$scope.$watch(function(){var b=\na.$$ngModelGet(a.$$scope);if(b!==a.$modelValue&&(a.$modelValue===a.$modelValue||b===b)){a.$modelValue=a.$$rawModelValue=b;a.$$parserValid=void 0;for(var d=a.$formatters,c=d.length,f=b;c--;)f=d[c](f);a.$viewValue!==f&&(a.$$updateEmptyClasses(f),a.$viewValue=a.$$lastCommittedViewValue=f,a.$render(),a.$$runValidators(a.$modelValue,a.$viewValue,w))}return b})}function Bc(a){this.$$options=a}function ae(a,b){q(b,function(b,c){v(a[c])||(a[c]=b)})}var Ng=/^\\/(.+)\\/([a-z]*)$/,va=Object.prototype.hasOwnProperty,\nP=function(a){return E(a)?a.toLowerCase():a},vb=function(a){return E(a)?a.toUpperCase():a},La,D,oa,wa=[].slice,ng=[].splice,Og=[].push,na=Object.prototype.toString,Gc=Object.getPrototypeOf,Ga=M(\"ng\"),$=z.angular||(z.angular={}),Zb,rb=0;La=z.document.documentMode;var ga=Number.isNaN||function(a){return a!==a};w.$inject=[];Ya.$inject=[];var C=Array.isArray,le=/^\\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/,S=function(a){return E(a)?a.trim():a},Gd=function(a){return a.replace(/([-()[\\]{}+?*.$^|,:#<!\\\\])/g,\n\"\\\\$1\").replace(/\\x08/g,\"\\\\x08\")},za=function(){if(!v(za.rules)){var a=z.document.querySelector(\"[ng-csp]\")||z.document.querySelector(\"[data-ng-csp]\");if(a){var b=a.getAttribute(\"ng-csp\")||a.getAttribute(\"data-ng-csp\");za.rules={noUnsafeEval:!b||-1!==b.indexOf(\"no-unsafe-eval\"),noInlineStyle:!b||-1!==b.indexOf(\"no-inline-style\")}}else{a=za;try{new Function(\"\"),b=!1}catch(d){b=!0}a.rules={noUnsafeEval:b,noInlineStyle:!1}}}return za.rules},sb=function(){if(v(sb.name_))return sb.name_;var a,b,d=Ka.length,\nc,f;for(b=0;b<d;++b)if(c=Ka[b],a=z.document.querySelector(\"[\"+c.replace(\":\",\"\\\\:\")+\"jq]\")){f=a.getAttribute(c+\"jq\");break}return sb.name_=f},ne=/:/g,Ka=[\"ng-\",\"data-ng-\",\"ng:\",\"x-ng-\"],qe=function(a){if(!a.currentScript)return!0;var b=a.currentScript.getAttribute(\"src\"),d=a.createElement(\"a\");d.href=b;if(a.location.origin===d.origin)return!0;switch(d.protocol){case \"http:\":case \"https:\":case \"ftp:\":case \"blob:\":case \"file:\":case \"data:\":return!0;default:return!1}}(z.document),te=/[A-Z]/g,Oc=!1,Ja=\n3,ye={full:\"1.6.1\",major:1,minor:6,dot:1,codeName:\"promise-rectification\"};X.expando=\"ng339\";var ib=X.cache={},$f=1;X._data=function(a){return this.cache[a[this.expando]]||{}};var Wf=/-([a-z])/g,Pg=/^-ms-/,Ab={mouseleave:\"mouseout\",mouseenter:\"mouseover\"},ac=M(\"jqLite\"),Zf=/^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/,$b=/<|&#?\\w+;/,Xf=/<([\\w:-]+)/,Yf=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,ha={option:[1,'<select multiple=\"multiple\">',\"</select>\"],thead:[1,\"<table>\",\"</table>\"],\ncol:[2,\"<table><colgroup>\",\"</colgroup></table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],_default:[0,\"\",\"\"]};ha.optgroup=ha.option;ha.tbody=ha.tfoot=ha.colgroup=ha.caption=ha.thead;ha.th=ha.td;var eg=z.Node.prototype.contains||function(a){return!!(this.compareDocumentPosition(a)&16)},Oa=X.prototype={ready:$c,toString:function(){var a=[];q(this,function(b){a.push(\"\"+b)});return\"[\"+a.join(\", \")+\"]\"},eq:function(a){return 0<=a?D(this[a]):D(this[this.length+\na])},length:0,push:Og,sort:[].sort,splice:[].splice},Gb={};q(\"multiple selected checked disabled readOnly required open\".split(\" \"),function(a){Gb[P(a)]=a});var ed={};q(\"input select option textarea button form details\".split(\" \"),function(a){ed[a]=!0});var ld={ngMinlength:\"minlength\",ngMaxlength:\"maxlength\",ngMin:\"min\",ngMax:\"max\",ngPattern:\"pattern\",ngStep:\"step\"};q({data:dc,removeData:hb,hasData:function(a){for(var b in ib[a.ng339])return!0;return!1},cleanData:function(a){for(var b=0,d=a.length;b<\nd;b++)hb(a[b])}},function(a,b){X[b]=a});q({data:dc,inheritedData:Eb,scope:function(a){return D.data(a,\"$scope\")||Eb(a.parentNode||a,[\"$isolateScope\",\"$scope\"])},isolateScope:function(a){return D.data(a,\"$isolateScope\")||D.data(a,\"$isolateScopeNoTemplate\")},controller:bd,injector:function(a){return Eb(a,\"$injector\")},removeAttr:function(a,b){a.removeAttribute(b)},hasClass:Bb,css:function(a,b,d){b=xb(b.replace(Pg,\"ms-\"));if(v(d))a.style[b]=d;else return a.style[b]},attr:function(a,b,d){var c=a.nodeType;\nif(c!==Ja&&2!==c&&8!==c&&a.getAttribute){var c=P(b),f=Gb[c];if(v(d))null===d||!1===d&&f?a.removeAttribute(b):a.setAttribute(b,f?c:d);else return a=a.getAttribute(b),f&&null!==a&&(a=c),null===a?void 0:a}},prop:function(a,b,d){if(v(d))a[b]=d;else return a[b]},text:function(){function a(a,d){if(x(d)){var c=a.nodeType;return 1===c||c===Ja?a.textContent:\"\"}a.textContent=d}a.$dv=\"\";return a}(),val:function(a,b){if(x(b)){if(a.multiple&&\"select\"===xa(a)){var d=[];q(a.options,function(a){a.selected&&d.push(a.value||\na.text)});return d}return a.value}a.value=b},html:function(a,b){if(x(b))return a.innerHTML;yb(a,!0);a.innerHTML=b},empty:cd},function(a,b){X.prototype[b]=function(b,c){var f,e,g=this.length;if(a!==cd&&x(2===a.length&&a!==Bb&&a!==bd?b:c)){if(F(b)){for(f=0;f<g;f++)if(a===dc)a(this[f],b);else for(e in b)a(this[f],e,b[e]);return this}f=a.$dv;g=x(f)?Math.min(g,1):g;for(e=0;e<g;e++){var h=a(this[e],b,c);f=f?f+h:h}return f}for(f=0;f<g;f++)a(this[f],b,c);return this}});q({removeData:hb,on:function(a,b,d,\nc){if(v(c))throw ac(\"onargs\");if(Yc(a)){c=zb(a,!0);var f=c.events,e=c.handle;e||(e=c.handle=bg(a,f));c=0<=b.indexOf(\" \")?b.split(\" \"):[b];for(var g=c.length,h=function(b,c,g){var h=f[b];h||(h=f[b]=[],h.specialHandlerWrapper=c,\"$destroy\"===b||g||a.addEventListener(b,e));h.push(d)};g--;)b=c[g],Ab[b]?(h(Ab[b],dg),h(b,void 0,!0)):h(b)}},off:ad,one:function(a,b,d){a=D(a);a.on(b,function f(){a.off(b,d);a.off(b,f)});a.on(b,d)},replaceWith:function(a,b){var d,c=a.parentNode;yb(a);q(new X(b),function(b){d?\nc.insertBefore(b,d.nextSibling):c.replaceChild(b,a);d=b})},children:function(a){var b=[];q(a.childNodes,function(a){1===a.nodeType&&b.push(a)});return b},contents:function(a){return a.contentDocument||a.childNodes||[]},append:function(a,b){var d=a.nodeType;if(1===d||11===d){b=new X(b);for(var d=0,c=b.length;d<c;d++)a.appendChild(b[d])}},prepend:function(a,b){if(1===a.nodeType){var d=a.firstChild;q(new X(b),function(b){a.insertBefore(b,d)})}},wrap:function(a,b){var d=D(b).eq(0).clone()[0],c=a.parentNode;\nc&&c.replaceChild(d,a);d.appendChild(a)},remove:Fb,detach:function(a){Fb(a,!0)},after:function(a,b){var d=a,c=a.parentNode;if(c){b=new X(b);for(var f=0,e=b.length;f<e;f++){var g=b[f];c.insertBefore(g,d.nextSibling);d=g}}},addClass:Db,removeClass:Cb,toggleClass:function(a,b,d){b&&q(b.split(\" \"),function(b){var f=d;x(f)&&(f=!Bb(a,b));(f?Db:Cb)(a,b)})},parent:function(a){return(a=a.parentNode)&&11!==a.nodeType?a:null},next:function(a){return a.nextElementSibling},find:function(a,b){return a.getElementsByTagName?\na.getElementsByTagName(b):[]},clone:cc,triggerHandler:function(a,b,d){var c,f,e=b.type||b,g=zb(a);if(g=(g=g&&g.events)&&g[e])c={preventDefault:function(){this.defaultPrevented=!0},isDefaultPrevented:function(){return!0===this.defaultPrevented},stopImmediatePropagation:function(){this.immediatePropagationStopped=!0},isImmediatePropagationStopped:function(){return!0===this.immediatePropagationStopped},stopPropagation:w,type:e,target:a},b.type&&(c=R(c,b)),b=ra(g),f=d?[c].concat(d):[c],q(b,function(b){c.isImmediatePropagationStopped()||\nb.apply(a,f)})}},function(a,b){X.prototype[b]=function(b,c,f){for(var e,g=0,h=this.length;g<h;g++)x(e)?(e=a(this[g],b,c,f),v(e)&&(e=D(e))):bc(e,a(this[g],b,c,f));return v(e)?e:this}});X.prototype.bind=X.prototype.on;X.prototype.unbind=X.prototype.off;Qa.prototype={put:function(a,b){this[la(a,this.nextUid)]=b},get:function(a){return this[la(a,this.nextUid)]},remove:function(a){var b=this[a=la(a,this.nextUid)];delete this[a];return b}};var Uf=[function(){this.$get=[function(){return Qa}]}],gg=/^([^(]+?)=>/,\nhg=/^[^(]*\\(\\s*([^)]*)\\)/m,Qg=/,/,Rg=/^\\s*(_?)(\\S+?)\\1\\s*$/,fg=/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg,da=M(\"$injector\");eb.$$annotate=function(a,b,d){var c;if(\"function\"===typeof a){if(!(c=a.$inject)){c=[];if(a.length){if(b)throw E(d)&&d||(d=a.name||ig(a)),da(\"strictdi\",d);b=fd(a);q(b[1].split(Qg),function(a){a.replace(Rg,function(a,b,d){c.push(d)})})}a.$inject=c}}else C(a)?(b=a.length-1,tb(a[b],\"fn\"),c=a.slice(0,b)):tb(a,\"fn\",!0);return c};var be=M(\"$animate\"),lf=function(){this.$get=w},mf=function(){var a=\nnew Qa,b=[];this.$get=[\"$$AnimateRunner\",\"$rootScope\",function(d,c){function f(a,b,c){var d=!1;b&&(b=E(b)?b.split(\" \"):C(b)?b:[],q(b,function(b){b&&(d=!0,a[b]=c)}));return d}function e(){q(b,function(b){var c=a.get(b);if(c){var d=jg(b.attr(\"class\")),e=\"\",f=\"\";q(c,function(a,b){a!==!!d[b]&&(a?e+=(e.length?\" \":\"\")+b:f+=(f.length?\" \":\"\")+b)});q(b,function(a){e&&Db(a,e);f&&Cb(a,f)});a.remove(b)}});b.length=0}return{enabled:w,on:w,off:w,pin:w,push:function(g,h,k,l){l&&l();k=k||{};k.from&&g.css(k.from);\nk.to&&g.css(k.to);if(k.addClass||k.removeClass)if(h=k.addClass,l=k.removeClass,k=a.get(g)||{},h=f(k,h,!0),l=f(k,l,!1),h||l)a.put(g,k),b.push(g),1===b.length&&c.$$postDigest(e);g=new d;g.complete();return g}}}]},jf=[\"$provide\",function(a){var b=this;this.$$registeredAnimations=Object.create(null);this.register=function(d,c){if(d&&\".\"!==d.charAt(0))throw be(\"notcsel\",d);var f=d+\"-animation\";b.$$registeredAnimations[d.substr(1)]=f;a.factory(f,c)};this.classNameFilter=function(a){if(1===arguments.length&&\n(this.$$classNameFilter=a instanceof RegExp?a:null)&&/(\\s+|\\/)ng-animate(\\s+|\\/)/.test(this.$$classNameFilter.toString()))throw be(\"nongcls\",\"ng-animate\");return this.$$classNameFilter};this.$get=[\"$$animateQueue\",function(a){function b(a,c,d){if(d){var h;a:{for(h=0;h<d.length;h++){var k=d[h];if(1===k.nodeType){h=k;break a}}h=void 0}!h||h.parentNode||h.previousElementSibling||(d=null)}d?d.after(a):c.prepend(a)}return{on:a.on,off:a.off,pin:a.pin,enabled:a.enabled,cancel:function(a){a.end&&a.end()},\nenter:function(f,e,g,h){e=e&&D(e);g=g&&D(g);e=e||g.parent();b(f,e,g);return a.push(f,\"enter\",Aa(h))},move:function(f,e,g,h){e=e&&D(e);g=g&&D(g);e=e||g.parent();b(f,e,g);return a.push(f,\"move\",Aa(h))},leave:function(b,c){return a.push(b,\"leave\",Aa(c),function(){b.remove()})},addClass:function(b,c,g){g=Aa(g);g.addClass=jb(g.addclass,c);return a.push(b,\"addClass\",g)},removeClass:function(b,c,g){g=Aa(g);g.removeClass=jb(g.removeClass,c);return a.push(b,\"removeClass\",g)},setClass:function(b,c,g,h){h=Aa(h);\nh.addClass=jb(h.addClass,c);h.removeClass=jb(h.removeClass,g);return a.push(b,\"setClass\",h)},animate:function(b,c,g,h,k){k=Aa(k);k.from=k.from?R(k.from,c):c;k.to=k.to?R(k.to,g):g;k.tempClasses=jb(k.tempClasses,h||\"ng-inline-animate\");return a.push(b,\"animate\",k)}}}]}],of=function(){this.$get=[\"$$rAF\",function(a){function b(b){d.push(b);1<d.length||a(function(){for(var a=0;a<d.length;a++)d[a]();d=[]})}var d=[];return function(){var a=!1;b(function(){a=!0});return function(d){a?d():b(d)}}}]},nf=function(){this.$get=\n[\"$q\",\"$sniffer\",\"$$animateAsyncRun\",\"$$isDocumentHidden\",\"$timeout\",function(a,b,d,c,f){function e(a){this.setHost(a);var b=d();this._doneCallbacks=[];this._tick=function(a){c()?f(a,0,!1):b(a)};this._state=0}e.chain=function(a,b){function c(){if(d===a.length)b(!0);else a[d](function(a){!1===a?b(!1):(d++,c())})}var d=0;c()};e.all=function(a,b){function c(f){e=e&&f;++d===a.length&&b(e)}var d=0,e=!0;q(a,function(a){a.done(c)})};e.prototype={setHost:function(a){this.host=a||{}},done:function(a){2===\nthis._state?a():this._doneCallbacks.push(a)},progress:w,getPromise:function(){if(!this.promise){var b=this;this.promise=a(function(a,c){b.done(function(b){!1===b?c():a()})})}return this.promise},then:function(a,b){return this.getPromise().then(a,b)},\"catch\":function(a){return this.getPromise()[\"catch\"](a)},\"finally\":function(a){return this.getPromise()[\"finally\"](a)},pause:function(){this.host.pause&&this.host.pause()},resume:function(){this.host.resume&&this.host.resume()},end:function(){this.host.end&&\nthis.host.end();this._resolve(!0)},cancel:function(){this.host.cancel&&this.host.cancel();this._resolve(!1)},complete:function(a){var b=this;0===b._state&&(b._state=1,b._tick(function(){b._resolve(a)}))},_resolve:function(a){2!==this._state&&(q(this._doneCallbacks,function(b){b(a)}),this._doneCallbacks.length=0,this._state=2)}};return e}]},kf=function(){this.$get=[\"$$rAF\",\"$q\",\"$$AnimateRunner\",function(a,b,d){return function(b,f){function e(){a(function(){g.addClass&&(b.addClass(g.addClass),g.addClass=\nnull);g.removeClass&&(b.removeClass(g.removeClass),g.removeClass=null);g.to&&(b.css(g.to),g.to=null);h||k.complete();h=!0});return k}var g=f||{};g.$$prepared||(g=Fa(g));g.cleanupStyles&&(g.from=g.to=null);g.from&&(b.css(g.from),g.from=null);var h,k=new d;return{start:e,end:e}}}]},ea=M(\"$compile\"),hc=new function(){};Qc.$inject=[\"$provide\",\"$$sanitizeUriProvider\"];Ib.prototype.isFirstChange=function(){return this.previousValue===hc};var gd=/^((?:x|data)[:\\-_])/i,mg=/[:\\-_]+(.)/g,nd=M(\"$controller\"),\nmd=/^(\\S+)(\\s+as\\s+([\\w$]+))?$/,vf=function(){this.$get=[\"$document\",function(a){return function(b){b?!b.nodeType&&b instanceof D&&(b=b[0]):b=a[0].body;return b.offsetWidth+1}}]},od=\"application/json\",kc={\"Content-Type\":od+\";charset=utf-8\"},pg=/^\\[|^\\{(?!\\{)/,qg={\"[\":/]$/,\"{\":/}$/},og=/^\\)]\\}',?\\n/,td=M(\"$http\"),Ea=$.$interpolateMinErr=M(\"$interpolate\");Ea.throwNoconcat=function(a){throw Ea(\"noconcat\",a);};Ea.interr=function(a,b){return Ea(\"interr\",a,b.toString())};var Df=function(){this.$get=[\"$window\",\nfunction(a){function b(a){var b=function(a){b.data=a;b.called=!0};b.id=a;return b}var d=a.angular.callbacks,c={};return{createCallback:function(a){a=\"_\"+(d.$$counter++).toString(36);var e=\"angular.callbacks.\"+a,g=b(a);c[e]=d[a]=g;return e},wasCalled:function(a){return c[a].called},getResponse:function(a){return c[a].data},removeCallback:function(a){delete d[c[a].id];delete c[a]}}}]},Sg=/^([^?#]*)(\\?([^#]*))?(#(.*))?$/,sg={http:80,https:443,ftp:21},lb=M(\"$location\"),tg=/^\\s*[\\\\/]{2,}/,Tg={$$absUrl:\"\",\n$$html5:!1,$$replace:!1,absUrl:Jb(\"$$absUrl\"),url:function(a){if(x(a))return this.$$url;var b=Sg.exec(a);(b[1]||\"\"===a)&&this.path(decodeURIComponent(b[1]));(b[2]||b[1]||\"\"===a)&&this.search(b[3]||\"\");this.hash(b[5]||\"\");return this},protocol:Jb(\"$$protocol\"),host:Jb(\"$$host\"),port:Jb(\"$$port\"),path:xd(\"$$path\",function(a){a=null!==a?a.toString():\"\";return\"/\"===a.charAt(0)?a:\"/\"+a}),search:function(a,b){switch(arguments.length){case 0:return this.$$search;case 1:if(E(a)||Y(a))a=a.toString(),this.$$search=\nLc(a);else if(F(a))a=Fa(a,{}),q(a,function(b,c){null==b&&delete a[c]}),this.$$search=a;else throw lb(\"isrcharg\");break;default:x(b)||null===b?delete this.$$search[a]:this.$$search[a]=b}this.$$compose();return this},hash:xd(\"$$hash\",function(a){return null!==a?a.toString():\"\"}),replace:function(){this.$$replace=!0;return this}};q([wd,oc,nc],function(a){a.prototype=Object.create(Tg);a.prototype.state=function(b){if(!arguments.length)return this.$$state;if(a!==nc||!this.$$html5)throw lb(\"nostate\");this.$$state=\nx(b)?null:b;return this}});var Ua=M(\"$parse\"),wg={}.constructor.prototype.valueOf,Qb=W();q(\"+ - * / % === !== == != < > <= >= && || ! = |\".split(\" \"),function(a){Qb[a]=!0});var Ug={n:\"\\n\",f:\"\\f\",r:\"\\r\",t:\"\\t\",v:\"\\v\",\"'\":\"'\",'\"':'\"'},qc=function(a){this.options=a};qc.prototype={constructor:qc,lex:function(a){this.text=a;this.index=0;for(this.tokens=[];this.index<this.text.length;)if(a=this.text.charAt(this.index),'\"'===a||\"'\"===a)this.readString(a);else if(this.isNumber(a)||\".\"===a&&this.isNumber(this.peek()))this.readNumber();\nelse if(this.isIdentifierStart(this.peekMultichar()))this.readIdent();else if(this.is(a,\"(){}[].,;:?\"))this.tokens.push({index:this.index,text:a}),this.index++;else if(this.isWhitespace(a))this.index++;else{var b=a+this.peek(),d=b+this.peek(2),c=Qb[b],f=Qb[d];Qb[a]||c||f?(a=f?d:c?b:a,this.tokens.push({index:this.index,text:a,operator:!0}),this.index+=a.length):this.throwError(\"Unexpected next character \",this.index,this.index+1)}return this.tokens},is:function(a,b){return-1!==b.indexOf(a)},peek:function(a){a=\na||1;return this.index+a<this.text.length?this.text.charAt(this.index+a):!1},isNumber:function(a){return\"0\"<=a&&\"9\">=a&&\"string\"===typeof a},isWhitespace:function(a){return\" \"===a||\"\\r\"===a||\"\\t\"===a||\"\\n\"===a||\"\\v\"===a||\"\\u00a0\"===a},isIdentifierStart:function(a){return this.options.isIdentifierStart?this.options.isIdentifierStart(a,this.codePointAt(a)):this.isValidIdentifierStart(a)},isValidIdentifierStart:function(a){return\"a\"<=a&&\"z\">=a||\"A\"<=a&&\"Z\">=a||\"_\"===a||\"$\"===a},isIdentifierContinue:function(a){return this.options.isIdentifierContinue?\nthis.options.isIdentifierContinue(a,this.codePointAt(a)):this.isValidIdentifierContinue(a)},isValidIdentifierContinue:function(a,b){return this.isValidIdentifierStart(a,b)||this.isNumber(a)},codePointAt:function(a){return 1===a.length?a.charCodeAt(0):(a.charCodeAt(0)<<10)+a.charCodeAt(1)-56613888},peekMultichar:function(){var a=this.text.charAt(this.index),b=this.peek();if(!b)return a;var d=a.charCodeAt(0),c=b.charCodeAt(0);return 55296<=d&&56319>=d&&56320<=c&&57343>=c?a+b:a},isExpOperator:function(a){return\"-\"===\na||\"+\"===a||this.isNumber(a)},throwError:function(a,b,d){d=d||this.index;b=v(b)?\"s \"+b+\"-\"+this.index+\" [\"+this.text.substring(b,d)+\"]\":\" \"+d;throw Ua(\"lexerr\",a,b,this.text);},readNumber:function(){for(var a=\"\",b=this.index;this.index<this.text.length;){var d=P(this.text.charAt(this.index));if(\".\"===d||this.isNumber(d))a+=d;else{var c=this.peek();if(\"e\"===d&&this.isExpOperator(c))a+=d;else if(this.isExpOperator(d)&&c&&this.isNumber(c)&&\"e\"===a.charAt(a.length-1))a+=d;else if(!this.isExpOperator(d)||\nc&&this.isNumber(c)||\"e\"!==a.charAt(a.length-1))break;else this.throwError(\"Invalid exponent\")}this.index++}this.tokens.push({index:b,text:a,constant:!0,value:Number(a)})},readIdent:function(){var a=this.index;for(this.index+=this.peekMultichar().length;this.index<this.text.length;){var b=this.peekMultichar();if(!this.isIdentifierContinue(b))break;this.index+=b.length}this.tokens.push({index:a,text:this.text.slice(a,this.index),identifier:!0})},readString:function(a){var b=this.index;this.index++;\nfor(var d=\"\",c=a,f=!1;this.index<this.text.length;){var e=this.text.charAt(this.index),c=c+e;if(f)\"u\"===e?(f=this.text.substring(this.index+1,this.index+5),f.match(/[\\da-f]{4}/i)||this.throwError(\"Invalid unicode escape [\\\\u\"+f+\"]\"),this.index+=4,d+=String.fromCharCode(parseInt(f,16))):d+=Ug[e]||e,f=!1;else if(\"\\\\\"===e)f=!0;else{if(e===a){this.index++;this.tokens.push({index:b,text:c,constant:!0,value:d});return}d+=e}this.index++}this.throwError(\"Unterminated quote\",b)}};var s=function(a,b){this.lexer=\na;this.options=b};s.Program=\"Program\";s.ExpressionStatement=\"ExpressionStatement\";s.AssignmentExpression=\"AssignmentExpression\";s.ConditionalExpression=\"ConditionalExpression\";s.LogicalExpression=\"LogicalExpression\";s.BinaryExpression=\"BinaryExpression\";s.UnaryExpression=\"UnaryExpression\";s.CallExpression=\"CallExpression\";s.MemberExpression=\"MemberExpression\";s.Identifier=\"Identifier\";s.Literal=\"Literal\";s.ArrayExpression=\"ArrayExpression\";s.Property=\"Property\";s.ObjectExpression=\"ObjectExpression\";\ns.ThisExpression=\"ThisExpression\";s.LocalsExpression=\"LocalsExpression\";s.NGValueParameter=\"NGValueParameter\";s.prototype={ast:function(a){this.text=a;this.tokens=this.lexer.lex(a);a=this.program();0!==this.tokens.length&&this.throwError(\"is an unexpected token\",this.tokens[0]);return a},program:function(){for(var a=[];;)if(0<this.tokens.length&&!this.peek(\"}\",\")\",\";\",\"]\")&&a.push(this.expressionStatement()),!this.expect(\";\"))return{type:s.Program,body:a}},expressionStatement:function(){return{type:s.ExpressionStatement,\nexpression:this.filterChain()}},filterChain:function(){for(var a=this.expression();this.expect(\"|\");)a=this.filter(a);return a},expression:function(){return this.assignment()},assignment:function(){var a=this.ternary();if(this.expect(\"=\")){if(!Ad(a))throw Ua(\"lval\");a={type:s.AssignmentExpression,left:a,right:this.assignment(),operator:\"=\"}}return a},ternary:function(){var a=this.logicalOR(),b,d;return this.expect(\"?\")&&(b=this.expression(),this.consume(\":\"))?(d=this.expression(),{type:s.ConditionalExpression,\ntest:a,alternate:b,consequent:d}):a},logicalOR:function(){for(var a=this.logicalAND();this.expect(\"||\");)a={type:s.LogicalExpression,operator:\"||\",left:a,right:this.logicalAND()};return a},logicalAND:function(){for(var a=this.equality();this.expect(\"&&\");)a={type:s.LogicalExpression,operator:\"&&\",left:a,right:this.equality()};return a},equality:function(){for(var a=this.relational(),b;b=this.expect(\"==\",\"!=\",\"===\",\"!==\");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.relational()};\nreturn a},relational:function(){for(var a=this.additive(),b;b=this.expect(\"<\",\">\",\"<=\",\">=\");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.additive()};return a},additive:function(){for(var a=this.multiplicative(),b;b=this.expect(\"+\",\"-\");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.multiplicative()};return a},multiplicative:function(){for(var a=this.unary(),b;b=this.expect(\"*\",\"/\",\"%\");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.unary()};return a},\nunary:function(){var a;return(a=this.expect(\"+\",\"-\",\"!\"))?{type:s.UnaryExpression,operator:a.text,prefix:!0,argument:this.unary()}:this.primary()},primary:function(){var a;this.expect(\"(\")?(a=this.filterChain(),this.consume(\")\")):this.expect(\"[\")?a=this.arrayDeclaration():this.expect(\"{\")?a=this.object():this.selfReferential.hasOwnProperty(this.peek().text)?a=Fa(this.selfReferential[this.consume().text]):this.options.literals.hasOwnProperty(this.peek().text)?a={type:s.Literal,value:this.options.literals[this.consume().text]}:\nthis.peek().identifier?a=this.identifier():this.peek().constant?a=this.constant():this.throwError(\"not a primary expression\",this.peek());for(var b;b=this.expect(\"(\",\"[\",\".\");)\"(\"===b.text?(a={type:s.CallExpression,callee:a,arguments:this.parseArguments()},this.consume(\")\")):\"[\"===b.text?(a={type:s.MemberExpression,object:a,property:this.expression(),computed:!0},this.consume(\"]\")):\".\"===b.text?a={type:s.MemberExpression,object:a,property:this.identifier(),computed:!1}:this.throwError(\"IMPOSSIBLE\");\nreturn a},filter:function(a){a=[a];for(var b={type:s.CallExpression,callee:this.identifier(),arguments:a,filter:!0};this.expect(\":\");)a.push(this.expression());return b},parseArguments:function(){var a=[];if(\")\"!==this.peekToken().text){do a.push(this.filterChain());while(this.expect(\",\"))}return a},identifier:function(){var a=this.consume();a.identifier||this.throwError(\"is not a valid identifier\",a);return{type:s.Identifier,name:a.text}},constant:function(){return{type:s.Literal,value:this.consume().value}},\narrayDeclaration:function(){var a=[];if(\"]\"!==this.peekToken().text){do{if(this.peek(\"]\"))break;a.push(this.expression())}while(this.expect(\",\"))}this.consume(\"]\");return{type:s.ArrayExpression,elements:a}},object:function(){var a=[],b;if(\"}\"!==this.peekToken().text){do{if(this.peek(\"}\"))break;b={type:s.Property,kind:\"init\"};this.peek().constant?(b.key=this.constant(),b.computed=!1,this.consume(\":\"),b.value=this.expression()):this.peek().identifier?(b.key=this.identifier(),b.computed=!1,this.peek(\":\")?\n(this.consume(\":\"),b.value=this.expression()):b.value=b.key):this.peek(\"[\")?(this.consume(\"[\"),b.key=this.expression(),this.consume(\"]\"),b.computed=!0,this.consume(\":\"),b.value=this.expression()):this.throwError(\"invalid key\",this.peek());a.push(b)}while(this.expect(\",\"))}this.consume(\"}\");return{type:s.ObjectExpression,properties:a}},throwError:function(a,b){throw Ua(\"syntax\",b.text,a,b.index+1,this.text,this.text.substring(b.index));},consume:function(a){if(0===this.tokens.length)throw Ua(\"ueoe\",\nthis.text);var b=this.expect(a);b||this.throwError(\"is unexpected, expecting [\"+a+\"]\",this.peek());return b},peekToken:function(){if(0===this.tokens.length)throw Ua(\"ueoe\",this.text);return this.tokens[0]},peek:function(a,b,d,c){return this.peekAhead(0,a,b,d,c)},peekAhead:function(a,b,d,c,f){if(this.tokens.length>a){a=this.tokens[a];var e=a.text;if(e===b||e===d||e===c||e===f||!(b||d||c||f))return a}return!1},expect:function(a,b,d,c){return(a=this.peek(a,b,d,c))?(this.tokens.shift(),a):!1},selfReferential:{\"this\":{type:s.ThisExpression},\n$locals:{type:s.LocalsExpression}}};Dd.prototype={compile:function(a){var b=this;a=this.astBuilder.ast(a);this.state={nextId:0,filters:{},fn:{vars:[],body:[],own:{}},assign:{vars:[],body:[],own:{}},inputs:[]};V(a,b.$filter);var d=\"\",c;this.stage=\"assign\";if(c=Bd(a))this.state.computing=\"assign\",d=this.nextId(),this.recurse(c,d),this.return_(d),d=\"fn.assign=\"+this.generateFunction(\"assign\",\"s,v,l\");c=zd(a.body);b.stage=\"inputs\";q(c,function(a,c){var d=\"fn\"+c;b.state[d]={vars:[],body:[],own:{}};b.state.computing=\nd;var h=b.nextId();b.recurse(a,h);b.return_(h);b.state.inputs.push(d);a.watchId=c});this.state.computing=\"fn\";this.stage=\"main\";this.recurse(a);d='\"'+this.USE+\" \"+this.STRICT+'\";\\n'+this.filterPrefix()+\"var fn=\"+this.generateFunction(\"fn\",\"s,l,a,i\")+d+this.watchFns()+\"return fn;\";d=(new Function(\"$filter\",\"getStringValue\",\"ifDefined\",\"plus\",d))(this.$filter,ug,vg,yd);this.state=this.stage=void 0;d.literal=Cd(a);d.constant=a.constant;return d},USE:\"use\",STRICT:\"strict\",watchFns:function(){var a=[],\nb=this.state.inputs,d=this;q(b,function(b){a.push(\"var \"+b+\"=\"+d.generateFunction(b,\"s\"))});b.length&&a.push(\"fn.inputs=[\"+b.join(\",\")+\"];\");return a.join(\"\")},generateFunction:function(a,b){return\"function(\"+b+\"){\"+this.varsPrefix(a)+this.body(a)+\"};\"},filterPrefix:function(){var a=[],b=this;q(this.state.filters,function(d,c){a.push(d+\"=$filter(\"+b.escape(c)+\")\")});return a.length?\"var \"+a.join(\",\")+\";\":\"\"},varsPrefix:function(a){return this.state[a].vars.length?\"var \"+this.state[a].vars.join(\",\")+\n\";\":\"\"},body:function(a){return this.state[a].body.join(\"\")},recurse:function(a,b,d,c,f,e){var g,h,k=this,l,m,n;c=c||w;if(!e&&v(a.watchId))b=b||this.nextId(),this.if_(\"i\",this.lazyAssign(b,this.computedMember(\"i\",a.watchId)),this.lazyRecurse(a,b,d,c,f,!0));else switch(a.type){case s.Program:q(a.body,function(b,c){k.recurse(b.expression,void 0,void 0,function(a){h=a});c!==a.body.length-1?k.current().body.push(h,\";\"):k.return_(h)});break;case s.Literal:m=this.escape(a.value);this.assign(b,m);c(b||m);\nbreak;case s.UnaryExpression:this.recurse(a.argument,void 0,void 0,function(a){h=a});m=a.operator+\"(\"+this.ifDefined(h,0)+\")\";this.assign(b,m);c(m);break;case s.BinaryExpression:this.recurse(a.left,void 0,void 0,function(a){g=a});this.recurse(a.right,void 0,void 0,function(a){h=a});m=\"+\"===a.operator?this.plus(g,h):\"-\"===a.operator?this.ifDefined(g,0)+a.operator+this.ifDefined(h,0):\"(\"+g+\")\"+a.operator+\"(\"+h+\")\";this.assign(b,m);c(m);break;case s.LogicalExpression:b=b||this.nextId();k.recurse(a.left,\nb);k.if_(\"&&\"===a.operator?b:k.not(b),k.lazyRecurse(a.right,b));c(b);break;case s.ConditionalExpression:b=b||this.nextId();k.recurse(a.test,b);k.if_(b,k.lazyRecurse(a.alternate,b),k.lazyRecurse(a.consequent,b));c(b);break;case s.Identifier:b=b||this.nextId();d&&(d.context=\"inputs\"===k.stage?\"s\":this.assign(this.nextId(),this.getHasOwnProperty(\"l\",a.name)+\"?l:s\"),d.computed=!1,d.name=a.name);k.if_(\"inputs\"===k.stage||k.not(k.getHasOwnProperty(\"l\",a.name)),function(){k.if_(\"inputs\"===k.stage||\"s\",function(){f&&\n1!==f&&k.if_(k.isNull(k.nonComputedMember(\"s\",a.name)),k.lazyAssign(k.nonComputedMember(\"s\",a.name),\"{}\"));k.assign(b,k.nonComputedMember(\"s\",a.name))})},b&&k.lazyAssign(b,k.nonComputedMember(\"l\",a.name)));c(b);break;case s.MemberExpression:g=d&&(d.context=this.nextId())||this.nextId();b=b||this.nextId();k.recurse(a.object,g,void 0,function(){k.if_(k.notNull(g),function(){a.computed?(h=k.nextId(),k.recurse(a.property,h),k.getStringValue(h),f&&1!==f&&k.if_(k.not(k.computedMember(g,h)),k.lazyAssign(k.computedMember(g,\nh),\"{}\")),m=k.computedMember(g,h),k.assign(b,m),d&&(d.computed=!0,d.name=h)):(f&&1!==f&&k.if_(k.isNull(k.nonComputedMember(g,a.property.name)),k.lazyAssign(k.nonComputedMember(g,a.property.name),\"{}\")),m=k.nonComputedMember(g,a.property.name),k.assign(b,m),d&&(d.computed=!1,d.name=a.property.name))},function(){k.assign(b,\"undefined\")});c(b)},!!f);break;case s.CallExpression:b=b||this.nextId();a.filter?(h=k.filter(a.callee.name),l=[],q(a.arguments,function(a){var b=k.nextId();k.recurse(a,b);l.push(b)}),\nm=h+\"(\"+l.join(\",\")+\")\",k.assign(b,m),c(b)):(h=k.nextId(),g={},l=[],k.recurse(a.callee,h,g,function(){k.if_(k.notNull(h),function(){q(a.arguments,function(b){k.recurse(b,a.constant?void 0:k.nextId(),void 0,function(a){l.push(a)})});m=g.name?k.member(g.context,g.name,g.computed)+\"(\"+l.join(\",\")+\")\":h+\"(\"+l.join(\",\")+\")\";k.assign(b,m)},function(){k.assign(b,\"undefined\")});c(b)}));break;case s.AssignmentExpression:h=this.nextId();g={};this.recurse(a.left,void 0,g,function(){k.if_(k.notNull(g.context),\nfunction(){k.recurse(a.right,h);m=k.member(g.context,g.name,g.computed)+a.operator+h;k.assign(b,m);c(b||m)})},1);break;case s.ArrayExpression:l=[];q(a.elements,function(b){k.recurse(b,a.constant?void 0:k.nextId(),void 0,function(a){l.push(a)})});m=\"[\"+l.join(\",\")+\"]\";this.assign(b,m);c(b||m);break;case s.ObjectExpression:l=[];n=!1;q(a.properties,function(a){a.computed&&(n=!0)});n?(b=b||this.nextId(),this.assign(b,\"{}\"),q(a.properties,function(a){a.computed?(g=k.nextId(),k.recurse(a.key,g)):g=a.key.type===\ns.Identifier?a.key.name:\"\"+a.key.value;h=k.nextId();k.recurse(a.value,h);k.assign(k.member(b,g,a.computed),h)})):(q(a.properties,function(b){k.recurse(b.value,a.constant?void 0:k.nextId(),void 0,function(a){l.push(k.escape(b.key.type===s.Identifier?b.key.name:\"\"+b.key.value)+\":\"+a)})}),m=\"{\"+l.join(\",\")+\"}\",this.assign(b,m));c(b||m);break;case s.ThisExpression:this.assign(b,\"s\");c(b||\"s\");break;case s.LocalsExpression:this.assign(b,\"l\");c(b||\"l\");break;case s.NGValueParameter:this.assign(b,\"v\"),c(b||\n\"v\")}},getHasOwnProperty:function(a,b){var d=a+\".\"+b,c=this.current().own;c.hasOwnProperty(d)||(c[d]=this.nextId(!1,a+\"&&(\"+this.escape(b)+\" in \"+a+\")\"));return c[d]},assign:function(a,b){if(a)return this.current().body.push(a,\"=\",b,\";\"),a},filter:function(a){this.state.filters.hasOwnProperty(a)||(this.state.filters[a]=this.nextId(!0));return this.state.filters[a]},ifDefined:function(a,b){return\"ifDefined(\"+a+\",\"+this.escape(b)+\")\"},plus:function(a,b){return\"plus(\"+a+\",\"+b+\")\"},return_:function(a){this.current().body.push(\"return \",\na,\";\")},if_:function(a,b,d){if(!0===a)b();else{var c=this.current().body;c.push(\"if(\",a,\"){\");b();c.push(\"}\");d&&(c.push(\"else{\"),d(),c.push(\"}\"))}},not:function(a){return\"!(\"+a+\")\"},isNull:function(a){return a+\"==null\"},notNull:function(a){return a+\"!=null\"},nonComputedMember:function(a,b){var d=/[^$_a-zA-Z0-9]/g;return/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(b)?a+\".\"+b:a+'[\"'+b.replace(d,this.stringEscapeFn)+'\"]'},computedMember:function(a,b){return a+\"[\"+b+\"]\"},member:function(a,b,d){return d?this.computedMember(a,\nb):this.nonComputedMember(a,b)},getStringValue:function(a){this.assign(a,\"getStringValue(\"+a+\")\")},lazyRecurse:function(a,b,d,c,f,e){var g=this;return function(){g.recurse(a,b,d,c,f,e)}},lazyAssign:function(a,b){var d=this;return function(){d.assign(a,b)}},stringEscapeRegex:/[^ a-zA-Z0-9]/g,stringEscapeFn:function(a){return\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)},escape:function(a){if(E(a))return\"'\"+a.replace(this.stringEscapeRegex,this.stringEscapeFn)+\"'\";if(Y(a))return a.toString();\nif(!0===a)return\"true\";if(!1===a)return\"false\";if(null===a)return\"null\";if(\"undefined\"===typeof a)return\"undefined\";throw Ua(\"esc\");},nextId:function(a,b){var d=\"v\"+this.state.nextId++;a||this.current().vars.push(d+(b?\"=\"+b:\"\"));return d},current:function(){return this.state[this.state.computing]}};Ed.prototype={compile:function(a){var b=this;a=this.astBuilder.ast(a);V(a,b.$filter);var d,c;if(d=Bd(a))c=this.recurse(d);d=zd(a.body);var f;d&&(f=[],q(d,function(a,c){var d=b.recurse(a);a.input=d;f.push(d);\na.watchId=c}));var e=[];q(a.body,function(a){e.push(b.recurse(a.expression))});d=0===a.body.length?w:1===a.body.length?e[0]:function(a,b){var c;q(e,function(d){c=d(a,b)});return c};c&&(d.assign=function(a,b,d){return c(a,d,b)});f&&(d.inputs=f);d.literal=Cd(a);d.constant=a.constant;return d},recurse:function(a,b,d){var c,f,e=this,g;if(a.input)return this.inputs(a.input,a.watchId);switch(a.type){case s.Literal:return this.value(a.value,b);case s.UnaryExpression:return f=this.recurse(a.argument),this[\"unary\"+\na.operator](f,b);case s.BinaryExpression:return c=this.recurse(a.left),f=this.recurse(a.right),this[\"binary\"+a.operator](c,f,b);case s.LogicalExpression:return c=this.recurse(a.left),f=this.recurse(a.right),this[\"binary\"+a.operator](c,f,b);case s.ConditionalExpression:return this[\"ternary?:\"](this.recurse(a.test),this.recurse(a.alternate),this.recurse(a.consequent),b);case s.Identifier:return e.identifier(a.name,b,d);case s.MemberExpression:return c=this.recurse(a.object,!1,!!d),a.computed||(f=a.property.name),\na.computed&&(f=this.recurse(a.property)),a.computed?this.computedMember(c,f,b,d):this.nonComputedMember(c,f,b,d);case s.CallExpression:return g=[],q(a.arguments,function(a){g.push(e.recurse(a))}),a.filter&&(f=this.$filter(a.callee.name)),a.filter||(f=this.recurse(a.callee,!0)),a.filter?function(a,c,d,e){for(var n=[],p=0;p<g.length;++p)n.push(g[p](a,c,d,e));a=f.apply(void 0,n,e);return b?{context:void 0,name:void 0,value:a}:a}:function(a,c,d,e){var n=f(a,c,d,e),p;if(null!=n.value){p=[];for(var r=0;r<\ng.length;++r)p.push(g[r](a,c,d,e));p=n.value.apply(n.context,p)}return b?{value:p}:p};case s.AssignmentExpression:return c=this.recurse(a.left,!0,1),f=this.recurse(a.right),function(a,d,e,g){var n=c(a,d,e,g);a=f(a,d,e,g);n.context[n.name]=a;return b?{value:a}:a};case s.ArrayExpression:return g=[],q(a.elements,function(a){g.push(e.recurse(a))}),function(a,c,d,e){for(var f=[],p=0;p<g.length;++p)f.push(g[p](a,c,d,e));return b?{value:f}:f};case s.ObjectExpression:return g=[],q(a.properties,function(a){a.computed?\ng.push({key:e.recurse(a.key),computed:!0,value:e.recurse(a.value)}):g.push({key:a.key.type===s.Identifier?a.key.name:\"\"+a.key.value,computed:!1,value:e.recurse(a.value)})}),function(a,c,d,e){for(var f={},p=0;p<g.length;++p)g[p].computed?f[g[p].key(a,c,d,e)]=g[p].value(a,c,d,e):f[g[p].key]=g[p].value(a,c,d,e);return b?{value:f}:f};case s.ThisExpression:return function(a){return b?{value:a}:a};case s.LocalsExpression:return function(a,c){return b?{value:c}:c};case s.NGValueParameter:return function(a,\nc,d){return b?{value:d}:d}}},\"unary+\":function(a,b){return function(d,c,f,e){d=a(d,c,f,e);d=v(d)?+d:0;return b?{value:d}:d}},\"unary-\":function(a,b){return function(d,c,f,e){d=a(d,c,f,e);d=v(d)?-d:-0;return b?{value:d}:d}},\"unary!\":function(a,b){return function(d,c,f,e){d=!a(d,c,f,e);return b?{value:d}:d}},\"binary+\":function(a,b,d){return function(c,f,e,g){var h=a(c,f,e,g);c=b(c,f,e,g);h=yd(h,c);return d?{value:h}:h}},\"binary-\":function(a,b,d){return function(c,f,e,g){var h=a(c,f,e,g);c=b(c,f,e,g);\nh=(v(h)?h:0)-(v(c)?c:0);return d?{value:h}:h}},\"binary*\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)*b(c,f,e,g);return d?{value:c}:c}},\"binary/\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)/b(c,f,e,g);return d?{value:c}:c}},\"binary%\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)%b(c,f,e,g);return d?{value:c}:c}},\"binary===\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)===b(c,f,e,g);return d?{value:c}:c}},\"binary!==\":function(a,b,d){return function(c,f,e,g){c=a(c,\nf,e,g)!==b(c,f,e,g);return d?{value:c}:c}},\"binary==\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)==b(c,f,e,g);return d?{value:c}:c}},\"binary!=\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)!=b(c,f,e,g);return d?{value:c}:c}},\"binary<\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)<b(c,f,e,g);return d?{value:c}:c}},\"binary>\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)>b(c,f,e,g);return d?{value:c}:c}},\"binary<=\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,\ng)<=b(c,f,e,g);return d?{value:c}:c}},\"binary>=\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)>=b(c,f,e,g);return d?{value:c}:c}},\"binary&&\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)&&b(c,f,e,g);return d?{value:c}:c}},\"binary||\":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)||b(c,f,e,g);return d?{value:c}:c}},\"ternary?:\":function(a,b,d,c){return function(f,e,g,h){f=a(f,e,g,h)?b(f,e,g,h):d(f,e,g,h);return c?{value:f}:f}},value:function(a,b){return function(){return b?{context:void 0,\nname:void 0,value:a}:a}},identifier:function(a,b,d){return function(c,f,e,g){c=f&&a in f?f:c;d&&1!==d&&c&&null==c[a]&&(c[a]={});f=c?c[a]:void 0;return b?{context:c,name:a,value:f}:f}},computedMember:function(a,b,d,c){return function(f,e,g,h){var k=a(f,e,g,h),l,m;null!=k&&(l=b(f,e,g,h),l+=\"\",c&&1!==c&&k&&!k[l]&&(k[l]={}),m=k[l]);return d?{context:k,name:l,value:m}:m}},nonComputedMember:function(a,b,d,c){return function(f,e,g,h){f=a(f,e,g,h);c&&1!==c&&f&&null==f[b]&&(f[b]={});e=null!=f?f[b]:void 0;\nreturn d?{context:f,name:b,value:e}:e}},inputs:function(a,b){return function(d,c,f,e){return e?e[b]:a(d,c,f)}}};var rc=function(a,b,d){this.lexer=a;this.$filter=b;this.options=d;this.ast=new s(a,d);this.astCompiler=d.csp?new Ed(this.ast,b):new Dd(this.ast,b)};rc.prototype={constructor:rc,parse:function(a){return this.astCompiler.compile(a)}};var ua=M(\"$sce\"),pa={HTML:\"html\",CSS:\"css\",URL:\"url\",RESOURCE_URL:\"resourceUrl\",JS:\"js\"},sc=/_([a-z])/g,yg=M(\"$compile\"),ca=z.document.createElement(\"a\"),Id=\nDa(z.location.href);Jd.$inject=[\"$document\"];Xc.$inject=[\"$provide\"];var Qd=22,Pd=\".\",uc=\"0\";Kd.$inject=[\"$locale\"];Md.$inject=[\"$locale\"];var Jg={yyyy:aa(\"FullYear\",4,0,!1,!0),yy:aa(\"FullYear\",2,0,!0,!0),y:aa(\"FullYear\",1,0,!1,!0),MMMM:nb(\"Month\"),MMM:nb(\"Month\",!0),MM:aa(\"Month\",2,1),M:aa(\"Month\",1,1),LLLL:nb(\"Month\",!1,!0),dd:aa(\"Date\",2),d:aa(\"Date\",1),HH:aa(\"Hours\",2),H:aa(\"Hours\",1),hh:aa(\"Hours\",2,-12),h:aa(\"Hours\",1,-12),mm:aa(\"Minutes\",2),m:aa(\"Minutes\",1),ss:aa(\"Seconds\",2),s:aa(\"Seconds\",\n1),sss:aa(\"Milliseconds\",3),EEEE:nb(\"Day\"),EEE:nb(\"Day\",!0),a:function(a,b){return 12>a.getHours()?b.AMPMS[0]:b.AMPMS[1]},Z:function(a,b,d){a=-1*d;return a=(0<=a?\"+\":\"\")+(Kb(Math[0<a?\"floor\":\"ceil\"](a/60),2)+Kb(Math.abs(a%60),2))},ww:Sd(2),w:Sd(1),G:vc,GG:vc,GGG:vc,GGGG:function(a,b){return 0>=a.getFullYear()?b.ERANAMES[0]:b.ERANAMES[1]}},Ig=/((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,Hg=/^-?\\d+$/;Ld.$inject=[\"$locale\"];var Cg=ma(P),Dg=ma(vb);Nd.$inject=\n[\"$parse\"];var Ae=ma({restrict:\"E\",compile:function(a,b){if(!b.href&&!b.xlinkHref)return function(a,b){if(\"a\"===b[0].nodeName.toLowerCase()){var f=\"[object SVGAnimatedString]\"===na.call(b.prop(\"href\"))?\"xlink:href\":\"href\";b.on(\"click\",function(a){b.attr(f)||a.preventDefault()})}}}}),wb={};q(Gb,function(a,b){function d(a,d,f){a.$watch(f[c],function(a){f.$set(b,!!a)})}if(\"multiple\"!==a){var c=Ca(\"ng-\"+b),f=d;\"checked\"===a&&(f=function(a,b,f){f.ngModel!==f[c]&&d(a,b,f)});wb[c]=function(){return{restrict:\"A\",\npriority:100,link:f}}}});q(ld,function(a,b){wb[b]=function(){return{priority:100,link:function(a,c,f){if(\"ngPattern\"===b&&\"/\"===f.ngPattern.charAt(0)&&(c=f.ngPattern.match(Ng))){f.$set(\"ngPattern\",new RegExp(c[1],c[2]));return}a.$watch(f[b],function(a){f.$set(b,a)})}}}});q([\"src\",\"srcset\",\"href\"],function(a){var b=Ca(\"ng-\"+a);wb[b]=function(){return{priority:99,link:function(d,c,f){var e=a,g=a;\"href\"===a&&\"[object SVGAnimatedString]\"===na.call(c.prop(\"href\"))&&(g=\"xlinkHref\",f.$attr[g]=\"xlink:href\",\ne=null);f.$observe(b,function(b){b?(f.$set(g,b),La&&e&&c.prop(e,f[g])):\"href\"===a&&f.$set(g,null)})}}}});var Mb={$addControl:w,$$renameControl:function(a,b){a.$name=b},$removeControl:w,$setValidity:w,$setDirty:w,$setPristine:w,$setSubmitted:w};Lb.$inject=[\"$element\",\"$attrs\",\"$scope\",\"$animate\",\"$interpolate\"];Lb.prototype={$rollbackViewValue:function(){q(this.$$controls,function(a){a.$rollbackViewValue()})},$commitViewValue:function(){q(this.$$controls,function(a){a.$commitViewValue()})},$addControl:function(a){Pa(a.$name,\n\"input\");this.$$controls.push(a);a.$name&&(this[a.$name]=a);a.$$parentForm=this},$$renameControl:function(a,b){var d=a.$name;this[d]===a&&delete this[d];this[b]=a;a.$name=b},$removeControl:function(a){a.$name&&this[a.$name]===a&&delete this[a.$name];q(this.$pending,function(b,d){this.$setValidity(d,null,a)},this);q(this.$error,function(b,d){this.$setValidity(d,null,a)},this);q(this.$$success,function(b,d){this.$setValidity(d,null,a)},this);$a(this.$$controls,a);a.$$parentForm=Mb},$setDirty:function(){this.$$animate.removeClass(this.$$element,\nVa);this.$$animate.addClass(this.$$element,Rb);this.$dirty=!0;this.$pristine=!1;this.$$parentForm.$setDirty()},$setPristine:function(){this.$$animate.setClass(this.$$element,Va,Rb+\" ng-submitted\");this.$dirty=!1;this.$pristine=!0;this.$submitted=!1;q(this.$$controls,function(a){a.$setPristine()})},$setUntouched:function(){q(this.$$controls,function(a){a.$setUntouched()})},$setSubmitted:function(){this.$$animate.addClass(this.$$element,\"ng-submitted\");this.$submitted=!0;this.$$parentForm.$setSubmitted()}};\nVd({clazz:Lb,set:function(a,b,d){var c=a[b];c?-1===c.indexOf(d)&&c.push(d):a[b]=[d]},unset:function(a,b,d){var c=a[b];c&&($a(c,d),0===c.length&&delete a[b])}});var ce=function(a){return[\"$timeout\",\"$parse\",function(b,d){function c(a){return\"\"===a?d('this[\"\"]').assign:d(a).assign||w}return{name:\"form\",restrict:a?\"EAC\":\"E\",require:[\"form\",\"^^?form\"],controller:Lb,compile:function(d,e){d.addClass(Va).addClass(ob);var g=e.name?\"name\":a&&e.ngForm?\"ngForm\":!1;return{pre:function(a,d,e,f){var n=f[0];if(!(\"action\"in\ne)){var p=function(b){a.$apply(function(){n.$commitViewValue();n.$setSubmitted()});b.preventDefault()};d[0].addEventListener(\"submit\",p);d.on(\"$destroy\",function(){b(function(){d[0].removeEventListener(\"submit\",p)},0,!1)})}(f[1]||n.$$parentForm).$addControl(n);var r=g?c(n.$name):w;g&&(r(a,n),e.$observe(g,function(b){n.$name!==b&&(r(a,void 0),n.$$parentForm.$$renameControl(n,b),r=c(n.$name),r(a,n))}));d.on(\"$destroy\",function(){n.$$parentForm.$removeControl(n);r(a,void 0);R(n,Mb)})}}}}}]},Be=ce(),\nNe=ce(!0),Kg=/^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/,Vg=/^[a-z][a-z\\d.+-]*:\\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\\s:/?#]+|\\[[a-f\\d:]+])(?::\\d+)?(?:\\/[^?#]*)?(?:\\?[^#]*)?(?:#.*)?$/i,Wg=/^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/,Lg=/^\\s*(-|\\+)?(\\d+|(\\d*(\\.\\d*)))([eE][+-]?\\d+)?\\s*$/,de=/^(\\d{4,})-(\\d{2})-(\\d{2})$/,ee=/^(\\d{4,})-(\\d\\d)-(\\d\\d)T(\\d\\d):(\\d\\d)(?::(\\d\\d)(\\.\\d{1,3})?)?$/,\nCc=/^(\\d{4,})-W(\\d\\d)$/,fe=/^(\\d{4,})-(\\d\\d)$/,ge=/^(\\d\\d):(\\d\\d)(?::(\\d\\d)(\\.\\d{1,3})?)?$/,Xd=W();q([\"date\",\"datetime-local\",\"month\",\"time\",\"week\"],function(a){Xd[a]=!0});var he={text:function(a,b,d,c,f,e){Sa(a,b,d,c,f,e);xc(c)},date:pb(\"date\",de,Nb(de,[\"yyyy\",\"MM\",\"dd\"]),\"yyyy-MM-dd\"),\"datetime-local\":pb(\"datetimelocal\",ee,Nb(ee,\"yyyy MM dd HH mm ss sss\".split(\" \")),\"yyyy-MM-ddTHH:mm:ss.sss\"),time:pb(\"time\",ge,Nb(ge,[\"HH\",\"mm\",\"ss\",\"sss\"]),\"HH:mm:ss.sss\"),week:pb(\"week\",Cc,function(a,b){if(fa(a))return a;\nif(E(a)){Cc.lastIndex=0;var d=Cc.exec(a);if(d){var c=+d[1],f=+d[2],e=d=0,g=0,h=0,k=Rd(c),f=7*(f-1);b&&(d=b.getHours(),e=b.getMinutes(),g=b.getSeconds(),h=b.getMilliseconds());return new Date(c,0,k.getDate()+f,d,e,g,h)}}return NaN},\"yyyy-Www\"),month:pb(\"month\",fe,Nb(fe,[\"yyyy\",\"MM\"]),\"yyyy-MM\"),number:function(a,b,d,c,f,e){yc(a,b,d,c);Yd(c);Sa(a,b,d,c,f,e);var g,h;if(v(d.min)||d.ngMin)c.$validators.min=function(a){return c.$isEmpty(a)||x(g)||a>=g},d.$observe(\"min\",function(a){g=Ta(a);c.$validate()});\nif(v(d.max)||d.ngMax)c.$validators.max=function(a){return c.$isEmpty(a)||x(h)||a<=h},d.$observe(\"max\",function(a){h=Ta(a);c.$validate()});if(v(d.step)||d.ngStep){var k;c.$validators.step=function(a,b){return c.$isEmpty(b)||x(k)||Zd(b,g||0,k)};d.$observe(\"step\",function(a){k=Ta(a);c.$validate()})}},url:function(a,b,d,c,f,e){Sa(a,b,d,c,f,e);xc(c);c.$$parserName=\"url\";c.$validators.url=function(a,b){var d=a||b;return c.$isEmpty(d)||Vg.test(d)}},email:function(a,b,d,c,f,e){Sa(a,b,d,c,f,e);xc(c);c.$$parserName=\n\"email\";c.$validators.email=function(a,b){var d=a||b;return c.$isEmpty(d)||Wg.test(d)}},radio:function(a,b,d,c){var f=!d.ngTrim||\"false\"!==S(d.ngTrim);x(d.name)&&b.attr(\"name\",++rb);b.on(\"click\",function(a){var g;b[0].checked&&(g=d.value,f&&(g=S(g)),c.$setViewValue(g,a&&a.type))});c.$render=function(){var a=d.value;f&&(a=S(a));b[0].checked=a===c.$viewValue};d.$observe(\"value\",c.$render)},range:function(a,b,d,c,f,e){function g(a,c){b.attr(a,d[a]);d.$observe(a,c)}function h(a){n=Ta(a);ga(c.$modelValue)||\n(m?(a=b.val(),n>a&&(a=n,b.val(a)),c.$setViewValue(a)):c.$validate())}function k(a){p=Ta(a);ga(c.$modelValue)||(m?(a=b.val(),p<a&&(b.val(p),a=p<n?n:p),c.$setViewValue(a)):c.$validate())}function l(a){r=Ta(a);ga(c.$modelValue)||(m&&c.$viewValue!==b.val()?c.$setViewValue(b.val()):c.$validate())}yc(a,b,d,c);Yd(c);Sa(a,b,d,c,f,e);var m=c.$$hasNativeValidators&&\"range\"===b[0].type,n=m?0:void 0,p=m?100:void 0,r=m?1:void 0,q=b[0].validity;a=v(d.min);f=v(d.max);e=v(d.step);var s=c.$render;c.$render=m&&v(q.rangeUnderflow)&&\nv(q.rangeOverflow)?function(){s();c.$setViewValue(b.val())}:s;a&&(c.$validators.min=m?function(){return!0}:function(a,b){return c.$isEmpty(b)||x(n)||b>=n},g(\"min\",h));f&&(c.$validators.max=m?function(){return!0}:function(a,b){return c.$isEmpty(b)||x(p)||b<=p},g(\"max\",k));e&&(c.$validators.step=m?function(){return!q.stepMismatch}:function(a,b){return c.$isEmpty(b)||x(r)||Zd(b,n||0,r)},g(\"step\",l))},checkbox:function(a,b,d,c,f,e,g,h){var k=$d(h,a,\"ngTrueValue\",d.ngTrueValue,!0),l=$d(h,a,\"ngFalseValue\",\nd.ngFalseValue,!1);b.on(\"click\",function(a){c.$setViewValue(b[0].checked,a&&a.type)});c.$render=function(){b[0].checked=c.$viewValue};c.$isEmpty=function(a){return!1===a};c.$formatters.push(function(a){return qa(a,k)});c.$parsers.push(function(a){return a?k:l})},hidden:w,button:w,submit:w,reset:w,file:w},Rc=[\"$browser\",\"$sniffer\",\"$filter\",\"$parse\",function(a,b,d,c){return{restrict:\"E\",require:[\"?ngModel\"],link:{pre:function(f,e,g,h){h[0]&&(he[P(g.type)]||he.text)(f,e,g,h[0],b,a,d,c)}}}}],Xg=/^(true|false|\\d+)$/,\nef=function(){return{restrict:\"A\",priority:100,compile:function(a,b){return Xg.test(b.ngValue)?function(a,b,f){a=a.$eval(f.ngValue);b.prop(\"value\",a);f.$set(\"value\",a)}:function(a,b,f){a.$watch(f.ngValue,function(a){b.prop(\"value\",a);f.$set(\"value\",a)})}}}},Fe=[\"$compile\",function(a){return{restrict:\"AC\",compile:function(b){a.$$addBindingClass(b);return function(b,c,f){a.$$addBindingInfo(c,f.ngBind);c=c[0];b.$watch(f.ngBind,function(a){c.textContent=Yb(a)})}}}}],He=[\"$interpolate\",\"$compile\",function(a,\nb){return{compile:function(d){b.$$addBindingClass(d);return function(c,d,e){c=a(d.attr(e.$attr.ngBindTemplate));b.$$addBindingInfo(d,c.expressions);d=d[0];e.$observe(\"ngBindTemplate\",function(a){d.textContent=x(a)?\"\":a})}}}}],Ge=[\"$sce\",\"$parse\",\"$compile\",function(a,b,d){return{restrict:\"A\",compile:function(c,f){var e=b(f.ngBindHtml),g=b(f.ngBindHtml,function(b){return a.valueOf(b)});d.$$addBindingClass(c);return function(b,c,f){d.$$addBindingInfo(c,f.ngBindHtml);b.$watch(g,function(){var d=e(b);\nc.html(a.getTrustedHtml(d)||\"\")})}}}}],df=ma({restrict:\"A\",require:\"ngModel\",link:function(a,b,d,c){c.$viewChangeListeners.push(function(){a.$eval(d.ngChange)})}}),Ie=Ac(\"\",!0),Ke=Ac(\"Odd\",0),Je=Ac(\"Even\",1),Le=Ra({compile:function(a,b){b.$set(\"ngCloak\",void 0);a.removeClass(\"ng-cloak\")}}),Me=[function(){return{restrict:\"A\",scope:!0,controller:\"@\",priority:500}}],Wc={},Yg={blur:!0,focus:!0};q(\"click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste\".split(\" \"),\nfunction(a){var b=Ca(\"ng-\"+a);Wc[b]=[\"$parse\",\"$rootScope\",function(d,c){return{restrict:\"A\",compile:function(f,e){var g=d(e[b],null,!0);return function(b,d){d.on(a,function(d){var e=function(){g(b,{$event:d})};Yg[a]&&c.$$phase?b.$evalAsync(e):b.$apply(e)})}}}}]});var Pe=[\"$animate\",\"$compile\",function(a,b){return{multiElement:!0,transclude:\"element\",priority:600,terminal:!0,restrict:\"A\",$$tlb:!0,link:function(d,c,f,e,g){var h,k,l;d.$watch(f.ngIf,function(d){d?k||g(function(d,e){k=e;d[d.length++]=\nb.$$createComment(\"end ngIf\",f.ngIf);h={clone:d};a.enter(d,c.parent(),c)}):(l&&(l.remove(),l=null),k&&(k.$destroy(),k=null),h&&(l=ub(h.clone),a.leave(l).done(function(a){!1!==a&&(l=null)}),h=null))})}}}],Qe=[\"$templateRequest\",\"$anchorScroll\",\"$animate\",function(a,b,d){return{restrict:\"ECA\",priority:400,terminal:!0,transclude:\"element\",controller:$.noop,compile:function(c,f){var e=f.ngInclude||f.src,g=f.onload||\"\",h=f.autoscroll;return function(c,f,m,n,p){var q=0,s,w,u,H=function(){w&&(w.remove(),\nw=null);s&&(s.$destroy(),s=null);u&&(d.leave(u).done(function(a){!1!==a&&(w=null)}),w=u,u=null)};c.$watch(e,function(e){var m=function(a){!1===a||!v(h)||h&&!c.$eval(h)||b()},w=++q;e?(a(e,!0).then(function(a){if(!c.$$destroyed&&w===q){var b=c.$new();n.template=a;a=p(b,function(a){H();d.enter(a,null,f).done(m)});s=b;u=a;s.$emit(\"$includeContentLoaded\",e);c.$eval(g)}},function(){c.$$destroyed||w!==q||(H(),c.$emit(\"$includeContentError\",e))}),c.$emit(\"$includeContentRequested\",e)):(H(),n.template=null)})}}}}],\ngf=[\"$compile\",function(a){return{restrict:\"ECA\",priority:-400,require:\"ngInclude\",link:function(b,d,c,f){na.call(d[0]).match(/SVG/)?(d.empty(),a(Zc(f.template,z.document).childNodes)(b,function(a){d.append(a)},{futureParentElement:d})):(d.html(f.template),a(d.contents())(b))}}}],Re=Ra({priority:450,compile:function(){return{pre:function(a,b,d){a.$eval(d.ngInit)}}}}),cf=function(){return{restrict:\"A\",priority:100,require:\"ngModel\",link:function(a,b,d,c){var f=d.ngList||\", \",e=\"false\"!==d.ngTrim,g=\ne?S(f):f;c.$parsers.push(function(a){if(!x(a)){var b=[];a&&q(a.split(g),function(a){a&&b.push(e?S(a):a)});return b}});c.$formatters.push(function(a){if(C(a))return a.join(f)});c.$isEmpty=function(a){return!a||!a.length}}}},ob=\"ng-valid\",Ud=\"ng-invalid\",Va=\"ng-pristine\",Rb=\"ng-dirty\",qb=M(\"ngModel\");Ob.$inject=\"$scope $exceptionHandler $attrs $element $parse $animate $timeout $q $interpolate\".split(\" \");Ob.prototype={$$initGetterSetters:function(){if(this.$options.getOption(\"getterSetter\")){var a=\nthis.$$parse(this.$$attr.ngModel+\"()\"),b=this.$$parse(this.$$attr.ngModel+\"($$$p)\");this.$$ngModelGet=function(b){var c=this.$$parsedNgModel(b);y(c)&&(c=a(b));return c};this.$$ngModelSet=function(a,c){y(this.$$parsedNgModel(a))?b(a,{$$$p:c}):this.$$parsedNgModelAssign(a,c)}}else if(!this.$$parsedNgModel.assign)throw qb(\"nonassign\",this.$$attr.ngModel,ya(this.$$element));},$render:w,$isEmpty:function(a){return x(a)||\"\"===a||null===a||a!==a},$$updateEmptyClasses:function(a){this.$isEmpty(a)?(this.$$animate.removeClass(this.$$element,\n\"ng-not-empty\"),this.$$animate.addClass(this.$$element,\"ng-empty\")):(this.$$animate.removeClass(this.$$element,\"ng-empty\"),this.$$animate.addClass(this.$$element,\"ng-not-empty\"))},$setPristine:function(){this.$dirty=!1;this.$pristine=!0;this.$$animate.removeClass(this.$$element,Rb);this.$$animate.addClass(this.$$element,Va)},$setDirty:function(){this.$dirty=!0;this.$pristine=!1;this.$$animate.removeClass(this.$$element,Va);this.$$animate.addClass(this.$$element,Rb);this.$$parentForm.$setDirty()},\n$setUntouched:function(){this.$touched=!1;this.$untouched=!0;this.$$animate.setClass(this.$$element,\"ng-untouched\",\"ng-touched\")},$setTouched:function(){this.$touched=!0;this.$untouched=!1;this.$$animate.setClass(this.$$element,\"ng-touched\",\"ng-untouched\")},$rollbackViewValue:function(){this.$$timeout.cancel(this.$$pendingDebounce);this.$viewValue=this.$$lastCommittedViewValue;this.$render()},$validate:function(){if(!ga(this.$modelValue)){var a=this.$$lastCommittedViewValue,b=this.$$rawModelValue,\nd=this.$valid,c=this.$modelValue,f=this.$options.getOption(\"allowInvalid\"),e=this;this.$$runValidators(b,a,function(a){f||d===a||(e.$modelValue=a?b:void 0,e.$modelValue!==c&&e.$$writeModelToScope())})}},$$runValidators:function(a,b,d){function c(){var c=!0;q(k.$validators,function(d,f){var g=Boolean(d(a,b));c=c&&g;e(f,g)});return c?!0:(q(k.$asyncValidators,function(a,b){e(b,null)}),!1)}function f(){var c=[],d=!0;q(k.$asyncValidators,function(f,g){var h=f(a,b);if(!h||!y(h.then))throw qb(\"nopromise\",\nh);e(g,void 0);c.push(h.then(function(){e(g,!0)},function(){d=!1;e(g,!1)}))});c.length?k.$$q.all(c).then(function(){g(d)},w):g(!0)}function e(a,b){h===k.$$currentValidationRunId&&k.$setValidity(a,b)}function g(a){h===k.$$currentValidationRunId&&d(a)}this.$$currentValidationRunId++;var h=this.$$currentValidationRunId,k=this;(function(){var a=k.$$parserName||\"parse\";if(x(k.$$parserValid))e(a,null);else return k.$$parserValid||(q(k.$validators,function(a,b){e(b,null)}),q(k.$asyncValidators,function(a,\nb){e(b,null)})),e(a,k.$$parserValid),k.$$parserValid;return!0})()?c()?f():g(!1):g(!1)},$commitViewValue:function(){var a=this.$viewValue;this.$$timeout.cancel(this.$$pendingDebounce);if(this.$$lastCommittedViewValue!==a||\"\"===a&&this.$$hasNativeValidators)this.$$updateEmptyClasses(a),this.$$lastCommittedViewValue=a,this.$pristine&&this.$setDirty(),this.$$parseAndValidate()},$$parseAndValidate:function(){var a=this.$$lastCommittedViewValue,b=this;if(this.$$parserValid=x(a)?void 0:!0)for(var d=0;d<\nthis.$parsers.length;d++)if(a=this.$parsers[d](a),x(a)){this.$$parserValid=!1;break}ga(this.$modelValue)&&(this.$modelValue=this.$$ngModelGet(this.$$scope));var c=this.$modelValue,f=this.$options.getOption(\"allowInvalid\");this.$$rawModelValue=a;f&&(this.$modelValue=a,b.$modelValue!==c&&b.$$writeModelToScope());this.$$runValidators(a,this.$$lastCommittedViewValue,function(d){f||(b.$modelValue=d?a:void 0,b.$modelValue!==c&&b.$$writeModelToScope())})},$$writeModelToScope:function(){this.$$ngModelSet(this.$$scope,\nthis.$modelValue);q(this.$viewChangeListeners,function(a){try{a()}catch(b){this.$$exceptionHandler(b)}},this)},$setViewValue:function(a,b){this.$viewValue=a;this.$options.getOption(\"updateOnDefault\")&&this.$$debounceViewValueCommit(b)},$$debounceViewValueCommit:function(a){var b=this.$options.getOption(\"debounce\");Y(b[a])?b=b[a]:Y(b[\"default\"])&&(b=b[\"default\"]);this.$$timeout.cancel(this.$$pendingDebounce);var d=this;0<b?this.$$pendingDebounce=this.$$timeout(function(){d.$commitViewValue()},b):this.$$scope.$root.$$phase?\nthis.$commitViewValue():this.$$scope.$apply(function(){d.$commitViewValue()})}};Vd({clazz:Ob,set:function(a,b){a[b]=!0},unset:function(a,b){delete a[b]}});var bf=[\"$rootScope\",function(a){return{restrict:\"A\",require:[\"ngModel\",\"^?form\",\"^?ngModelOptions\"],controller:Ob,priority:1,compile:function(b){b.addClass(Va).addClass(\"ng-untouched\").addClass(ob);return{pre:function(a,b,f,e){var g=e[0];b=e[1]||g.$$parentForm;if(e=e[2])g.$options=e.$options;g.$$initGetterSetters();b.$addControl(g);f.$observe(\"name\",\nfunction(a){g.$name!==a&&g.$$parentForm.$$renameControl(g,a)});a.$on(\"$destroy\",function(){g.$$parentForm.$removeControl(g)})},post:function(b,c,f,e){function g(){h.$setTouched()}var h=e[0];if(h.$options.getOption(\"updateOn\"))c.on(h.$options.getOption(\"updateOn\"),function(a){h.$$debounceViewValueCommit(a&&a.type)});c.on(\"blur\",function(){h.$touched||(a.$$phase?b.$evalAsync(g):b.$apply(g))})}}}}}],Pb,Zg=/(\\s+|^)default(\\s+|$)/;Bc.prototype={getOption:function(a){return this.$$options[a]},createChild:function(a){var b=\n!1;a=R({},a);q(a,function(d,c){\"$inherit\"===d?\"*\"===c?b=!0:(a[c]=this.$$options[c],\"updateOn\"===c&&(a.updateOnDefault=this.$$options.updateOnDefault)):\"updateOn\"===c&&(a.updateOnDefault=!1,a[c]=S(d.replace(Zg,function(){a.updateOnDefault=!0;return\" \"})))},this);b&&(delete a[\"*\"],ae(a,this.$$options));ae(a,Pb.$$options);return new Bc(a)}};Pb=new Bc({updateOn:\"\",updateOnDefault:!0,debounce:0,getterSetter:!1,allowInvalid:!1,timezone:null});var ff=function(){function a(a,d){this.$$attrs=a;this.$$scope=\nd}a.$inject=[\"$attrs\",\"$scope\"];a.prototype={$onInit:function(){var a=this.parentCtrl?this.parentCtrl.$options:Pb,d=this.$$scope.$eval(this.$$attrs.ngModelOptions);this.$options=a.createChild(d)}};return{restrict:\"A\",priority:10,require:{parentCtrl:\"?^^ngModelOptions\"},bindToController:!0,controller:a}},Se=Ra({terminal:!0,priority:1E3}),$g=M(\"ngOptions\"),ah=/^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+group\\s+by\\s+([\\s\\S]+?))?(?:\\s+disable\\s+when\\s+([\\s\\S]+?))?\\s+for\\s+(?:([$\\w][$\\w]*)|(?:\\(\\s*([$\\w][$\\w]*)\\s*,\\s*([$\\w][$\\w]*)\\s*\\)))\\s+in\\s+([\\s\\S]+?)(?:\\s+track\\s+by\\s+([\\s\\S]+?))?$/,\n$e=[\"$compile\",\"$document\",\"$parse\",function(a,b,d){function c(a,b,c){function e(a,b,c,d,f){this.selectValue=a;this.viewValue=b;this.label=c;this.group=d;this.disabled=f}function f(a){var b;if(!q&&ta(a))b=a;else{b=[];for(var c in a)a.hasOwnProperty(c)&&\"$\"!==c.charAt(0)&&b.push(c)}return b}var n=a.match(ah);if(!n)throw $g(\"iexp\",a,ya(b));var p=n[5]||n[7],q=n[6];a=/ as /.test(n[0])&&n[1];var s=n[9];b=d(n[2]?n[1]:p);var v=a&&d(a)||b,u=s&&d(s),w=s?function(a,b){return u(c,b)}:function(a){return la(a)},\nx=function(a,b){return w(a,B(a,b))},t=d(n[2]||n[1]),z=d(n[3]||\"\"),A=d(n[4]||\"\"),K=d(n[8]),I={},B=q?function(a,b){I[q]=b;I[p]=a;return I}:function(a){I[p]=a;return I};return{trackBy:s,getTrackByValue:x,getWatchables:d(K,function(a){var b=[];a=a||[];for(var d=f(a),e=d.length,g=0;g<e;g++){var h=a===d?g:d[g],l=a[h],h=B(l,h),l=w(l,h);b.push(l);if(n[2]||n[1])l=t(c,h),b.push(l);n[4]&&(h=A(c,h),b.push(h))}return b}),getOptions:function(){for(var a=[],b={},d=K(c)||[],g=f(d),h=g.length,n=0;n<h;n++){var p=d===\ng?n:g[n],q=B(d[p],p),r=v(c,q),p=w(r,q),u=t(c,q),I=z(c,q),q=A(c,q),r=new e(p,r,u,I,q);a.push(r);b[p]=r}return{items:a,selectValueMap:b,getOptionFromViewValue:function(a){return b[x(a)]},getViewValueFromOption:function(a){return s?Fa(a.viewValue):a.viewValue}}}}}var f=z.document.createElement(\"option\"),e=z.document.createElement(\"optgroup\");return{restrict:\"A\",terminal:!0,require:[\"select\",\"ngModel\"],link:{pre:function(a,b,c,d){d[0].registerOption=w},post:function(d,h,k,l){function m(a){var b=(a=t.getOptionFromViewValue(a))&&\na.element;b&&!b.selected&&(b.selected=!0);return a}function n(a,b){a.element=b;b.disabled=a.disabled;a.label!==b.label&&(b.label=a.label,b.textContent=a.label);b.value=a.selectValue}function p(){var a=t&&r.readValue();if(t)for(var b=t.items.length-1;0<=b;b--){var c=t.items[b];v(c.group)?Fb(c.element.parentNode):Fb(c.element)}t=y.getOptions();var d={};z&&h.prepend(r.emptyOption);t.items.forEach(function(a){var b;if(v(a.group)){b=d[a.group];b||(b=e.cloneNode(!1),A.appendChild(b),b.label=null===a.group?\n\"null\":a.group,d[a.group]=b);var c=f.cloneNode(!1)}else b=A,c=f.cloneNode(!1);b.appendChild(c);n(a,c)});h[0].appendChild(A);s.$render();s.$isEmpty(a)||(b=r.readValue(),(y.trackBy||w?qa(a,b):a===b)||(s.$setViewValue(b),s.$render()))}var r=l[0],s=l[1],w=k.multiple;l=0;for(var u=h.children(),x=u.length;l<x;l++)if(\"\"===u[l].value){r.hasEmptyOption=!0;r.emptyOption=u.eq(l);break}var z=!!r.emptyOption;D(f.cloneNode(!1)).val(\"?\");var t,y=c(k.ngOptions,h,d),A=b[0].createDocumentFragment();r.generateUnknownOptionValue=\nfunction(a){return\"?\"};w?(r.writeValue=function(a){var b=a&&a.map(m)||[];t.items.forEach(function(a){a.element.selected&&-1===Array.prototype.indexOf.call(b,a)&&(a.element.selected=!1)})},r.readValue=function(){var a=h.val()||[],b=[];q(a,function(a){(a=t.selectValueMap[a])&&!a.disabled&&b.push(t.getViewValueFromOption(a))});return b},y.trackBy&&d.$watchCollection(function(){if(C(s.$viewValue))return s.$viewValue.map(function(a){return y.getTrackByValue(a)})},function(){s.$render()})):(r.writeValue=\nfunction(a){var b=t.selectValueMap[h.val()],c=t.getOptionFromViewValue(a);b&&b.element.removeAttribute(\"selected\");c?(h[0].value!==c.selectValue&&(r.removeUnknownOption(),r.unselectEmptyOption(),h[0].value=c.selectValue,c.element.selected=!0),c.element.setAttribute(\"selected\",\"selected\")):z?r.selectEmptyOption():r.unknownOption.parent().length?r.updateUnknownOption(a):r.renderUnknownOption(a)},r.readValue=function(){var a=t.selectValueMap[h.val()];return a&&!a.disabled?(r.unselectEmptyOption(),r.removeUnknownOption(),\nt.getViewValueFromOption(a)):null},y.trackBy&&d.$watch(function(){return y.getTrackByValue(s.$viewValue)},function(){s.$render()}));z&&(r.emptyOption.remove(),a(r.emptyOption)(d),8===r.emptyOption[0].nodeType?(r.hasEmptyOption=!1,r.registerOption=function(a,b){\"\"===b.val()&&(r.hasEmptyOption=!0,r.emptyOption=b,r.emptyOption.removeClass(\"ng-scope\"),s.$render(),b.on(\"$destroy\",function(){r.hasEmptyOption=!1;r.emptyOption=void 0}))}):r.emptyOption.removeClass(\"ng-scope\"));h.empty();p();d.$watchCollection(y.getWatchables,\np)}}}}],Te=[\"$locale\",\"$interpolate\",\"$log\",function(a,b,d){var c=/{}/g,f=/^when(Minus)?(.+)$/;return{link:function(e,g,h){function k(a){g.text(a||\"\")}var l=h.count,m=h.$attr.when&&g.attr(h.$attr.when),n=h.offset||0,p=e.$eval(m)||{},r={},s=b.startSymbol(),v=b.endSymbol(),u=s+l+\"-\"+n+v,H=$.noop,y;q(h,function(a,b){var c=f.exec(b);c&&(c=(c[1]?\"-\":\"\")+P(c[2]),p[c]=g.attr(h.$attr[b]))});q(p,function(a,d){r[d]=b(a.replace(c,u))});e.$watch(l,function(b){var c=parseFloat(b),f=ga(c);f||c in p||(c=a.pluralCat(c-\nn));c===y||f&&ga(y)||(H(),f=r[c],x(f)?(null!=b&&d.debug(\"ngPluralize: no rule defined for '\"+c+\"' in \"+m),H=w,k()):H=e.$watch(f,k),y=c)})}}}],Ue=[\"$parse\",\"$animate\",\"$compile\",function(a,b,d){var c=M(\"ngRepeat\"),f=function(a,b,c,d,f,m,n){a[c]=d;f&&(a[f]=m);a.$index=b;a.$first=0===b;a.$last=b===n-1;a.$middle=!(a.$first||a.$last);a.$odd=!(a.$even=0===(b&1))};return{restrict:\"A\",multiElement:!0,transclude:\"element\",priority:1E3,terminal:!0,$$tlb:!0,compile:function(e,g){var h=g.ngRepeat,k=d.$$createComment(\"end ngRepeat\",\nh),l=h.match(/^\\s*([\\s\\S]+?)\\s+in\\s+([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+track\\s+by\\s+([\\s\\S]+?))?\\s*$/);if(!l)throw c(\"iexp\",h);var m=l[1],n=l[2],p=l[3],r=l[4],l=m.match(/^(?:(\\s*[$\\w]+)|\\(\\s*([$\\w]+)\\s*,\\s*([$\\w]+)\\s*\\))$/);if(!l)throw c(\"iidexp\",m);var s=l[3]||l[1],v=l[2];if(p&&(!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(p)||/^(null|undefined|this|\\$index|\\$first|\\$middle|\\$last|\\$even|\\$odd|\\$parent|\\$root|\\$id)$/.test(p)))throw c(\"badident\",p);var u,w,x,t,y={$id:la};r?u=a(r):(x=function(a,b){return la(b)},\nt=function(a){return a});return function(a,d,e,g,l){u&&(w=function(b,c,d){v&&(y[v]=b);y[s]=c;y.$index=d;return u(a,y)});var m=W();a.$watchCollection(n,function(e){var g,n,r=d[0],u,y=W(),z,D,E,B,F,C,I;p&&(a[p]=e);if(ta(e))F=e,n=w||x;else for(I in n=w||t,F=[],e)va.call(e,I)&&\"$\"!==I.charAt(0)&&F.push(I);z=F.length;I=Array(z);for(g=0;g<z;g++)if(D=e===F?g:F[g],E=e[D],B=n(D,E,g),m[B])C=m[B],delete m[B],y[B]=C,I[g]=C;else{if(y[B])throw q(I,function(a){a&&a.scope&&(m[a.id]=a)}),c(\"dupes\",h,B,E);I[g]={id:B,\nscope:void 0,clone:void 0};y[B]=!0}for(u in m){C=m[u];B=ub(C.clone);b.leave(B);if(B[0].parentNode)for(g=0,n=B.length;g<n;g++)B[g].$$NG_REMOVED=!0;C.scope.$destroy()}for(g=0;g<z;g++)if(D=e===F?g:F[g],E=e[D],C=I[g],C.scope){u=r;do u=u.nextSibling;while(u&&u.$$NG_REMOVED);C.clone[0]!==u&&b.move(ub(C.clone),null,r);r=C.clone[C.clone.length-1];f(C.scope,g,s,E,v,D,z)}else l(function(a,c){C.scope=c;var d=k.cloneNode(!1);a[a.length++]=d;b.enter(a,null,r);r=d;C.clone=a;y[C.id]=C;f(C.scope,g,s,E,v,D,z)});m=\ny})}}}}],Ve=[\"$animate\",function(a){return{restrict:\"A\",multiElement:!0,link:function(b,d,c){b.$watch(c.ngShow,function(b){a[b?\"removeClass\":\"addClass\"](d,\"ng-hide\",{tempClasses:\"ng-hide-animate\"})})}}}],Oe=[\"$animate\",function(a){return{restrict:\"A\",multiElement:!0,link:function(b,d,c){b.$watch(c.ngHide,function(b){a[b?\"addClass\":\"removeClass\"](d,\"ng-hide\",{tempClasses:\"ng-hide-animate\"})})}}}],We=Ra(function(a,b,d){a.$watch(d.ngStyle,function(a,d){d&&a!==d&&q(d,function(a,c){b.css(c,\"\")});a&&b.css(a)},\n!0)}),Xe=[\"$animate\",\"$compile\",function(a,b){return{require:\"ngSwitch\",controller:[\"$scope\",function(){this.cases={}}],link:function(d,c,f,e){var g=[],h=[],k=[],l=[],m=function(a,b){return function(c){!1!==c&&a.splice(b,1)}};d.$watch(f.ngSwitch||f.on,function(c){for(var d,f;k.length;)a.cancel(k.pop());d=0;for(f=l.length;d<f;++d){var s=ub(h[d].clone);l[d].$destroy();(k[d]=a.leave(s)).done(m(k,d))}h.length=0;l.length=0;(g=e.cases[\"!\"+c]||e.cases[\"?\"])&&q(g,function(c){c.transclude(function(d,e){l.push(e);\nvar f=c.element;d[d.length++]=b.$$createComment(\"end ngSwitchWhen\");h.push({clone:d});a.enter(d,f.parent(),f)})})})}}}],Ye=Ra({transclude:\"element\",priority:1200,require:\"^ngSwitch\",multiElement:!0,link:function(a,b,d,c,f){a=d.ngSwitchWhen.split(d.ngSwitchWhenSeparator).sort().filter(function(a,b,c){return c[b-1]!==a});q(a,function(a){c.cases[\"!\"+a]=c.cases[\"!\"+a]||[];c.cases[\"!\"+a].push({transclude:f,element:b})})}}),Ze=Ra({transclude:\"element\",priority:1200,require:\"^ngSwitch\",multiElement:!0,link:function(a,\nb,d,c,f){c.cases[\"?\"]=c.cases[\"?\"]||[];c.cases[\"?\"].push({transclude:f,element:b})}}),bh=M(\"ngTransclude\"),af=[\"$compile\",function(a){return{restrict:\"EAC\",terminal:!0,compile:function(b){var d=a(b.contents());b.empty();return function(a,b,e,g,h){function k(){d(a,function(a){b.append(a)})}if(!h)throw bh(\"orphan\",ya(b));e.ngTransclude===e.$attr.ngTransclude&&(e.ngTransclude=\"\");e=e.ngTransclude||e.ngTranscludeSlot;h(function(a,c){var d;if(d=a.length)a:{d=0;for(var e=a.length;d<e;d++){var g=a[d];if(g.nodeType!==\nJa||g.nodeValue.trim()){d=!0;break a}}d=void 0}d?b.append(a):(k(),c.$destroy())},null,e);e&&!h.isSlotFilled(e)&&k()}}}}],Ce=[\"$templateCache\",function(a){return{restrict:\"E\",terminal:!0,compile:function(b,d){\"text/ng-template\"===d.type&&a.put(d.id,b[0].text)}}}],ch={$setViewValue:w,$render:w},dh=[\"$element\",\"$scope\",function(a,b){function d(){h||(h=!0,b.$$postDigest(function(){h=!1;e.ngModelCtrl.$render()}))}function c(a){k||(k=!0,b.$$postDigest(function(){b.$$destroyed||(k=!1,e.ngModelCtrl.$setViewValue(e.readValue()),\na&&e.ngModelCtrl.$render())}))}function f(a){a.prop(\"selected\",!0);a.attr(\"selected\",!0)}var e=this,g=new Qa;e.selectValueMap={};e.ngModelCtrl=ch;e.multiple=!1;e.unknownOption=D(z.document.createElement(\"option\"));e.hasEmptyOption=!1;e.emptyOption=void 0;e.renderUnknownOption=function(b){b=e.generateUnknownOptionValue(b);e.unknownOption.val(b);a.prepend(e.unknownOption);f(e.unknownOption);a.val(b)};e.updateUnknownOption=function(b){b=e.generateUnknownOptionValue(b);e.unknownOption.val(b);f(e.unknownOption);\na.val(b)};e.generateUnknownOptionValue=function(a){return\"? \"+la(a)+\" ?\"};e.removeUnknownOption=function(){e.unknownOption.parent()&&e.unknownOption.remove()};e.selectEmptyOption=function(){e.emptyOption&&(a.val(\"\"),f(e.emptyOption))};e.unselectEmptyOption=function(){e.hasEmptyOption&&e.emptyOption.removeAttr(\"selected\")};b.$on(\"$destroy\",function(){e.renderUnknownOption=w});e.readValue=function(){var b=a.val(),b=b in e.selectValueMap?e.selectValueMap[b]:b;return e.hasOption(b)?b:null};e.writeValue=\nfunction(b){var c=a[0].options[a[0].selectedIndex];c&&c.removeAttribute(\"selected\");e.hasOption(b)?(e.removeUnknownOption(),c=la(b),a.val(c in e.selectValueMap?c:b),f(D(a[0].options[a[0].selectedIndex]))):null==b&&e.emptyOption?(e.removeUnknownOption(),e.selectEmptyOption()):e.unknownOption.parent().length?e.updateUnknownOption(b):e.renderUnknownOption(b)};e.addOption=function(a,b){if(8!==b[0].nodeType){Pa(a,'\"option value\"');\"\"===a&&(e.hasEmptyOption=!0,e.emptyOption=b);var c=g.get(a)||0;g.put(a,\nc+1);d()}};e.removeOption=function(a){var b=g.get(a);b&&(1===b?(g.remove(a),\"\"===a&&(e.hasEmptyOption=!1,e.emptyOption=void 0)):g.put(a,b-1))};e.hasOption=function(a){return!!g.get(a)};var h=!1,k=!1;e.registerOption=function(a,b,d,f,g){if(d.$attr.ngValue){var h,k=NaN;d.$observe(\"value\",function(a){var d,f=b.prop(\"selected\");v(k)&&(e.removeOption(h),delete e.selectValueMap[k],d=!0);k=la(a);h=a;e.selectValueMap[k]=a;e.addOption(a,b);b.attr(\"value\",k);d&&f&&c()})}else f?d.$observe(\"value\",function(a){e.readValue();\nvar d,f=b.prop(\"selected\");v(h)&&(e.removeOption(h),d=!0);h=a;e.addOption(a,b);d&&f&&c()}):g?a.$watch(g,function(a,f){d.$set(\"value\",a);var g=b.prop(\"selected\");f!==a&&e.removeOption(f);e.addOption(a,b);f&&g&&c()}):e.addOption(d.value,b);d.$observe(\"disabled\",function(a){if(\"true\"===a||a&&b.prop(\"selected\"))e.multiple?c(!0):(e.ngModelCtrl.$setViewValue(null),e.ngModelCtrl.$render())});b.on(\"$destroy\",function(){var a=e.readValue(),b=d.value;e.removeOption(b);e.ngModelCtrl.$render();(e.multiple&&a&&\n-1!==a.indexOf(b)||a===b)&&c(!0)})}}],De=function(){return{restrict:\"E\",require:[\"select\",\"?ngModel\"],controller:dh,priority:1,link:{pre:function(a,b,d,c){var f=c[0],e=c[1];if(e){if(f.ngModelCtrl=e,b.on(\"change\",function(){f.removeUnknownOption();a.$apply(function(){e.$setViewValue(f.readValue())})}),d.multiple){f.multiple=!0;f.readValue=function(){var a=[];q(b.find(\"option\"),function(b){b.selected&&!b.disabled&&(b=b.value,a.push(b in f.selectValueMap?f.selectValueMap[b]:b))});return a};f.writeValue=\nfunction(a){var c=new Qa(a);q(b.find(\"option\"),function(a){a.selected=v(c.get(a.value))||v(c.get(f.selectValueMap[a.value]))})};var g,h=NaN;a.$watch(function(){h!==e.$viewValue||qa(g,e.$viewValue)||(g=ra(e.$viewValue),e.$render());h=e.$viewValue});e.$isEmpty=function(a){return!a||0===a.length}}}else f.registerOption=w},post:function(a,b,d,c){var f=c[1];if(f){var e=c[0];f.$render=function(){e.writeValue(f.$viewValue)}}}}}},Ee=[\"$interpolate\",function(a){return{restrict:\"E\",priority:100,compile:function(b,\nd){var c,f;v(d.ngValue)||(v(d.value)?c=a(d.value,!0):(f=a(b.text(),!0))||d.$set(\"value\",b.text()));return function(a,b,d){var k=b.parent();(k=k.data(\"$selectController\")||k.parent().data(\"$selectController\"))&&k.registerOption(a,b,d,c,f)}}}}],Tc=function(){return{restrict:\"A\",require:\"?ngModel\",link:function(a,b,d,c){c&&(d.required=!0,c.$validators.required=function(a,b){return!d.required||!c.$isEmpty(b)},d.$observe(\"required\",function(){c.$validate()}))}}},Sc=function(){return{restrict:\"A\",require:\"?ngModel\",\nlink:function(a,b,d,c){if(c){var f,e=d.ngPattern||d.pattern;d.$observe(\"pattern\",function(a){E(a)&&0<a.length&&(a=new RegExp(\"^\"+a+\"$\"));if(a&&!a.test)throw M(\"ngPattern\")(\"noregexp\",e,a,ya(b));f=a||void 0;c.$validate()});c.$validators.pattern=function(a,b){return c.$isEmpty(b)||x(f)||f.test(b)}}}}},Vc=function(){return{restrict:\"A\",require:\"?ngModel\",link:function(a,b,d,c){if(c){var f=-1;d.$observe(\"maxlength\",function(a){a=Z(a);f=ga(a)?-1:a;c.$validate()});c.$validators.maxlength=function(a,b){return 0>\nf||c.$isEmpty(b)||b.length<=f}}}}},Uc=function(){return{restrict:\"A\",require:\"?ngModel\",link:function(a,b,d,c){if(c){var f=0;d.$observe(\"minlength\",function(a){f=Z(a)||0;c.$validate()});c.$validators.minlength=function(a,b){return c.$isEmpty(b)||b.length>=f}}}}};z.angular.bootstrap?z.console&&console.log(\"WARNING: Tried to load angular more than once.\"):(ue(),xe($),$.module(\"ngLocale\",[],[\"$provide\",function(a){function b(a){a+=\"\";var b=a.indexOf(\".\");return-1==b?0:a.length-b-1}a.value(\"$locale\",\n{DATETIME_FORMATS:{AMPMS:[\"AM\",\"PM\"],DAY:\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),ERANAMES:[\"Before Christ\",\"Anno Domini\"],ERAS:[\"BC\",\"AD\"],FIRSTDAYOFWEEK:6,MONTH:\"January February March April May June July August September October November December\".split(\" \"),SHORTDAY:\"Sun Mon Tue Wed Thu Fri Sat\".split(\" \"),SHORTMONTH:\"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),STANDALONEMONTH:\"January February March April May June July August September October November December\".split(\" \"),\nWEEKENDRANGE:[5,6],fullDate:\"EEEE, MMMM d, y\",longDate:\"MMMM d, y\",medium:\"MMM d, y h:mm:ss a\",mediumDate:\"MMM d, y\",mediumTime:\"h:mm:ss a\",\"short\":\"M/d/yy h:mm a\",shortDate:\"M/d/yy\",shortTime:\"h:mm a\"},NUMBER_FORMATS:{CURRENCY_SYM:\"$\",DECIMAL_SEP:\".\",GROUP_SEP:\",\",PATTERNS:[{gSize:3,lgSize:3,maxFrac:3,minFrac:0,minInt:1,negPre:\"-\",negSuf:\"\",posPre:\"\",posSuf:\"\"},{gSize:3,lgSize:3,maxFrac:2,minFrac:2,minInt:1,negPre:\"-\\u00a4\",negSuf:\"\",posPre:\"\\u00a4\",posSuf:\"\"}]},id:\"en-us\",localeID:\"en_US\",pluralCat:function(a,\nc){var f=a|0,e=c;void 0===e&&(e=Math.min(b(a),3));Math.pow(10,e);return 1==f&&0==e?\"one\":\"other\"}})}]),D(function(){pe(z.document,Mc)}))})(window);!window.angular.$$csp().noInlineStyle&&window.angular.element(document.head).prepend('<style type=\"text/css\">@charset \"UTF-8\";[ng\\\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');\n//# sourceMappingURL=angular.min.js.map\n","/**\n * @license AngularJS v1.6.1\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar ADD_CLASS_SUFFIX = '-add';\nvar REMOVE_CLASS_SUFFIX = '-remove';\nvar EVENT_CLASS_PREFIX = 'ng-';\nvar ACTIVE_CLASS_SUFFIX = '-active';\nvar PREPARE_CLASS_SUFFIX = '-prepare';\n\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif ((window.ontransitionend === undefined) && (window.onwebkittransitionend !== undefined)) {\n  CSS_PREFIX = '-webkit-';\n  TRANSITION_PROP = 'WebkitTransition';\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n  TRANSITION_PROP = 'transition';\n  TRANSITIONEND_EVENT = 'transitionend';\n}\n\nif ((window.onanimationend === undefined) && (window.onwebkitanimationend !== undefined)) {\n  CSS_PREFIX = '-webkit-';\n  ANIMATION_PROP = 'WebkitAnimation';\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n  ANIMATION_PROP = 'animation';\n  ANIMATIONEND_EVENT = 'animationend';\n}\n\nvar DURATION_KEY = 'Duration';\nvar PROPERTY_KEY = 'Property';\nvar DELAY_KEY = 'Delay';\nvar TIMING_KEY = 'TimingFunction';\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar ngMinErr = angular.$$minErr('ng');\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', 'Argument \\'{0}\\' is {1}', (name || '?'), (reason || 'required'));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return '';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(' ');\n  if (isArray(b)) b = b.join(' ');\n  return a + ' ' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = '';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? ' ' : '';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return element;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it's important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType === ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  };\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationDetails(element, oldAnimation, newAnimation) {\n  var target = oldAnimation.options || {};\n  var newOptions = newAnimation.options || {};\n\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\n  if (newOptions.preparationClasses) {\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n    delete newOptions.preparationClasses;\n  }\n\n  // noop is basically when there is no callback; otherwise something has been set\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\n  extend(target, newOptions);\n\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {\n    target.domOperation = realDomOperation;\n  }\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  oldAnimation.addClass = target.addClass;\n  oldAnimation.removeClass = target.removeClass;\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: '',\n    removeClass: ''\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = 'addClass';\n      allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];\n    } else if (val === REMOVE_CLASS) {\n      prop = 'removeClass';\n      allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += ' ';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(' ');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof jqLite) ? element[0] : element;\n}\n\nfunction applyGeneratedPreparationClasses(element, event, options) {\n  var classes = '';\n  if (event) {\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n  }\n  if (options.addClass) {\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n  }\n  if (options.removeClass) {\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n  }\n  if (classes.length) {\n    options.preparationClasses = classes;\n    element.addClass(classes);\n  }\n}\n\nfunction clearGeneratedClasses(element, options) {\n  if (options.preparationClasses) {\n    element.removeClass(options.preparationClasses);\n    options.preparationClasses = null;\n  }\n  if (options.activeClasses) {\n    element.removeClass(options.activeClasses);\n    options.activeClasses = null;\n  }\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? '-' + duration + 's' : '';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? 'paused' : '';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction concatWithSpace(a,b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a + ' ' + b;\n}\n\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n  var queue, cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    queue = queue.concat(tasks);\n    nextTick();\n  }\n\n  queue = scheduler.queue = [];\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!queue.length) return;\n\n    var items = queue.shift();\n    for (var i = 0; i < items.length; i++) {\n      items[i]();\n    }\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n}];\n\n/**\n * @ngdoc directive\n * @name ngAnimateChildren\n * @restrict AE\n * @element ANY\n *\n * @description\n *\n * ngAnimateChildren allows you to specify that children of this element should animate even if any\n * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`\n * (structural) animation, child elements that also have an active structural animation are not animated.\n *\n * Note that even if `ngAnimateChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).\n *\n *\n * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,\n *     then child animations are allowed. If the value is `false`, child animations are not allowed.\n *\n * @example\n * <example module=\"ngAnimateChildren\" name=\"ngAnimateChildren\" deps=\"angular-animate.js\" animations=\"true\">\n     <file name=\"index.html\">\n       <div ng-controller=\"MainController as main\">\n         <label>Show container? <input type=\"checkbox\" ng-model=\"main.enterElement\" /></label>\n         <label>Animate children? <input type=\"checkbox\" ng-model=\"main.animateChildren\" /></label>\n         <hr>\n         <div ng-animate-children=\"{{main.animateChildren}}\">\n           <div ng-if=\"main.enterElement\" class=\"container\">\n             List of items:\n             <div ng-repeat=\"item in [0, 1, 2, 3]\" class=\"item\">Item {{item}}</div>\n           </div>\n         </div>\n       </div>\n     </file>\n     <file name=\"animations.css\">\n\n      .container.ng-enter,\n      .container.ng-leave {\n        transition: all ease 1.5s;\n      }\n\n      .container.ng-enter,\n      .container.ng-leave-active {\n        opacity: 0;\n      }\n\n      .container.ng-leave,\n      .container.ng-enter-active {\n        opacity: 1;\n      }\n\n      .item {\n        background: firebrick;\n        color: #FFF;\n        margin-bottom: 10px;\n      }\n\n      .item.ng-enter,\n      .item.ng-leave {\n        transition: transform 1.5s ease;\n      }\n\n      .item.ng-enter {\n        transform: translateX(50px);\n      }\n\n      .item.ng-enter-active {\n        transform: translateX(0);\n      }\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngAnimateChildren', ['ngAnimate'])\n        .controller('MainController', function MainController() {\n          this.animateChildren = false;\n          this.enterElement = false;\n        });\n    </file>\n  </example>\n */\nvar $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {\n  return {\n    link: function(scope, element, attrs) {\n      var val = attrs.ngAnimateChildren;\n      if (isString(val) && val.length === 0) { //empty attribute\n        element.data(NG_ANIMATE_CHILDREN_DATA, true);\n      } else {\n        // Interpolate and set the value, so that it is available to\n        // animations that run right after compilation\n        setData($interpolate(val)(scope));\n        attrs.$observe('ngAnimateChildren', setData);\n      }\n\n      function setData(value) {\n        value = value === 'on' || value === 'true';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      }\n    }\n  };\n}];\n\n/* exported $AnimateCssProvider */\n\nvar ANIMATE_TIMER_KEY = '$$animateCss';\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and\n * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n *    the animation is closed. This is useful for when the styles are used purely for the sake of\n *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).\n *    By default this value is set to `false`.\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\nvar ONE_SECOND = 1000;\n\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + 's'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + 's'];\n}\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === '-' || c === '+' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for negative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it's always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) === 's') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + 's';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += ' linear all';\n  }\n  return [style, value];\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\n// we do not reassign an already present style value since\n// if we detect the style property value again we may be\n// detecting styles that were added via the `from` styles.\n// We make use of `isDefined` here since an empty string\n// or null value (which is what getPropertyValue will return\n// for a non-existing style) will still be marked as a valid\n// value for the style (a falsy value implies that the style\n// is to be removed at the end of the animation). If we had a simple\n// \"OR\" statement then it would not be enough to catch that.\nfunction registerRestorableStyles(backup, node, properties) {\n  forEach(properties, function(prop) {\n    backup[prop] = isDefined(backup[prop])\n        ? backup[prop]\n        : node.style.getPropertyValue(prop);\n  });\n}\n\nvar $AnimateCssProvider = ['$animateProvider', /** @this */ function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = '$$ngAnimateParentKey';\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === 'infinite') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we're keeping an internal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, '-stagger');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n        var pageWidth = $$forceReflow();\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](pageWidth);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    return function init(element, initialOptions) {\n      // all of the animation functions should create\n      // a copy of the options data, however, if a\n      // parent service has already created a copy then\n      // we should stick to using that\n      var options = initialOptions || {};\n      if (!options.$$prepared) {\n        options = prepareAnimationOptions(copy(options));\n      }\n\n      var restoreStyles = {};\n      var node = getDomNode(element);\n      if (!node\n          || !node.parentNode\n          || !$$animateQueue.enabled()) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var temporaryStyles = [];\n      var classes = element.attr('class');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n      var startTime;\n      var events = [];\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(' ')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = '';\n      var addRemoveClassName = '';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += ' ';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n      }\n\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n      var fullClassName = classes + ' ' + preparationClasses;\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !preparationClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      if (!options.$$skipPreparationClasses) {\n        $$jqLite.addClass(element, preparationClasses);\n      }\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst && !options.skipBlocking) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty === 'all';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      if (options.delay != null) {\n        var delayStyle;\n        if (typeof options.delay !== 'boolean') {\n          delayStyle = parseFloat(options.delay);\n          // number in options.delay means we have to recalculate the delay for the closing timeout\n          maxDelay = Math.max(delayStyle, 0);\n        }\n\n        if (flags.applyTransitionDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle));\n        }\n\n        if (flags.applyAnimationDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n        }\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      if (options.from) {\n        if (options.cleanupStyles) {\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n        }\n        applyAnimationFromStyles(element, options);\n      }\n\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n        applyBlocking(maxDuration);\n      } else if (!options.skipBlocking) {\n        blockTransitions(node, false);\n      }\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don't have access to pause/resume the animation\n          // since it hasn't run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) {\n        // if the promise has been called already then we shouldn't close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        if (!options.$$skipPreparationClasses) {\n          $$jqLite.removeClass(element, preparationClasses);\n        }\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = '';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        if (Object.keys(restoreStyles).length) {\n          forEach(restoreStyles, function(value, prop) {\n            if (value) {\n              node.style.setProperty(prop, value);\n            } else {\n              node.style.removeProperty(prop);\n            }\n          });\n        }\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        if (events && events.length) {\n          // Remove the transitionend / animationend listener(s)\n          element.off(events.join(' '), onAnimationProgress);\n        }\n\n        //Cancel the fallback closing timeout and remove the timer data\n        var animationTimerData = element.data(ANIMATE_TIMER_KEY);\n        if (animationTimerData) {\n          $timeout.cancel(animationTimerData[0].timer);\n          element.removeData(ANIMATE_TIMER_KEY);\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        // should flush the cache animation\n        waitUntilQuiet(noop);\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function onAnimationProgress(event) {\n        event.stopPropagation();\n        var ev = event.originalEvent || event;\n\n        // we now always use `Date.now()` due to the recent changes with\n        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)\n        var timeStamp = ev.$manualTimeStamp || Date.now();\n\n        /* Firefox (or possibly just Gecko) likes to not round values up\n         * when a ms measurement is used for the animation */\n        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n        /* $manualTimeStamp is a mocked timeStamp value which is set\n         * within browserTrigger(). This is only here so that tests can\n         * mock animations properly. Real events fallback to event.timeStamp,\n         * or, if they don't, then a timeStamp is automatically created for them.\n         * We're checking to see if the timeStamp surpasses the expected delay,\n         * but we're using elapsedTime instead of the timeStamp on the 2nd\n         * pre-condition since animationPauseds sometimes close off early */\n        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n          // we set this flag to ensure that if the transition is paused then, when resumed,\n          // the animation will automatically close itself since transitions cannot be paused.\n          animationCompleted = true;\n          close();\n        }\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              if (animationPaused) {\n                temporaryStyles.push(value);\n              } else {\n                removeFromArray(temporaryStyles, value);\n              }\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidentally cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intentional stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.getAttribute('class') + ' ' + preparationClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== 'boolean' && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n            timings.animationDelay = relativeDelay;\n            delayStyle = getCssDelayStyle(relativeDelay, true);\n            temporaryStyles.push(delayStyle);\n            node.style[delayStyle[0]] = delayStyle[1];\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n          var endTime = startTime + timerTime;\n\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n          var setupFallbackTimer = true;\n          if (animationsData.length) {\n            var currentTimerData = animationsData[0];\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n            if (setupFallbackTimer) {\n              $timeout.cancel(currentTimerData.timer);\n            } else {\n              animationsData.push(close);\n            }\n          }\n\n          if (setupFallbackTimer) {\n            var timer = $timeout(onAnimationExpired, timerTime, false);\n            animationsData[0] = {\n              timer: timer,\n              expectedEndTime: endTime\n            };\n            animationsData.push(close);\n            element.data(ANIMATE_TIMER_KEY, animationsData);\n          }\n\n          if (events.length) {\n            element.on(events.join(' '), onAnimationProgress);\n          }\n\n          if (options.to) {\n            if (options.cleanupStyles) {\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n            }\n            applyAnimationToStyles(element, options);\n          }\n        }\n\n        function onAnimationExpired() {\n          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\n          // this will be false in the event that the element was\n          // removed from the DOM (via a leave animation or something\n          // similar)\n          if (animationsData) {\n            for (var i = 1; i < animationsData.length; i++) {\n              animationsData[i]();\n            }\n            element.removeData(ANIMATE_TIMER_KEY);\n          }\n        }\n      }\n    };\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = ['$$animationProvider', /** @this */ function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateCssDriver');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\n  function isDocumentFragment(node) {\n    return node.parentNode && node.parentNode.nodeType === 11;\n  }\n\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = $document[0].body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(\n      // this is to avoid using something that exists outside of the body\n      // we also special case the doc fragment case because our unit test code\n      // appends the $rootElement to the body after the app has been bootstrapped\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n    );\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, '');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(' ');\n      if (isString(b)) b = b.split(' ');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(' ');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn't return\n        // all the keys for the coords object when iterated\n        forEach(['width','height','top','left'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case 'top':\n              value += bodyNode.scrollTop;\n              break;\n            case 'left':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + 'px';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr('class') || '';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from, noop);\n      var toAnimation = prepareRegularAnimation(to, noop);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor['out'];\n        var inElement = anchor['in'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        options.event = animationDetails.event;\n        options.structural = true;\n        options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        if (animationDetails.event === 'leave') {\n          options.onDone = options.domOperation;\n        }\n      }\n\n      // We assign the preparationClasses as the actual animation event since\n      // the internals of $animateCss will just suffix the event token values\n      // with `-active` to trigger the animation.\n      if (options.preparationClasses) {\n        options.event = concatWithSpace(options.event, options.preparationClasses);\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = ['$animateProvider', /** @this */ function($animateProvider) {\n  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n       function($injector,   $$AnimateRunner,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, 'enter');\n    return function(element, event, classes, options) {\n      var animationClosed = false;\n\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element's className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr('class') || '';\n        if (options.addClass) {\n          classes += ' ' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += ' ' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don't return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event === 'leave') {\n          beforeFn = 'leave';\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== 'enter' && event !== 'move') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      function close() {\n        animationClosed = true;\n        applyOptions();\n        applyAnimationStyles(element, options);\n      }\n\n      var runner;\n\n      return {\n        $$willAnimate: true,\n        end: function() {\n          if (runner) {\n            runner.end();\n          } else {\n            close();\n            runner = new $$AnimateRunner();\n            runner.complete(true);\n          }\n          return runner;\n        },\n        start: function() {\n          if (runner) {\n            return runner;\n          }\n\n          runner = new $$AnimateRunner();\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          runner.setHost({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            close(success);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case 'animate':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case 'setClass':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case 'addClass':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case 'removeClass':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a, b;\n          if (fnName === 'beforeSetClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n          } else if (fnName === 'setClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          if (runners.length) {\n            $$AnimateRunner.all(runners, callback);\n          }  else {\n            callback();\n          }\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              if (reject) {\n                runner.cancel();\n              } else {\n                runner.end();\n              }\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(' ');\n      var matches = [], flagMap = {};\n      for (var i = 0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = ['$$animationProvider', /** @this */ function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateJsDriver');\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\nvar $$AnimateQueueProvider = ['$animateProvider', /** @this */ function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n  var ONE_SPACE = ' ';\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function makeTruthyCssClassMap(classString) {\n    if (!classString) {\n      return null;\n    }\n\n    var keys = classString.split(ONE_SPACE);\n    var map = Object.create(null);\n\n    forEach(keys, function(key) {\n      map[key] = true;\n    });\n    return map;\n  }\n\n  function hasMatchingClasses(newClassString, currentClassString) {\n    if (newClassString && currentClassString) {\n      var currentClassMap = makeTruthyCssClassMap(currentClassString);\n      return newClassString.split(ONE_SPACE).some(function(className) {\n        return currentClassMap[className];\n      });\n    }\n  }\n\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(element, currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(animation, and) {\n    var a = (animation.addClass || '').length > 0;\n    var b = (animation.removeClass || '').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(element, newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event === 'leave' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // if there is an ongoing current animation then don't even bother running the class-based animation\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // cancel the animation if classes added / removed in both animation cancel each other out,\n    // but only if the current animation isn't structural\n\n    if (currentAnimation.structural) return false;\n\n    var nA = newAnimation.addClass;\n    var nR = newAnimation.removeClass;\n    var cA = currentAnimation.addClass;\n    var cR = currentAnimation.removeClass;\n\n    // early detection to save the global CPU shortage :)\n    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {\n      return false;\n    }\n\n    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);\n  });\n\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n               '$$isDocumentHidden',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow,\n                $$isDocumentHidden) {\n\n    var activeAnimationsLookup = new $$HashMap();\n    var disabledElementsLookup = new $$HashMap();\n    var animationsEnabled = null;\n\n    function postDigestTaskFactory() {\n      var postDigestCalled = false;\n      return function(fn) {\n        // we only issue a call to postDigest before\n        // it has first passed. This prevents any callbacks\n        // from not firing once the animation has completed\n        // since it will be out of the digest cycle.\n        if (postDigestCalled) {\n          fn();\n        } else {\n          $rootScope.$$postDigest(function() {\n            postDigestCalled = true;\n            fn();\n          });\n        }\n      };\n    }\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it's important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var callbackRegistry = Object.create(null);\n\n    // remember that the classNameFilter is set during the provider/config\n    // stage therefore we can optimize here and setup a helper function\n    var classNameFilter = $animateProvider.classNameFilter();\n    var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationDetails(element, animation) {\n      return mergeAnimationDetails(element, animation, {});\n    }\n\n    // IE9-11 has no method \"contains\" in SVG element and in Node.prototype. Bug #10259.\n    var contains = window.Node.prototype.contains || /** @this */ function(arg) {\n      // eslint-disable-next-line no-bitwise\n      return this === arg || !!(this.compareDocumentPosition(arg) & 16);\n    };\n\n    function findCallbacks(parent, element, event) {\n      var targetNode = getDomNode(element);\n      var targetParentNode = getDomNode(parent);\n\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (contains.call(entry.node, targetNode)) {\n            matches.push(entry.callback);\n          } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    function filterFromRegistry(list, matchContainer, matchCallback) {\n      var containerNode = extractElementNode(matchContainer);\n      return list.filter(function(entry) {\n        var isMatch = entry.node === containerNode &&\n                        (!matchCallback || entry.callback === matchCallback);\n        return !isMatch;\n      });\n    }\n\n    function cleanupEventListeners(phase, element) {\n      if (phase === 'close' && !element[0].parentNode) {\n        // If the element is not attached to a parentNode, it has been removed by\n        // the domOperation, and we can safely remove the event callbacks\n        $animate.off(element);\n      }\n    }\n\n    var $animate = {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n\n        // Remove the callback when the element is removed from the DOM\n        jqLite(container).on('$destroy', function() {\n          var animationDetails = activeAnimationsLookup.get(node);\n\n          if (!animationDetails) {\n            // If there's an animation ongoing, the callback calling code will remove\n            // the event listeners. If we'd remove here, the callbacks would be removed\n            // before the animation ends\n            $animate.off(event, container, callback);\n          }\n        });\n      },\n\n      off: function(event, container, callback) {\n        if (arguments.length === 1 && !isString(arguments[0])) {\n          container = arguments[0];\n          for (var eventType in callbackRegistry) {\n            callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);\n          }\n\n          return;\n        }\n\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), 'element', 'not an element');\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !disabledElementsLookup.get(node);\n            } else {\n              // (element, bool) - Element setter\n              disabledElementsLookup.put(node, !bool);\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    return $animate;\n\n    function queueAnimation(element, event, initialOptions) {\n      // we always make a copy of the options since\n      // there should never be any side effects on\n      // the input data when running `$animateCss`.\n      var options = copy(initialOptions);\n\n      var node, parent;\n      element = stripCommentsFromElement(element);\n      if (element) {\n        node = getDomNode(element);\n        parent = element.parent();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // this is used to trigger callbacks in postDigest mode\n      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(' ');\n      }\n\n      if (options.addClass && !isString(options.addClass)) {\n        options.addClass = null;\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(' ');\n      }\n\n      if (options.removeClass && !isString(options.removeClass)) {\n        options.removeClass = null;\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      // there are situations where a directive issues an animation for\n      // a jqLite wrapper that contains only comment nodes... If this\n      // happens then there is no way we can perform an animation\n      if (!node) {\n        close();\n        return runner;\n      }\n\n      var className = [node.getAttribute('class'), options.addClass, options.removeClass].join(' ');\n      if (!isAnimatableClassName(className)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      var documentHidden = $$isDocumentHidden();\n\n      // this is a hard disable of all animations for the application or on\n      // the element itself, therefore  there is no need to continue further\n      // past this point if not enabled\n      // Animations are also disabled if the document is currently hidden (page is not visible\n      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame\n      var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state !== PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(element, parent, event);\n      }\n\n      if (skipAnimations) {\n        // Callbacks should fire even if the document is hidden (regression fix for issue #14120)\n        if (documentHidden) notifyProgress(runner, event, 'start');\n        close();\n        if (documentHidden) notifyProgress(runner, event, 'close');\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(element);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        addClass: options.addClass,\n        removeClass: options.removeClass,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationDetails(element, existingAnimation, newAnimation);\n            return existingAnimation.runner;\n          }\n        }\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn't started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the new animation options into existing animation options\n            mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n            return existingAnimation.runner;\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationDetails(element, newAnimation);\n            } else {\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n              //we return the same runner since only the option values of this animation will\n              //be fed into the `existingAnimation`.\n              return existingAnimation.runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationDetails(element, newAnimation);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(element);\n        return runner;\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === 'animate'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it's the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn't allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won't read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(element);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)\n            ? 'setClass'\n            : animationDetails.event;\n\n        markElementAnimationState(element, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n\n        // this will update the runner's flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, 'start', {});\n\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(getDomNode(element));\n          }\n          notifyProgress(runner, event, 'close', {});\n        });\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        runInNextPostDigestOrNow(function() {\n          var callbacks = findCallbacks(parent, element, event);\n          if (callbacks.length) {\n            // do not optimize this call here to RAF because\n            // we don't know how heavy the callback code here will\n            // be and if this code is buffered then this can\n            // lead to a performance regression.\n            $$rAF(function() {\n              forEach(callbacks, function(callback) {\n                callback(element, phase, data);\n              });\n              cleanupEventListeners(phase, element);\n            });\n          } else {\n            cleanupEventListeners(phase, element);\n          }\n        });\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) {\n        clearGeneratedClasses(element, options);\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(element) {\n      var node = getDomNode(element);\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10);\n        var animationDetails = activeAnimationsLookup.get(child);\n        if (animationDetails) {\n          switch (state) {\n            case RUNNING_STATE:\n              animationDetails.runner.end();\n              /* falls through */\n            case PRE_DIGEST_STATE:\n              activeAnimationsLookup.remove(child);\n              break;\n          }\n        }\n      });\n    }\n\n    function clearElementAnimationState(element) {\n      var node = getDomNode(element);\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.remove(node);\n    }\n\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n    }\n\n    /**\n     * This fn returns false if any of the following is true:\n     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed\n     * b) a parent element has an ongoing structural animation, and animateChildren is false\n     * c) the element is not a child of the body\n     * d) the element is not a child of the $rootElement\n     */\n    function areAnimationsAllowed(element, parentElement, event) {\n      var bodyElement = jqLite($document[0].body);\n      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';\n      var rootElementDetected = isMatchingElement(element, $rootElement);\n      var parentAnimationDetected = false;\n      var animateChildren;\n      var elementDisabled = disabledElementsLookup.get(getDomNode(element));\n\n      var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentElement = parentHost;\n      }\n\n      parentElement = getDomNode(parentElement);\n\n      while (parentElement) {\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n        }\n\n        if (parentElement.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentElement) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can't allow any animations to take place\n        // but if a parent animation is class-based then that's ok\n        if (!parentAnimationDetected) {\n          var parentElementDisabled = disabledElementsLookup.get(parentElement);\n\n          if (parentElementDisabled === true && elementDisabled !== false) {\n            // disable animations if the user hasn't explicitly enabled animations on the\n            // current element\n            elementDisabled = true;\n            // element is disabled via parent element, no need to check anything else\n            break;\n          } else if (parentElementDisabled === false) {\n            elementDisabled = false;\n          }\n          parentAnimationDetected = details.structural;\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!bodyElementDetected) {\n          // we also need to ensure that the element is or will be a part of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n        }\n\n        if (bodyElementDetected && rootElementDetected) {\n          // If both body and root have been found, any other checks are pointless,\n          // as no animation data should live outside the application\n          break;\n        }\n\n        if (!rootElementDetected) {\n          // If no rootElement is detected, check if the parentElement is pinned to another element\n          parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);\n          if (parentHost) {\n            // The pin target element becomes the next parent element\n            parentElement = getDomNode(parentHost);\n            continue;\n          }\n        }\n\n        parentElement = parentElement.parentNode;\n      }\n\n      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;\n      return allowAnimation && rootElementDetected && bodyElementDetected;\n    }\n\n    function markElementAnimationState(element, state, details) {\n      details = details || {};\n      details.state = state;\n\n      var node = getDomNode(element);\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.put(node, newValue);\n    }\n  }];\n}];\n\n/* exported $$AnimationProvider */\n\nvar $$AnimationProvider = ['$animateProvider', /** @this */ function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function sortAnimations(animations) {\n      var tree = { children: [] };\n      var i, lookup = new $$HashMap();\n\n      // this is done first beforehand so that the hashmap\n      // is filled with a list of the elements that will be animated\n      for (i = 0; i < animations.length; i++) {\n        var animation = animations[i];\n        lookup.put(animation.domNode, animations[i] = {\n          domNode: animation.domNode,\n          fn: animation.fn,\n          children: []\n        });\n      }\n\n      for (i = 0; i < animations.length; i++) {\n        processNode(animations[i]);\n      }\n\n      return flatten(tree);\n\n      function processNode(entry) {\n        if (entry.processed) return entry;\n        entry.processed = true;\n\n        var elementNode = entry.domNode;\n        var parentNode = elementNode.parentNode;\n        lookup.put(elementNode, entry);\n\n        var parentEntry;\n        while (parentNode) {\n          parentEntry = lookup.get(parentNode);\n          if (parentEntry) {\n            if (!parentEntry.processed) {\n              parentEntry = processNode(parentEntry);\n            }\n            break;\n          }\n          parentNode = parentNode.parentNode;\n        }\n\n        (parentEntry || tree).children.push(entry);\n        return entry;\n      }\n\n      function flatten(tree) {\n        var result = [];\n        var queue = [];\n        var i;\n\n        for (i = 0; i < tree.children.length; i++) {\n          queue.push(tree.children[i]);\n        }\n\n        var remainingLevelEntries = queue.length;\n        var nextLevelEntries = 0;\n        var row = [];\n\n        for (i = 0; i < queue.length; i++) {\n          var entry = queue[i];\n          if (remainingLevelEntries <= 0) {\n            remainingLevelEntries = nextLevelEntries;\n            nextLevelEntries = 0;\n            result.push(row);\n            row = [];\n          }\n          row.push(entry.fn);\n          entry.children.forEach(function(childEntry) {\n            nextLevelEntries++;\n            queue.push(childEntry);\n          });\n          remainingLevelEntries--;\n        }\n\n        if (row.length) {\n          result.push(row);\n        }\n\n        return result;\n      }\n    }\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver's end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += ' ' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      var prepareClassName;\n      if (isStructural) {\n        prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;\n        $$jqLite.addClass(element, prepareClassName);\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on('$destroy', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can't animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          } else {\n            entry.close();\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        var groupedAnimations = groupAnimations(animations);\n        var toBeSortedAnimations = [];\n\n        forEach(groupedAnimations, function(animationEntry) {\n          toBeSortedAnimations.push({\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n            fn: function triggerAnimationStart() {\n              // it's important that we apply the `ng-animate` CSS class and the\n              // temporary classes before we do any driver invoking since these\n              // CSS classes may be required for proper CSS detection.\n              animationEntry.beforeStart();\n\n              var startAnimationFn, closeFn = animationEntry.close;\n\n              // in the event that the element was removed before the digest runs or\n              // during the RAF sequencing then we should not trigger the animation.\n              var targetElement = animationEntry.anchors\n                  ? (animationEntry.from.element || animationEntry.to.element)\n                  : animationEntry.element;\n\n              if (getRunner(targetElement)) {\n                var operation = invokeFirstDriver(animationEntry);\n                if (operation) {\n                  startAnimationFn = operation.start;\n                }\n              }\n\n              if (!startAnimationFn) {\n                closeFn();\n              } else {\n                var animationRunner = startAnimationFn();\n                animationRunner.done(function(status) {\n                  closeFn(!status);\n                });\n                updateAnimationRunners(animationEntry, animationRunner);\n              }\n            }\n          });\n        });\n\n        // we need to sort each of the animations in order of parent to child\n        // relationships. This ensures that the child classes are applied at the\n        // right time.\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? 'to' : 'from';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can't have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effectively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            'out': from.element, 'in': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(' ');\n        b = b.split(' ');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === 'ng-') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(' ');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n        if (prepareClassName) {\n          $$jqLite.removeClass(element, prepareClassName);\n          prepareClassName = null;\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          var runner = getRunner(element);\n          if (runner) runner.setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) {\n        element.off('$destroy', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/**\n * @ngdoc directive\n * @name ngAnimateSwap\n * @restrict A\n * @scope\n *\n * @description\n *\n * ngAnimateSwap is a animation-oriented directive that allows for the container to\n * be removed and entered in whenever the associated expression changes. A\n * common usecase for this directive is a rotating banner or slider component which\n * contains one image being present at a time. When the active image changes\n * then the old image will perform a `leave` animation and the new element\n * will be inserted via an `enter` animation.\n *\n * @animations\n * | Animation                        | Occurs                               |\n * |----------------------------------|--------------------------------------|\n * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |\n * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |\n *\n * @example\n * <example name=\"ngAnimateSwap-directive\" module=\"ngAnimateSwapExample\"\n *          deps=\"angular-animate.js\"\n *          animations=\"true\" fixBase=\"true\">\n *   <file name=\"index.html\">\n *     <div class=\"container\" ng-controller=\"AppCtrl\">\n *       <div ng-animate-swap=\"number\" class=\"cell swap-animation\" ng-class=\"colorClass(number)\">\n *         {{ number }}\n *       </div>\n *     </div>\n *   </file>\n *   <file name=\"script.js\">\n *     angular.module('ngAnimateSwapExample', ['ngAnimate'])\n *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {\n *         $scope.number = 0;\n *         $interval(function() {\n *           $scope.number++;\n *         }, 1000);\n *\n *         var colors = ['red','blue','green','yellow','orange'];\n *         $scope.colorClass = function(number) {\n *           return colors[number % colors.length];\n *         };\n *       }]);\n *   </file>\n *  <file name=\"animations.css\">\n *  .container {\n *    height:250px;\n *    width:250px;\n *    position:relative;\n *    overflow:hidden;\n *    border:2px solid black;\n *  }\n *  .container .cell {\n *    font-size:150px;\n *    text-align:center;\n *    line-height:250px;\n *    position:absolute;\n *    top:0;\n *    left:0;\n *    right:0;\n *    border-bottom:2px solid black;\n *  }\n *  .swap-animation.ng-enter, .swap-animation.ng-leave {\n *    transition:0.5s linear all;\n *  }\n *  .swap-animation.ng-enter {\n *    top:-250px;\n *  }\n *  .swap-animation.ng-enter-active {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave-active {\n *    top:250px;\n *  }\n *  .red { background:red; }\n *  .green { background:green; }\n *  .blue { background:blue; }\n *  .yellow { background:yellow; }\n *  .orange { background:orange; }\n *  </file>\n * </example>\n */\nvar ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {\n  return {\n    restrict: 'A',\n    transclude: 'element',\n    terminal: true,\n    priority: 600, // we use 600 here to ensure that the directive is caught before others\n    link: function(scope, $element, attrs, ctrl, $transclude) {\n      var previousElement, previousScope;\n      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {\n        if (previousElement) {\n          $animate.leave(previousElement);\n        }\n        if (previousScope) {\n          previousScope.$destroy();\n          previousScope = null;\n        }\n        if (value || value === 0) {\n          previousScope = scope.$new();\n          $transclude(previousScope, function(element) {\n            previousElement = element;\n            $animate.enter(element, null, $element);\n          });\n        }\n      });\n    }\n  };\n}];\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=!bool\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n *     to not accidentally inherit a delay property from another CSS class &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ### The `ng-[event]-prepare` class\n *\n * This is a special class that can be used to prevent unwanted flickering / flash of content before\n * the actual animation starts. The class is added as soon as an animation is initialized, but removed\n * before the actual animation starts (after waiting for a $digest).\n * It is also only added for *structural* animations (`enter`, `move`, and `leave`).\n *\n * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`\n * into elements that have class-based animations such as `ngClass`.\n *\n * ```html\n * <div ng-class=\"{red: myProp}\">\n *   <div ng-class=\"{blue: myProp}\">\n *     <div class=\"message\" ng-if=\"myProp\"></div>\n *   </div>\n * </div>\n * ```\n *\n * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.\n * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:\n *\n * ```css\n * .message.ng-enter-prepare {\n *   opacity: 0;\n * }\n *\n * ```\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the animation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]);\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true,\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#!/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id: 1, title: 'Miss Beulah Roob' },\n            { id: 2, title: 'Trent Morissette' },\n            { id: 3, title: 'Miss Ava Pouros' },\n            { id: 4, title: 'Rod Pouros' },\n            { id: 5, title: 'Abdul Rice' },\n            { id: 6, title: 'Laurie Rutherford Sr.' },\n            { id: 7, title: 'Nakia McLaughlin' },\n            { id: 8, title: 'Jordon Blanda DVM' },\n            { id: 9, title: 'Rhoda Hand' },\n            { id: 10, title: 'Alexandrea Sauer' }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams',\n            function ProfileController($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#!/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\nvar copy;\nvar extend;\nvar forEach;\nvar isArray;\nvar isDefined;\nvar isElement;\nvar isFunction;\nvar isObject;\nvar isString;\nvar isUndefined;\nvar jqLite;\nvar noop;\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n */\nangular.module('ngAnimate', [], function initAngularHelpers() {\n  // Access helpers from angular core.\n  // Do it inside a `config` block to ensure `window.angular` is available.\n  noop        = angular.noop;\n  copy        = angular.copy;\n  extend      = angular.extend;\n  jqLite      = angular.element;\n  forEach     = angular.forEach;\n  isArray     = angular.isArray;\n  isString    = angular.isString;\n  isObject    = angular.isObject;\n  isUndefined = angular.isUndefined;\n  isDefined   = angular.isDefined;\n  isFunction  = angular.isFunction;\n  isElement   = angular.isElement;\n})\n  .directive('ngAnimateSwap', ngAnimateSwapDirective)\n\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\n  .provider('$$animateQueue', $$AnimateQueueProvider)\n  .provider('$$animation', $$AnimationProvider)\n\n  .provider('$animateCss', $AnimateCssProvider)\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\n  .provider('$$animateJs', $$AnimateJsProvider)\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n","/*\n angular-file-upload v2.5.0\n https://github.com/nervgh/angular-file-upload\n*/\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angular-file-upload\"] = factory();\n\telse\n\t\troot[\"angular-file-upload\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tvar _options = __webpack_require__(2);\n\t\n\tvar _options2 = _interopRequireDefault(_options);\n\t\n\tvar _FileUploader = __webpack_require__(3);\n\t\n\tvar _FileUploader2 = _interopRequireDefault(_FileUploader);\n\t\n\tvar _FileLikeObject = __webpack_require__(4);\n\t\n\tvar _FileLikeObject2 = _interopRequireDefault(_FileLikeObject);\n\t\n\tvar _FileItem = __webpack_require__(5);\n\t\n\tvar _FileItem2 = _interopRequireDefault(_FileItem);\n\t\n\tvar _FileDirective = __webpack_require__(6);\n\t\n\tvar _FileDirective2 = _interopRequireDefault(_FileDirective);\n\t\n\tvar _FileSelect = __webpack_require__(7);\n\t\n\tvar _FileSelect2 = _interopRequireDefault(_FileSelect);\n\t\n\tvar _Pipeline = __webpack_require__(8);\n\t\n\tvar _Pipeline2 = _interopRequireDefault(_Pipeline);\n\t\n\tvar _FileDrop = __webpack_require__(9);\n\t\n\tvar _FileDrop2 = _interopRequireDefault(_FileDrop);\n\t\n\tvar _FileOver = __webpack_require__(10);\n\t\n\tvar _FileOver2 = _interopRequireDefault(_FileOver);\n\t\n\tvar _FileSelect3 = __webpack_require__(11);\n\t\n\tvar _FileSelect4 = _interopRequireDefault(_FileSelect3);\n\t\n\tvar _FileDrop3 = __webpack_require__(12);\n\t\n\tvar _FileDrop4 = _interopRequireDefault(_FileDrop3);\n\t\n\tvar _FileOver3 = __webpack_require__(13);\n\t\n\tvar _FileOver4 = _interopRequireDefault(_FileOver3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tangular.module(_config2.default.name, []).value('fileUploaderOptions', _options2.default).factory('FileUploader', _FileUploader2.default).factory('FileLikeObject', _FileLikeObject2.default).factory('FileItem', _FileItem2.default).factory('FileDirective', _FileDirective2.default).factory('FileSelect', _FileSelect2.default).factory('FileDrop', _FileDrop2.default).factory('FileOver', _FileOver2.default).factory('Pipeline', _Pipeline2.default).directive('nvFileSelect', _FileSelect4.default).directive('nvFileDrop', _FileDrop4.default).directive('nvFileOver', _FileOver4.default).run(['FileUploader', 'FileLikeObject', 'FileItem', 'FileDirective', 'FileSelect', 'FileDrop', 'FileOver', 'Pipeline', function (FileUploader, FileLikeObject, FileItem, FileDirective, FileSelect, FileDrop, FileOver, Pipeline) {\n\t    // only for compatibility\n\t    FileUploader.FileLikeObject = FileLikeObject;\n\t    FileUploader.FileItem = FileItem;\n\t    FileUploader.FileDirective = FileDirective;\n\t    FileUploader.FileSelect = FileSelect;\n\t    FileUploader.FileDrop = FileDrop;\n\t    FileUploader.FileOver = FileOver;\n\t    FileUploader.Pipeline = Pipeline;\n\t}]);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"name\": \"angularFileUpload\"\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = {\n\t    url: '/',\n\t    alias: 'file',\n\t    headers: {},\n\t    queue: [],\n\t    progress: 0,\n\t    autoUpload: false,\n\t    removeAfterUpload: false,\n\t    method: 'POST',\n\t    filters: [],\n\t    formData: [],\n\t    queueLimit: Number.MAX_VALUE,\n\t    withCredentials: false,\n\t    disableMultipart: false\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _angular = angular;\n\tvar bind = _angular.bind;\n\tvar copy = _angular.copy;\n\tvar extend = _angular.extend;\n\tvar forEach = _angular.forEach;\n\tvar isObject = _angular.isObject;\n\tvar isNumber = _angular.isNumber;\n\tvar isDefined = _angular.isDefined;\n\tvar isArray = _angular.isArray;\n\tvar isUndefined = _angular.isUndefined;\n\tvar element = _angular.element;\n\tfunction __identity(fileUploaderOptions, $rootScope, $http, $window, $timeout, FileLikeObject, FileItem, Pipeline) {\n\t    var File = $window.File;\n\t    var FormData = $window.FormData;\n\t\n\t    var FileUploader = function () {\n\t        /**********************\n\t         * PUBLIC\n\t         **********************/\n\t        /**\n\t         * Creates an instance of FileUploader\n\t         * @param {Object} [options]\n\t         * @constructor\n\t         */\n\t\n\t        function FileUploader(options) {\n\t            _classCallCheck(this, FileUploader);\n\t\n\t            var settings = copy(fileUploaderOptions);\n\t\n\t            extend(this, settings, options, {\n\t                isUploading: false,\n\t                _nextIndex: 0,\n\t                _directives: { select: [], drop: [], over: [] }\n\t            });\n\t\n\t            // add default filters\n\t            this.filters.unshift({ name: 'queueLimit', fn: this._queueLimitFilter });\n\t            this.filters.unshift({ name: 'folder', fn: this._folderFilter });\n\t        }\n\t        /**\n\t         * Adds items to the queue\n\t         * @param {File|HTMLInputElement|Object|FileList|Array<Object>} files\n\t         * @param {Object} [options]\n\t         * @param {Array<Function>|String} filters\n\t         */\n\t\n\t\n\t        FileUploader.prototype.addToQueue = function addToQueue(files, options, filters) {\n\t            var _this = this;\n\t\n\t            var incomingQueue = this.isArrayLikeObject(files) ? Array.prototype.slice.call(files) : [files];\n\t            var arrayOfFilters = this._getFilters(filters);\n\t            var count = this.queue.length;\n\t            var addedFileItems = [];\n\t\n\t            var next = function next() {\n\t                var something = incomingQueue.shift();\n\t\n\t                if (isUndefined(something)) {\n\t                    return done();\n\t                }\n\t\n\t                var fileLikeObject = _this.isFile(something) ? something : new FileLikeObject(something);\n\t                var pipes = _this._convertFiltersToPipes(arrayOfFilters);\n\t                var pipeline = new Pipeline(pipes);\n\t                var onThrown = function onThrown(err) {\n\t                    var originalFilter = err.pipe.originalFilter;\n\t\n\t                    var _err$args = _slicedToArray(err.args, 2);\n\t\n\t                    var fileLikeObject = _err$args[0];\n\t                    var options = _err$args[1];\n\t\n\t                    _this._onWhenAddingFileFailed(fileLikeObject, originalFilter, options);\n\t                    next();\n\t                };\n\t                var onSuccessful = function onSuccessful(fileLikeObject, options) {\n\t                    var fileItem = new FileItem(_this, fileLikeObject, options);\n\t                    addedFileItems.push(fileItem);\n\t                    _this.queue.push(fileItem);\n\t                    _this._onAfterAddingFile(fileItem);\n\t                    next();\n\t                };\n\t                pipeline.onThrown = onThrown;\n\t                pipeline.onSuccessful = onSuccessful;\n\t                pipeline.exec(fileLikeObject, options);\n\t            };\n\t\n\t            var done = function done() {\n\t                if (_this.queue.length !== count) {\n\t                    _this._onAfterAddingAll(addedFileItems);\n\t                    _this.progress = _this._getTotalProgress();\n\t                }\n\t\n\t                _this._render();\n\t                if (_this.autoUpload) _this.uploadAll();\n\t            };\n\t\n\t            next();\n\t        };\n\t        /**\n\t         * Remove items from the queue. Remove last: index = -1\n\t         * @param {FileItem|Number} value\n\t         */\n\t\n\t\n\t        FileUploader.prototype.removeFromQueue = function removeFromQueue(value) {\n\t            var index = this.getIndexOfItem(value);\n\t            var item = this.queue[index];\n\t            if (item.isUploading) item.cancel();\n\t            this.queue.splice(index, 1);\n\t            item._destroy();\n\t            this.progress = this._getTotalProgress();\n\t        };\n\t        /**\n\t         * Clears the queue\n\t         */\n\t\n\t\n\t        FileUploader.prototype.clearQueue = function clearQueue() {\n\t            while (this.queue.length) {\n\t                this.queue[0].remove();\n\t            }\n\t            this.progress = 0;\n\t        };\n\t        /**\n\t         * Uploads a item from the queue\n\t         * @param {FileItem|Number} value\n\t         */\n\t\n\t\n\t        FileUploader.prototype.uploadItem = function uploadItem(value) {\n\t            var index = this.getIndexOfItem(value);\n\t            var item = this.queue[index];\n\t            var transport = this.isHTML5 ? '_xhrTransport' : '_iframeTransport';\n\t\n\t            item._prepareToUploading();\n\t            if (this.isUploading) return;\n\t\n\t            this._onBeforeUploadItem(item);\n\t            if (item.isCancel) return;\n\t\n\t            item.isUploading = true;\n\t            this.isUploading = true;\n\t            this[transport](item);\n\t            this._render();\n\t        };\n\t        /**\n\t         * Cancels uploading of item from the queue\n\t         * @param {FileItem|Number} value\n\t         */\n\t\n\t\n\t        FileUploader.prototype.cancelItem = function cancelItem(value) {\n\t            var _this2 = this;\n\t\n\t            var index = this.getIndexOfItem(value);\n\t            var item = this.queue[index];\n\t            var prop = this.isHTML5 ? '_xhr' : '_form';\n\t            if (!item) return;\n\t            item.isCancel = true;\n\t            if (item.isUploading) {\n\t                // It will call this._onCancelItem() & this._onCompleteItem() asynchronously\n\t                item[prop].abort();\n\t            } else {\n\t                (function () {\n\t                    var dummy = [undefined, 0, {}];\n\t                    var onNextTick = function onNextTick() {\n\t                        _this2._onCancelItem.apply(_this2, [item].concat(dummy));\n\t                        _this2._onCompleteItem.apply(_this2, [item].concat(dummy));\n\t                    };\n\t                    $timeout(onNextTick); // Trigger callbacks asynchronously (setImmediate emulation)\n\t                })();\n\t            }\n\t        };\n\t        /**\n\t         * Uploads all not uploaded items of queue\n\t         */\n\t\n\t\n\t        FileUploader.prototype.uploadAll = function uploadAll() {\n\t            var items = this.getNotUploadedItems().filter(function (item) {\n\t                return !item.isUploading;\n\t            });\n\t            if (!items.length) return;\n\t\n\t            forEach(items, function (item) {\n\t                return item._prepareToUploading();\n\t            });\n\t            items[0].upload();\n\t        };\n\t        /**\n\t         * Cancels all uploads\n\t         */\n\t\n\t\n\t        FileUploader.prototype.cancelAll = function cancelAll() {\n\t            var items = this.getNotUploadedItems();\n\t            forEach(items, function (item) {\n\t                return item.cancel();\n\t            });\n\t        };\n\t        /**\n\t         * Returns \"true\" if value an instance of File\n\t         * @param {*} value\n\t         * @returns {Boolean}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype.isFile = function isFile(value) {\n\t            return this.constructor.isFile(value);\n\t        };\n\t        /**\n\t         * Returns \"true\" if value an instance of FileLikeObject\n\t         * @param {*} value\n\t         * @returns {Boolean}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype.isFileLikeObject = function isFileLikeObject(value) {\n\t            return this.constructor.isFileLikeObject(value);\n\t        };\n\t        /**\n\t         * Returns \"true\" if value is array like object\n\t         * @param {*} value\n\t         * @returns {Boolean}\n\t         */\n\t\n\t\n\t        FileUploader.prototype.isArrayLikeObject = function isArrayLikeObject(value) {\n\t            return this.constructor.isArrayLikeObject(value);\n\t        };\n\t        /**\n\t         * Returns a index of item from the queue\n\t         * @param {Item|Number} value\n\t         * @returns {Number}\n\t         */\n\t\n\t\n\t        FileUploader.prototype.getIndexOfItem = function getIndexOfItem(value) {\n\t            return isNumber(value) ? value : this.queue.indexOf(value);\n\t        };\n\t        /**\n\t         * Returns not uploaded items\n\t         * @returns {Array}\n\t         */\n\t\n\t\n\t        FileUploader.prototype.getNotUploadedItems = function getNotUploadedItems() {\n\t            return this.queue.filter(function (item) {\n\t                return !item.isUploaded;\n\t            });\n\t        };\n\t        /**\n\t         * Returns items ready for upload\n\t         * @returns {Array}\n\t         */\n\t\n\t\n\t        FileUploader.prototype.getReadyItems = function getReadyItems() {\n\t            return this.queue.filter(function (item) {\n\t                return item.isReady && !item.isUploading;\n\t            }).sort(function (item1, item2) {\n\t                return item1.index - item2.index;\n\t            });\n\t        };\n\t        /**\n\t         * Destroys instance of FileUploader\n\t         */\n\t\n\t\n\t        FileUploader.prototype.destroy = function destroy() {\n\t            var _this3 = this;\n\t\n\t            forEach(this._directives, function (key) {\n\t                forEach(_this3._directives[key], function (object) {\n\t                    object.destroy();\n\t                });\n\t            });\n\t        };\n\t        /**\n\t         * Callback\n\t         * @param {Array} fileItems\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onAfterAddingAll = function onAfterAddingAll(fileItems) {};\n\t        /**\n\t         * Callback\n\t         * @param {FileItem} fileItem\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onAfterAddingFile = function onAfterAddingFile(fileItem) {};\n\t        /**\n\t         * Callback\n\t         * @param {File|Object} item\n\t         * @param {Object} filter\n\t         * @param {Object} options\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onWhenAddingFileFailed = function onWhenAddingFileFailed(item, filter, options) {};\n\t        /**\n\t         * Callback\n\t         * @param {FileItem} fileItem\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onBeforeUploadItem = function onBeforeUploadItem(fileItem) {};\n\t        /**\n\t         * Callback\n\t         * @param {FileItem} fileItem\n\t         * @param {Number} progress\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onProgressItem = function onProgressItem(fileItem, progress) {};\n\t        /**\n\t         * Callback\n\t         * @param {Number} progress\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onProgressAll = function onProgressAll(progress) {};\n\t        /**\n\t         * Callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onSuccessItem = function onSuccessItem(item, response, status, headers) {};\n\t        /**\n\t         * Callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onErrorItem = function onErrorItem(item, response, status, headers) {};\n\t        /**\n\t         * Callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onCancelItem = function onCancelItem(item, response, status, headers) {};\n\t        /**\n\t         * Callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onCompleteItem = function onCompleteItem(item, response, status, headers) {};\n\t        /**\n\t         * Callback\n\t         */\n\t\n\t\n\t        FileUploader.prototype.onCompleteAll = function onCompleteAll() {};\n\t        /**********************\n\t         * PRIVATE\n\t         **********************/\n\t        /**\n\t         * Returns the total progress\n\t         * @param {Number} [value]\n\t         * @returns {Number}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._getTotalProgress = function _getTotalProgress(value) {\n\t            if (this.removeAfterUpload) return value || 0;\n\t\n\t            var notUploaded = this.getNotUploadedItems().length;\n\t            var uploaded = notUploaded ? this.queue.length - notUploaded : this.queue.length;\n\t            var ratio = 100 / this.queue.length;\n\t            var current = (value || 0) * ratio / 100;\n\t\n\t            return Math.round(uploaded * ratio + current);\n\t        };\n\t        /**\n\t         * Returns array of filters\n\t         * @param {Array<Function>|String} filters\n\t         * @returns {Array<Function>}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._getFilters = function _getFilters(filters) {\n\t            if (!filters) return this.filters;\n\t            if (isArray(filters)) return filters;\n\t            var names = filters.match(/[^\\s,]+/g);\n\t            return this.filters.filter(function (filter) {\n\t                return names.indexOf(filter.name) !== -1;\n\t            });\n\t        };\n\t        /**\n\t        * @param {Array<Function>} filters\n\t        * @returns {Array<Function>}\n\t        * @private\n\t        */\n\t\n\t\n\t        FileUploader.prototype._convertFiltersToPipes = function _convertFiltersToPipes(filters) {\n\t            var _this4 = this;\n\t\n\t            return filters.map(function (filter) {\n\t                var fn = bind(_this4, filter.fn);\n\t                fn.isAsync = filter.fn.length === 3;\n\t                fn.originalFilter = filter;\n\t                return fn;\n\t            });\n\t        };\n\t        /**\n\t         * Updates html\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._render = function _render() {\n\t            if (!$rootScope.$$phase) $rootScope.$apply();\n\t        };\n\t        /**\n\t         * Returns \"true\" if item is a file (not folder)\n\t         * @param {File|FileLikeObject} item\n\t         * @returns {Boolean}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._folderFilter = function _folderFilter(item) {\n\t            return !!(item.size || item.type);\n\t        };\n\t        /**\n\t         * Returns \"true\" if the limit has not been reached\n\t         * @returns {Boolean}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._queueLimitFilter = function _queueLimitFilter() {\n\t            return this.queue.length < this.queueLimit;\n\t        };\n\t        /**\n\t         * Checks whether upload successful\n\t         * @param {Number} status\n\t         * @returns {Boolean}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._isSuccessCode = function _isSuccessCode(status) {\n\t            return status >= 200 && status < 300 || status === 304;\n\t        };\n\t        /**\n\t         * Transforms the server response\n\t         * @param {*} response\n\t         * @param {Object} headers\n\t         * @returns {*}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._transformResponse = function _transformResponse(response, headers) {\n\t            var headersGetter = this._headersGetter(headers);\n\t            forEach($http.defaults.transformResponse, function (transformFn) {\n\t                response = transformFn(response, headersGetter);\n\t            });\n\t            return response;\n\t        };\n\t        /**\n\t         * Parsed response headers\n\t         * @param headers\n\t         * @returns {Object}\n\t         * @see https://github.com/angular/angular.js/blob/master/src/ng/http.js\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._parseHeaders = function _parseHeaders(headers) {\n\t            var parsed = {},\n\t                key,\n\t                val,\n\t                i;\n\t\n\t            if (!headers) return parsed;\n\t\n\t            forEach(headers.split('\\n'), function (line) {\n\t                i = line.indexOf(':');\n\t                key = line.slice(0, i).trim().toLowerCase();\n\t                val = line.slice(i + 1).trim();\n\t\n\t                if (key) {\n\t                    parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n\t                }\n\t            });\n\t\n\t            return parsed;\n\t        };\n\t        /**\n\t         * Returns function that returns headers\n\t         * @param {Object} parsedHeaders\n\t         * @returns {Function}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._headersGetter = function _headersGetter(parsedHeaders) {\n\t            return function (name) {\n\t                if (name) {\n\t                    return parsedHeaders[name.toLowerCase()] || null;\n\t                }\n\t                return parsedHeaders;\n\t            };\n\t        };\n\t        /**\n\t         * The XMLHttpRequest transport\n\t         * @param {FileItem} item\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._xhrTransport = function _xhrTransport(item) {\n\t            var _this5 = this;\n\t\n\t            var xhr = item._xhr = new XMLHttpRequest();\n\t            var sendable;\n\t\n\t            if (!item.disableMultipart) {\n\t                sendable = new FormData();\n\t                forEach(item.formData, function (obj) {\n\t                    forEach(obj, function (value, key) {\n\t                        sendable.append(key, value);\n\t                    });\n\t                });\n\t\n\t                sendable.append(item.alias, item._file, item.file.name);\n\t            } else {\n\t                sendable = item._file;\n\t            }\n\t\n\t            if (typeof item._file.size != 'number') {\n\t                throw new TypeError('The file specified is no longer valid');\n\t            }\n\t\n\t            xhr.upload.onprogress = function (event) {\n\t                var progress = Math.round(event.lengthComputable ? event.loaded * 100 / event.total : 0);\n\t                _this5._onProgressItem(item, progress);\n\t            };\n\t\n\t            xhr.onload = function () {\n\t                var headers = _this5._parseHeaders(xhr.getAllResponseHeaders());\n\t                var response = _this5._transformResponse(xhr.response, headers);\n\t                var gist = _this5._isSuccessCode(xhr.status) ? 'Success' : 'Error';\n\t                var method = '_on' + gist + 'Item';\n\t                _this5[method](item, response, xhr.status, headers);\n\t                _this5._onCompleteItem(item, response, xhr.status, headers);\n\t            };\n\t\n\t            xhr.onerror = function () {\n\t                var headers = _this5._parseHeaders(xhr.getAllResponseHeaders());\n\t                var response = _this5._transformResponse(xhr.response, headers);\n\t                _this5._onErrorItem(item, response, xhr.status, headers);\n\t                _this5._onCompleteItem(item, response, xhr.status, headers);\n\t            };\n\t\n\t            xhr.onabort = function () {\n\t                var headers = _this5._parseHeaders(xhr.getAllResponseHeaders());\n\t                var response = _this5._transformResponse(xhr.response, headers);\n\t                _this5._onCancelItem(item, response, xhr.status, headers);\n\t                _this5._onCompleteItem(item, response, xhr.status, headers);\n\t            };\n\t\n\t            xhr.open(item.method, item.url, true);\n\t\n\t            xhr.withCredentials = item.withCredentials;\n\t\n\t            forEach(item.headers, function (value, name) {\n\t                xhr.setRequestHeader(name, value);\n\t            });\n\t\n\t            xhr.send(sendable);\n\t        };\n\t        /**\n\t         * The IFrame transport\n\t         * @param {FileItem} item\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._iframeTransport = function _iframeTransport(item) {\n\t            var _this6 = this;\n\t\n\t            var form = element('<form style=\"display: none;\" />');\n\t            var iframe = element('<iframe name=\"iframeTransport' + Date.now() + '\">');\n\t            var input = item._input;\n\t\n\t            if (item._form) item._form.replaceWith(input); // remove old form\n\t            item._form = form; // save link to new form\n\t\n\t            input.prop('name', item.alias);\n\t\n\t            forEach(item.formData, function (obj) {\n\t                forEach(obj, function (value, key) {\n\t                    var element_ = element('<input type=\"hidden\" name=\"' + key + '\" />');\n\t                    element_.val(value);\n\t                    form.append(element_);\n\t                });\n\t            });\n\t\n\t            form.prop({\n\t                action: item.url,\n\t                method: 'POST',\n\t                target: iframe.prop('name'),\n\t                enctype: 'multipart/form-data',\n\t                encoding: 'multipart/form-data' // old IE\n\t            });\n\t\n\t            iframe.bind('load', function () {\n\t                var html = '';\n\t                var status = 200;\n\t\n\t                try {\n\t                    // Fix for legacy IE browsers that loads internal error page\n\t                    // when failed WS response received. In consequence iframe\n\t                    // content access denied error is thrown becouse trying to\n\t                    // access cross domain page. When such thing occurs notifying\n\t                    // with empty response object. See more info at:\n\t                    // http://stackoverflow.com/questions/151362/access-is-denied-error-on-accessing-iframe-document-object\n\t                    // Note that if non standard 4xx or 5xx error code returned\n\t                    // from WS then response content can be accessed without error\n\t                    // but 'XHR' status becomes 200. In order to avoid confusion\n\t                    // returning response via same 'success' event handler.\n\t\n\t                    // fixed angular.contents() for iframes\n\t                    html = iframe[0].contentDocument.body.innerHTML;\n\t                } catch (e) {\n\t                    // in case we run into the access-is-denied error or we have another error on the server side\n\t                    // (intentional 500,40... errors), we at least say 'something went wrong' -> 500\n\t                    status = 500;\n\t                }\n\t\n\t                var xhr = { response: html, status: status, dummy: true };\n\t                var headers = {};\n\t                var response = _this6._transformResponse(xhr.response, headers);\n\t\n\t                _this6._onSuccessItem(item, response, xhr.status, headers);\n\t                _this6._onCompleteItem(item, response, xhr.status, headers);\n\t            });\n\t\n\t            form.abort = function () {\n\t                var xhr = { status: 0, dummy: true };\n\t                var headers = {};\n\t                var response;\n\t\n\t                iframe.unbind('load').prop('src', 'javascript:false;');\n\t                form.replaceWith(input);\n\t\n\t                _this6._onCancelItem(item, response, xhr.status, headers);\n\t                _this6._onCompleteItem(item, response, xhr.status, headers);\n\t            };\n\t\n\t            input.after(form);\n\t            form.append(input).append(iframe);\n\t\n\t            form[0].submit();\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {File|Object} item\n\t         * @param {Object} filter\n\t         * @param {Object} options\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onWhenAddingFileFailed = function _onWhenAddingFileFailed(item, filter, options) {\n\t            this.onWhenAddingFileFailed(item, filter, options);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {FileItem} item\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onAfterAddingFile = function _onAfterAddingFile(item) {\n\t            this.onAfterAddingFile(item);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {Array<FileItem>} items\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onAfterAddingAll = function _onAfterAddingAll(items) {\n\t            this.onAfterAddingAll(items);\n\t        };\n\t        /**\n\t         *  Inner callback\n\t         * @param {FileItem} item\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onBeforeUploadItem = function _onBeforeUploadItem(item) {\n\t            item._onBeforeUpload();\n\t            this.onBeforeUploadItem(item);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {FileItem} item\n\t         * @param {Number} progress\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onProgressItem = function _onProgressItem(item, progress) {\n\t            var total = this._getTotalProgress(progress);\n\t            this.progress = total;\n\t            item._onProgress(progress);\n\t            this.onProgressItem(item, progress);\n\t            this.onProgressAll(total);\n\t            this._render();\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onSuccessItem = function _onSuccessItem(item, response, status, headers) {\n\t            item._onSuccess(response, status, headers);\n\t            this.onSuccessItem(item, response, status, headers);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onErrorItem = function _onErrorItem(item, response, status, headers) {\n\t            item._onError(response, status, headers);\n\t            this.onErrorItem(item, response, status, headers);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onCancelItem = function _onCancelItem(item, response, status, headers) {\n\t            item._onCancel(response, status, headers);\n\t            this.onCancelItem(item, response, status, headers);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {FileItem} item\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.prototype._onCompleteItem = function _onCompleteItem(item, response, status, headers) {\n\t            item._onComplete(response, status, headers);\n\t            this.onCompleteItem(item, response, status, headers);\n\t\n\t            var nextItem = this.getReadyItems()[0];\n\t            this.isUploading = false;\n\t\n\t            if (isDefined(nextItem)) {\n\t                nextItem.upload();\n\t                return;\n\t            }\n\t\n\t            this.onCompleteAll();\n\t            this.progress = this._getTotalProgress();\n\t            this._render();\n\t        };\n\t        /**********************\n\t         * STATIC\n\t         **********************/\n\t        /**\n\t         * Returns \"true\" if value an instance of File\n\t         * @param {*} value\n\t         * @returns {Boolean}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.isFile = function isFile(value) {\n\t            return File && value instanceof File;\n\t        };\n\t        /**\n\t         * Returns \"true\" if value an instance of FileLikeObject\n\t         * @param {*} value\n\t         * @returns {Boolean}\n\t         * @private\n\t         */\n\t\n\t\n\t        FileUploader.isFileLikeObject = function isFileLikeObject(value) {\n\t            return value instanceof FileLikeObject;\n\t        };\n\t        /**\n\t         * Returns \"true\" if value is array like object\n\t         * @param {*} value\n\t         * @returns {Boolean}\n\t         */\n\t\n\t\n\t        FileUploader.isArrayLikeObject = function isArrayLikeObject(value) {\n\t            return isObject(value) && 'length' in value;\n\t        };\n\t        /**\n\t         * Inherits a target (Class_1) by a source (Class_2)\n\t         * @param {Function} target\n\t         * @param {Function} source\n\t         */\n\t\n\t\n\t        FileUploader.inherit = function inherit(target, source) {\n\t            target.prototype = Object.create(source.prototype);\n\t            target.prototype.constructor = target;\n\t            target.super_ = source;\n\t        };\n\t\n\t        return FileUploader;\n\t    }();\n\t\n\t    /**********************\n\t     * PUBLIC\n\t     **********************/\n\t    /**\n\t     * Checks a support the html5 uploader\n\t     * @returns {Boolean}\n\t     * @readonly\n\t     */\n\t\n\t\n\t    FileUploader.prototype.isHTML5 = !!(File && FormData);\n\t    /**********************\n\t     * STATIC\n\t     **********************/\n\t    /**\n\t     * @borrows FileUploader.prototype.isHTML5\n\t     */\n\t    FileUploader.isHTML5 = FileUploader.prototype.isHTML5;\n\t\n\t    return FileUploader;\n\t}\n\t\n\t__identity.$inject = ['fileUploaderOptions', '$rootScope', '$http', '$window', '$timeout', 'FileLikeObject', 'FileItem', 'Pipeline'];\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _angular = angular;\n\tvar copy = _angular.copy;\n\tvar isElement = _angular.isElement;\n\tvar isString = _angular.isString;\n\tfunction __identity() {\n\t\n\t    return function () {\n\t        /**\n\t         * Creates an instance of FileLikeObject\n\t         * @param {File|HTMLInputElement|Object} fileOrInput\n\t         * @constructor\n\t         */\n\t\n\t        function FileLikeObject(fileOrInput) {\n\t            _classCallCheck(this, FileLikeObject);\n\t\n\t            var isInput = isElement(fileOrInput);\n\t            var fakePathOrObject = isInput ? fileOrInput.value : fileOrInput;\n\t            var postfix = isString(fakePathOrObject) ? 'FakePath' : 'Object';\n\t            var method = '_createFrom' + postfix;\n\t            this[method](fakePathOrObject);\n\t        }\n\t        /**\n\t         * Creates file like object from fake path string\n\t         * @param {String} path\n\t         * @private\n\t         */\n\t\n\t\n\t        FileLikeObject.prototype._createFromFakePath = function _createFromFakePath(path) {\n\t            this.lastModifiedDate = null;\n\t            this.size = null;\n\t            this.type = 'like/' + path.slice(path.lastIndexOf('.') + 1).toLowerCase();\n\t            this.name = path.slice(path.lastIndexOf('/') + path.lastIndexOf('\\\\') + 2);\n\t        };\n\t        /**\n\t         * Creates file like object from object\n\t         * @param {File|FileLikeObject} object\n\t         * @private\n\t         */\n\t\n\t\n\t        FileLikeObject.prototype._createFromObject = function _createFromObject(object) {\n\t            this.lastModifiedDate = copy(object.lastModifiedDate);\n\t            this.size = object.size;\n\t            this.type = object.type;\n\t            this.name = object.name;\n\t        };\n\t\n\t        return FileLikeObject;\n\t    }();\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _angular = angular;\n\tvar copy = _angular.copy;\n\tvar extend = _angular.extend;\n\tvar element = _angular.element;\n\tvar isElement = _angular.isElement;\n\tfunction __identity($compile, FileLikeObject) {\n\t\n\t    return function () {\n\t        /**\n\t         * Creates an instance of FileItem\n\t         * @param {FileUploader} uploader\n\t         * @param {File|HTMLInputElement|Object} some\n\t         * @param {Object} options\n\t         * @constructor\n\t         */\n\t\n\t        function FileItem(uploader, some, options) {\n\t            _classCallCheck(this, FileItem);\n\t\n\t            var isInput = isElement(some);\n\t            var input = isInput ? element(some) : null;\n\t            var file = !isInput ? some : null;\n\t\n\t            extend(this, {\n\t                url: uploader.url,\n\t                alias: uploader.alias,\n\t                headers: copy(uploader.headers),\n\t                formData: copy(uploader.formData),\n\t                removeAfterUpload: uploader.removeAfterUpload,\n\t                withCredentials: uploader.withCredentials,\n\t                disableMultipart: uploader.disableMultipart,\n\t                method: uploader.method\n\t            }, options, {\n\t                uploader: uploader,\n\t                file: new FileLikeObject(some),\n\t                isReady: false,\n\t                isUploading: false,\n\t                isUploaded: false,\n\t                isSuccess: false,\n\t                isCancel: false,\n\t                isError: false,\n\t                progress: 0,\n\t                index: null,\n\t                _file: file,\n\t                _input: input\n\t            });\n\t\n\t            if (input) this._replaceNode(input);\n\t        }\n\t        /**********************\n\t         * PUBLIC\n\t         **********************/\n\t        /**\n\t         * Uploads a FileItem\n\t         */\n\t\n\t\n\t        FileItem.prototype.upload = function upload() {\n\t            try {\n\t                this.uploader.uploadItem(this);\n\t            } catch (e) {\n\t                var message = e.name + ':' + e.message;\n\t                this.uploader._onCompleteItem(this, message, e.code, []);\n\t                this.uploader._onErrorItem(this, message, e.code, []);\n\t            }\n\t        };\n\t        /**\n\t         * Cancels uploading of FileItem\n\t         */\n\t\n\t\n\t        FileItem.prototype.cancel = function cancel() {\n\t            this.uploader.cancelItem(this);\n\t        };\n\t        /**\n\t         * Removes a FileItem\n\t         */\n\t\n\t\n\t        FileItem.prototype.remove = function remove() {\n\t            this.uploader.removeFromQueue(this);\n\t        };\n\t        /**\n\t         * Callback\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype.onBeforeUpload = function onBeforeUpload() {};\n\t        /**\n\t         * Callback\n\t         * @param {Number} progress\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype.onProgress = function onProgress(progress) {};\n\t        /**\n\t         * Callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileItem.prototype.onSuccess = function onSuccess(response, status, headers) {};\n\t        /**\n\t         * Callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileItem.prototype.onError = function onError(response, status, headers) {};\n\t        /**\n\t         * Callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileItem.prototype.onCancel = function onCancel(response, status, headers) {};\n\t        /**\n\t         * Callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         */\n\t\n\t\n\t        FileItem.prototype.onComplete = function onComplete(response, status, headers) {};\n\t        /**********************\n\t         * PRIVATE\n\t         **********************/\n\t        /**\n\t         * Inner callback\n\t         */\n\t\n\t\n\t        FileItem.prototype._onBeforeUpload = function _onBeforeUpload() {\n\t            this.isReady = true;\n\t            this.isUploading = false;\n\t            this.isUploaded = false;\n\t            this.isSuccess = false;\n\t            this.isCancel = false;\n\t            this.isError = false;\n\t            this.progress = 0;\n\t            this.onBeforeUpload();\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {Number} progress\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype._onProgress = function _onProgress(progress) {\n\t            this.progress = progress;\n\t            this.onProgress(progress);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype._onSuccess = function _onSuccess(response, status, headers) {\n\t            this.isReady = false;\n\t            this.isUploading = false;\n\t            this.isUploaded = true;\n\t            this.isSuccess = true;\n\t            this.isCancel = false;\n\t            this.isError = false;\n\t            this.progress = 100;\n\t            this.index = null;\n\t            this.onSuccess(response, status, headers);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype._onError = function _onError(response, status, headers) {\n\t            this.isReady = false;\n\t            this.isUploading = false;\n\t            this.isUploaded = true;\n\t            this.isSuccess = false;\n\t            this.isCancel = false;\n\t            this.isError = true;\n\t            this.progress = 0;\n\t            this.index = null;\n\t            this.onError(response, status, headers);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype._onCancel = function _onCancel(response, status, headers) {\n\t            this.isReady = false;\n\t            this.isUploading = false;\n\t            this.isUploaded = false;\n\t            this.isSuccess = false;\n\t            this.isCancel = true;\n\t            this.isError = false;\n\t            this.progress = 0;\n\t            this.index = null;\n\t            this.onCancel(response, status, headers);\n\t        };\n\t        /**\n\t         * Inner callback\n\t         * @param {*} response\n\t         * @param {Number} status\n\t         * @param {Object} headers\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype._onComplete = function _onComplete(response, status, headers) {\n\t            this.onComplete(response, status, headers);\n\t            if (this.removeAfterUpload) this.remove();\n\t        };\n\t        /**\n\t         * Destroys a FileItem\n\t         */\n\t\n\t\n\t        FileItem.prototype._destroy = function _destroy() {\n\t            if (this._input) this._input.remove();\n\t            if (this._form) this._form.remove();\n\t            delete this._form;\n\t            delete this._input;\n\t        };\n\t        /**\n\t         * Prepares to uploading\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype._prepareToUploading = function _prepareToUploading() {\n\t            this.index = this.index || ++this.uploader._nextIndex;\n\t            this.isReady = true;\n\t        };\n\t        /**\n\t         * Replaces input element on his clone\n\t         * @param {JQLite|jQuery} input\n\t         * @private\n\t         */\n\t\n\t\n\t        FileItem.prototype._replaceNode = function _replaceNode(input) {\n\t            var clone = $compile(input.clone())(input.scope());\n\t            clone.prop('value', null); // FF fix\n\t            input.css('display', 'none');\n\t            input.after(clone); // remove jquery dependency\n\t        };\n\t\n\t        return FileItem;\n\t    }();\n\t}\n\t\n\t__identity.$inject = ['$compile', 'FileLikeObject'];\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _angular = angular;\n\tvar extend = _angular.extend;\n\tfunction __identity() {\n\t    var FileDirective = function () {\n\t        /**\n\t         * Creates instance of {FileDirective} object\n\t         * @param {Object} options\n\t         * @param {Object} options.uploader\n\t         * @param {HTMLElement} options.element\n\t         * @param {Object} options.events\n\t         * @param {String} options.prop\n\t         * @constructor\n\t         */\n\t\n\t        function FileDirective(options) {\n\t            _classCallCheck(this, FileDirective);\n\t\n\t            extend(this, options);\n\t            this.uploader._directives[this.prop].push(this);\n\t            this._saveLinks();\n\t            this.bind();\n\t        }\n\t        /**\n\t         * Binds events handles\n\t         */\n\t\n\t\n\t        FileDirective.prototype.bind = function bind() {\n\t            for (var key in this.events) {\n\t                var prop = this.events[key];\n\t                this.element.bind(key, this[prop]);\n\t            }\n\t        };\n\t        /**\n\t         * Unbinds events handles\n\t         */\n\t\n\t\n\t        FileDirective.prototype.unbind = function unbind() {\n\t            for (var key in this.events) {\n\t                this.element.unbind(key, this.events[key]);\n\t            }\n\t        };\n\t        /**\n\t         * Destroys directive\n\t         */\n\t\n\t\n\t        FileDirective.prototype.destroy = function destroy() {\n\t            var index = this.uploader._directives[this.prop].indexOf(this);\n\t            this.uploader._directives[this.prop].splice(index, 1);\n\t            this.unbind();\n\t            // this.element = null;\n\t        };\n\t        /**\n\t         * Saves links to functions\n\t         * @private\n\t         */\n\t\n\t\n\t        FileDirective.prototype._saveLinks = function _saveLinks() {\n\t            for (var key in this.events) {\n\t                var prop = this.events[key];\n\t                this[prop] = this[prop].bind(this);\n\t            }\n\t        };\n\t\n\t        return FileDirective;\n\t    }();\n\t\n\t    /**\n\t     * Map of events\n\t     * @type {Object}\n\t     */\n\t\n\t\n\t    FileDirective.prototype.events = {};\n\t\n\t    return FileDirective;\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _angular = angular;\n\tvar extend = _angular.extend;\n\tfunction __identity($compile, FileDirective) {\n\t\n\t    return function (_FileDirective) {\n\t        _inherits(FileSelect, _FileDirective);\n\t\n\t        /**\n\t         * Creates instance of {FileSelect} object\n\t         * @param {Object} options\n\t         * @constructor\n\t         */\n\t\n\t        function FileSelect(options) {\n\t            _classCallCheck(this, FileSelect);\n\t\n\t            var extendedOptions = extend(options, {\n\t                // Map of events\n\t                events: {\n\t                    $destroy: 'destroy',\n\t                    change: 'onChange'\n\t                },\n\t                // Name of property inside uploader._directive object\n\t                prop: 'select'\n\t            });\n\t\n\t            var _this = _possibleConstructorReturn(this, _FileDirective.call(this, extendedOptions));\n\t\n\t            if (!_this.uploader.isHTML5) {\n\t                _this.element.removeAttr('multiple');\n\t            }\n\t            _this.element.prop('value', null); // FF fix\n\t            return _this;\n\t        }\n\t        /**\n\t         * Returns options\n\t         * @return {Object|undefined}\n\t         */\n\t\n\t\n\t        FileSelect.prototype.getOptions = function getOptions() {};\n\t        /**\n\t         * Returns filters\n\t         * @return {Array<Function>|String|undefined}\n\t         */\n\t\n\t\n\t        FileSelect.prototype.getFilters = function getFilters() {};\n\t        /**\n\t         * If returns \"true\" then HTMLInputElement will be cleared\n\t         * @returns {Boolean}\n\t         */\n\t\n\t\n\t        FileSelect.prototype.isEmptyAfterSelection = function isEmptyAfterSelection() {\n\t            return !!this.element.attr('multiple');\n\t        };\n\t        /**\n\t         * Event handler\n\t         */\n\t\n\t\n\t        FileSelect.prototype.onChange = function onChange() {\n\t            var files = this.uploader.isHTML5 ? this.element[0].files : this.element[0];\n\t            var options = this.getOptions();\n\t            var filters = this.getFilters();\n\t\n\t            if (!this.uploader.isHTML5) this.destroy();\n\t            this.uploader.addToQueue(files, options, filters);\n\t            if (this.isEmptyAfterSelection()) {\n\t                this.element.prop('value', null);\n\t                this.element.replaceWith($compile(this.element.clone())(this.scope)); // IE fix\n\t            }\n\t        };\n\t\n\t        return FileSelect;\n\t    }(FileDirective);\n\t}\n\t\n\t__identity.$inject = ['$compile', 'FileDirective'];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = __identity;\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _angular = angular;\n\tvar bind = _angular.bind;\n\tvar isUndefined = _angular.isUndefined;\n\tfunction __identity($q) {\n\t\n\t  return function () {\n\t    /**\n\t     * @param {Array<Function>} pipes\n\t     */\n\t\n\t    function Pipeline() {\n\t      var pipes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\t\n\t      _classCallCheck(this, Pipeline);\n\t\n\t      this.pipes = pipes;\n\t    }\n\t\n\t    Pipeline.prototype.next = function next(args) {\n\t      var pipe = this.pipes.shift();\n\t      if (isUndefined(pipe)) {\n\t        this.onSuccessful.apply(this, _toConsumableArray(args));\n\t        return;\n\t      }\n\t      var err = new Error('The filter has not passed');\n\t      err.pipe = pipe;\n\t      err.args = args;\n\t      if (pipe.isAsync) {\n\t        var deferred = $q.defer();\n\t        var onFulfilled = bind(this, this.next, args);\n\t        var onRejected = bind(this, this.onThrown, err);\n\t        deferred.promise.then(onFulfilled, onRejected);\n\t        pipe.apply(undefined, _toConsumableArray(args).concat([deferred]));\n\t      } else {\n\t        var isDone = Boolean(pipe.apply(undefined, _toConsumableArray(args)));\n\t        if (isDone) {\n\t          this.next(args);\n\t        } else {\n\t          this.onThrown(err);\n\t        }\n\t      }\n\t    };\n\t\n\t    Pipeline.prototype.exec = function exec() {\n\t      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t      }\n\t\n\t      this.next(args);\n\t    };\n\t\n\t    Pipeline.prototype.onThrown = function onThrown(err) {};\n\t\n\t    Pipeline.prototype.onSuccessful = function onSuccessful() {};\n\t\n\t    return Pipeline;\n\t  }();\n\t}\n\t\n\t__identity.$inject = ['$q'];\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _angular = angular;\n\tvar extend = _angular.extend;\n\tvar forEach = _angular.forEach;\n\tfunction __identity(FileDirective) {\n\t\n\t    return function (_FileDirective) {\n\t        _inherits(FileDrop, _FileDirective);\n\t\n\t        /**\n\t         * Creates instance of {FileDrop} object\n\t         * @param {Object} options\n\t         * @constructor\n\t         */\n\t\n\t        function FileDrop(options) {\n\t            _classCallCheck(this, FileDrop);\n\t\n\t            var extendedOptions = extend(options, {\n\t                // Map of events\n\t                events: {\n\t                    $destroy: 'destroy',\n\t                    drop: 'onDrop',\n\t                    dragover: 'onDragOver',\n\t                    dragleave: 'onDragLeave'\n\t                },\n\t                // Name of property inside uploader._directive object\n\t                prop: 'drop'\n\t            });\n\t\n\t            return _possibleConstructorReturn(this, _FileDirective.call(this, extendedOptions));\n\t        }\n\t        /**\n\t         * Returns options\n\t         * @return {Object|undefined}\n\t         */\n\t\n\t\n\t        FileDrop.prototype.getOptions = function getOptions() {};\n\t        /**\n\t         * Returns filters\n\t         * @return {Array<Function>|String|undefined}\n\t         */\n\t\n\t\n\t        FileDrop.prototype.getFilters = function getFilters() {};\n\t        /**\n\t         * Event handler\n\t         */\n\t\n\t\n\t        FileDrop.prototype.onDrop = function onDrop(event) {\n\t            var transfer = this._getTransfer(event);\n\t            if (!transfer) return;\n\t            var options = this.getOptions();\n\t            var filters = this.getFilters();\n\t            this._preventAndStop(event);\n\t            forEach(this.uploader._directives.over, this._removeOverClass, this);\n\t            this.uploader.addToQueue(transfer.files, options, filters);\n\t        };\n\t        /**\n\t         * Event handler\n\t         */\n\t\n\t\n\t        FileDrop.prototype.onDragOver = function onDragOver(event) {\n\t            var transfer = this._getTransfer(event);\n\t            if (!this._haveFiles(transfer.types)) return;\n\t            transfer.dropEffect = 'copy';\n\t            this._preventAndStop(event);\n\t            forEach(this.uploader._directives.over, this._addOverClass, this);\n\t        };\n\t        /**\n\t         * Event handler\n\t         */\n\t\n\t\n\t        FileDrop.prototype.onDragLeave = function onDragLeave(event) {\n\t            if (event.currentTarget === this.element[0]) return;\n\t            this._preventAndStop(event);\n\t            forEach(this.uploader._directives.over, this._removeOverClass, this);\n\t        };\n\t        /**\n\t         * Helper\n\t         */\n\t\n\t\n\t        FileDrop.prototype._getTransfer = function _getTransfer(event) {\n\t            return event.dataTransfer ? event.dataTransfer : event.originalEvent.dataTransfer; // jQuery fix;\n\t        };\n\t        /**\n\t         * Helper\n\t         */\n\t\n\t\n\t        FileDrop.prototype._preventAndStop = function _preventAndStop(event) {\n\t            event.preventDefault();\n\t            event.stopPropagation();\n\t        };\n\t        /**\n\t         * Returns \"true\" if types contains files\n\t         * @param {Object} types\n\t         */\n\t\n\t\n\t        FileDrop.prototype._haveFiles = function _haveFiles(types) {\n\t            if (!types) return false;\n\t            if (types.indexOf) {\n\t                return types.indexOf('Files') !== -1;\n\t            } else if (types.contains) {\n\t                return types.contains('Files');\n\t            } else {\n\t                return false;\n\t            }\n\t        };\n\t        /**\n\t         * Callback\n\t         */\n\t\n\t\n\t        FileDrop.prototype._addOverClass = function _addOverClass(item) {\n\t            item.addOverClass();\n\t        };\n\t        /**\n\t         * Callback\n\t         */\n\t\n\t\n\t        FileDrop.prototype._removeOverClass = function _removeOverClass(item) {\n\t            item.removeOverClass();\n\t        };\n\t\n\t        return FileDrop;\n\t    }(FileDirective);\n\t}\n\t\n\t__identity.$inject = ['FileDirective'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _angular = angular;\n\tvar extend = _angular.extend;\n\tfunction __identity(FileDirective) {\n\t\n\t    return function (_FileDirective) {\n\t        _inherits(FileOver, _FileDirective);\n\t\n\t        /**\n\t         * Creates instance of {FileDrop} object\n\t         * @param {Object} options\n\t         * @constructor\n\t         */\n\t\n\t        function FileOver(options) {\n\t            _classCallCheck(this, FileOver);\n\t\n\t            var extendedOptions = extend(options, {\n\t                // Map of events\n\t                events: {\n\t                    $destroy: 'destroy'\n\t                },\n\t                // Name of property inside uploader._directive object\n\t                prop: 'over',\n\t                // Over class\n\t                overClass: 'nv-file-over'\n\t            });\n\t\n\t            return _possibleConstructorReturn(this, _FileDirective.call(this, extendedOptions));\n\t        }\n\t        /**\n\t         * Adds over class\n\t         */\n\t\n\t\n\t        FileOver.prototype.addOverClass = function addOverClass() {\n\t            this.element.addClass(this.getOverClass());\n\t        };\n\t        /**\n\t         * Removes over class\n\t         */\n\t\n\t\n\t        FileOver.prototype.removeOverClass = function removeOverClass() {\n\t            this.element.removeClass(this.getOverClass());\n\t        };\n\t        /**\n\t         * Returns over class\n\t         * @returns {String}\n\t         */\n\t\n\t\n\t        FileOver.prototype.getOverClass = function getOverClass() {\n\t            return this.overClass;\n\t        };\n\t\n\t        return FileOver;\n\t    }(FileDirective);\n\t}\n\t\n\t__identity.$inject = ['FileDirective'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction __identity($parse, FileUploader, FileSelect) {\n\t\n\t    return {\n\t        link: function link(scope, element, attributes) {\n\t            var uploader = scope.$eval(attributes.uploader);\n\t\n\t            if (!(uploader instanceof FileUploader)) {\n\t                throw new TypeError('\"Uploader\" must be an instance of FileUploader');\n\t            }\n\t\n\t            var object = new FileSelect({\n\t                uploader: uploader,\n\t                element: element,\n\t                scope: scope\n\t            });\n\t\n\t            object.getOptions = $parse(attributes.options).bind(object, scope);\n\t            object.getFilters = function () {\n\t                return attributes.filters;\n\t            };\n\t        }\n\t    };\n\t}\n\t\n\t__identity.$inject = ['$parse', 'FileUploader', 'FileSelect'];\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction __identity($parse, FileUploader, FileDrop) {\n\t\n\t    return {\n\t        link: function link(scope, element, attributes) {\n\t            var uploader = scope.$eval(attributes.uploader);\n\t\n\t            if (!(uploader instanceof FileUploader)) {\n\t                throw new TypeError('\"Uploader\" must be an instance of FileUploader');\n\t            }\n\t\n\t            if (!uploader.isHTML5) return;\n\t\n\t            var object = new FileDrop({\n\t                uploader: uploader,\n\t                element: element\n\t            });\n\t\n\t            object.getOptions = $parse(attributes.options).bind(object, scope);\n\t            object.getFilters = function () {\n\t                return attributes.filters;\n\t            };\n\t        }\n\t    };\n\t}\n\t\n\t__identity.$inject = ['$parse', 'FileUploader', 'FileDrop'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = __identity;\n\t\n\tvar _config = __webpack_require__(1);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction __identity(FileUploader, FileOver) {\n\t\n\t    return {\n\t        link: function link(scope, element, attributes) {\n\t            var uploader = scope.$eval(attributes.uploader);\n\t\n\t            if (!(uploader instanceof FileUploader)) {\n\t                throw new TypeError('\"Uploader\" must be an instance of FileUploader');\n\t            }\n\t\n\t            var object = new FileOver({\n\t                uploader: uploader,\n\t                element: element\n\t            });\n\t\n\t            object.getOverClass = function () {\n\t                return attributes.overClass || object.overClass;\n\t            };\n\t        }\n\t    };\n\t}\n\t\n\t__identity.$inject = ['FileUploader', 'FileOver'];\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=angular-file-upload.js.map","/**\n * Bunch of useful filters for angularJS(with no external dependencies!)\n * @version v0.5.15 - 2017-01-17 * @link https://github.com/a8m/angular-filter\n * @author Ariel Mashraki <ariel@mashraki.co.il>\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n(function ( window, angular, undefined ) {\n/*jshint globalstrict:true*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isUndefined = angular.isUndefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isNumber = angular.isNumber,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy,\n    equals = angular.equals;\n\n\n/**\n * @description\n * get an object and return array of values\n * @param object\n * @returns {Array}\n */\nfunction toArray(object) {\n  return isArray(object) \n    ? object \n    : Object.keys(object).map(function(key) {\n      return object[key];\n    });\n}\n\n/**\n * @param value\n * @returns {boolean}\n */\nfunction isNull(value) {\n    return value === null;\n}\n\n/**\n * @description\n * return if object contains partial object\n * @param partial{object}\n * @param object{object}\n * @returns {boolean}\n */\nfunction objectContains(partial, object) {\n  var keys = Object.keys(partial);\n\n  return keys.map(function(el) {\n    return (object[el] !== undefined) && (object[el] == partial[el]);\n  }).indexOf(false) == -1;\n\n}\n\n/**\n * @description\n * search for approximate pattern in string\n * @param word\n * @param pattern\n * @returns {*}\n */\nfunction hasApproxPattern(word, pattern) {\n  // cheaper version of indexOf; instead of creating each\n  // iteration new str.\n  function indexOf(word, p, c) {\n    var j = 0;\n    while ((p + j) <= word.length) {\n      if (word.charAt(p + j) == c) return j;\n      j++;\n    }\n    return -1;\n  }\n  var p = 0;\n  for (var i = 0; i <= pattern.length; i++) {\n    var index = indexOf(word, p, pattern.charAt(i));\n    if (index == -1) return false;\n    p += index + 1;\n  }\n  return true\n}\n\n/**\n * @description\n * return the first n element of an array,\n * if expression provided, is returns as long the expression return truthy\n * @param array\n * @param n {number}\n * @param expression {$parse}\n * @return array or single object\n */\nfunction getFirstMatches(array, n, expression) {\n  var count = 0;\n\n  return array.filter(function(elm) {\n    var rest = isDefined(expression) ? (count < n && expression(elm)) : count < n;\n    count = rest ? count+1 : count;\n\n    return rest;\n  });\n}\n/**\n * Polyfill to ECMA6 String.prototype.contains\n */\nif (!String.prototype.contains) {\n  String.prototype.contains = function() {\n    return String.prototype.indexOf.apply(this, arguments) !== -1;\n  };\n}\n\n/**\n * @param num {Number}\n * @param decimal {Number}\n * @returns {Number}\n */\nfunction convertToDecimal(num, decimal){\n  return Math.round(num * Math.pow(10,decimal)) / (Math.pow(10, decimal));\n}\n\n/**\n * @description\n * Get an object, and return an array composed of it's properties names(nested too).\n * @param obj {Object}\n * @param stack {Array}\n * @param parent {String}\n * @returns {Array}\n * @example\n * parseKeys({ a:1, b: { c:2, d: { e: 3 } } }) ==> [\"a\", \"b.c\", \"b.d.e\"]\n */\nfunction deepKeys(obj, stack, parent) {\n  stack = stack || [];\n  var keys = Object.keys(obj);\n\n  keys.forEach(function(el) {\n    //if it's a nested object\n    if(isObject(obj[el]) && !isArray(obj[el])) {\n      //concatenate the new parent if exist\n      var p = parent ? parent + '.' + el : parent;\n      deepKeys(obj[el], stack, p || el);\n    } else {\n      //create and save the key\n      var key = parent ? parent + '.' + el : el;\n      stack.push(key)\n    }\n  });\n  return stack\n}\n\n/**\n * @description\n * Test if given object is a Scope instance\n * @param obj\n * @returns {Boolean}\n */\nfunction isScope(obj) {\n  return obj && obj.$evalAsync && obj.$watch;\n}\n\n/**\n * @ngdoc filter\n * @name a8m.angular\n * @kind function\n *\n * @description\n * reference to angular function\n */\n\nangular.module('a8m.angular', [])\n\n    .filter('isUndefined', function () {\n      return function (input) {\n        return angular.isUndefined(input);\n      }\n    })\n    .filter('isDefined', function() {\n      return function (input) {\n        return angular.isDefined(input);\n      }\n    })\n    .filter('isFunction', function() {\n      return function (input) {\n        return angular.isFunction(input);\n      }\n    })\n    .filter('isString', function() {\n      return function (input) {\n        return angular.isString(input)\n      }\n    })\n    .filter('isNumber', function() {\n      return function (input) {\n        return angular.isNumber(input);\n      }\n    })\n    .filter('isArray', function() {\n      return function (input) {\n        return angular.isArray(input);\n      }\n    })\n    .filter('isObject', function() {\n      return function (input) {\n        return angular.isObject(input);\n      }\n    })\n    .filter('isEqual', function() {\n      return function (o1, o2) {\n        return angular.equals(o1, o2);\n      }\n    });\n\n/**\n * @ngdoc filter\n * @name a8m.conditions\n * @kind function\n *\n * @description\n * reference to math conditions\n */\n angular.module('a8m.conditions', [])\n\n  .filter({\n    isGreaterThan  : isGreaterThanFilter,\n    '>'            : isGreaterThanFilter,\n\n    isGreaterThanOrEqualTo  : isGreaterThanOrEqualToFilter,\n    '>='                    : isGreaterThanOrEqualToFilter,\n\n    isLessThan  : isLessThanFilter,\n    '<'         : isLessThanFilter,\n\n    isLessThanOrEqualTo  : isLessThanOrEqualToFilter,\n    '<='                 : isLessThanOrEqualToFilter,\n\n    isEqualTo  : isEqualToFilter,\n    '=='       : isEqualToFilter,\n\n    isNotEqualTo  : isNotEqualToFilter,\n    '!='          : isNotEqualToFilter,\n\n    isIdenticalTo  : isIdenticalToFilter,\n    '==='          : isIdenticalToFilter,\n\n    isNotIdenticalTo  : isNotIdenticalToFilter,\n    '!=='             : isNotIdenticalToFilter\n  });\n\n  function isGreaterThanFilter() {\n    return function (input, check) {\n      return input > check;\n    };\n  }\n\n  function isGreaterThanOrEqualToFilter() {\n    return function (input, check) {\n      return input >= check;\n    };\n  }\n\n  function isLessThanFilter() {\n    return function (input, check) {\n      return input < check;\n    };\n  }\n\n  function isLessThanOrEqualToFilter() {\n    return function (input, check) {\n      return input <= check;\n    };\n  }\n\n  function isEqualToFilter() {\n    return function (input, check) {\n      return input == check;\n    };\n  }\n\n  function isNotEqualToFilter() {\n    return function (input, check) {\n      return input != check;\n    };\n  }\n\n  function isIdenticalToFilter() {\n    return function (input, check) {\n      return input === check;\n    };\n  }\n\n  function isNotIdenticalToFilter() {\n    return function (input, check) {\n      return input !== check;\n    };\n  }\n/**\n * @ngdoc filter\n * @name isNull\n * @kind function\n *\n * @description\n * checks if value is null or not\n * @return Boolean\n */\nangular.module('a8m.is-null', [])\n    .filter('isNull', function () {\n      return function(input) {\n        return isNull(input);\n      }\n    });\n\n/**\n * @ngdoc filter\n * @name after-where\n * @kind function\n *\n * @description\n * get a collection and properties object, and returns all of the items\n * in the collection after the first that found with the given properties.\n *\n */\nangular.module('a8m.after-where', [])\n    .filter('afterWhere', function() {\n      return function (collection, object) {\n\n        collection = isObject(collection)\n          ? toArray(collection)\n          : collection;\n\n        if(!isArray(collection) || isUndefined(object)) return collection;\n\n        var index = collection.map( function( elm ) {\n          return objectContains(object, elm);\n        }).indexOf( true );\n\n        return collection.slice((index === -1) ? 0 : index);\n      }\n    });\n\n/**\n * @ngdoc filter\n * @name after\n * @kind function\n *\n * @description\n * get a collection and specified count, and returns all of the items\n * in the collection after the specified count.\n *\n */\n\nangular.module('a8m.after', [])\n    .filter('after', function() {\n      return function (collection, count) {\n        collection = isObject(collection)\n          ? toArray(collection)\n          : collection;\n\n        return (isArray(collection))\n          ? collection.slice(count)\n          : collection;\n      }\n    });\n\n/**\n * @ngdoc filter\n * @name before-where\n * @kind function\n *\n * @description\n * get a collection and properties object, and returns all of the items\n * in the collection before the first that found with the given properties.\n */\nangular.module('a8m.before-where', [])\n  .filter('beforeWhere', function() {\n    return function (collection, object) {\n\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      if(!isArray(collection) || isUndefined(object)) return collection;\n\n      var index = collection.map( function( elm ) {\n        return objectContains(object, elm);\n      }).indexOf( true );\n\n      return collection.slice(0, (index === -1) ? collection.length : ++index);\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name before\n * @kind function\n *\n * @description\n * get a collection and specified count, and returns all of the items\n * in the collection before the specified count.\n */\nangular.module('a8m.before', [])\n    .filter('before', function() {\n      return function (collection, count) {\n        collection = isObject(collection)\n          ? toArray(collection)\n          : collection;\n\n        return (isArray(collection))\n          ? collection.slice(0, (!count) ? count : --count)\n          : collection;\n      }\n    });\n\n/**\n * @ngdoc filter\n * @name chunkBy\n * @kind function\n *\n * @description\n * Collect data into fixed-length chunks or blocks\n */\n\nangular.module('a8m.chunk-by', ['a8m.filter-watcher'])\n    .filter('chunkBy', ['filterWatcher', function (filterWatcher) {\n      return function (array, n, fillVal) {\n\n        return filterWatcher.isMemoized('chunkBy', arguments) ||\n            filterWatcher.memoize('chunkBy', arguments, this,\n                _chunkBy(array, n, fillVal));\n        /**\n         * @description\n         * Get array with size `n` in `val` inside it.\n         * @param n\n         * @param val\n         * @returns {Array}\n         */\n        function fill(n, val) {\n          var ret = [];\n          while (n--) ret[n] = val;\n          return ret;\n        }\n\n        function _chunkBy(array, n, fillVal) {\n          if (!isArray(array)) return array;\n          return array.map(function (el, i, self) {\n            i = i * n;\n            el = self.slice(i, i + n);\n            return !isUndefined(fillVal) && el.length < n\n                ? el.concat(fill(n - el.length, fillVal))\n                : el;\n          }).slice(0, Math.ceil(array.length / n));\n        }\n      }\n    }]);\n\n/**\n * @ngdoc filter\n * @name concat\n * @kind function\n *\n * @description\n * get (array/object, object/array) and return merged collection\n */\nangular.module('a8m.concat', [])\n  .filter('concat', [function () {\n    return function (collection, joined) {\n\n      if (isUndefined(joined)) return collection;\n\n      if (isArray(collection)) {\n        return isObject(joined)\n          ? collection.concat(toArray(joined))\n          : collection.concat(joined);\n      }\n\n      if (isObject(collection)) {\n        var array = toArray(collection);\n        return (isObject(joined))\n          ? array.concat(toArray(joined))\n          : array.concat(joined);\n      }\n      return collection;\n    };\n  }\n]);\n\n/**\n * @ngdoc filter\n * @name contains\n * @kind function\n *\n * @description\n * Checks if given expression is present in one or more object in the collection\n */\nangular.module('a8m.contains', [])\n  .filter({\n    contains: ['$parse', containsFilter],\n    some: ['$parse', containsFilter]\n  });\n\nfunction containsFilter($parse) {\n    return function (collection, expression) {\n\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      if(!isArray(collection) || isUndefined(expression)) {\n        return false;\n      }\n\n      return collection.some(function(elm) {\n        return ((isString(expression) && isObject(elm)) || isFunction(expression))\n          ? $parse(expression)(elm)\n          : elm === expression;\n      });\n\n    }\n }\n\n/**\n * @ngdoc filter\n * @name countBy\n * @kind function\n *\n * @description\n * Sorts a list into groups and returns a count for the number of objects in each group.\n */\n\nangular.module('a8m.count-by', [])\n\n  .filter('countBy', [ '$parse', function ( $parse ) {\n    return function (collection, property) {\n\n      var result = {},\n        get = $parse(property),\n        prop;\n\n      collection = (isObject(collection)) ? toArray(collection) : collection;\n\n      if(!isArray(collection) || isUndefined(property)) {\n        return collection;\n      }\n\n      collection.forEach( function( elm ) {\n        prop = get(elm);\n\n        if(!result[prop]) {\n          result[prop] = 0;\n        }\n\n        result[prop]++;\n      });\n\n      return result;\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name defaults\n * @kind function\n *\n * @description\n * defaultsFilter allows to specify a default fallback value for properties that resolve to undefined.\n */\nangular.module('a8m.defaults', [])\n  .filter('defaults', ['$parse', function( $parse ) {\n    return function(collection, defaults) {\n\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      if(!isArray(collection) || !isObject(defaults)) {\n        return collection;\n      }\n\n      var keys = deepKeys(defaults);\n\n      collection.forEach(function(elm) {\n        //loop through all the keys\n        keys.forEach(function(key) {\n          var getter = $parse(key);\n          var setter = getter.assign;\n          //if it's not exist\n          if(isUndefined(getter(elm))) {\n            //get from defaults, and set to the returned object\n            setter(elm, getter(defaults))\n          }\n        });\n      });\n\n      return collection;\n    }\n  }]);\n/**\n * @ngdoc filter\n * @name every\n * @kind function\n *\n * @description\n * Checks if given expression is present in all members in the collection\n *\n */\nangular.module('a8m.every', [])\n  .filter('every', ['$parse', function($parse) {\n    return function (collection, expression) {\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      if(!isArray(collection) || isUndefined(expression)) {\n        return true;\n      }\n\n      return collection.every( function(elm) {\n        return (isObject(elm) || isFunction(expression))\n          ? $parse(expression)(elm)\n          : elm === expression;\n      });\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name filterBy\n * @kind function\n *\n * @description\n * filter by specific properties, avoid the rest\n */\nangular.module('a8m.filter-by', [])\n  .filter('filterBy', ['$parse', function( $parse ) {\n    return function(collection, properties, search, strict) {\n      var comparator;\n\n      search = (isString(search) || isNumber(search)) ?\n        String(search).toLowerCase() : undefined;\n\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      if(!isArray(collection) || isUndefined(search)) {\n        return collection;\n      }\n\n      return collection.filter(function(elm) {\n        return properties.some(function(prop) {\n\n          /**\n           * check if there is concatenate properties\n           * example:\n           * object: { first: 'foo', last:'bar' }\n           * filterBy: ['first + last'] => search by full name(i.e 'foo bar')\n           */\n          if(!~prop.indexOf('+')) {\n            comparator = $parse(prop)(elm)\n          } else {\n            var propList = prop.replace(/\\s+/g, '').split('+');\n            comparator = propList\n              .map(function(prop) { return $parse(prop)(elm); })\n              .join(' ');\n          }\n\n          if (!isString(comparator) && !isNumber(comparator)) {\n            return false;\n          }\n\n          comparator = String(comparator).toLowerCase();\n\n          return strict ? comparator === search : comparator.contains(search);\n        });\n      });\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name first\n * @kind function\n *\n * @description\n * Gets the first element or first n elements of an array\n * if callback is provided, is returns as long the callback return truthy\n */\nangular.module('a8m.first', [])\n  .filter('first', ['$parse', function( $parse ) {\n    return function(collection) {\n      var n\n        , getter\n        , args;\n\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      if(!isArray(collection)) {\n        return collection;\n      }\n\n      args = Array.prototype.slice.call(arguments, 1);\n      n = (isNumber(args[0])) ? args[0] : 1;\n      getter = (!isNumber(args[0]))  ? args[0] : (!isNumber(args[1])) ? args[1] : undefined;\n\n      return (args.length) ? getFirstMatches(collection, n,(getter) ? $parse(getter) : getter) :\n        collection[0];\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name flatten\n * @kind function\n *\n * @description\n * Flattens a nested array (the nesting can be to any depth).\n * If you pass shallow, the array will only be flattened a single level\n */\nangular.module('a8m.flatten', [])\n  .filter('flatten', function () {\n    return function(collection, shallow) {\n\n      shallow = shallow || false;\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      if(!isArray(collection)) {\n        return collection;\n      }\n\n      return !shallow\n        ? flatten(collection, 0)\n        : [].concat.apply([], collection);\n    }\n  });\n\n/**\n * flatten nested array (the nesting can be to any depth).\n * @param array {Array}\n * @param i {int}\n * @returns {Array}\n * @private\n */\nfunction flatten(array, i) {\n  i = i || 0;\n\n  if(i >= array.length)\n    return array;\n\n  if(isArray(array[i])) {\n    return flatten(array.slice(0,i)\n      .concat(array[i], array.slice(i+1)), i);\n  }\n  return flatten(array, i+1);\n}\n\n/**\n * @ngdoc filter\n * @name fuzzyByKey\n * @kind function\n *\n * @description\n * fuzzy string searching by key\n */\nangular.module('a8m.fuzzy-by', [])\n  .filter('fuzzyBy', ['$parse', function ( $parse ) {\n    return function (collection, property, search, csensitive) {\n\n      var sensitive = csensitive || false,\n        prop, getter;\n\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      if(!isArray(collection) || isUndefined(property)\n        || isUndefined(search)) {\n        return collection;\n      }\n\n      getter = $parse(property);\n\n      return collection.filter(function(elm) {\n\n        prop = getter(elm);\n        if(!isString(prop)) {\n          return false;\n        }\n\n        prop = (sensitive) ? prop : prop.toLowerCase();\n        search = (sensitive) ? search : search.toLowerCase();\n\n        return hasApproxPattern(prop, search) !== false\n      })\n    }\n\n }]);\n/**\n * @ngdoc filter\n * @name fuzzy\n * @kind function\n *\n * @description\n * fuzzy string searching for array of strings, objects\n */\nangular.module('a8m.fuzzy', [])\n  .filter('fuzzy', function () {\n    return function (collection, search, csensitive) {\n      var sensitive = csensitive || false;\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      if(!isArray(collection) || isUndefined(search)) {\n        return collection;\n      }\n\n      search = (sensitive) ? search : search.toLowerCase();\n\n      return collection.filter(function(elm) {\n        if(isString(elm)) {\n          elm = (sensitive) ? elm : elm.toLowerCase();\n          return hasApproxPattern(elm, search) !== false\n        }\n        return (isObject(elm)) ? _hasApproximateKey(elm, search) : false;\n      });\n\n      /**\n       * checks if object has key{string} that match\n       * to fuzzy search pattern\n       * @param object\n       * @param search\n       * @returns {boolean}\n       * @private\n       */\n      function _hasApproximateKey(object, search) {\n        var properties = Object.keys(object),\n          prop, flag;\n        return 0 < properties.filter(function (elm) {\n          prop = object[elm];\n\n          //avoid iteration if we found some key that equal[performance]\n          if(flag) return true;\n\n          if (isString(prop)) {\n            prop = (sensitive) ? prop : prop.toLowerCase();\n            return flag = (hasApproxPattern(prop, search) !== false);\n          }\n\n          return false;\n\n        }).length;\n      }\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name groupBy\n * @kind function\n *\n * @description\n * Create an object composed of keys generated from the result of running each element of a collection,\n * each key is an array of the elements.\n */\n\nangular.module('a8m.group-by', [ 'a8m.filter-watcher' ])\n  .filter('groupBy', [ '$parse', 'filterWatcher', function ( $parse, filterWatcher ) {\n    return function (collection, property) {\n\n      if(!isObject(collection) || isUndefined(property)) {\n        return collection;\n      }\n\n      return filterWatcher.isMemoized('groupBy', arguments) ||\n        filterWatcher.memoize('groupBy', arguments, this,\n          _groupBy(collection, $parse(property)));\n\n      /**\n       * groupBy function\n       * @param collection\n       * @param getter\n       * @returns {{}}\n       */\n      function _groupBy(collection, getter) {\n        var result = {};\n        var prop;\n\n        forEach( collection, function( elm ) {\n          prop = getter(elm);\n\n          if(!result[prop]) {\n            result[prop] = [];\n          }\n          result[prop].push(elm);\n        });\n        return result;\n      }\n    }\n }]);\n\n/**\n * @ngdoc filter\n * @name isEmpty\n * @kind function\n *\n * @description\n * get collection or string and return if it empty\n */\nangular.module('a8m.is-empty', [])\n  .filter('isEmpty', function () {\n    return function(collection) {\n      return isObject(collection)\n        ? !toArray(collection).length\n        : !collection.length;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name join\n * @kind function\n *\n * @description\n * join a collection by a provided delimiter (space by default)\n */\nangular.module('a8m.join', [])\n  .filter('join', function () {\n    return function (input, delimiter) {\n      if (isUndefined(input) || !isArray(input)) {\n        return input;\n      }\n      if (isUndefined(delimiter)) delimiter = ' ';\n\n      return input.join(delimiter);\n    };\n  })\n;\n\n/**\n * @ngdoc filter\n * @name last\n * @kind function\n *\n * @description\n * Gets the last element or last n elements of an array\n * if callback is provided, is returns as long the callback return truthy\n */\nangular.module('a8m.last', [])\n  .filter('last', ['$parse', function( $parse ) {\n    return function(collection) {\n      var n\n        , getter\n        , args\n        //cuz reverse change our src collection\n        //and we don't want side effects\n        , reversed = copy(collection);\n\n      reversed = isObject(reversed)\n        ? toArray(reversed)\n        : reversed;\n\n      if(!isArray(reversed)) {\n        return reversed;\n      }\n\n      args = Array.prototype.slice.call(arguments, 1);\n      n = (isNumber(args[0])) ? args[0] : 1;\n      getter = (!isNumber(args[0]))  ? args[0] : (!isNumber(args[1])) ? args[1] : undefined;\n\n      return (args.length)\n        //send reversed collection as arguments, and reverse it back as result\n        ? getFirstMatches(reversed.reverse(), n,(getter) ? $parse(getter) : getter).reverse()\n        //get the last element\n        : reversed[reversed.length-1];\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name map\n * @kind function\n *\n * @description\n * Returns a new collection of the results of each expression execution.\n */\nangular.module('a8m.map', [])\n  .filter('map', ['$parse', function($parse) {\n    return function (collection, expression) {\n\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      if(!isArray(collection) || isUndefined(expression)) {\n        return collection;\n      }\n\n      return collection.map(function (elm) {\n        return $parse(expression)(elm);\n      });\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name omit\n * @kind function\n *\n * @description\n * filter collection by expression\n */\n\nangular.module('a8m.omit', [])\n\n  .filter('omit', ['$parse', function($parse) {\n    return function (collection, expression) {\n\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      if(!isArray(collection) || isUndefined(expression)) {\n        return collection;\n      }\n\n      return collection.filter(function (elm) {\n        return !($parse(expression)(elm));\n      });\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name pick\n * @kind function\n *\n * @description\n * filter collection by expression\n */\n\nangular.module('a8m.pick', [])\n\n  .filter('pick', ['$parse', function($parse) {\n    return function (collection, expression) {\n\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      if(!isArray(collection) || isUndefined(expression)) {\n        return collection;\n      }\n\n      return collection.filter(function (elm) {\n        return $parse(expression)(elm);\n      });\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name range\n * @kind function\n *\n * @description\n * rangeFilter provides some support for a for loop using numbers\n */\nangular.module('a8m.range', [])\n  .filter('range', function () {\n    return function (input, total, start, increment, cb) {\n      start = start || 0;\n      increment = increment || 1;\n      for (var i = 0; i < parseInt(total); i++) {\n        var j = start + i * increment;\n        input.push(isFunction(cb) ? cb(j) : j);\n      }\n      return input;\n    };\n  });\n/**\n * @ngdoc filter\n * @name removeWith\n * @kind function\n *\n * @description\n * get collection and properties object, and removed elements\n * with this properties\n */\n\nangular.module('a8m.remove-with', [])\n  .filter('removeWith', function() {\n    return function (collection, object) {\n\n      if(isUndefined(object)) {\n        return collection;\n      }\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      return collection.filter(function (elm) {\n        return !objectContains(object, elm);\n      });\n    }\n  });\n\n\n/**\n * @ngdoc filter\n * @name remove\n * @kind function\n *\n * @description\n * remove specific members from collection\n */\n\nangular.module('a8m.remove', [])\n\n  .filter('remove', function () {\n    return function (collection) {\n      collection = isObject(collection) ? toArray(collection) : collection;\n      var args = Array.prototype.slice.call(arguments, 1);\n\n      if(!isArray(collection)) {\n        return collection;\n      }\n\n      return collection.filter( function( member ) {\n        return !args.some(function(nest) {\n          return equals(nest, member);\n        })\n      });\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name reverse\n * @kind function\n *\n * @description\n * Reverses a string or collection\n */\nangular.module('a8m.reverse', [])\n    .filter('reverse',[ function () {\n      return function (input) {\n        input = isObject(input) ? toArray(input) : input;\n\n        if(isString(input)) {\n          return input.split('').reverse().join('');\n        }\n\n        return isArray(input)\n          ? input.slice().reverse()\n          : input;\n      }\n    }]);\n\n/**\n * @ngdoc filter\n * @name searchField\n * @kind function\n *\n * @description\n * for each member, join several strings field and add them to\n * new field called 'searchField' (use for search filtering)\n */\nangular.module('a8m.search-field', [])\n  .filter('searchField', ['$parse', function ($parse) {\n    return function (collection) {\n\n      var get, field;\n\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      var args = Array.prototype.slice.call(arguments, 1);\n\n      if(!isArray(collection) || !args.length) {\n        return collection;\n      }\n\n      return collection.map(function(member) {\n\n        field = args.map(function(field) {\n          get = $parse(field);\n          return get(member);\n        }).join(' ');\n\n        return extend(member, { searchField: field });\n      });\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name toArray\n * @kind function\n *\n * @description\n * Convert objects into stable arrays.\n * if addKey set to true,the filter also attaches a new property\n * $key to the value containing the original key that was used in\n * the object we are iterating over to reference the property\n */\nangular.module('a8m.to-array', [])\n  .filter('toArray', function() {\n    return function (collection, addKey) {\n\n      if(!isObject(collection)) {\n        return collection;\n      }\n\n      return !addKey\n        ? toArray(collection)\n        : Object.keys(collection).map(function (key) {\n            return extend(collection[key], { $key: key });\n          });\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name unique/uniq\n * @kind function\n *\n * @description\n * get collection and filter duplicate members\n * if uniqueFilter get a property(nested to) as argument it's\n * filter by this property as unique identifier\n */\n\nangular.module('a8m.unique', [])\n  .filter({\n      unique: ['$parse', uniqFilter],\n      uniq: ['$parse', uniqFilter]\n    });\n\nfunction uniqFilter($parse) {\n    return function (collection, property) {\n\n      collection = isObject(collection) ? toArray(collection) : collection;\n\n      if (!isArray(collection)) {\n        return collection;\n      }\n\n      //store all unique identifiers\n      var uniqueItems = [],\n          get = $parse(property);\n\n      return (isUndefined(property))\n        //if it's kind of primitive array\n        ? collection.filter(function (elm, pos, self) {\n          return self.indexOf(elm) === pos;\n        })\n        //else compare with equals\n        : collection.filter(function (elm) {\n          var prop = get(elm);\n          if(some(uniqueItems, prop)) {\n            return false;\n          }\n          uniqueItems.push(prop);\n          return true;\n      });\n\n      //checked if the unique identifier is already exist\n      function some(array, member) {\n        if(isUndefined(member)) {\n          return false;\n        }\n        return array.some(function(el) {\n          return equals(el, member);\n        });\n      }\n    }\n}\n\n/**\n * @ngdoc filter\n * @name where\n * @kind function\n *\n * @description\n * of each element in a collection to the given properties object,\n * returning an array of all elements that have equivalent property values.\n *\n */\nangular.module('a8m.where', [])\n  .filter('where', function() {\n    return function (collection, object) {\n      if(isUndefined(object)) return collection;\n      collection = isObject(collection)\n        ? toArray(collection)\n        : collection;\n\n      return collection.filter(function (elm) {\n        return objectContains(object, elm);\n      });\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name xor\n * @kind function\n *\n * @description\n * Exclusive or filter by expression\n */\n\nangular.module('a8m.xor', [])\n\n  .filter('xor', ['$parse', function($parse) {\n    return function (col1, col2, expression) {\n\n      expression = expression || false;\n\n      col1 = isObject(col1) ? toArray(col1) : col1;\n      col2 = isObject(col2) ? toArray(col2) : col2;\n\n      if(!isArray(col1) || !isArray(col2)) return col1;\n\n      return col1.concat(col2)\n        .filter(function(elm) {\n          return !(some(elm, col1) && some(elm, col2));\n        });\n\n      function some(el, col) {\n        var getter = $parse(expression);\n        return col.some(function(dElm) {\n          return expression\n            ? equals(getter(dElm), getter(el))\n            : equals(dElm, el);\n        });\n      }\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name abs\n * @kind function\n *\n * @description\n * Will return the absolute value of a number\n */\nangular.module('a8m.math.abs', [])\n  .filter('abs', function () {\n    return function (input) {\n      return Math.abs(input);\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name formatBytes\n * @kind function\n *\n * @description\n * Convert bytes into appropriate display \n * 1024 bytes => 1 KB\n */\nangular.module('a8m.math.byteFmt', [])\n  .filter('byteFmt', function () {\n    var compared = [{str: 'B', val: 1024}];\n    ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'].forEach(function(el, i) {\n      compared.push({str: el, val: compared[i].val * 1024 });\n    });\n    return function (bytes, decimal) {\n      if(isNumber(decimal) && isFinite(decimal) && decimal%1===0 && decimal >= 0 &&\n        isNumber(bytes) && isFinite(bytes)) {\n        var i = 0;\n        while (i < compared.length-1 && bytes >= compared[i].val) i++;\n        bytes /= i > 0 ? compared[i-1].val : 1;\n        return convertToDecimal(bytes, decimal) + ' ' + compared[i].str;\n      }\n      return 'NaN';\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name degrees\n * @kind function\n *\n * @description\n * Convert angle from radians to degrees\n */\nangular.module('a8m.math.degrees', [])\n  .filter('degrees', function () {\n    return function (radians, decimal) {\n      // if decimal is not an integer greater than -1, we cannot do. quit with error \"NaN\"\n      // if degrees is not a real number, we cannot do also. quit with error \"NaN\"\n      if(isNumber(decimal) && isFinite(decimal) && decimal%1===0 && decimal >= 0 &&\n        isNumber(radians) && isFinite(radians)) {\n        var degrees = (radians * 180) / Math.PI;\n        return Math.round(degrees * Math.pow(10,decimal)) / (Math.pow(10,decimal));\n      } else {\n        return 'NaN';\n      }\n    }\n  });\n\n \n \n/**\n * @ngdoc filter\n * @name formatBytes\n * @kind function\n *\n * @description\n * Convert bytes into appropriate display \n * 1024 kilobytes => 1 MB\n */\nangular.module('a8m.math.kbFmt', [])\n  .filter('kbFmt', function () {\n    var compared = [{str: 'KB', val: 1024}];\n    ['MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'].forEach(function(el, i) {\n      compared.push({str: el, val: compared[i].val * 1024 });\n    });\n    return function (bytes, decimal) {\n      if(isNumber(decimal) && isFinite(decimal) && decimal%1===0 && decimal >= 0 &&\n        isNumber(bytes) && isFinite(bytes)) {\n        var i = 0;\n        while (i < compared.length-1 && bytes >= compared[i].val) i++;\n        bytes /= i > 0 ? compared[i-1].val : 1;\n        return convertToDecimal(bytes, decimal) + ' ' + compared[i].str;\n      }\n      return 'NaN';\n    }\n  });\n/**\n * @ngdoc filter\n * @name max\n * @kind function\n *\n * @description\n * Math.max will get an array and return the max value. if an expression\n * is provided, will return max value by expression.\n */\nangular.module('a8m.math.max', [])\n  .filter('max', ['$parse', function ($parse) {\n    return function (input, expression) {\n\n      if(!isArray(input)) {\n        return input;\n      }\n      return isUndefined(expression)\n        ? Math.max.apply(Math, input)\n        : input[indexByMax(input, expression)];\n    };\n\n    /**\n     * @private\n     * @param array\n     * @param exp\n     * @returns {number|*|Number}\n     */\n    function indexByMax(array, exp) {\n      var mappedArray = array.map(function(elm){\n        return $parse(exp)(elm);\n      });\n      return mappedArray.indexOf(Math.max.apply(Math, mappedArray));\n    }\n  }]);\n/**\n * @ngdoc filter\n * @name min\n * @kind function\n *\n * @description\n * Math.min will get an array and return the min value. if an expression\n * is provided, will return min value by expression.\n */\nangular.module('a8m.math.min', [])\n  .filter('min', ['$parse', function ($parse) {\n    return function (input, expression) {\n\n      if(!isArray(input)) {\n        return input;\n      }\n      return isUndefined(expression)\n        ? Math.min.apply(Math, input)\n        : input[indexByMin(input, expression)];\n    };\n\n    /**\n     * @private\n     * @param array\n     * @param exp\n     * @returns {number|*|Number}\n     */\n    function indexByMin(array, exp) {\n      var mappedArray = array.map(function(elm){\n        return $parse(exp)(elm);\n      });\n      return mappedArray.indexOf(Math.min.apply(Math, mappedArray));\n    }\n  }]);\n/**\n * @ngdoc filter\n * @name Percent\n * @kind function\n *\n * @description\n * percentage between two numbers\n */\nangular.module('a8m.math.percent', [])\n  .filter('percent', function () {\n    return function (input, divided, round) {\n\n      var divider = isString(input) ? Number(input) : input;\n      divided = divided || 100;\n      round = round || false;\n\n      if (!isNumber(divider) || isNaN(divider)) return input;\n\n      return round\n        ? Math.round((divider / divided) * 100)\n        : (divider / divided) * 100;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name toRadians\n * @kind function\n *\n * @description\n * Convert angle from degrees to radians\n */\nangular.module('a8m.math.radians', [])\n  .filter('radians', function() {\n    return function (degrees, decimal) {\n      // if decimal is not an integer greater than -1, we cannot do. quit with error \"NaN\"\n      // if degrees is not a real number, we cannot do also. quit with error \"NaN\"\n      if(isNumber(decimal) && isFinite(decimal) && decimal%1===0 && decimal >= 0 &&\n        isNumber(degrees) && isFinite(degrees)) {\n        var radians = (degrees * 3.14159265359) / 180;\n        return Math.round(radians * Math.pow(10,decimal)) / (Math.pow(10,decimal));\n      }\n      return 'NaN';\n    }\n  });\n\n \n \n/**\n * @ngdoc filter\n * @name Radix\n * @kind function\n *\n * @description\n * converting decimal numbers to different bases(radix)\n */\nangular.module('a8m.math.radix', [])\n  .filter('radix', function () {\n    return function (input, radix) {\n      var RANGE = /^[2-9]$|^[1-2]\\d$|^3[0-6]$/;\n\n      if(!isNumber(input) || !RANGE.test(radix)) {\n        return input;\n      }\n\n      return input.toString(radix).toUpperCase();\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name formatBytes\n * @kind function\n *\n * @description\n * Convert number into abbreviations.\n * i.e: K for one thousand, M for Million, B for billion\n * e.g: number of users:235,221, decimal:1 => 235.2 K\n */\nangular.module('a8m.math.shortFmt', [])\n  .filter('shortFmt', function () {\n    return function (number, decimal) {\n      if(isNumber(decimal) && isFinite(decimal) && decimal%1===0 && decimal >= 0 &&\n        isNumber(number) && isFinite(number)){\n        if(number < 1e3) {\n          return '' + number;  // Coerce to string\n        } else if(number < 1e6) {\n          return convertToDecimal((number / 1e3), decimal) + ' K';\n        } else if(number < 1e9){\n          return convertToDecimal((number / 1e6), decimal) + ' M';\n        } else {\n          return convertToDecimal((number / 1e9), decimal) + ' B';\n        }\n\n      }\n      return 'NaN';\n    }\n  });\n/**\n * @ngdoc filter\n * @name sum\n * @kind function\n *\n * @description\n * Sum up all values within an array\n */\nangular.module('a8m.math.sum', [])\n  .filter('sum', function () {\n    return function (input, initial) {\n      return !isArray(input)\n        ? input\n        : input.reduce(function(prev, curr) {\n          return prev + curr;\n        }, initial || 0);\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name endsWith\n * @kind function\n *\n * @description\n * checks whether string ends with the ends parameter.\n */\nangular.module('a8m.ends-with', [])\n\n  .filter('endsWith', function () {\n    return function (input, ends, csensitive) {\n\n      var sensitive = csensitive || false,\n        position;\n\n      if(!isString(input) || isUndefined(ends)) {\n        return input;\n      }\n\n      input = (sensitive) ? input : input.toLowerCase();\n      position = input.length - ends.length;\n\n      return input.indexOf((sensitive) ? ends : ends.toLowerCase(), position) !== -1;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name latinize\n * @kind function\n *\n * @description\n * remove accents/diacritics from a string\n */\nangular.module('a8m.latinize', [])\n  .filter('latinize',[ function () {\n    var defaultDiacriticsRemovalap = [\n      {'base':'A', 'letters':'\\u0041\\u24B6\\uFF21\\u00C0\\u00C1\\u00C2\\u1EA6\\u1EA4\\u1EAA\\u1EA8\\u00C3\\u0100\\u0102\\u1EB0\\u1EAE\\u1EB4\\u1EB2\\u0226\\u01E0\\u00C4\\u01DE\\u1EA2\\u00C5\\u01FA\\u01CD\\u0200\\u0202\\u1EA0\\u1EAC\\u1EB6\\u1E00\\u0104\\u023A\\u2C6F'},\n      {'base':'AA','letters':'\\uA732'},\n      {'base':'AE','letters':'\\u00C6\\u01FC\\u01E2'},\n      {'base':'AO','letters':'\\uA734'},\n      {'base':'AU','letters':'\\uA736'},\n      {'base':'AV','letters':'\\uA738\\uA73A'},\n      {'base':'AY','letters':'\\uA73C'},\n      {'base':'B', 'letters':'\\u0042\\u24B7\\uFF22\\u1E02\\u1E04\\u1E06\\u0243\\u0182\\u0181'},\n      {'base':'C', 'letters':'\\u0043\\u24B8\\uFF23\\u0106\\u0108\\u010A\\u010C\\u00C7\\u1E08\\u0187\\u023B\\uA73E'},\n      {'base':'D', 'letters':'\\u0044\\u24B9\\uFF24\\u1E0A\\u010E\\u1E0C\\u1E10\\u1E12\\u1E0E\\u0110\\u018B\\u018A\\u0189\\uA779'},\n      {'base':'DZ','letters':'\\u01F1\\u01C4'},\n      {'base':'Dz','letters':'\\u01F2\\u01C5'},\n      {'base':'E', 'letters':'\\u0045\\u24BA\\uFF25\\u00C8\\u00C9\\u00CA\\u1EC0\\u1EBE\\u1EC4\\u1EC2\\u1EBC\\u0112\\u1E14\\u1E16\\u0114\\u0116\\u00CB\\u1EBA\\u011A\\u0204\\u0206\\u1EB8\\u1EC6\\u0228\\u1E1C\\u0118\\u1E18\\u1E1A\\u0190\\u018E'},\n      {'base':'F', 'letters':'\\u0046\\u24BB\\uFF26\\u1E1E\\u0191\\uA77B'},\n      {'base':'G', 'letters':'\\u0047\\u24BC\\uFF27\\u01F4\\u011C\\u1E20\\u011E\\u0120\\u01E6\\u0122\\u01E4\\u0193\\uA7A0\\uA77D\\uA77E'},\n      {'base':'H', 'letters':'\\u0048\\u24BD\\uFF28\\u0124\\u1E22\\u1E26\\u021E\\u1E24\\u1E28\\u1E2A\\u0126\\u2C67\\u2C75\\uA78D'},\n      {'base':'I', 'letters':'\\u0049\\u24BE\\uFF29\\u00CC\\u00CD\\u00CE\\u0128\\u012A\\u012C\\u0130\\u00CF\\u1E2E\\u1EC8\\u01CF\\u0208\\u020A\\u1ECA\\u012E\\u1E2C\\u0197'},\n      {'base':'J', 'letters':'\\u004A\\u24BF\\uFF2A\\u0134\\u0248'},\n      {'base':'K', 'letters':'\\u004B\\u24C0\\uFF2B\\u1E30\\u01E8\\u1E32\\u0136\\u1E34\\u0198\\u2C69\\uA740\\uA742\\uA744\\uA7A2'},\n      {'base':'L', 'letters':'\\u004C\\u24C1\\uFF2C\\u013F\\u0139\\u013D\\u1E36\\u1E38\\u013B\\u1E3C\\u1E3A\\u0141\\u023D\\u2C62\\u2C60\\uA748\\uA746\\uA780'},\n      {'base':'LJ','letters':'\\u01C7'},\n      {'base':'Lj','letters':'\\u01C8'},\n      {'base':'M', 'letters':'\\u004D\\u24C2\\uFF2D\\u1E3E\\u1E40\\u1E42\\u2C6E\\u019C'},\n      {'base':'N', 'letters':'\\u004E\\u24C3\\uFF2E\\u01F8\\u0143\\u00D1\\u1E44\\u0147\\u1E46\\u0145\\u1E4A\\u1E48\\u0220\\u019D\\uA790\\uA7A4'},\n      {'base':'NJ','letters':'\\u01CA'},\n      {'base':'Nj','letters':'\\u01CB'},\n      {'base':'O', 'letters':'\\u004F\\u24C4\\uFF2F\\u00D2\\u00D3\\u00D4\\u1ED2\\u1ED0\\u1ED6\\u1ED4\\u00D5\\u1E4C\\u022C\\u1E4E\\u014C\\u1E50\\u1E52\\u014E\\u022E\\u0230\\u00D6\\u022A\\u1ECE\\u0150\\u01D1\\u020C\\u020E\\u01A0\\u1EDC\\u1EDA\\u1EE0\\u1EDE\\u1EE2\\u1ECC\\u1ED8\\u01EA\\u01EC\\u00D8\\u01FE\\u0186\\u019F\\uA74A\\uA74C'},\n      {'base':'OI','letters':'\\u01A2'},\n      {'base':'OO','letters':'\\uA74E'},\n      {'base':'OU','letters':'\\u0222'},\n      {'base':'OE','letters':'\\u008C\\u0152'},\n      {'base':'oe','letters':'\\u009C\\u0153'},\n      {'base':'P', 'letters':'\\u0050\\u24C5\\uFF30\\u1E54\\u1E56\\u01A4\\u2C63\\uA750\\uA752\\uA754'},\n      {'base':'Q', 'letters':'\\u0051\\u24C6\\uFF31\\uA756\\uA758\\u024A'},\n      {'base':'R', 'letters':'\\u0052\\u24C7\\uFF32\\u0154\\u1E58\\u0158\\u0210\\u0212\\u1E5A\\u1E5C\\u0156\\u1E5E\\u024C\\u2C64\\uA75A\\uA7A6\\uA782'},\n      {'base':'S', 'letters':'\\u0053\\u24C8\\uFF33\\u1E9E\\u015A\\u1E64\\u015C\\u1E60\\u0160\\u1E66\\u1E62\\u1E68\\u0218\\u015E\\u2C7E\\uA7A8\\uA784'},\n      {'base':'T', 'letters':'\\u0054\\u24C9\\uFF34\\u1E6A\\u0164\\u1E6C\\u021A\\u0162\\u1E70\\u1E6E\\u0166\\u01AC\\u01AE\\u023E\\uA786'},\n      {'base':'TZ','letters':'\\uA728'},\n      {'base':'U', 'letters':'\\u0055\\u24CA\\uFF35\\u00D9\\u00DA\\u00DB\\u0168\\u1E78\\u016A\\u1E7A\\u016C\\u00DC\\u01DB\\u01D7\\u01D5\\u01D9\\u1EE6\\u016E\\u0170\\u01D3\\u0214\\u0216\\u01AF\\u1EEA\\u1EE8\\u1EEE\\u1EEC\\u1EF0\\u1EE4\\u1E72\\u0172\\u1E76\\u1E74\\u0244'},\n      {'base':'V', 'letters':'\\u0056\\u24CB\\uFF36\\u1E7C\\u1E7E\\u01B2\\uA75E\\u0245'},\n      {'base':'VY','letters':'\\uA760'},\n      {'base':'W', 'letters':'\\u0057\\u24CC\\uFF37\\u1E80\\u1E82\\u0174\\u1E86\\u1E84\\u1E88\\u2C72'},\n      {'base':'X', 'letters':'\\u0058\\u24CD\\uFF38\\u1E8A\\u1E8C'},\n      {'base':'Y', 'letters':'\\u0059\\u24CE\\uFF39\\u1EF2\\u00DD\\u0176\\u1EF8\\u0232\\u1E8E\\u0178\\u1EF6\\u1EF4\\u01B3\\u024E\\u1EFE'},\n      {'base':'Z', 'letters':'\\u005A\\u24CF\\uFF3A\\u0179\\u1E90\\u017B\\u017D\\u1E92\\u1E94\\u01B5\\u0224\\u2C7F\\u2C6B\\uA762'},\n      {'base':'a', 'letters':'\\u0061\\u24D0\\uFF41\\u1E9A\\u00E0\\u00E1\\u00E2\\u1EA7\\u1EA5\\u1EAB\\u1EA9\\u00E3\\u0101\\u0103\\u1EB1\\u1EAF\\u1EB5\\u1EB3\\u0227\\u01E1\\u00E4\\u01DF\\u1EA3\\u00E5\\u01FB\\u01CE\\u0201\\u0203\\u1EA1\\u1EAD\\u1EB7\\u1E01\\u0105\\u2C65\\u0250'},\n      {'base':'aa','letters':'\\uA733'},\n      {'base':'ae','letters':'\\u00E6\\u01FD\\u01E3'},\n      {'base':'ao','letters':'\\uA735'},\n      {'base':'au','letters':'\\uA737'},\n      {'base':'av','letters':'\\uA739\\uA73B'},\n      {'base':'ay','letters':'\\uA73D'},\n      {'base':'b', 'letters':'\\u0062\\u24D1\\uFF42\\u1E03\\u1E05\\u1E07\\u0180\\u0183\\u0253'},\n      {'base':'c', 'letters':'\\u0063\\u24D2\\uFF43\\u0107\\u0109\\u010B\\u010D\\u00E7\\u1E09\\u0188\\u023C\\uA73F\\u2184'},\n      {'base':'d', 'letters':'\\u0064\\u24D3\\uFF44\\u1E0B\\u010F\\u1E0D\\u1E11\\u1E13\\u1E0F\\u0111\\u018C\\u0256\\u0257\\uA77A'},\n      {'base':'dz','letters':'\\u01F3\\u01C6'},\n      {'base':'e', 'letters':'\\u0065\\u24D4\\uFF45\\u00E8\\u00E9\\u00EA\\u1EC1\\u1EBF\\u1EC5\\u1EC3\\u1EBD\\u0113\\u1E15\\u1E17\\u0115\\u0117\\u00EB\\u1EBB\\u011B\\u0205\\u0207\\u1EB9\\u1EC7\\u0229\\u1E1D\\u0119\\u1E19\\u1E1B\\u0247\\u025B\\u01DD'},\n      {'base':'f', 'letters':'\\u0066\\u24D5\\uFF46\\u1E1F\\u0192\\uA77C'},\n      {'base':'g', 'letters':'\\u0067\\u24D6\\uFF47\\u01F5\\u011D\\u1E21\\u011F\\u0121\\u01E7\\u0123\\u01E5\\u0260\\uA7A1\\u1D79\\uA77F'},\n      {'base':'h', 'letters':'\\u0068\\u24D7\\uFF48\\u0125\\u1E23\\u1E27\\u021F\\u1E25\\u1E29\\u1E2B\\u1E96\\u0127\\u2C68\\u2C76\\u0265'},\n      {'base':'hv','letters':'\\u0195'},\n      {'base':'i', 'letters':'\\u0069\\u24D8\\uFF49\\u00EC\\u00ED\\u00EE\\u0129\\u012B\\u012D\\u00EF\\u1E2F\\u1EC9\\u01D0\\u0209\\u020B\\u1ECB\\u012F\\u1E2D\\u0268\\u0131'},\n      {'base':'j', 'letters':'\\u006A\\u24D9\\uFF4A\\u0135\\u01F0\\u0249'},\n      {'base':'k', 'letters':'\\u006B\\u24DA\\uFF4B\\u1E31\\u01E9\\u1E33\\u0137\\u1E35\\u0199\\u2C6A\\uA741\\uA743\\uA745\\uA7A3'},\n      {'base':'l', 'letters':'\\u006C\\u24DB\\uFF4C\\u0140\\u013A\\u013E\\u1E37\\u1E39\\u013C\\u1E3D\\u1E3B\\u017F\\u0142\\u019A\\u026B\\u2C61\\uA749\\uA781\\uA747'},\n      {'base':'lj','letters':'\\u01C9'},\n      {'base':'m', 'letters':'\\u006D\\u24DC\\uFF4D\\u1E3F\\u1E41\\u1E43\\u0271\\u026F'},\n      {'base':'n', 'letters':'\\u006E\\u24DD\\uFF4E\\u01F9\\u0144\\u00F1\\u1E45\\u0148\\u1E47\\u0146\\u1E4B\\u1E49\\u019E\\u0272\\u0149\\uA791\\uA7A5'},\n      {'base':'nj','letters':'\\u01CC'},\n      {'base':'o', 'letters':'\\u006F\\u24DE\\uFF4F\\u00F2\\u00F3\\u00F4\\u1ED3\\u1ED1\\u1ED7\\u1ED5\\u00F5\\u1E4D\\u022D\\u1E4F\\u014D\\u1E51\\u1E53\\u014F\\u022F\\u0231\\u00F6\\u022B\\u1ECF\\u0151\\u01D2\\u020D\\u020F\\u01A1\\u1EDD\\u1EDB\\u1EE1\\u1EDF\\u1EE3\\u1ECD\\u1ED9\\u01EB\\u01ED\\u00F8\\u01FF\\u0254\\uA74B\\uA74D\\u0275'},\n      {'base':'oi','letters':'\\u01A3'},\n      {'base':'ou','letters':'\\u0223'},\n      {'base':'oo','letters':'\\uA74F'},\n      {'base':'p','letters':'\\u0070\\u24DF\\uFF50\\u1E55\\u1E57\\u01A5\\u1D7D\\uA751\\uA753\\uA755'},\n      {'base':'q','letters':'\\u0071\\u24E0\\uFF51\\u024B\\uA757\\uA759'},\n      {'base':'r','letters':'\\u0072\\u24E1\\uFF52\\u0155\\u1E59\\u0159\\u0211\\u0213\\u1E5B\\u1E5D\\u0157\\u1E5F\\u024D\\u027D\\uA75B\\uA7A7\\uA783'},\n      {'base':'s','letters':'\\u0073\\u24E2\\uFF53\\u00DF\\u015B\\u1E65\\u015D\\u1E61\\u0161\\u1E67\\u1E63\\u1E69\\u0219\\u015F\\u023F\\uA7A9\\uA785\\u1E9B'},\n      {'base':'t','letters':'\\u0074\\u24E3\\uFF54\\u1E6B\\u1E97\\u0165\\u1E6D\\u021B\\u0163\\u1E71\\u1E6F\\u0167\\u01AD\\u0288\\u2C66\\uA787'},\n      {'base':'tz','letters':'\\uA729'},\n      {'base':'u','letters': '\\u0075\\u24E4\\uFF55\\u00F9\\u00FA\\u00FB\\u0169\\u1E79\\u016B\\u1E7B\\u016D\\u00FC\\u01DC\\u01D8\\u01D6\\u01DA\\u1EE7\\u016F\\u0171\\u01D4\\u0215\\u0217\\u01B0\\u1EEB\\u1EE9\\u1EEF\\u1EED\\u1EF1\\u1EE5\\u1E73\\u0173\\u1E77\\u1E75\\u0289'},\n      {'base':'v','letters':'\\u0076\\u24E5\\uFF56\\u1E7D\\u1E7F\\u028B\\uA75F\\u028C'},\n      {'base':'vy','letters':'\\uA761'},\n      {'base':'w','letters':'\\u0077\\u24E6\\uFF57\\u1E81\\u1E83\\u0175\\u1E87\\u1E85\\u1E98\\u1E89\\u2C73'},\n      {'base':'x','letters':'\\u0078\\u24E7\\uFF58\\u1E8B\\u1E8D'},\n      {'base':'y','letters':'\\u0079\\u24E8\\uFF59\\u1EF3\\u00FD\\u0177\\u1EF9\\u0233\\u1E8F\\u00FF\\u1EF7\\u1E99\\u1EF5\\u01B4\\u024F\\u1EFF'},\n      {'base':'z','letters':'\\u007A\\u24E9\\uFF5A\\u017A\\u1E91\\u017C\\u017E\\u1E93\\u1E95\\u01B6\\u0225\\u0240\\u2C6C\\uA763'}\n    ];\n\n    var diacriticsMap = {};\n    for (var i = 0; i < defaultDiacriticsRemovalap.length; i++) {\n      var letters = defaultDiacriticsRemovalap[i].letters.split(\"\");\n      for (var j = 0; j < letters.length ; j++){\n        diacriticsMap[letters[j]] = defaultDiacriticsRemovalap[i].base;\n      }\n    }\n\n    // \"what?\" version ... http://jsperf.com/diacritics/12\n    function removeDiacritics (str) {\n      return str.replace(/[^\\u0000-\\u007E]/g, function(a){\n        return diacriticsMap[a] || a;\n      });\n    }\n\n    return function (input) {\n\n      return isString(input)\n        ? removeDiacritics(input)\n        : input;\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name ltrim\n * @kind function\n *\n * @description\n * Left trim. Similar to trimFilter, but only for left side.\n */\nangular.module('a8m.ltrim', [])\n  .filter('ltrim', function () {\n    return function(input, chars) {\n\n      var trim = chars || '\\\\s';\n\n      return isString(input)\n        ? input.replace(new RegExp('^' + trim + '+'), '')\n        : input;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name match\n * @kind function\n *\n * @description\n * Return the matched pattern in a string.\n */\nangular.module('a8m.match', [])\n  .filter('match', function () {\n    return function (input, pattern, flag) {\n\n      var reg = new RegExp(pattern, flag);\n\n      return isString(input)\n        ? input.match(reg)\n        : null;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name phone-us\n * @kind function\n *\n * @description\n * format a string or a number into a us-style\n * phone number in the form (***) ***-****\n */\nangular.module('a8m.phoneUS', [])\n  .filter('phoneUS', function () {\n    return function(num) {\n      num += '';\n      return '(' + num.slice(0, 3) + ') ' + num.slice(3, 6) + '-' + num.slice(6);\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name repeat\n * @kind function\n *\n * @description\n * Repeats a string n times\n */\nangular.module('a8m.repeat', [])\n  .filter('repeat',[ function () {\n    return function (input, n, separator) {\n\n      var times = ~~n;\n\n      if(!isString(input)) {\n        return input;\n      }\n\n      return !times\n        ? input\n        : strRepeat(input, --n, separator || '');\n    }\n  }]);\n\n/**\n * Repeats a string n times with given separator\n * @param str string to repeat\n * @param n number of times\n * @param sep separator\n * @returns {*}\n */\nfunction strRepeat(str, n, sep) {\n  if(!n) {\n    return str;\n  }\n  return str + sep + strRepeat(str, --n, sep);\n}\n/**\n* @ngdoc filter\n* @name rtrim\n* @kind function\n*\n* @description\n* Right trim. Similar to trimFilter, but only for right side.\n*/\nangular.module('a8m.rtrim', [])\n  .filter('rtrim', function () {\n    return function(input, chars) {\n\n      var trim = chars || '\\\\s';\n\n      return isString(input)\n        ? input.replace(new RegExp(trim + '+$'), '')\n        : input;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name slugify\n * @kind function\n *\n * @description\n * remove spaces from string, replace with \"-\" or given argument\n */\nangular.module('a8m.slugify', [])\n  .filter('slugify',[ function () {\n    return function (input, sub) {\n\n      var replace = (isUndefined(sub)) ? '-' : sub;\n\n      return isString(input)\n        ? input.toLowerCase().replace(/\\s+/g, replace)\n        : input;\n    }\n  }]);\n\n/**\n * @ngdoc filter\n * @name split\n * @kind function\n *\n * @description\n * split a string by a provided delimiter (none '' by default) and skip first n-delimiters\n */\nangular.module('a8m.split', [])\n  .filter('split', function () {\n    function escapeRegExp(str) {\n      return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n    }\n\n    return function (input, delimiter, skip) {\n      var _regexp, _matches, _splitted, _temp;\n\n      if (isUndefined(input) || !isString(input)) {\n        return null;\n      }\n      if (isUndefined(delimiter)) delimiter = '';\n      if (isNaN(skip)) skip = 0;\n\n      _regexp = new RegExp(escapeRegExp(delimiter), 'g');\n      _matches = input.match(_regexp);\n      \n      if (isNull(_matches) || skip >= _matches.length) {\n        return [input];\n      }\n\n      if (skip === 0) return input.split(delimiter);\n      \n      _splitted = input.split(delimiter);\n      _temp = _splitted.splice(0, skip + 1);\n      _splitted.unshift(_temp.join(delimiter));\n    \n      return _splitted;\n    };\n  })\n;\n\n/**\n * @ngdoc filter\n * @name startWith\n * @kind function\n *\n * @description\n * checks whether string starts with the starts parameter.\n */\nangular.module('a8m.starts-with', [])\n  .filter('startsWith', function () {\n    return function (input, start, csensitive) {\n\n      var sensitive = csensitive || false;\n\n      if(!isString(input) || isUndefined(start)) {\n        return input;\n      }\n\n      input = (sensitive) ? input : input.toLowerCase();\n\n      return !input.indexOf((sensitive) ? start : start.toLowerCase());\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name stringular\n * @kind function\n *\n * @description\n * get string with {n} and replace match with enumeration values\n */\nangular.module('a8m.stringular', [])\n  .filter('stringular', function () {\n    return function(input) {\n\n      var args = Array.prototype.slice.call(arguments, 1);\n\n      return input.replace(/{(\\d+)}/g, function (match, number) {\n        return isUndefined(args[number]) ? match : args[number];\n      });\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name stripTags\n * @kind function\n *\n * @description\n * strip html tags from string\n */\nangular.module('a8m.strip-tags', [])\n  .filter('stripTags', function () {\n    return function(input) {\n      return isString(input)\n        ? input.replace(/<\\S[^><]*>/g, '')\n        : input;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name test\n * @kind function\n *\n * @description\n * test if a string match a pattern.\n */\nangular.module('a8m.test', [])\n  .filter('test', function () {\n    return function (input, pattern, flag) {\n\n      var reg = new RegExp(pattern, flag);\n\n      return isString(input)\n        ? reg.test(input)\n        : input;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name trim\n * @kind function\n *\n * @description\n *  Strip whitespace (or other characters) from the beginning and end of a string\n */\nangular.module('a8m.trim', [])\n  .filter('trim', function () {\n    return function(input, chars) {\n\n      var trim = chars || '\\\\s';\n\n      return isString(input)\n        ? input.replace(new RegExp('^' + trim + '+|' + trim + '+$', 'g'), '')\n        : input;\n    }\n  });\n\n/**\n * @ngdoc filter\n * @name truncate\n * @kind function\n *\n * @description\n * truncates a string given a specified length, providing a custom string to denote an omission.\n */\nangular.module('a8m.truncate', [])\n  .filter('truncate', function () {\n    return function(input, length, suffix, preserve) {\n\n      length = isUndefined(length) ? input.length : length;\n      preserve = preserve || false;\n      suffix = suffix || '';\n\n      if(!isString(input) || (input.length <= length)) return input;\n\n      return input.substring(0, (preserve)\n        ? ((input.indexOf(' ', length) === -1) ? input.length : input.indexOf(' ', length))\n        : length) + suffix;\n    };\n  });\n\n/**\n * @ngdoc filter\n * @name ucfirst\n * @kind function\n *\n * @description\n * ucfirst\n */\nangular.module('a8m.ucfirst', [])\n  .filter({\n    ucfirst: ucfirstFilter,\n    titleize: ucfirstFilter\n  });\n\nfunction ucfirstFilter() {\n  return function (input) {\n    return isString(input)\n      ? input\n      .split(' ')\n      .map(function (ch) {\n        return ch.charAt(0).toUpperCase() + ch.substring(1);\n      })\n      .join(' ')\n      : input;\n  }\n}\n\n/**\n * @ngdoc filter\n * @name uriComponentEncode\n * @kind function\n *\n * @description\n * get string as parameter and return encoded string\n */\nangular.module('a8m.uri-component-encode', [])\n  .filter('uriComponentEncode',['$window', function ($window) {\n      return function (input) {\n        return isString(input)\n          ? $window.encodeURIComponent(input)\n          : input;\n      }\n    }]);\n\n/**\n * @ngdoc filter\n * @name uriEncode\n * @kind function\n *\n * @description\n * get string as parameter and return encoded string\n */\nangular.module('a8m.uri-encode', [])\n  .filter('uriEncode',['$window', function ($window) {\n      return function (input) {\n        return isString(input)\n          ? $window.encodeURI(input)\n          : input;\n      }\n    }]);\n\n/**\n * @ngdoc filter\n * @name wrap\n * @kind function\n *\n * @description\n * Wrap a string with another string\n */\nangular.module('a8m.wrap', [])\n  .filter('wrap', function () {\n    return function(input, wrap, ends) {\n      return isString(input) && isDefined(wrap)\n        ? [wrap, input, ends || wrap].join('')\n        : input;\n    }\n  });\n\n/**\n * @ngdoc provider\n * @name filterWatcher\n * @kind function\n *\n * @description\n * store specific filters result in $$cache, based on scope life time(avoid memory leak).\n * on scope.$destroy remove it's cache from $$cache container\n */\n\nangular.module('a8m.filter-watcher', [])\n  .provider('filterWatcher', function() {\n\n    this.$get = ['$window', '$rootScope', function($window, $rootScope) {\n\n      /**\n       * Cache storing\n       * @type {Object}\n       */\n      var $$cache = {};\n\n      /**\n       * Scope listeners container\n       * scope.$destroy => remove all cache keys\n       * bind to current scope.\n       * @type {Object}\n       */\n      var $$listeners = {};\n\n      /**\n       * $timeout without triggering the digest cycle\n       * @type {function}\n       */\n      var $$timeout = $window.setTimeout;\n\n      /**\n       * @description\n       * get `HashKey` string based on the given arguments.\n       * @param fName\n       * @param args\n       * @returns {string}\n       */\n      function getHashKey(fName, args) {\n        function replacerFactory() {\n          var cache = [];\n          return function(key, val) {\n            if(isObject(val) && !isNull(val)) {\n              if (~cache.indexOf(val)) return '[Circular]';\n              cache.push(val)\n            }\n            if($window == val) return '$WINDOW';\n            if($window.document == val) return '$DOCUMENT';\n            if(isScope(val)) return '$SCOPE';\n            return val;\n          }\n        }\n        return [fName, JSON.stringify(args, replacerFactory())]\n          .join('#')\n          .replace(/\"/g,'');\n      }\n\n      /**\n       * @description\n       * fir on $scope.$destroy,\n       * remove cache based scope from `$$cache`,\n       * and remove itself from `$$listeners`\n       * @param event\n       */\n      function removeCache(event) {\n        var id = event.targetScope.$id;\n        forEach($$listeners[id], function(key) {\n          delete $$cache[key];\n        });\n        delete $$listeners[id];\n      }\n\n      /**\n       * @description\n       * for angular version that greater than v.1.3.0\n       * it clear cache when the digest cycle is end.\n       */\n      function cleanStateless() {\n        $$timeout(function() {\n          if(!$rootScope.$$phase)\n            $$cache = {};\n        }, 2000);\n      }\n\n      /**\n       * @description\n       * Store hashKeys in $$listeners container\n       * on scope.$destroy, remove them all(bind an event).\n       * @param scope\n       * @param hashKey\n       * @returns {*}\n       */\n      function addListener(scope, hashKey) {\n        var id = scope.$id;\n        if(isUndefined($$listeners[id])) {\n          scope.$on('$destroy', removeCache);\n          $$listeners[id] = [];\n        }\n        return $$listeners[id].push(hashKey);\n      }\n\n      /**\n       * @description\n       * return the `cacheKey` or undefined.\n       * @param filterName\n       * @param args\n       * @returns {*}\n       */\n      function $$isMemoized(filterName, args) {\n        var hashKey = getHashKey(filterName, args);\n        return $$cache[hashKey];\n      }\n\n      /**\n       * @description\n       * store `result` in `$$cache` container, based on the hashKey.\n       * add $destroy listener and return result\n       * @param filterName\n       * @param args\n       * @param scope\n       * @param result\n       * @returns {*}\n       */\n      function $$memoize(filterName, args, scope, result) {\n        var hashKey = getHashKey(filterName, args);\n        //store result in `$$cache` container\n        $$cache[hashKey] = result;\n        // for angular versions that less than 1.3\n        // add to `$destroy` listener, a cleaner callback\n        if(isScope(scope)) {\n          addListener(scope, hashKey);\n        } else {\n          cleanStateless();\n        }\n        return result;\n      }\n\n      return {\n        isMemoized: $$isMemoized,\n        memoize: $$memoize\n      }\n    }];\n  });\n  \n\n/**\n * @ngdoc module\n * @name angular.filters\n * @description\n * Bunch of useful filters for angularJS\n */\n\nangular.module('angular.filter', [\n\n  'a8m.ucfirst',\n  'a8m.uri-encode',\n  'a8m.uri-component-encode',\n  'a8m.slugify',\n  'a8m.latinize',\n  'a8m.strip-tags',\n  'a8m.stringular',\n  'a8m.truncate',\n  'a8m.starts-with',\n  'a8m.ends-with',\n  'a8m.wrap',\n  'a8m.trim',\n  'a8m.ltrim',\n  'a8m.rtrim',\n  'a8m.repeat',\n  'a8m.test',\n  'a8m.match',\n  'a8m.split',\n\n  'a8m.to-array',\n  'a8m.concat',\n  'a8m.contains',\n  'a8m.unique',\n  'a8m.is-empty',\n  'a8m.after',\n  'a8m.after-where',\n  'a8m.before',\n  'a8m.before-where',\n  'a8m.defaults',\n  'a8m.where',\n  'a8m.reverse',\n  'a8m.remove',\n  'a8m.remove-with',\n  'a8m.group-by',\n  'a8m.count-by',\n  'a8m.chunk-by',\n  'a8m.search-field',\n  'a8m.fuzzy-by',\n  'a8m.fuzzy',\n  'a8m.omit',\n  'a8m.pick',\n  'a8m.every',\n  'a8m.filter-by',\n  'a8m.xor',\n  'a8m.map',\n  'a8m.first',\n  'a8m.last',\n  'a8m.flatten',\n  'a8m.join',\n  'a8m.range',\n\n  'a8m.math.max',\n  'a8m.math.min',\n  'a8m.math.abs',\n  'a8m.math.percent',\n  'a8m.math.radix',\n  'a8m.math.sum',\n  'a8m.math.degrees',\n  'a8m.math.radians',\n  'a8m.math.byteFmt',\n  'a8m.math.kbFmt',\n  'a8m.math.shortFmt',\n\n  'a8m.angular',\n  'a8m.conditions',\n  'a8m.is-null',\n\n  'a8m.filter-watcher'\n]);\n})( window, window.angular );","/**\n * @license AngularJS v1.6.1\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\n/* global shallowCopy: true */\n\n/**\n * Creates a shallow copy of an object, an array or a primitive.\n *\n * Assumes that there are no proto properties for objects.\n */\nfunction shallowCopy(src, dst) {\n  if (isArray(src)) {\n    dst = dst || [];\n\n    for (var i = 0, ii = src.length; i < ii; i++) {\n      dst[i] = src[i];\n    }\n  } else if (isObject(src)) {\n    dst = dst || {};\n\n    for (var key in src) {\n      if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {\n        dst[key] = src[key];\n      }\n    }\n  }\n\n  return dst || src;\n}\n\n/* global shallowCopy: false */\n\n// `isArray` and `isObject` are necessary for `shallowCopy()` (included via `src/shallowCopy.js`).\n// They are initialized inside the `$RouteProvider`, to ensure `window.angular` is available.\nvar isArray;\nvar isObject;\nvar isDefined;\n\n/**\n * @ngdoc module\n * @name ngRoute\n * @description\n *\n * # ngRoute\n *\n * The `ngRoute` module provides routing and deeplinking services and directives for angular apps.\n *\n * ## Example\n * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.\n *\n *\n * <div doc-module-components=\"ngRoute\"></div>\n */\n/* global -ngRouteModule */\nvar ngRouteModule = angular.\n  module('ngRoute', []).\n  provider('$route', $RouteProvider).\n  // Ensure `$route` will be instantiated in time to capture the initial `$locationChangeSuccess`\n  // event (unless explicitly disabled). This is necessary in case `ngView` is included in an\n  // asynchronously loaded template.\n  run(instantiateRoute);\nvar $routeMinErr = angular.$$minErr('ngRoute');\nvar isEagerInstantiationEnabled;\n\n\n/**\n * @ngdoc provider\n * @name $routeProvider\n * @this\n *\n * @description\n *\n * Used for configuring routes.\n *\n * ## Example\n * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.\n *\n * ## Dependencies\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n */\nfunction $RouteProvider() {\n  isArray = angular.isArray;\n  isObject = angular.isObject;\n  isDefined = angular.isDefined;\n\n  function inherit(parent, extra) {\n    return angular.extend(Object.create(parent), extra);\n  }\n\n  var routes = {};\n\n  /**\n   * @ngdoc method\n   * @name $routeProvider#when\n   *\n   * @param {string} path Route path (matched against `$location.path`). If `$location.path`\n   *    contains redundant trailing slash or is missing one, the route will still match and the\n   *    `$location.path` will be updated to add or drop the trailing slash to exactly match the\n   *    route definition.\n   *\n   *    * `path` can contain named groups starting with a colon: e.g. `:name`. All characters up\n   *        to the next slash are matched and stored in `$routeParams` under the given `name`\n   *        when the route matches.\n   *    * `path` can contain named groups starting with a colon and ending with a star:\n   *        e.g.`:name*`. All characters are eagerly stored in `$routeParams` under the given `name`\n   *        when the route matches.\n   *    * `path` can contain optional named groups with a question mark: e.g.`:name?`.\n   *\n   *    For example, routes like `/color/:color/largecode/:largecode*\\/edit` will match\n   *    `/color/brown/largecode/code/with/slashes/edit` and extract:\n   *\n   *    * `color: brown`\n   *    * `largecode: code/with/slashes`.\n   *\n   *\n   * @param {Object} route Mapping information to be assigned to `$route.current` on route\n   *    match.\n   *\n   *    Object properties:\n   *\n   *    - `controller` – `{(string|Function)=}` – Controller fn that should be associated with\n   *      newly created scope or the name of a {@link angular.Module#controller registered\n   *      controller} if passed as a string.\n   *    - `controllerAs` – `{string=}` – An identifier name for a reference to the controller.\n   *      If present, the controller will be published to scope under the `controllerAs` name.\n   *    - `template` – `{(string|Function)=}` – html template as a string or a function that\n   *      returns an html template as a string which should be used by {@link\n   *      ngRoute.directive:ngView ngView} or {@link ng.directive:ngInclude ngInclude} directives.\n   *      This property takes precedence over `templateUrl`.\n   *\n   *      If `template` is a function, it will be called with the following parameters:\n   *\n   *      - `{Array.<Object>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route\n   *\n   *      One of `template` or `templateUrl` is required.\n   *\n   *    - `templateUrl` – `{(string|Function)=}` – path or function that returns a path to an html\n   *      template that should be used by {@link ngRoute.directive:ngView ngView}.\n   *\n   *      If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *      - `{Array.<Object>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route\n   *\n   *      One of `templateUrl` or `template` is required.\n   *\n   *    - `resolve` - `{Object.<string, Function>=}` - An optional map of dependencies which should\n   *      be injected into the controller. If any of these dependencies are promises, the router\n   *      will wait for them all to be resolved or one to be rejected before the controller is\n   *      instantiated.\n   *      If all the promises are resolved successfully, the values of the resolved promises are\n   *      injected and {@link ngRoute.$route#$routeChangeSuccess $routeChangeSuccess} event is\n   *      fired. If any of the promises are rejected the\n   *      {@link ngRoute.$route#$routeChangeError $routeChangeError} event is fired.\n   *      For easier access to the resolved dependencies from the template, the `resolve` map will\n   *      be available on the scope of the route, under `$resolve` (by default) or a custom name\n   *      specified by the `resolveAs` property (see below). This can be particularly useful, when\n   *      working with {@link angular.Module#component components} as route templates.<br />\n   *      <div class=\"alert alert-warning\">\n   *        **Note:** If your scope already contains a property with this name, it will be hidden\n   *        or overwritten. Make sure, you specify an appropriate name for this property, that\n   *        does not collide with other properties on the scope.\n   *      </div>\n   *      The map object is:\n   *\n   *      - `key` – `{string}`: a name of a dependency to be injected into the controller.\n   *      - `factory` - `{string|Function}`: If `string` then it is an alias for a service.\n   *        Otherwise if function, then it is {@link auto.$injector#invoke injected}\n   *        and the return value is treated as the dependency. If the result is a promise, it is\n   *        resolved before its value is injected into the controller. Be aware that\n   *        `ngRoute.$routeParams` will still refer to the previous route within these resolve\n   *        functions.  Use `$route.current.params` to access the new route parameters, instead.\n   *\n   *    - `resolveAs` - `{string=}` - The name under which the `resolve` map will be available on\n   *      the scope of the route. If omitted, defaults to `$resolve`.\n   *\n   *    - `redirectTo` – `{(string|Function)=}` – value to update\n   *      {@link ng.$location $location} path with and trigger route redirection.\n   *\n   *      If `redirectTo` is a function, it will be called with the following parameters:\n   *\n   *      - `{Object.<string>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route templateUrl.\n   *      - `{string}` - current `$location.path()`\n   *      - `{Object}` - current `$location.search()`\n   *\n   *      The custom `redirectTo` function is expected to return a string which will be used\n   *      to update `$location.url()`. If the function throws an error, no further processing will\n   *      take place and the {@link ngRoute.$route#$routeChangeError $routeChangeError} event will\n   *      be fired.\n   *\n   *      Routes that specify `redirectTo` will not have their controllers, template functions\n   *      or resolves called, the `$location` will be changed to the redirect url and route\n   *      processing will stop. The exception to this is if the `redirectTo` is a function that\n   *      returns `undefined`. In this case the route transition occurs as though there was no\n   *      redirection.\n   *\n   *    - `resolveRedirectTo` – `{Function=}` – a function that will (eventually) return the value\n   *      to update {@link ng.$location $location} URL with and trigger route redirection. In\n   *      contrast to `redirectTo`, dependencies can be injected into `resolveRedirectTo` and the\n   *      return value can be either a string or a promise that will be resolved to a string.\n   *\n   *      Similar to `redirectTo`, if the return value is `undefined` (or a promise that gets\n   *      resolved to `undefined`), no redirection takes place and the route transition occurs as\n   *      though there was no redirection.\n   *\n   *      If the function throws an error or the returned promise gets rejected, no further\n   *      processing will take place and the\n   *      {@link ngRoute.$route#$routeChangeError $routeChangeError} event will be fired.\n   *\n   *      `redirectTo` takes precedence over `resolveRedirectTo`, so specifying both on the same\n   *      route definition, will cause the latter to be ignored.\n   *\n   *    - `[reloadOnSearch=true]` - `{boolean=}` - reload route when only `$location.search()`\n   *      or `$location.hash()` changes.\n   *\n   *      If the option is set to `false` and url in the browser changes, then\n   *      `$routeUpdate` event is broadcasted on the root scope.\n   *\n   *    - `[caseInsensitiveMatch=false]` - `{boolean=}` - match routes without being case sensitive\n   *\n   *      If the option is set to `true`, then the particular route can be matched without being\n   *      case sensitive\n   *\n   * @returns {Object} self\n   *\n   * @description\n   * Adds a new route definition to the `$route` service.\n   */\n  this.when = function(path, route) {\n    //copy original route object to preserve params inherited from proto chain\n    var routeCopy = shallowCopy(route);\n    if (angular.isUndefined(routeCopy.reloadOnSearch)) {\n      routeCopy.reloadOnSearch = true;\n    }\n    if (angular.isUndefined(routeCopy.caseInsensitiveMatch)) {\n      routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch;\n    }\n    routes[path] = angular.extend(\n      routeCopy,\n      path && pathRegExp(path, routeCopy)\n    );\n\n    // create redirection for trailing slashes\n    if (path) {\n      var redirectPath = (path[path.length - 1] === '/')\n            ? path.substr(0, path.length - 1)\n            : path + '/';\n\n      routes[redirectPath] = angular.extend(\n        {redirectTo: path},\n        pathRegExp(redirectPath, routeCopy)\n      );\n    }\n\n    return this;\n  };\n\n  /**\n   * @ngdoc property\n   * @name $routeProvider#caseInsensitiveMatch\n   * @description\n   *\n   * A boolean property indicating if routes defined\n   * using this provider should be matched using a case insensitive\n   * algorithm. Defaults to `false`.\n   */\n  this.caseInsensitiveMatch = false;\n\n   /**\n    * @param path {string} path\n    * @param opts {Object} options\n    * @return {?Object}\n    *\n    * @description\n    * Normalizes the given path, returning a regular expression\n    * and the original path.\n    *\n    * Inspired by pathRexp in visionmedia/express/lib/utils.js.\n    */\n  function pathRegExp(path, opts) {\n    var insensitive = opts.caseInsensitiveMatch,\n        ret = {\n          originalPath: path,\n          regexp: path\n        },\n        keys = ret.keys = [];\n\n    path = path\n      .replace(/([().])/g, '\\\\$1')\n      .replace(/(\\/)?:(\\w+)(\\*\\?|[?*])?/g, function(_, slash, key, option) {\n        var optional = (option === '?' || option === '*?') ? '?' : null;\n        var star = (option === '*' || option === '*?') ? '*' : null;\n        keys.push({ name: key, optional: !!optional });\n        slash = slash || '';\n        return ''\n          + (optional ? '' : slash)\n          + '(?:'\n          + (optional ? slash : '')\n          + (star && '(.+?)' || '([^/]+)')\n          + (optional || '')\n          + ')'\n          + (optional || '');\n      })\n      .replace(/([/$*])/g, '\\\\$1');\n\n    ret.regexp = new RegExp('^' + path + '$', insensitive ? 'i' : '');\n    return ret;\n  }\n\n  /**\n   * @ngdoc method\n   * @name $routeProvider#otherwise\n   *\n   * @description\n   * Sets route definition that will be used on route change when no other route definition\n   * is matched.\n   *\n   * @param {Object|string} params Mapping information to be assigned to `$route.current`.\n   * If called with a string, the value maps to `redirectTo`.\n   * @returns {Object} self\n   */\n  this.otherwise = function(params) {\n    if (typeof params === 'string') {\n      params = {redirectTo: params};\n    }\n    this.when(null, params);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @name $routeProvider#eagerInstantiationEnabled\n   * @kind function\n   *\n   * @description\n   * Call this method as a setter to enable/disable eager instantiation of the\n   * {@link ngRoute.$route $route} service upon application bootstrap. You can also call it as a\n   * getter (i.e. without any arguments) to get the current value of the\n   * `eagerInstantiationEnabled` flag.\n   *\n   * Instantiating `$route` early is necessary for capturing the initial\n   * {@link ng.$location#$locationChangeStart $locationChangeStart} event and navigating to the\n   * appropriate route. Usually, `$route` is instantiated in time by the\n   * {@link ngRoute.ngView ngView} directive. Yet, in cases where `ngView` is included in an\n   * asynchronously loaded template (e.g. in another directive's template), the directive factory\n   * might not be called soon enough for `$route` to be instantiated _before_ the initial\n   * `$locationChangeSuccess` event is fired. Eager instantiation ensures that `$route` is always\n   * instantiated in time, regardless of when `ngView` will be loaded.\n   *\n   * The default value is true.\n   *\n   * **Note**:<br />\n   * You may want to disable the default behavior when unit-testing modules that depend on\n   * `ngRoute`, in order to avoid an unexpected request for the default route's template.\n   *\n   * @param {boolean=} enabled - If provided, update the internal `eagerInstantiationEnabled` flag.\n   *\n   * @returns {*} The current value of the `eagerInstantiationEnabled` flag if used as a getter or\n   *     itself (for chaining) if used as a setter.\n   */\n  isEagerInstantiationEnabled = true;\n  this.eagerInstantiationEnabled = function eagerInstantiationEnabled(enabled) {\n    if (isDefined(enabled)) {\n      isEagerInstantiationEnabled = enabled;\n      return this;\n    }\n\n    return isEagerInstantiationEnabled;\n  };\n\n\n  this.$get = ['$rootScope',\n               '$location',\n               '$routeParams',\n               '$q',\n               '$injector',\n               '$templateRequest',\n               '$sce',\n      function($rootScope, $location, $routeParams, $q, $injector, $templateRequest, $sce) {\n\n    /**\n     * @ngdoc service\n     * @name $route\n     * @requires $location\n     * @requires $routeParams\n     *\n     * @property {Object} current Reference to the current route definition.\n     * The route definition contains:\n     *\n     *   - `controller`: The controller constructor as defined in the route definition.\n     *   - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for\n     *     controller instantiation. The `locals` contain\n     *     the resolved values of the `resolve` map. Additionally the `locals` also contain:\n     *\n     *     - `$scope` - The current route scope.\n     *     - `$template` - The current route template HTML.\n     *\n     *     The `locals` will be assigned to the route scope's `$resolve` property. You can override\n     *     the property name, using `resolveAs` in the route definition. See\n     *     {@link ngRoute.$routeProvider $routeProvider} for more info.\n     *\n     * @property {Object} routes Object with all route configuration Objects as its properties.\n     *\n     * @description\n     * `$route` is used for deep-linking URLs to controllers and views (HTML partials).\n     * It watches `$location.url()` and tries to map the path to an existing route definition.\n     *\n     * Requires the {@link ngRoute `ngRoute`} module to be installed.\n     *\n     * You can define routes through {@link ngRoute.$routeProvider $routeProvider}'s API.\n     *\n     * The `$route` service is typically used in conjunction with the\n     * {@link ngRoute.directive:ngView `ngView`} directive and the\n     * {@link ngRoute.$routeParams `$routeParams`} service.\n     *\n     * @example\n     * This example shows how changing the URL hash causes the `$route` to match a route against the\n     * URL, and the `ngView` pulls in the partial.\n     *\n     * <example name=\"$route-service\" module=\"ngRouteExample\"\n     *          deps=\"angular-route.js\" fixBase=\"true\">\n     *   <file name=\"index.html\">\n     *     <div ng-controller=\"MainController\">\n     *       Choose:\n     *       <a href=\"Book/Moby\">Moby</a> |\n     *       <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n     *       <a href=\"Book/Gatsby\">Gatsby</a> |\n     *       <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n     *       <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n     *\n     *       <div ng-view></div>\n     *\n     *       <hr />\n     *\n     *       <pre>$location.path() = {{$location.path()}}</pre>\n     *       <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>\n     *       <pre>$route.current.params = {{$route.current.params}}</pre>\n     *       <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>\n     *       <pre>$routeParams = {{$routeParams}}</pre>\n     *     </div>\n     *   </file>\n     *\n     *   <file name=\"book.html\">\n     *     controller: {{name}}<br />\n     *     Book Id: {{params.bookId}}<br />\n     *   </file>\n     *\n     *   <file name=\"chapter.html\">\n     *     controller: {{name}}<br />\n     *     Book Id: {{params.bookId}}<br />\n     *     Chapter Id: {{params.chapterId}}\n     *   </file>\n     *\n     *   <file name=\"script.js\">\n     *     angular.module('ngRouteExample', ['ngRoute'])\n     *\n     *      .controller('MainController', function($scope, $route, $routeParams, $location) {\n     *          $scope.$route = $route;\n     *          $scope.$location = $location;\n     *          $scope.$routeParams = $routeParams;\n     *      })\n     *\n     *      .controller('BookController', function($scope, $routeParams) {\n     *          $scope.name = 'BookController';\n     *          $scope.params = $routeParams;\n     *      })\n     *\n     *      .controller('ChapterController', function($scope, $routeParams) {\n     *          $scope.name = 'ChapterController';\n     *          $scope.params = $routeParams;\n     *      })\n     *\n     *     .config(function($routeProvider, $locationProvider) {\n     *       $routeProvider\n     *        .when('/Book/:bookId', {\n     *         templateUrl: 'book.html',\n     *         controller: 'BookController',\n     *         resolve: {\n     *           // I will cause a 1 second delay\n     *           delay: function($q, $timeout) {\n     *             var delay = $q.defer();\n     *             $timeout(delay.resolve, 1000);\n     *             return delay.promise;\n     *           }\n     *         }\n     *       })\n     *       .when('/Book/:bookId/ch/:chapterId', {\n     *         templateUrl: 'chapter.html',\n     *         controller: 'ChapterController'\n     *       });\n     *\n     *       // configure html5 to get links working on jsfiddle\n     *       $locationProvider.html5Mode(true);\n     *     });\n     *\n     *   </file>\n     *\n     *   <file name=\"protractor.js\" type=\"protractor\">\n     *     it('should load and compile correct template', function() {\n     *       element(by.linkText('Moby: Ch1')).click();\n     *       var content = element(by.css('[ng-view]')).getText();\n     *       expect(content).toMatch(/controller: ChapterController/);\n     *       expect(content).toMatch(/Book Id: Moby/);\n     *       expect(content).toMatch(/Chapter Id: 1/);\n     *\n     *       element(by.partialLinkText('Scarlet')).click();\n     *\n     *       content = element(by.css('[ng-view]')).getText();\n     *       expect(content).toMatch(/controller: BookController/);\n     *       expect(content).toMatch(/Book Id: Scarlet/);\n     *     });\n     *   </file>\n     * </example>\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeStart\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted before a route change. At this  point the route services starts\n     * resolving all of the dependencies needed for the route change to occur.\n     * Typically this involves fetching the view template as well as any dependencies\n     * defined in `resolve` route property. Once  all of the dependencies are resolved\n     * `$routeChangeSuccess` is fired.\n     *\n     * The route change (and the `$location` change that triggered it) can be prevented\n     * by calling `preventDefault` method of the event. See {@link ng.$rootScope.Scope#$on}\n     * for more details about event object.\n     *\n     * @param {Object} angularEvent Synthetic event object.\n     * @param {Route} next Future route information.\n     * @param {Route} current Current route information.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeSuccess\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted after a route change has happened successfully.\n     * The `resolve` dependencies are now available in the `current.locals` property.\n     *\n     * {@link ngRoute.directive:ngView ngView} listens for the directive\n     * to instantiate the controller and render the view.\n     *\n     * @param {Object} angularEvent Synthetic event object.\n     * @param {Route} current Current route information.\n     * @param {Route|Undefined} previous Previous route information, or undefined if current is\n     * first route entered.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeError\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted if a redirection function fails or any redirection or resolve promises are\n     * rejected.\n     *\n     * @param {Object} angularEvent Synthetic event object\n     * @param {Route} current Current route information.\n     * @param {Route} previous Previous route information.\n     * @param {Route} rejection The thrown error or the rejection reason of the promise. Usually\n     * the rejection reason is the error that caused the promise to get rejected.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeUpdate\n     * @eventType broadcast on root scope\n     * @description\n     * The `reloadOnSearch` property has been set to false, and we are reusing the same\n     * instance of the Controller.\n     *\n     * @param {Object} angularEvent Synthetic event object\n     * @param {Route} current Current/previous route information.\n     */\n\n    var forceReload = false,\n        preparedRoute,\n        preparedRouteIsUpdateOnly,\n        $route = {\n          routes: routes,\n\n          /**\n           * @ngdoc method\n           * @name $route#reload\n           *\n           * @description\n           * Causes `$route` service to reload the current route even if\n           * {@link ng.$location $location} hasn't changed.\n           *\n           * As a result of that, {@link ngRoute.directive:ngView ngView}\n           * creates new scope and reinstantiates the controller.\n           */\n          reload: function() {\n            forceReload = true;\n\n            var fakeLocationEvent = {\n              defaultPrevented: false,\n              preventDefault: function fakePreventDefault() {\n                this.defaultPrevented = true;\n                forceReload = false;\n              }\n            };\n\n            $rootScope.$evalAsync(function() {\n              prepareRoute(fakeLocationEvent);\n              if (!fakeLocationEvent.defaultPrevented) commitRoute();\n            });\n          },\n\n          /**\n           * @ngdoc method\n           * @name $route#updateParams\n           *\n           * @description\n           * Causes `$route` service to update the current URL, replacing\n           * current route parameters with those specified in `newParams`.\n           * Provided property names that match the route's path segment\n           * definitions will be interpolated into the location's path, while\n           * remaining properties will be treated as query params.\n           *\n           * @param {!Object<string, string>} newParams mapping of URL parameter names to values\n           */\n          updateParams: function(newParams) {\n            if (this.current && this.current.$$route) {\n              newParams = angular.extend({}, this.current.params, newParams);\n              $location.path(interpolate(this.current.$$route.originalPath, newParams));\n              // interpolate modifies newParams, only query params are left\n              $location.search(newParams);\n            } else {\n              throw $routeMinErr('norout', 'Tried updating route when with no current route');\n            }\n          }\n        };\n\n    $rootScope.$on('$locationChangeStart', prepareRoute);\n    $rootScope.$on('$locationChangeSuccess', commitRoute);\n\n    return $route;\n\n    /////////////////////////////////////////////////////\n\n    /**\n     * @param on {string} current url\n     * @param route {Object} route regexp to match the url against\n     * @return {?Object}\n     *\n     * @description\n     * Check if the route matches the current url.\n     *\n     * Inspired by match in\n     * visionmedia/express/lib/router/router.js.\n     */\n    function switchRouteMatcher(on, route) {\n      var keys = route.keys,\n          params = {};\n\n      if (!route.regexp) return null;\n\n      var m = route.regexp.exec(on);\n      if (!m) return null;\n\n      for (var i = 1, len = m.length; i < len; ++i) {\n        var key = keys[i - 1];\n\n        var val = m[i];\n\n        if (key && val) {\n          params[key.name] = val;\n        }\n      }\n      return params;\n    }\n\n    function prepareRoute($locationEvent) {\n      var lastRoute = $route.current;\n\n      preparedRoute = parseRoute();\n      preparedRouteIsUpdateOnly = preparedRoute && lastRoute && preparedRoute.$$route === lastRoute.$$route\n          && angular.equals(preparedRoute.pathParams, lastRoute.pathParams)\n          && !preparedRoute.reloadOnSearch && !forceReload;\n\n      if (!preparedRouteIsUpdateOnly && (lastRoute || preparedRoute)) {\n        if ($rootScope.$broadcast('$routeChangeStart', preparedRoute, lastRoute).defaultPrevented) {\n          if ($locationEvent) {\n            $locationEvent.preventDefault();\n          }\n        }\n      }\n    }\n\n    function commitRoute() {\n      var lastRoute = $route.current;\n      var nextRoute = preparedRoute;\n\n      if (preparedRouteIsUpdateOnly) {\n        lastRoute.params = nextRoute.params;\n        angular.copy(lastRoute.params, $routeParams);\n        $rootScope.$broadcast('$routeUpdate', lastRoute);\n      } else if (nextRoute || lastRoute) {\n        forceReload = false;\n        $route.current = nextRoute;\n\n        var nextRoutePromise = $q.resolve(nextRoute);\n\n        nextRoutePromise.\n          then(getRedirectionData).\n          then(handlePossibleRedirection).\n          then(function(keepProcessingRoute) {\n            return keepProcessingRoute && nextRoutePromise.\n              then(resolveLocals).\n              then(function(locals) {\n                // after route change\n                if (nextRoute === $route.current) {\n                  if (nextRoute) {\n                    nextRoute.locals = locals;\n                    angular.copy(nextRoute.params, $routeParams);\n                  }\n                  $rootScope.$broadcast('$routeChangeSuccess', nextRoute, lastRoute);\n                }\n              });\n          }).catch(function(error) {\n            if (nextRoute === $route.current) {\n              $rootScope.$broadcast('$routeChangeError', nextRoute, lastRoute, error);\n            }\n          });\n      }\n    }\n\n    function getRedirectionData(route) {\n      var data = {\n        route: route,\n        hasRedirection: false\n      };\n\n      if (route) {\n        if (route.redirectTo) {\n          if (angular.isString(route.redirectTo)) {\n            data.path = interpolate(route.redirectTo, route.params);\n            data.search = route.params;\n            data.hasRedirection = true;\n          } else {\n            var oldPath = $location.path();\n            var oldSearch = $location.search();\n            var newUrl = route.redirectTo(route.pathParams, oldPath, oldSearch);\n\n            if (angular.isDefined(newUrl)) {\n              data.url = newUrl;\n              data.hasRedirection = true;\n            }\n          }\n        } else if (route.resolveRedirectTo) {\n          return $q.\n            resolve($injector.invoke(route.resolveRedirectTo)).\n            then(function(newUrl) {\n              if (angular.isDefined(newUrl)) {\n                data.url = newUrl;\n                data.hasRedirection = true;\n              }\n\n              return data;\n            });\n        }\n      }\n\n      return data;\n    }\n\n    function handlePossibleRedirection(data) {\n      var keepProcessingRoute = true;\n\n      if (data.route !== $route.current) {\n        keepProcessingRoute = false;\n      } else if (data.hasRedirection) {\n        var oldUrl = $location.url();\n        var newUrl = data.url;\n\n        if (newUrl) {\n          $location.\n            url(newUrl).\n            replace();\n        } else {\n          newUrl = $location.\n            path(data.path).\n            search(data.search).\n            replace().\n            url();\n        }\n\n        if (newUrl !== oldUrl) {\n          // Exit out and don't process current next value,\n          // wait for next location change from redirect\n          keepProcessingRoute = false;\n        }\n      }\n\n      return keepProcessingRoute;\n    }\n\n    function resolveLocals(route) {\n      if (route) {\n        var locals = angular.extend({}, route.resolve);\n        angular.forEach(locals, function(value, key) {\n          locals[key] = angular.isString(value) ?\n              $injector.get(value) :\n              $injector.invoke(value, null, null, key);\n        });\n        var template = getTemplateFor(route);\n        if (angular.isDefined(template)) {\n          locals['$template'] = template;\n        }\n        return $q.all(locals);\n      }\n    }\n\n    function getTemplateFor(route) {\n      var template, templateUrl;\n      if (angular.isDefined(template = route.template)) {\n        if (angular.isFunction(template)) {\n          template = template(route.params);\n        }\n      } else if (angular.isDefined(templateUrl = route.templateUrl)) {\n        if (angular.isFunction(templateUrl)) {\n          templateUrl = templateUrl(route.params);\n        }\n        if (angular.isDefined(templateUrl)) {\n          route.loadedTemplateUrl = $sce.valueOf(templateUrl);\n          template = $templateRequest(templateUrl);\n        }\n      }\n      return template;\n    }\n\n    /**\n     * @returns {Object} the current active route, by matching it against the URL\n     */\n    function parseRoute() {\n      // Match a route\n      var params, match;\n      angular.forEach(routes, function(route, path) {\n        if (!match && (params = switchRouteMatcher($location.path(), route))) {\n          match = inherit(route, {\n            params: angular.extend({}, $location.search(), params),\n            pathParams: params});\n          match.$$route = route;\n        }\n      });\n      // No route matched; fallback to \"otherwise\" route\n      return match || routes[null] && inherit(routes[null], {params: {}, pathParams:{}});\n    }\n\n    /**\n     * @returns {string} interpolation of the redirect path with the parameters\n     */\n    function interpolate(string, params) {\n      var result = [];\n      angular.forEach((string || '').split(':'), function(segment, i) {\n        if (i === 0) {\n          result.push(segment);\n        } else {\n          var segmentMatch = segment.match(/(\\w+)(?:[?*])?(.*)/);\n          var key = segmentMatch[1];\n          result.push(params[key]);\n          result.push(segmentMatch[2] || '');\n          delete params[key];\n        }\n      });\n      return result.join('');\n    }\n  }];\n}\n\ninstantiateRoute.$inject = ['$injector'];\nfunction instantiateRoute($injector) {\n  if (isEagerInstantiationEnabled) {\n    // Instantiate `$route`\n    $injector.get('$route');\n  }\n}\n\nngRouteModule.provider('$routeParams', $RouteParamsProvider);\n\n\n/**\n * @ngdoc service\n * @name $routeParams\n * @requires $route\n * @this\n *\n * @description\n * The `$routeParams` service allows you to retrieve the current set of route parameters.\n *\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n *\n * The route parameters are a combination of {@link ng.$location `$location`}'s\n * {@link ng.$location#search `search()`} and {@link ng.$location#path `path()`}.\n * The `path` parameters are extracted when the {@link ngRoute.$route `$route`} path is matched.\n *\n * In case of parameter name collision, `path` params take precedence over `search` params.\n *\n * The service guarantees that the identity of the `$routeParams` object will remain unchanged\n * (but its properties will likely change) even when a route change occurs.\n *\n * Note that the `$routeParams` are only updated *after* a route change completes successfully.\n * This means that you cannot rely on `$routeParams` being correct in route resolve functions.\n * Instead you can use `$route.current.params` to access the new route's parameters.\n *\n * @example\n * ```js\n *  // Given:\n *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby\n *  // Route: /Chapter/:chapterId/Section/:sectionId\n *  //\n *  // Then\n *  $routeParams ==> {chapterId:'1', sectionId:'2', search:'moby'}\n * ```\n */\nfunction $RouteParamsProvider() {\n  this.$get = function() { return {}; };\n}\n\nngRouteModule.directive('ngView', ngViewFactory);\nngRouteModule.directive('ngView', ngViewFillContentFactory);\n\n\n/**\n * @ngdoc directive\n * @name ngView\n * @restrict ECA\n *\n * @description\n * # Overview\n * `ngView` is a directive that complements the {@link ngRoute.$route $route} service by\n * including the rendered template of the current route into the main layout (`index.html`) file.\n * Every time the current route changes, the included view changes with it according to the\n * configuration of the `$route` service.\n *\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n *\n * @animations\n * | Animation                        | Occurs                              |\n * |----------------------------------|-------------------------------------|\n * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM |\n * | {@link ng.$animate#leave leave}  | when the old element is removed from to the DOM  |\n *\n * The enter and leave animation occur concurrently.\n *\n * @scope\n * @priority 400\n * @param {string=} onload Expression to evaluate whenever the view updates.\n *\n * @param {string=} autoscroll Whether `ngView` should call {@link ng.$anchorScroll\n *                  $anchorScroll} to scroll the viewport after the view is updated.\n *\n *                  - If the attribute is not set, disable scrolling.\n *                  - If the attribute is set without value, enable scrolling.\n *                  - Otherwise enable scrolling only if the `autoscroll` attribute value evaluated\n *                    as an expression yields a truthy value.\n * @example\n    <example name=\"ngView-directive\" module=\"ngViewExample\"\n             deps=\"angular-route.js;angular-animate.js\"\n             animations=\"true\" fixBase=\"true\">\n      <file name=\"index.html\">\n        <div ng-controller=\"MainCtrl as main\">\n          Choose:\n          <a href=\"Book/Moby\">Moby</a> |\n          <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n          <a href=\"Book/Gatsby\">Gatsby</a> |\n          <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n          <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n\n          <div class=\"view-animate-container\">\n            <div ng-view class=\"view-animate\"></div>\n          </div>\n          <hr />\n\n          <pre>$location.path() = {{main.$location.path()}}</pre>\n          <pre>$route.current.templateUrl = {{main.$route.current.templateUrl}}</pre>\n          <pre>$route.current.params = {{main.$route.current.params}}</pre>\n          <pre>$routeParams = {{main.$routeParams}}</pre>\n        </div>\n      </file>\n\n      <file name=\"book.html\">\n        <div>\n          controller: {{book.name}}<br />\n          Book Id: {{book.params.bookId}}<br />\n        </div>\n      </file>\n\n      <file name=\"chapter.html\">\n        <div>\n          controller: {{chapter.name}}<br />\n          Book Id: {{chapter.params.bookId}}<br />\n          Chapter Id: {{chapter.params.chapterId}}\n        </div>\n      </file>\n\n      <file name=\"animations.css\">\n        .view-animate-container {\n          position:relative;\n          height:100px!important;\n          background:white;\n          border:1px solid black;\n          height:40px;\n          overflow:hidden;\n        }\n\n        .view-animate {\n          padding:10px;\n        }\n\n        .view-animate.ng-enter, .view-animate.ng-leave {\n          transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\n\n          display:block;\n          width:100%;\n          border-left:1px solid black;\n\n          position:absolute;\n          top:0;\n          left:0;\n          right:0;\n          bottom:0;\n          padding:10px;\n        }\n\n        .view-animate.ng-enter {\n          left:100%;\n        }\n        .view-animate.ng-enter.ng-enter-active {\n          left:0;\n        }\n        .view-animate.ng-leave.ng-leave-active {\n          left:-100%;\n        }\n      </file>\n\n      <file name=\"script.js\">\n        angular.module('ngViewExample', ['ngRoute', 'ngAnimate'])\n          .config(['$routeProvider', '$locationProvider',\n            function($routeProvider, $locationProvider) {\n              $routeProvider\n                .when('/Book/:bookId', {\n                  templateUrl: 'book.html',\n                  controller: 'BookCtrl',\n                  controllerAs: 'book'\n                })\n                .when('/Book/:bookId/ch/:chapterId', {\n                  templateUrl: 'chapter.html',\n                  controller: 'ChapterCtrl',\n                  controllerAs: 'chapter'\n                });\n\n              $locationProvider.html5Mode(true);\n          }])\n          .controller('MainCtrl', ['$route', '$routeParams', '$location',\n            function MainCtrl($route, $routeParams, $location) {\n              this.$route = $route;\n              this.$location = $location;\n              this.$routeParams = $routeParams;\n          }])\n          .controller('BookCtrl', ['$routeParams', function BookCtrl($routeParams) {\n            this.name = 'BookCtrl';\n            this.params = $routeParams;\n          }])\n          .controller('ChapterCtrl', ['$routeParams', function ChapterCtrl($routeParams) {\n            this.name = 'ChapterCtrl';\n            this.params = $routeParams;\n          }]);\n\n      </file>\n\n      <file name=\"protractor.js\" type=\"protractor\">\n        it('should load and compile correct template', function() {\n          element(by.linkText('Moby: Ch1')).click();\n          var content = element(by.css('[ng-view]')).getText();\n          expect(content).toMatch(/controller: ChapterCtrl/);\n          expect(content).toMatch(/Book Id: Moby/);\n          expect(content).toMatch(/Chapter Id: 1/);\n\n          element(by.partialLinkText('Scarlet')).click();\n\n          content = element(by.css('[ng-view]')).getText();\n          expect(content).toMatch(/controller: BookCtrl/);\n          expect(content).toMatch(/Book Id: Scarlet/);\n        });\n      </file>\n    </example>\n */\n\n\n/**\n * @ngdoc event\n * @name ngView#$viewContentLoaded\n * @eventType emit on the current ngView scope\n * @description\n * Emitted every time the ngView content is reloaded.\n */\nngViewFactory.$inject = ['$route', '$anchorScroll', '$animate'];\nfunction ngViewFactory($route, $anchorScroll, $animate) {\n  return {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    link: function(scope, $element, attr, ctrl, $transclude) {\n        var currentScope,\n            currentElement,\n            previousLeaveAnimation,\n            autoScrollExp = attr.autoscroll,\n            onloadExp = attr.onload || '';\n\n        scope.$on('$routeChangeSuccess', update);\n        update();\n\n        function cleanupLastView() {\n          if (previousLeaveAnimation) {\n            $animate.cancel(previousLeaveAnimation);\n            previousLeaveAnimation = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n          if (currentElement) {\n            previousLeaveAnimation = $animate.leave(currentElement);\n            previousLeaveAnimation.done(function(response) {\n              if (response !== false) previousLeaveAnimation = null;\n            });\n            currentElement = null;\n          }\n        }\n\n        function update() {\n          var locals = $route.current && $route.current.locals,\n              template = locals && locals.$template;\n\n          if (angular.isDefined(template)) {\n            var newScope = scope.$new();\n            var current = $route.current;\n\n            // Note: This will also link all children of ng-view that were contained in the original\n            // html. If that content contains controllers, ... they could pollute/change the scope.\n            // However, using ng-view on an element with additional content does not make sense...\n            // Note: We can't remove them in the cloneAttchFn of $transclude as that\n            // function is called before linking the content, which would apply child\n            // directives to non existing elements.\n            var clone = $transclude(newScope, function(clone) {\n              $animate.enter(clone, null, currentElement || $element).done(function onNgViewEnter(response) {\n                if (response !== false && angular.isDefined(autoScrollExp)\n                  && (!autoScrollExp || scope.$eval(autoScrollExp))) {\n                  $anchorScroll();\n                }\n              });\n              cleanupLastView();\n            });\n\n            currentElement = clone;\n            currentScope = current.scope = newScope;\n            currentScope.$emit('$viewContentLoaded');\n            currentScope.$eval(onloadExp);\n          } else {\n            cleanupLastView();\n          }\n        }\n    }\n  };\n}\n\n// This directive is called during the $transclude call of the first `ngView` directive.\n// It will replace and compile the content of the element with the loaded template.\n// We need this directive so that the element content is already filled when\n// the link function of another directive on the same element as ngView\n// is called.\nngViewFillContentFactory.$inject = ['$compile', '$controller', '$route'];\nfunction ngViewFillContentFactory($compile, $controller, $route) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    link: function(scope, $element) {\n      var current = $route.current,\n          locals = current.locals;\n\n      $element.html(locals.$template);\n\n      var link = $compile($element.contents());\n\n      if (current.controller) {\n        locals.$scope = scope;\n        var controller = $controller(current.controller, locals);\n        if (current.controllerAs) {\n          scope[current.controllerAs] = controller;\n        }\n        $element.data('$ngControllerController', controller);\n        $element.children().data('$ngControllerController', controller);\n      }\n      scope[current.resolveAs || '$resolve'] = locals;\n\n      link(scope);\n    }\n  };\n}\n\n\n})(window, window.angular);\n","/**\n * @license AngularJS v1.6.1\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $sanitizeMinErr = angular.$$minErr('$sanitize');\nvar bind;\nvar extend;\nvar forEach;\nvar isDefined;\nvar lowercase;\nvar noop;\nvar htmlParser;\nvar htmlSanitizeWriter;\n\n/**\n * @ngdoc module\n * @name ngSanitize\n * @description\n *\n * # ngSanitize\n *\n * The `ngSanitize` module provides functionality to sanitize HTML.\n *\n *\n * <div doc-module-components=\"ngSanitize\"></div>\n *\n * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n */\n\n/**\n * @ngdoc service\n * @name $sanitize\n * @kind function\n *\n * @description\n *   Sanitizes an html string by stripping all potentially dangerous tokens.\n *\n *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n *   then serialized back to properly escaped html string. This means that no unsafe input can make\n *   it into the returned string.\n *\n *   The whitelist for URL sanitization of attribute values is configured using the functions\n *   `aHrefSanitizationWhitelist` and `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider\n *   `$compileProvider`}.\n *\n *   The input may also contain SVG markup if this is enabled via {@link $sanitizeProvider}.\n *\n * @param {string} html HTML input.\n * @returns {string} Sanitized HTML.\n *\n * @example\n   <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\" name=\"sanitize-service\">\n   <file name=\"index.html\">\n     <script>\n         angular.module('sanitizeExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n             $scope.snippet =\n               '<p style=\"color:blue\">an html\\n' +\n               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n               'snippet</p>';\n             $scope.deliberatelyTrustDangerousSnippet = function() {\n               return $sce.trustAsHtml($scope.snippet);\n             };\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n        Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Directive</td>\n           <td>How</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"bind-html-with-sanitize\">\n           <td>ng-bind-html</td>\n           <td>Automatically uses $sanitize</td>\n           <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind-html=\"snippet\"></div></td>\n         </tr>\n         <tr id=\"bind-html-with-trust\">\n           <td>ng-bind-html</td>\n           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n           <td>\n           <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n&lt;/div&gt;</pre>\n           </td>\n           <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n         </tr>\n         <tr id=\"bind-default\">\n           <td>ng-bind</td>\n           <td>Automatically escapes</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n       </div>\n   </file>\n   <file name=\"protractor.js\" type=\"protractor\">\n     it('should sanitize the html snippet by default', function() {\n       expect(element(by.css('#bind-html-with-sanitize div')).getAttribute('innerHTML')).\n         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n     });\n\n     it('should inline raw snippet if bound to a trusted value', function() {\n       expect(element(by.css('#bind-html-with-trust div')).getAttribute('innerHTML')).\n         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n              \"snippet</p>\");\n     });\n\n     it('should escape snippet without any filter', function() {\n       expect(element(by.css('#bind-default div')).getAttribute('innerHTML')).\n         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n              \"snippet&lt;/p&gt;\");\n     });\n\n     it('should update', function() {\n       element(by.model('snippet')).clear();\n       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-html-with-sanitize div')).getAttribute('innerHTML')).\n         toBe('new <b>text</b>');\n       expect(element(by.css('#bind-html-with-trust div')).getAttribute('innerHTML')).toBe(\n         'new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-default div')).getAttribute('innerHTML')).toBe(\n         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n     });\n   </file>\n   </example>\n */\n\n\n/**\n * @ngdoc provider\n * @name $sanitizeProvider\n * @this\n *\n * @description\n * Creates and configures {@link $sanitize} instance.\n */\nfunction $SanitizeProvider() {\n  var svgEnabled = false;\n\n  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {\n    if (svgEnabled) {\n      extend(validElements, svgElements);\n    }\n    return function(html) {\n      var buf = [];\n      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {\n        return !/^unsafe:/.test($$sanitizeUri(uri, isImage));\n      }));\n      return buf.join('');\n    };\n  }];\n\n\n  /**\n   * @ngdoc method\n   * @name $sanitizeProvider#enableSvg\n   * @kind function\n   *\n   * @description\n   * Enables a subset of svg to be supported by the sanitizer.\n   *\n   * <div class=\"alert alert-warning\">\n   *   <p>By enabling this setting without taking other precautions, you might expose your\n   *   application to click-hijacking attacks. In these attacks, sanitized svg elements could be positioned\n   *   outside of the containing element and be rendered over other elements on the page (e.g. a login\n   *   link). Such behavior can then result in phishing incidents.</p>\n   *\n   *   <p>To protect against these, explicitly setup `overflow: hidden` css rule for all potential svg\n   *   tags within the sanitized content:</p>\n   *\n   *   <br>\n   *\n   *   <pre><code>\n   *   .rootOfTheIncludedContent svg {\n   *     overflow: hidden !important;\n   *   }\n   *   </code></pre>\n   * </div>\n   *\n   * @param {boolean=} flag Enable or disable SVG support in the sanitizer.\n   * @returns {boolean|ng.$sanitizeProvider} Returns the currently configured value if called\n   *    without an argument or self for chaining otherwise.\n   */\n  this.enableSvg = function(enableSvg) {\n    if (isDefined(enableSvg)) {\n      svgEnabled = enableSvg;\n      return this;\n    } else {\n      return svgEnabled;\n    }\n  };\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n  // Private stuff\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n\n  bind = angular.bind;\n  extend = angular.extend;\n  forEach = angular.forEach;\n  isDefined = angular.isDefined;\n  lowercase = angular.lowercase;\n  noop = angular.noop;\n\n  htmlParser = htmlParserImpl;\n  htmlSanitizeWriter = htmlSanitizeWriterImpl;\n\n  // Regular Expressions for parsing tags and attributes\n  var SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n    // Match everything outside of normal chars and \" (quote character)\n    NON_ALPHANUMERIC_REGEXP = /([^#-~ |!])/g;\n\n\n  // Good source of info about elements and attributes\n  // http://dev.w3.org/html5/spec/Overview.html#semantics\n  // http://simon.html5.org/html-elements\n\n  // Safe Void Elements - HTML5\n  // http://dev.w3.org/html5/spec/Overview.html#void-elements\n  var voidElements = toMap('area,br,col,hr,img,wbr');\n\n  // Elements that you can, intentionally, leave open (and which close themselves)\n  // http://dev.w3.org/html5/spec/Overview.html#optional-tags\n  var optionalEndTagBlockElements = toMap('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr'),\n      optionalEndTagInlineElements = toMap('rp,rt'),\n      optionalEndTagElements = extend({},\n                                              optionalEndTagInlineElements,\n                                              optionalEndTagBlockElements);\n\n  // Safe Block Elements - HTML5\n  var blockElements = extend({}, optionalEndTagBlockElements, toMap('address,article,' +\n          'aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +\n          'h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul'));\n\n  // Inline Elements - HTML5\n  var inlineElements = extend({}, optionalEndTagInlineElements, toMap('a,abbr,acronym,b,' +\n          'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,' +\n          'samp,small,span,strike,strong,sub,sup,time,tt,u,var'));\n\n  // SVG Elements\n  // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements\n  // Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.\n  // They can potentially allow for arbitrary javascript to be executed. See #11290\n  var svgElements = toMap('circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,' +\n          'hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,' +\n          'radialGradient,rect,stop,svg,switch,text,title,tspan');\n\n  // Blocked Elements (will be stripped)\n  var blockedElements = toMap('script,style');\n\n  var validElements = extend({},\n                                     voidElements,\n                                     blockElements,\n                                     inlineElements,\n                                     optionalEndTagElements);\n\n  //Attributes that have href and hence need to be sanitized\n  var uriAttrs = toMap('background,cite,href,longdesc,src,xlink:href');\n\n  var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +\n      'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +\n      'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +\n      'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +\n      'valign,value,vspace,width');\n\n  // SVG attributes (without \"id\" and \"name\" attributes)\n  // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes\n  var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +\n      'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +\n      'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +\n      'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +\n      'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +\n      'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +\n      'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +\n      'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +\n      'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +\n      'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +\n      'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +\n      'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +\n      'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +\n      'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +\n      'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);\n\n  var validAttrs = extend({},\n                                  uriAttrs,\n                                  svgAttrs,\n                                  htmlAttrs);\n\n  function toMap(str, lowercaseKeys) {\n    var obj = {}, items = str.split(','), i;\n    for (i = 0; i < items.length; i++) {\n      obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = true;\n    }\n    return obj;\n  }\n\n  var inertBodyElement;\n  (function(window) {\n    var doc;\n    if (window.document && window.document.implementation) {\n      doc = window.document.implementation.createHTMLDocument('inert');\n    } else {\n      throw $sanitizeMinErr('noinert', 'Can\\'t create an inert html document');\n    }\n    var docElement = doc.documentElement || doc.getDocumentElement();\n    var bodyElements = docElement.getElementsByTagName('body');\n\n    // usually there should be only one body element in the document, but IE doesn't have any, so we need to create one\n    if (bodyElements.length === 1) {\n      inertBodyElement = bodyElements[0];\n    } else {\n      var html = doc.createElement('html');\n      inertBodyElement = doc.createElement('body');\n      html.appendChild(inertBodyElement);\n      doc.appendChild(html);\n    }\n  })(window);\n\n  /**\n   * @example\n   * htmlParser(htmlString, {\n   *     start: function(tag, attrs) {},\n   *     end: function(tag) {},\n   *     chars: function(text) {},\n   *     comment: function(text) {}\n   * });\n   *\n   * @param {string} html string\n   * @param {object} handler\n   */\n  function htmlParserImpl(html, handler) {\n    if (html === null || html === undefined) {\n      html = '';\n    } else if (typeof html !== 'string') {\n      html = '' + html;\n    }\n    inertBodyElement.innerHTML = html;\n\n    //mXSS protection\n    var mXSSAttempts = 5;\n    do {\n      if (mXSSAttempts === 0) {\n        throw $sanitizeMinErr('uinput', 'Failed to sanitize html because the input is unstable');\n      }\n      mXSSAttempts--;\n\n      // strip custom-namespaced attributes on IE<=11\n      if (window.document.documentMode) {\n        stripCustomNsAttrs(inertBodyElement);\n      }\n      html = inertBodyElement.innerHTML; //trigger mXSS\n      inertBodyElement.innerHTML = html;\n    } while (html !== inertBodyElement.innerHTML);\n\n    var node = inertBodyElement.firstChild;\n    while (node) {\n      switch (node.nodeType) {\n        case 1: // ELEMENT_NODE\n          handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));\n          break;\n        case 3: // TEXT NODE\n          handler.chars(node.textContent);\n          break;\n      }\n\n      var nextNode;\n      if (!(nextNode = node.firstChild)) {\n        if (node.nodeType === 1) {\n          handler.end(node.nodeName.toLowerCase());\n        }\n        nextNode = node.nextSibling;\n        if (!nextNode) {\n          while (nextNode == null) {\n            node = node.parentNode;\n            if (node === inertBodyElement) break;\n            nextNode = node.nextSibling;\n            if (node.nodeType === 1) {\n              handler.end(node.nodeName.toLowerCase());\n            }\n          }\n        }\n      }\n      node = nextNode;\n    }\n\n    while ((node = inertBodyElement.firstChild)) {\n      inertBodyElement.removeChild(node);\n    }\n  }\n\n  function attrToMap(attrs) {\n    var map = {};\n    for (var i = 0, ii = attrs.length; i < ii; i++) {\n      var attr = attrs[i];\n      map[attr.name] = attr.value;\n    }\n    return map;\n  }\n\n\n  /**\n   * Escapes all potentially dangerous characters, so that the\n   * resulting string can be safely inserted into attribute or\n   * element text.\n   * @param value\n   * @returns {string} escaped text\n   */\n  function encodeEntities(value) {\n    return value.\n      replace(/&/g, '&amp;').\n      replace(SURROGATE_PAIR_REGEXP, function(value) {\n        var hi = value.charCodeAt(0);\n        var low = value.charCodeAt(1);\n        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n      }).\n      replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n        return '&#' + value.charCodeAt(0) + ';';\n      }).\n      replace(/</g, '&lt;').\n      replace(/>/g, '&gt;');\n  }\n\n  /**\n   * create an HTML/XML writer which writes to buffer\n   * @param {Array} buf use buf.join('') to get out sanitized html string\n   * @returns {object} in the form of {\n   *     start: function(tag, attrs) {},\n   *     end: function(tag) {},\n   *     chars: function(text) {},\n   *     comment: function(text) {}\n   * }\n   */\n  function htmlSanitizeWriterImpl(buf, uriValidator) {\n    var ignoreCurrentElement = false;\n    var out = bind(buf, buf.push);\n    return {\n      start: function(tag, attrs) {\n        tag = lowercase(tag);\n        if (!ignoreCurrentElement && blockedElements[tag]) {\n          ignoreCurrentElement = tag;\n        }\n        if (!ignoreCurrentElement && validElements[tag] === true) {\n          out('<');\n          out(tag);\n          forEach(attrs, function(value, key) {\n            var lkey = lowercase(key);\n            var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');\n            if (validAttrs[lkey] === true &&\n              (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {\n              out(' ');\n              out(key);\n              out('=\"');\n              out(encodeEntities(value));\n              out('\"');\n            }\n          });\n          out('>');\n        }\n      },\n      end: function(tag) {\n        tag = lowercase(tag);\n        if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {\n          out('</');\n          out(tag);\n          out('>');\n        }\n        // eslint-disable-next-line eqeqeq\n        if (tag == ignoreCurrentElement) {\n          ignoreCurrentElement = false;\n        }\n      },\n      chars: function(chars) {\n        if (!ignoreCurrentElement) {\n          out(encodeEntities(chars));\n        }\n      }\n    };\n  }\n\n\n  /**\n   * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1' attribute to declare\n   * ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo'). This is undesirable since we don't want\n   * to allow any of these custom attributes. This method strips them all.\n   *\n   * @param node Root element to process\n   */\n  function stripCustomNsAttrs(node) {\n    while (node) {\n      if (node.nodeType === window.Node.ELEMENT_NODE) {\n        var attrs = node.attributes;\n        for (var i = 0, l = attrs.length; i < l; i++) {\n          var attrNode = attrs[i];\n          var attrName = attrNode.name.toLowerCase();\n          if (attrName === 'xmlns:ns1' || attrName.lastIndexOf('ns1:', 0) === 0) {\n            node.removeAttributeNode(attrNode);\n            i--;\n            l--;\n          }\n        }\n      }\n\n      var nextNode = node.firstChild;\n      if (nextNode) {\n        stripCustomNsAttrs(nextNode);\n      }\n\n      node = node.nextSibling;\n    }\n  }\n}\n\nfunction sanitizeText(chars) {\n  var buf = [];\n  var writer = htmlSanitizeWriter(buf, noop);\n  writer.chars(chars);\n  return buf.join('');\n}\n\n\n// define ngSanitize module and register $sanitize service\nangular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);\n\n/**\n * @ngdoc filter\n * @name linky\n * @kind function\n *\n * @description\n * Finds links in text input and turns them into html links. Supports `http/https/ftp/mailto` and\n * plain email address links.\n *\n * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n *\n * @param {string} text Input text.\n * @param {string} target Window (`_blank|_self|_parent|_top`) or named frame to open links in.\n * @param {object|function(url)} [attributes] Add custom attributes to the link element.\n *\n *    Can be one of:\n *\n *    - `object`: A map of attributes\n *    - `function`: Takes the url as a parameter and returns a map of attributes\n *\n *    If the map of attributes contains a value for `target`, it overrides the value of\n *    the target parameter.\n *\n *\n * @returns {string} Html-linkified and {@link $sanitize sanitized} text.\n *\n * @usage\n   <span ng-bind-html=\"linky_expression | linky\"></span>\n *\n * @example\n   <example module=\"linkyExample\" deps=\"angular-sanitize.js\" name=\"linky-filter\">\n     <file name=\"index.html\">\n       <div ng-controller=\"ExampleController\">\n       Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <th>Filter</th>\n           <th>Source</th>\n           <th>Rendered</th>\n         </tr>\n         <tr id=\"linky-filter\">\n           <td>linky filter</td>\n           <td>\n             <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n           </td>\n           <td>\n             <div ng-bind-html=\"snippet | linky\"></div>\n           </td>\n         </tr>\n         <tr id=\"linky-target\">\n          <td>linky target</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithSingleURL | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithSingleURL | linky:'_blank'\"></div>\n          </td>\n         </tr>\n         <tr id=\"linky-custom-attributes\">\n          <td>linky custom attributes</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}\"></div>\n          </td>\n         </tr>\n         <tr id=\"escaped-html\">\n           <td>no filter</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n     </file>\n     <file name=\"script.js\">\n       angular.module('linkyExample', ['ngSanitize'])\n         .controller('ExampleController', ['$scope', function($scope) {\n           $scope.snippet =\n             'Pretty text with some links:\\n' +\n             'http://angularjs.org/,\\n' +\n             'mailto:us@somewhere.org,\\n' +\n             'another@somewhere.org,\\n' +\n             'and one more: ftp://127.0.0.1/.';\n           $scope.snippetWithSingleURL = 'http://angularjs.org/';\n         }]);\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n       it('should linkify the snippet with urls', function() {\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n       });\n\n       it('should not linkify snippet without the linky filter', function() {\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n       });\n\n       it('should update', function() {\n         element(by.model('snippet')).clear();\n         element(by.model('snippet')).sendKeys('new http://link.');\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('new http://link.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n             .toBe('new http://link.');\n       });\n\n       it('should work with the target property', function() {\n        expect(element(by.id('linky-target')).\n            element(by.binding(\"snippetWithSingleURL | linky:'_blank'\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n       });\n\n       it('should optionally add custom attributes', function() {\n        expect(element(by.id('linky-custom-attributes')).\n            element(by.binding(\"snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-custom-attributes a')).getAttribute('rel')).toEqual('nofollow');\n       });\n     </file>\n   </example>\n */\nangular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {\n  var LINKY_URL_REGEXP =\n        /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"\\u201d\\u2019]/i,\n      MAILTO_REGEXP = /^mailto:/i;\n\n  var linkyMinErr = angular.$$minErr('linky');\n  var isDefined = angular.isDefined;\n  var isFunction = angular.isFunction;\n  var isObject = angular.isObject;\n  var isString = angular.isString;\n\n  return function(text, target, attributes) {\n    if (text == null || text === '') return text;\n    if (!isString(text)) throw linkyMinErr('notstring', 'Expected string but received: {0}', text);\n\n    var attributesFn =\n      isFunction(attributes) ? attributes :\n      isObject(attributes) ? function getAttributesObject() {return attributes;} :\n      function getEmptyAttributesObject() {return {};};\n\n    var match;\n    var raw = text;\n    var html = [];\n    var url;\n    var i;\n    while ((match = raw.match(LINKY_URL_REGEXP))) {\n      // We can not end in these as they are sometimes found at the end of the sentence\n      url = match[0];\n      // if we did not match ftp/http/www/mailto then assume mailto\n      if (!match[2] && !match[4]) {\n        url = (match[3] ? 'http://' : 'mailto:') + url;\n      }\n      i = match.index;\n      addText(raw.substr(0, i));\n      addLink(url, match[0].replace(MAILTO_REGEXP, ''));\n      raw = raw.substring(i + match[0].length);\n    }\n    addText(raw);\n    return $sanitize(html.join(''));\n\n    function addText(text) {\n      if (!text) {\n        return;\n      }\n      html.push(sanitizeText(text));\n    }\n\n    function addLink(url, text) {\n      var key, linkAttributes = attributesFn(url);\n      html.push('<a ');\n\n      for (key in linkAttributes) {\n        html.push(key + '=\"' + linkAttributes[key] + '\" ');\n      }\n\n      if (isDefined(target) && !('target' in linkAttributes)) {\n        html.push('target=\"',\n                  target,\n                  '\" ');\n      }\n      html.push('href=\"',\n                url.replace(/\"/g, '&quot;'),\n                '\">');\n      addText(text);\n      html.push('</a>');\n    }\n  };\n}]);\n\n\n})(window, window.angular);\n","/**\n * @license AngularJS v1.3.10\n * (c) 2010-2014 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n    var $sanitizeMinErr = angular.$$minErr('$sanitize');\n\n    /**\n     * @ngdoc module\n     * @name ngSanitize\n     * @description\n     *\n     * # ngSanitize\n     *\n     * The `ngSanitize` module provides functionality to sanitize HTML.\n     *\n     *\n     * <div doc-module-components=\"ngSanitize\"></div>\n     *\n     * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n     */\n\n    /*\n     * HTML Parser By Misko Hevery (misko@hevery.com)\n     * based on:  HTML Parser By John Resig (ejohn.org)\n     * Original code by Erik Arvidsson, Mozilla Public License\n     * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n     *\n     * // Use like so:\n     * htmlParser(htmlString, {\n     *     start: function(tag, attrs, unary) {},\n     *     end: function(tag) {},\n     *     chars: function(text) {},\n     *     comment: function(text) {}\n     * });\n     *\n     */\n\n\n    /**\n     * @ngdoc service\n     * @name $sanitize\n     * @kind function\n     *\n     * @description\n     *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n     *   then serialized back to properly escaped html string. This means that no unsafe input can make\n     *   it into the returned string, however, since our parser is more strict than a typical browser\n     *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a\n     *   browser, won't make it through the sanitizer. The input may also contain SVG markup.\n     *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and\n     *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.\n     *\n     * @param {string} html HTML input.\n     * @returns {string} Sanitized HTML.\n     *\n     * @example\n     <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\">\n     <file name=\"index.html\">\n     <script>\n     angular.module('sanitizeExample', ['ngSanitize'])\n     .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n             $scope.snippet =\n               '<p style=\"color:blue\">an html\\n' +\n               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n               'snippet</p>';\n             $scope.deliberatelyTrustDangerousSnippet = function() {\n               return $sce.trustAsHtml($scope.snippet);\n             };\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n     Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n     <table>\n     <tr>\n     <td>Directive</td>\n     <td>How</td>\n     <td>Source</td>\n     <td>Rendered</td>\n     </tr>\n     <tr id=\"bind-html-with-sanitize\">\n     <td>ng-bind-html</td>\n     <td>Automatically uses $sanitize</td>\n     <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n     <td><div ng-bind-html=\"snippet\"></div></td>\n     </tr>\n     <tr id=\"bind-html-with-trust\">\n     <td>ng-bind-html</td>\n     <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n     <td>\n     <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n     &lt;/div&gt;</pre>\n     </td>\n     <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n     </tr>\n     <tr id=\"bind-default\">\n     <td>ng-bind</td>\n     <td>Automatically escapes</td>\n     <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n     <td><div ng-bind=\"snippet\"></div></td>\n     </tr>\n     </table>\n     </div>\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n     it('should sanitize the html snippet by default', function() {\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n     });\n\n     it('should inline raw snippet if bound to a trusted value', function() {\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).\n         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n              \"snippet</p>\");\n     });\n\n     it('should escape snippet without any filter', function() {\n       expect(element(by.css('#bind-default div')).getInnerHtml()).\n         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n              \"snippet&lt;/p&gt;\");\n     });\n\n     it('should update', function() {\n       element(by.model('snippet')).clear();\n       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('new <b>text</b>');\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(\n         'new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(\n         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n     });\n     </file>\n     </example>\n     */\n    function $SanitizeProvider() {\n        this.$get = ['$$sanitizeUri', function($$sanitizeUri) {\n            return function(html) {\n                if (typeof arguments[1] != 'undefined') {\n                    arguments[1].version = 'taSanitize';\n                }\n                var buf = [];\n                htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {\n                    return !/^unsafe/.test($$sanitizeUri(uri, isImage));\n                }));\n                return buf.join('');\n            };\n        }];\n    }\n\n    function sanitizeText(chars) {\n        var buf = [];\n        var writer = htmlSanitizeWriter(buf, angular.noop);\n        writer.chars(chars);\n        return buf.join('');\n    }\n\n\n// Regular Expressions for parsing tags and attributes\n    var START_TAG_REGEXP =\n            /^<((?:[a-zA-Z])[\\w:-]*)((?:\\s+[\\w:-]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)\\s*(>?)/,\n        END_TAG_REGEXP = /^<\\/\\s*([\\w:-]+)[^>]*>/,\n        ATTR_REGEXP = /([\\w:-]+)(?:\\s*=\\s*(?:(?:\"((?:[^\"])*)\")|(?:'((?:[^'])*)')|([^>\\s]+)))?/g,\n        BEGIN_TAG_REGEXP = /^</,\n        BEGING_END_TAGE_REGEXP = /^<\\//,\n        COMMENT_REGEXP = /<!--(.*?)-->/g,\n        SINGLE_COMMENT_REGEXP = /(^<!--.*?-->)/,\n        DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,\n        CDATA_REGEXP = /<!\\[CDATA\\[(.*?)]]>/g,\n        SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n        // Match everything outside of normal chars and \" (quote character)\n        NON_ALPHANUMERIC_REGEXP = /([^\\#-~| |!])/g,\n        WHITE_SPACE_REGEXP = /^(\\s+)/;\n\n\n// Good source of info about elements and attributes\n// http://dev.w3.org/html5/spec/Overview.html#semantics\n// http://simon.html5.org/html-elements\n\n// Safe Void Elements - HTML5\n// http://dev.w3.org/html5/spec/Overview.html#void-elements\n    var voidElements = makeMap(\"area,br,col,hr,img,wbr,input\");\n\n// Elements that you can, intentionally, leave open (and which close themselves)\n// http://dev.w3.org/html5/spec/Overview.html#optional-tags\n    var optionalEndTagBlockElements = makeMap(\"colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr\"),\n        optionalEndTagInlineElements = makeMap(\"rp,rt\"),\n        optionalEndTagElements = angular.extend({},\n            optionalEndTagInlineElements,\n            optionalEndTagBlockElements);\n\n// Safe Block Elements - HTML5\n    var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap(\"address,article,\" +\n        \"aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,\" +\n        \"h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul\"));\n\n// Inline Elements - HTML5\n    var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap(\"a,abbr,acronym,b,\" +\n        \"bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,\" +\n        \"samp,small,span,strike,strong,sub,sup,time,tt,u,var\"));\n\n// SVG Elements\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements\n    var svgElements = makeMap(\"animate,animateColor,animateMotion,animateTransform,circle,defs,\" +\n        \"desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,\" +\n        \"line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set,\" +\n        \"stop,svg,switch,text,title,tspan,use\");\n\n// Special Elements (can contain anything)\n    var specialElements = makeMap(\"script,style\");\n\n    var validElements = angular.extend({},\n        voidElements,\n        blockElements,\n        inlineElements,\n        optionalEndTagElements,\n        svgElements);\n\n//Attributes that have href and hence need to be sanitized\n    var uriAttrs = makeMap(\"background,cite,href,longdesc,src,usemap,xlink:href\");\n\n    var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,'+\n        'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,'+\n        'id,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,'+\n        'scope,scrolling,shape,size,span,start,summary,target,title,type,'+\n        'valign,value,vspace,width');\n\n// SVG attributes (without \"id\" and \"name\" attributes)\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes\n    var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +\n        'attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,' +\n        'color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,' +\n        'font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,' +\n        'gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,' +\n        'keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,' +\n        'markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,' +\n        'overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,' +\n        'repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,' +\n        'stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,' +\n        'stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,' +\n        'stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,' +\n        'underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,' +\n        'viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,' +\n        'xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,' +\n        'zoomAndPan');\n\n    var validAttrs = angular.extend({},\n        uriAttrs,\n        svgAttrs,\n        htmlAttrs);\n\n    function makeMap(str) {\n        var obj = {}, items = str.split(','), i;\n        for (i = 0; i < items.length; i++) obj[items[i]] = true;\n        return obj;\n    }\n\n\n    /**\n     * @example\n     * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n     *\n     * @param {string} html string\n     * @param {object} handler\n     */\n    function htmlParser(html, handler) {\n        if (typeof html !== 'string') {\n            if (html === null || typeof html === 'undefined') {\n                html = '';\n            } else {\n                html = '' + html;\n            }\n        }\n        var index, chars, match, stack = [], last = html, text;\n        stack.last = function() { return stack[ stack.length - 1 ]; };\n\n        while (html) {\n            text = '';\n            chars = true;\n\n            // Make sure we're not in a script or style element\n            if (!stack.last() || !specialElements[ stack.last() ]) {\n\n                // White space\n                if (WHITE_SPACE_REGEXP.test(html)) {\n                    match = html.match(WHITE_SPACE_REGEXP);\n\n                    if (match) {\n                        var mat = match[0];\n                        if (handler.whitespace) handler.whitespace(match[0]);\n                        html = html.replace(match[0], '');\n                        chars = false;\n                    }\n                    //Comment\n                } else if (SINGLE_COMMENT_REGEXP.test(html)) {\n                    match = html.match(SINGLE_COMMENT_REGEXP);\n\n                    if (match) {\n                        if (handler.comment) handler.comment(match[1]);\n                        html = html.replace(match[0], '');\n                        chars = false;\n                    }\n                    // DOCTYPE\n                } else if (DOCTYPE_REGEXP.test(html)) {\n                    match = html.match(DOCTYPE_REGEXP);\n\n                    if (match) {\n                        html = html.replace(match[0], '');\n                        chars = false;\n                    }\n                    // end tag\n                } else if (BEGING_END_TAGE_REGEXP.test(html)) {\n                    match = html.match(END_TAG_REGEXP);\n\n                    if (match) {\n                        html = html.substring(match[0].length);\n                        match[0].replace(END_TAG_REGEXP, parseEndTag);\n                        chars = false;\n                    }\n\n                    // start tag\n                } else if (BEGIN_TAG_REGEXP.test(html)) {\n                    match = html.match(START_TAG_REGEXP);\n\n                    if (match) {\n                        // We only have a valid start-tag if there is a '>'.\n                        if (match[4]) {\n                            html = html.substring(match[0].length);\n                            match[0].replace(START_TAG_REGEXP, parseStartTag);\n                        }\n                        chars = false;\n                    } else {\n                        // no ending tag found --- this piece should be encoded as an entity.\n                        text += '<';\n                        html = html.substring(1);\n                    }\n                }\n\n                if (chars) {\n                    index = html.indexOf(\"<\");\n\n                    text += index < 0 ? html : html.substring(0, index);\n                    html = index < 0 ? \"\" : html.substring(index);\n\n                    if (handler.chars) handler.chars(decodeEntities(text));\n                }\n\n            } else {\n                html = html.replace(new RegExp(\"([^]*)<\\\\s*\\\\/\\\\s*\" + stack.last() + \"[^>]*>\", 'i'),\n                    function(all, text) {\n                        text = text.replace(COMMENT_REGEXP, \"$1\").replace(CDATA_REGEXP, \"$1\");\n\n                        if (handler.chars) handler.chars(decodeEntities(text));\n\n                        return \"\";\n                    });\n\n                parseEndTag(\"\", stack.last());\n            }\n\n            if (html == last) {\n                throw $sanitizeMinErr('badparse', \"The sanitizer was unable to parse the following block \" +\n                    \"of html: {0}\", html);\n            }\n            last = html;\n        }\n\n        // Clean up any remaining tags\n        parseEndTag();\n\n        function parseStartTag(tag, tagName, rest, unary) {\n            tagName = angular.lowercase(tagName);\n            if (blockElements[ tagName ]) {\n                while (stack.last() && inlineElements[ stack.last() ]) {\n                    parseEndTag(\"\", stack.last());\n                }\n            }\n\n            if (optionalEndTagElements[ tagName ] && stack.last() == tagName) {\n                parseEndTag(\"\", tagName);\n            }\n\n            unary = voidElements[ tagName ] || !!unary;\n\n            if (!unary)\n                stack.push(tagName);\n\n            var attrs = {};\n\n            rest.replace(ATTR_REGEXP,\n                function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {\n                    var value = doubleQuotedValue\n                        || singleQuotedValue\n                        || unquotedValue\n                        || '';\n\n                    attrs[name] = decodeEntities(value);\n                });\n            if (handler.start) handler.start(tagName, attrs, unary);\n        }\n\n        function parseEndTag(tag, tagName) {\n            var pos = 0, i;\n            tagName = angular.lowercase(tagName);\n            if (tagName)\n            // Find the closest opened tag of the same type\n                for (pos = stack.length - 1; pos >= 0; pos--)\n                    if (stack[ pos ] == tagName)\n                        break;\n\n            if (pos >= 0) {\n                // Close all the open elements, up the stack\n                for (i = stack.length - 1; i >= pos; i--)\n                    if (handler.end) handler.end(stack[ i ]);\n\n                // Remove the open elements from the stack\n                stack.length = pos;\n            }\n        }\n    }\n\n    var hiddenPre=document.createElement(\"pre\");\n    var spaceRe = /^(\\s*)([\\s\\S]*?)(\\s*)$/;\n    /**\n     * decodes all entities into regular string\n     * @param value\n     * @returns {string} A string with decoded entities.\n     */\n    function decodeEntities(value) {\n        if (!value) { return ''; }\n\n        // Note: IE8 does not preserve spaces at the start/end of innerHTML\n        // so we must capture them and reattach them afterward\n        var parts = spaceRe.exec(value);\n        var spaceBefore = parts[1];\n        var spaceAfter = parts[3];\n        var content = parts[2];\n        if (content) {\n            hiddenPre.innerHTML=content.replace(/</g,\"&lt;\");\n            // innerText depends on styling as it doesn't display hidden elements.\n            // Therefore, it's better to use textContent not to cause unnecessary\n            // reflows. However, IE<9 don't support textContent so the innerText\n            // fallback is necessary.\n            content = 'textContent' in hiddenPre ?\n                hiddenPre.textContent : hiddenPre.innerText;\n        }\n        return spaceBefore + content + spaceAfter;\n    }\n\n    /**\n     * Escapes all potentially dangerous characters, so that the\n     * resulting string can be safely inserted into attribute or\n     * element text.\n     * @param value\n     * @returns {string} escaped text\n     */\n    function encodeEntities(value) {\n        return value.\n        replace(/&/g, '&amp;').\n        replace(SURROGATE_PAIR_REGEXP, function(value) {\n            var hi = value.charCodeAt(0);\n            var low = value.charCodeAt(1);\n            return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n        }).\n        replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n            // unsafe chars are: \\u0000-\\u001f \\u007f-\\u009f \\u00ad \\u0600-\\u0604 \\u070f \\u17b4 \\u17b5 \\u200c-\\u200f \\u2028-\\u202f \\u2060-\\u206f \\ufeff \\ufff0-\\uffff from jslint.com/lint.html\n            // decimal values are: 0-31, 127-159, 173, 1536-1540, 1807, 6068, 6069, 8204-8207, 8232-8239, 8288-8303, 65279, 65520-65535\n            var c = value.charCodeAt(0);\n            // if unsafe character encode\n            if(c <= 159 ||\n                c == 173 ||\n                (c >= 1536 && c <= 1540) ||\n                c == 1807 ||\n                c == 6068 ||\n                c == 6069 ||\n                (c >= 8204 && c <= 8207) ||\n                (c >= 8232 && c <= 8239) ||\n                (c >= 8288 && c <= 8303) ||\n                c == 65279 ||\n                (c >= 65520 && c <= 65535)) return '&#' + c + ';';\n            return value; // avoids multilingual issues\n        }).\n        replace(/</g, '&lt;').\n        replace(/>/g, '&gt;');\n    }\n\n    var trim = (function() {\n        // native trim is way faster: http://jsperf.com/angular-trim-test\n        // but IE doesn't have it... :-(\n        // TODO: we should move this into IE/ES5 polyfill\n        if (!String.prototype.trim) {\n            return function(value) {\n                return angular.isString(value) ? value.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '') : value;\n            };\n        }\n        return function(value) {\n            return angular.isString(value) ? value.trim() : value;\n        };\n    })();\n\n// Custom logic for accepting certain style options only - textAngular\n// Currently allows only the color, background-color, text-align, float, width and height attributes\n// all other attributes should be easily done through classes.\n    function validStyles(styleAttr){\n        var result = '';\n        var styleArray = styleAttr.split(';');\n        angular.forEach(styleArray, function(value){\n            var v = value.split(':');\n            if(v.length == 2){\n                var key = trim(angular.lowercase(v[0]));\n                var value = trim(angular.lowercase(v[1]));\n                if(\n                    (key === 'color' || key === 'background-color') && (\n                        value.match(/^rgb\\([0-9%,\\. ]*\\)$/i)\n                        || value.match(/^rgba\\([0-9%,\\. ]*\\)$/i)\n                        || value.match(/^hsl\\([0-9%,\\. ]*\\)$/i)\n                        || value.match(/^hsla\\([0-9%,\\. ]*\\)$/i)\n                        || value.match(/^#[0-9a-f]{3,6}$/i)\n                        || value.match(/^[a-z]*$/i)\n                    )\n                    ||\n                    key === 'text-align' && (\n                        value === 'left'\n                        || value === 'right'\n                        || value === 'center'\n                        || value === 'justify'\n                    )\n                    ||\n                    key === 'text-decoration' && (\n                        value === 'underline'\n                        || value === 'line-through'\n                    )\n                    ||\n                    key === 'font-weight' && (\n                        value === 'bold'\n                    )\n                    ||\n                    key === 'font-style' && (\n                        value === 'italic'\n                    )\n                    ||\n                    key === 'float' && (\n                        value === 'left'\n                        || value === 'right'\n                        || value === 'none'\n                    )\n                    ||\n                    key === 'vertical-align' && (\n                        value === 'baseline'\n                        || value === 'sub'\n                        || value === 'super'\n                        || value === 'test-top'\n                        || value === 'text-bottom'\n                        || value === 'middle'\n                        || value === 'top'\n                        || value === 'bottom'\n                        || value.match(/[0-9]*(px|em)/)\n                        || value.match(/[0-9]+?%/)\n                    )\n                    ||\n                    key === 'font-size' && (\n                        value === 'xx-small'\n                        || value === 'x-small'\n                        || value === 'small'\n                        || value === 'medium'\n                        || value === 'large'\n                        || value === 'x-large'\n                        || value === 'xx-large'\n                        || value === 'larger'\n                        || value === 'smaller'\n                        || value.match(/[0-9]*\\.?[0-9]*(px|em|rem|mm|q|cm|in|pt|pc|%)/)\n                    )\n                    ||\n                    (key === 'width' || key === 'height') && (\n                        value.match(/[0-9\\.]*(px|em|rem|%)/)\n                    )\n                    || // Reference #520\n                    (key === 'direction' && value.match(/^ltr|rtl|initial|inherit$/))\n                ) result += key + ': ' + value + ';';\n            }\n        });\n        return result;\n    }\n\n// this function is used to manually allow specific attributes on specific tags with certain prerequisites\n    function validCustomTag(tag, attrs, lkey, value){\n        // catch the div placeholder for the iframe replacement\n        if (tag === 'img' && attrs['ta-insert-video']){\n            if(lkey === 'ta-insert-video' || lkey === 'allowfullscreen' || lkey === 'frameborder' || (lkey === 'contenteditable' && value === 'false')) return true;\n        }\n        return false;\n    }\n\n    /**\n     * create an HTML/XML writer which writes to buffer\n     * @param {Array} buf use buf.jain('') to get out sanitized html string\n     * @returns {object} in the form of {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * }\n     */\n    function htmlSanitizeWriter(buf, uriValidator) {\n        var ignore = false;\n        var out = angular.bind(buf, buf.push);\n        return {\n            start: function(tag, attrs, unary) {\n                tag = angular.lowercase(tag);\n                if (!ignore && specialElements[tag]) {\n                    ignore = tag;\n                }\n                if (!ignore && validElements[tag] === true) {\n                    out('<');\n                    out(tag);\n                    angular.forEach(attrs, function(value, key) {\n                        var lkey=angular.lowercase(key);\n                        var isImage=(tag === 'img' && lkey === 'src') || (lkey === 'background');\n                        if ((lkey === 'style' && (value = validStyles(value)) !== '') || validCustomTag(tag, attrs, lkey, value) || validAttrs[lkey] === true &&\n                            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {\n                            out(' ');\n                            out(key);\n                            out('=\"');\n                            out(encodeEntities(value));\n                            out('\"');\n                        }\n                    });\n                    out(unary ? '/>' : '>');\n                }\n            },\n            comment: function (com) {\n                out(com);\n            },\n            whitespace: function (ws) {\n                out(encodeEntities(ws));\n            },\n            end: function(tag) {\n                tag = angular.lowercase(tag);\n                if (!ignore && validElements[tag] === true) {\n                    out('</');\n                    out(tag);\n                    out('>');\n                }\n                if (tag == ignore) {\n                    ignore = false;\n                }\n            },\n            chars: function(chars) {\n                if (!ignore) {\n                    out(encodeEntities(chars));\n                }\n            }\n        };\n    }\n\n\n// define ngSanitize module and register $sanitize service\n    angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);\n\n    /* global sanitizeText: false */\n\n    /**\n     * @ngdoc filter\n     * @name linky\n     * @kind function\n     *\n     * @description\n     * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and\n     * plain email address links.\n     *\n     * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n     *\n     * @param {string} text Input text.\n     * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.\n     * @returns {string} Html-linkified text.\n     *\n     * @usage\n     <span ng-bind-html=\"linky_expression | linky\"></span>\n     *\n     * @example\n     <example module=\"linkyExample\" deps=\"angular-sanitize.js\">\n     <file name=\"index.html\">\n     <script>\n     angular.module('linkyExample', ['ngSanitize'])\n     .controller('ExampleController', ['$scope', function($scope) {\n             $scope.snippet =\n               'Pretty text with some links:\\n'+\n               'http://angularjs.org/,\\n'+\n               'mailto:us@somewhere.org,\\n'+\n               'another@somewhere.org,\\n'+\n               'and one more: ftp://127.0.0.1/.';\n             $scope.snippetWithTarget = 'http://angularjs.org/';\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n     Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n     <table>\n     <tr>\n     <td>Filter</td>\n     <td>Source</td>\n     <td>Rendered</td>\n     </tr>\n     <tr id=\"linky-filter\">\n     <td>linky filter</td>\n     <td>\n     <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n     </td>\n     <td>\n     <div ng-bind-html=\"snippet | linky\"></div>\n     </td>\n     </tr>\n     <tr id=\"linky-target\">\n     <td>linky target</td>\n     <td>\n     <pre>&lt;div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n     </td>\n     <td>\n     <div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"></div>\n     </td>\n     </tr>\n     <tr id=\"escaped-html\">\n     <td>no filter</td>\n     <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n     <td><div ng-bind=\"snippet\"></div></td>\n     </tr>\n     </table>\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n     it('should linkify the snippet with urls', function() {\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n       });\n\n     it('should not linkify snippet without the linky filter', function() {\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n       });\n\n     it('should update', function() {\n         element(by.model('snippet')).clear();\n         element(by.model('snippet')).sendKeys('new http://link.');\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('new http://link.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n             .toBe('new http://link.');\n       });\n\n     it('should work with the target property', function() {\n        expect(element(by.id('linky-target')).\n            element(by.binding(\"snippetWithTarget | linky:'_blank'\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n       });\n     </file>\n     </example>\n     */\n    angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {\n        var LINKY_URL_REGEXP =\n                /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"”’]/,\n            MAILTO_REGEXP = /^mailto:/;\n\n        return function(text, target) {\n            if (!text) return text;\n            var match;\n            var raw = text;\n            var html = [];\n            var url;\n            var i;\n            while ((match = raw.match(LINKY_URL_REGEXP))) {\n                // We can not end in these as they are sometimes found at the end of the sentence\n                url = match[0];\n                // if we did not match ftp/http/www/mailto then assume mailto\n                if (!match[2] && !match[4]) {\n                    url = (match[3] ? 'http://' : 'mailto:') + url;\n                }\n                i = match.index;\n                addText(raw.substr(0, i));\n                addLink(url, match[0].replace(MAILTO_REGEXP, ''));\n                raw = raw.substring(i + match[0].length);\n            }\n            addText(raw);\n            return $sanitize(html.join(''));\n\n            function addText(text) {\n                if (!text) {\n                    return;\n                }\n                html.push(sanitizeText(text));\n            }\n\n            function addLink(url, text) {\n                html.push('<a ');\n                if (angular.isDefined(target)) {\n                    html.push('target=\"',\n                        target,\n                        '\" ');\n                }\n                html.push('href=\"',\n                    url.replace(/\"/g, '&quot;'),\n                    '\">');\n                addText(text);\n                html.push('</a>');\n            }\n        };\n    }]);\n\n\n})(window, window.angular);","/*\n @license textAngular\n Author : Austin Anderson\n License : 2013 MIT\n Version 1.5.16\n\n See README.md or https://github.com/fraywing/textAngular/wiki for requirements and use.\n */\n\n/*\n Commonjs package manager support (eg componentjs).\n */\n\n\n\"use strict\";// NOTE: textAngularVersion must match the Gruntfile.js 'setVersion' task.... and have format v/d+./d+./d+\nvar textAngularVersion = 'v1.5.16';   // This is automatically updated during the build process to the current release!\n\n\n// IE version detection - http://stackoverflow.com/questions/4169160/javascript-ie-detection-why-not-use-simple-conditional-comments\n// We need this as IE sometimes plays funny tricks with the contenteditable.\n// ----------------------------------------------------------\n// If you're not in IE (or IE version is less than 5) then:\n// ie === undefined\n// If you're in IE (>=5) then you can determine which version:\n// ie === 7; // IE7\n// Thus, to detect IE:\n// if (ie) {}\n// And to detect the version:\n// ie === 6 // IE6\n// ie > 7 // IE8, IE9, IE10 ...\n// ie < 9 // Anything less than IE9\n// ----------------------------------------------------------\n/* istanbul ignore next: untestable browser check */\nvar _browserDetect = {\n    ie: (function(){\n        var undef,\n            v = 3,\n            div = document.createElement('div'),\n            all = div.getElementsByTagName('i');\n\n        while (\n            div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->',\n                all[0]\n            );\n\n        return v > 4 ? v : undef;\n    }()),\n    webkit: /AppleWebKit\\/([\\d.]+)/i.test(navigator.userAgent),\n    isFirefox: navigator.userAgent.toLowerCase().indexOf('firefox') > -1\n};\n\n// Global to textAngular to measure performance where needed\n/* istanbul ignore next: untestable browser check */\nvar performance = performance || {};\n/* istanbul ignore next: untestable browser check */\nperformance.now = (function() {\n    return performance.now       ||\n        performance.mozNow    ||\n        performance.msNow     ||\n        performance.oNow      ||\n        performance.webkitNow ||\n        function() { return new Date().getTime(); };\n})();\n// usage is:\n// var t0 = performance.now();\n// doSomething();\n// var t1 = performance.now();\n// console.log('Took', (t1 - t0).toFixed(4), 'milliseconds to do something!');\n//\n\n// turn html into pure text that shows visiblity\nfunction stripHtmlToText(html)\n{\n    var tmp = document.createElement(\"DIV\");\n    tmp.innerHTML = html;\n    var res = tmp.textContent || tmp.innerText || '';\n    res.replace('\\u200B', ''); // zero width space\n    res = res.trim();\n    return res;\n}\n// get html\nfunction getDomFromHtml(html)\n{\n    var tmp = document.createElement(\"DIV\");\n    tmp.innerHTML = html;\n    return tmp;\n}\n\n\n// Global to textAngular REGEXP vars for block and list elements.\n\nvar BLOCKELEMENTS = /^(address|article|aside|audio|blockquote|canvas|center|dd|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|noscript|ol|output|p|pre|section|table|tfoot|ul|video)$/i;\nvar LISTELEMENTS = /^(ul|li|ol)$/i;\n// updated VALIDELEMENTS to include #text and span so that we can use nodeName instead of tagName\nvar VALIDELEMENTS = /^(#text|span|address|article|aside|audio|blockquote|canvas|center|dd|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|noscript|ol|output|p|pre|section|table|tfoot|ul|video|li)$/i;\n\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Compatibility\n/* istanbul ignore next: trim shim for older browsers */\nif (!String.prototype.trim) {\n    String.prototype.trim = function () {\n        return this.replace(/^\\s+|\\s+$/g, '');\n    };\n}\n\n/*\n Custom stylesheet for the placeholders rules.\n Credit to: http://davidwalsh.name/add-rules-stylesheets\n */\nvar sheet, addCSSRule, removeCSSRule, _addCSSRule, _removeCSSRule, _getRuleIndex;\n/* istanbul ignore else: IE <8 test*/\nif(_browserDetect.ie > 8 || _browserDetect.ie === undefined){\n    var _sheets = document.styleSheets;\n    /* istanbul ignore next: preference for stylesheet loaded externally */\n    for(var i = 0; i < _sheets.length; i++){\n        if(_sheets[i].media.length === 0 || _sheets[i].media.mediaText.match(/(all|screen)/ig)){\n            if(_sheets[i].href){\n                if(_sheets[i].href.match(/textangular\\.(min\\.|)css/ig)){\n                    sheet = _sheets[i];\n                    break;\n                }\n            }\n        }\n    }\n    /* istanbul ignore next: preference for stylesheet loaded externally */\n    if(!sheet){\n        // this sheet is used for the placeholders later on.\n        sheet = (function() {\n            // Create the <style> tag\n            var style = document.createElement(\"style\");\n            /* istanbul ignore else : WebKit hack :( */\n            if(_browserDetect.webkit) style.appendChild(document.createTextNode(\"\"));\n\n            // Add the <style> element to the page, add as first so the styles can be overridden by custom stylesheets\n            document.getElementsByTagName('head')[0].appendChild(style);\n\n            return style.sheet;\n        })();\n    }\n\n    // use as: addCSSRule(\"header\", \"float: left\");\n    addCSSRule = function(selector, rules) {\n        return _addCSSRule(sheet, selector, rules);\n    };\n    _addCSSRule = function(_sheet, selector, rules){\n        var insertIndex;\n        var insertedRule;\n        // This order is important as IE 11 has both cssRules and rules but they have different lengths - cssRules is correct, rules gives an error in IE 11\n        /* istanbul ignore next: browser catches */\n        if(_sheet.cssRules) insertIndex = Math.max(_sheet.cssRules.length - 1, 0);\n        else if(_sheet.rules) insertIndex = Math.max(_sheet.rules.length - 1, 0);\n\n        /* istanbul ignore else: untestable IE option */\n        if(_sheet.insertRule) {\n            _sheet.insertRule(selector + \"{\" + rules + \"}\", insertIndex);\n        }\n        else {\n            _sheet.addRule(selector, rules, insertIndex);\n        }\n        /* istanbul ignore next: browser catches */\n        if(sheet.rules) insertedRule = sheet.rules[insertIndex];\n        else if(sheet.cssRules) insertedRule = sheet.cssRules[insertIndex];\n        // return the inserted stylesheet rule\n        return insertedRule;\n    };\n\n    _getRuleIndex = function(rule, rules) {\n        var i, ruleIndex;\n        for (i=0; i < rules.length; i++) {\n            /* istanbul ignore else: check for correct rule */\n            if (rules[i].cssText === rule.cssText) {\n                ruleIndex = i;\n                break;\n            }\n        }\n        return ruleIndex;\n    };\n\n    removeCSSRule = function(rule){\n        _removeCSSRule(sheet, rule);\n    };\n    /* istanbul ignore next: tests are browser specific */\n    _removeCSSRule = function(sheet, rule){\n        var rules = sheet.cssRules || sheet.rules;\n        if(!rules || rules.length === 0) return;\n        var ruleIndex = _getRuleIndex(rule, rules);\n        if(sheet.removeRule){\n            sheet.removeRule(ruleIndex);\n        }else{\n            sheet.deleteRule(ruleIndex);\n        }\n    };\n}\n\nangular.module('textAngular.factories', [])\n    .factory('taBrowserTag', [function(){\n        return function(tag){\n            /* istanbul ignore next: ie specific test */\n            if(!tag) return (_browserDetect.ie <= 8)? 'P' : 'p';\n            else if(tag === '') return (_browserDetect.ie === undefined)? 'div' : (_browserDetect.ie <= 8)? 'P' : 'p';\n            else return (_browserDetect.ie <= 8)? tag.toUpperCase() : tag;\n        };\n    }]).factory('taApplyCustomRenderers', ['taCustomRenderers', 'taDOM', function(taCustomRenderers, taDOM){\n    return function(val){\n        var element = angular.element('<div></div>');\n        element[0].innerHTML = val;\n\n        angular.forEach(taCustomRenderers, function(renderer){\n            var elements = [];\n            // get elements based on what is defined. If both defined do secondary filter in the forEach after using selector string\n            if(renderer.selector && renderer.selector !== '')\n                elements = element.find(renderer.selector);\n            /* istanbul ignore else: shouldn't fire, if it does we're ignoring everything */\n            else if(renderer.customAttribute && renderer.customAttribute !== '')\n                elements = taDOM.getByAttribute(element, renderer.customAttribute);\n            // process elements if any found\n            angular.forEach(elements, function(_element){\n                _element = angular.element(_element);\n                if(renderer.selector && renderer.selector !== '' && renderer.customAttribute && renderer.customAttribute !== ''){\n                    if(_element.attr(renderer.customAttribute) !== undefined) renderer.renderLogic(_element);\n                } else renderer.renderLogic(_element);\n            });\n        });\n\n        return element[0].innerHTML;\n    };\n}]).factory('taFixChrome', function(){\n    // get whaterever rubbish is inserted in chrome\n    // should be passed an html string, returns an html string\n    var taFixChrome = function(html, keepStyles){\n        if(!html || !angular.isString(html) || html.length <= 0) return html;\n        // grab all elements with a style attibute\n        // a betterSpanMatch matches only a style=... with matching quotes\n        // this captures the whole:\n        // 'style=\"background-color: rgb(255, 255, 255);\"'\n        var betterSpanMatch = /style\\s?=\\s?([\"'])(?:(?=(\\\\?))\\2.)*?\\1/ig;\n        // where the original spanMatch = /<([^>\\/]+?)style=(\"([^\\\"]+)\"|'([^']+)')([^>]*)>/ig;\n        // captures too much and includes the front tag!\n        var spanMatch = /<([^>\\/]+?)style=(\"([^\\\"]+)\"|'([^']+)')([^>]*)>/ig;\n        var appleConvertedSpaceMatch = /<span class=\"Apple-converted-space\">([^<]+)<\\/span>/ig;\n        var match, styleVal, appleSpaceVal, newTag, finalHtml = '', lastIndex = 0;\n        // remove all the Apple-converted-space spans and replace with the content of the span\n        //console.log('before:', html);\n        /* istanbul ignore next: apple-contereted-space span match */\n        while(match = appleConvertedSpaceMatch.exec(html)){\n            appleSpaceVal = match[1];\n            appleSpaceVal = appleSpaceVal.replace(/&nbsp;/ig, ' ');\n            finalHtml += html.substring(lastIndex, match.index) + appleSpaceVal;\n            lastIndex = match.index + match[0].length;\n        }\n        /* istanbul ignore next: apple-contereted-space span has matched */\n        if (lastIndex) {\n            // modified....\n            finalHtml += html.substring(lastIndex);\n            html=finalHtml;\n            finalHtml='';\n            lastIndex=0;\n        }\n        /////////////////////////////////////////////////////////////\n        //\n        // Allow control of this modification\n        // taKeepStyles: False - removes these modification\n        //\n        // taFixChrome removes the following styles:\n        //    font-family: inherit;\n        //    line-height: <number>\n        //    color: inherit;\n        //    color: rgb( <rgb-component>#{3} )\n        //    background-color: rgb( <rgb-component>#{3} )\n        //\n        /////////////////////////////////////////////////////////////\n        if (!keepStyles) {\n            while (match = betterSpanMatch.exec(html)) {\n                finalHtml += html.substring(lastIndex, match.index-1);\n                styleVal = match[0];\n                // test for chrome inserted junk\n                match = /font-family: inherit;|line-height: 1.[0-9]{3,12};|color: inherit; line-height: 1.1;|color: rgb\\(\\d{1,3}, \\d{1,3}, \\d{1,3}\\);|background-color: rgb\\(\\d{1,3}, \\d{1,3}, \\d{1,3}\\);/gi.exec(styleVal);\n                if (match) {\n                    styleVal = styleVal.replace(/( |)font-family: inherit;|( |)line-height: 1.[0-9]{3,12};|( |)color: inherit;|( |)color: rgb\\(\\d{1,3}, \\d{1,3}, \\d{1,3}\\);|( |)background-color: rgb\\(\\d{1,3}, \\d{1,3}, \\d{1,3}\\);/ig, '');\n                    //console.log(styleVal, styleVal.length);\n                    if (styleVal.length > 8) {\n                        finalHtml += ' ' + styleVal;\n                    }\n                } else {\n                    finalHtml += ' ' + styleVal;\n                }\n                lastIndex = betterSpanMatch.lastIndex;\n            }\n            finalHtml += html.substring(lastIndex);\n        }\n        //console.log('final:', finalHtml);\n        // only replace when something has changed, else we get focus problems on inserting lists\n        if(lastIndex > 0){\n            // replace all empty strings\n            var fe = finalHtml.replace(/<span\\s?>(.*?)<\\/span>(<br(\\/|)>|)/ig, '$1');\n            return fe;\n        } else return html;\n    };\n    return taFixChrome;\n}).factory('taSanitize', ['$sanitize', function taSanitizeFactory($sanitize){\n\n    var convert_infos = [\n        {\n            property: 'font-weight',\n            values: [ 'bold' ],\n            tag: 'b'\n        },\n        {\n            property: 'font-style',\n            values: [ 'italic' ],\n            tag: 'i'\n        }\n    ];\n\n    var styleMatch = [];\n    for(var i = 0; i < convert_infos.length; i++){\n        var _partialStyle = '(' + convert_infos[i].property + ':\\\\s*(';\n        for(var j = 0; j < convert_infos[i].values.length; j++){\n            /* istanbul ignore next: not needed to be tested yet */\n            if(j > 0) _partialStyle += '|';\n            _partialStyle += convert_infos[i].values[j];\n        }\n        _partialStyle += ');)';\n        styleMatch.push(_partialStyle);\n    }\n    var styleRegexString = '(' + styleMatch.join('|') + ')';\n\n    function wrapNested(html, wrapTag) {\n        var depth = 0;\n        var lastIndex = 0;\n        var match;\n        var tagRegex = /<[^>]*>/ig;\n        while(match = tagRegex.exec(html)){\n            lastIndex = match.index;\n            if(match[0].substr(1, 1) === '/'){\n                if(depth === 0) break;\n                else depth--;\n            }else depth++;\n        }\n        return wrapTag +\n            html.substring(0, lastIndex) +\n            // get the start tags reversed - this is safe as we construct the strings with no content except the tags\n            angular.element(wrapTag)[0].outerHTML.substring(wrapTag.length) +\n            html.substring(lastIndex);\n    }\n\n    function transformLegacyStyles(html){\n        if(!html || !angular.isString(html) || html.length <= 0) return html;\n        var i;\n        var styleElementMatch = /<([^>\\/]+?)style=(\"([^\"]+)\"|'([^']+)')([^>]*)>/ig;\n        var match, subMatch, styleVal, newTag, lastNewTag = '', newHtml, finalHtml = '', lastIndex = 0;\n        while(match = styleElementMatch.exec(html)){\n            // one of the quoted values ' or \"\n            /* istanbul ignore next: quotations match */\n            styleVal = match[3] || match[4];\n            var styleRegex = new RegExp(styleRegexString, 'i');\n            // test for style values to change\n            if(angular.isString(styleVal) && styleRegex.test(styleVal)){\n                // remove build tag list\n                newTag = '';\n                // init regex here for exec\n                var styleRegexExec = new RegExp(styleRegexString, 'ig');\n                // find relevand tags and build a string of them\n                while(subMatch = styleRegexExec.exec(styleVal)){\n                    for(i = 0; i < convert_infos.length; i++){\n                        if(!!subMatch[(i*2) + 2]){\n                            newTag += '<' + convert_infos[i].tag + '>';\n                        }\n                    }\n                }\n                // recursively find more legacy styles in html before this tag and after the previous match (if any)\n                newHtml = transformLegacyStyles(html.substring(lastIndex, match.index));\n                // build up html\n                if(lastNewTag.length > 0){\n                    finalHtml += wrapNested(newHtml, lastNewTag);\n                }else finalHtml += newHtml;\n                // grab the style val without the transformed values\n                styleVal = styleVal.replace(new RegExp(styleRegexString, 'ig'), '');\n                // build the html tag\n                finalHtml += '<' + match[1].trim();\n                if(styleVal.length > 0) finalHtml += ' style=\"' + styleVal + '\"';\n                finalHtml += match[5] + '>';\n                // update the start index to after this tag\n                lastIndex = match.index + match[0].length;\n                lastNewTag = newTag;\n            }\n        }\n        if(lastNewTag.length > 0){\n            finalHtml += wrapNested(html.substring(lastIndex), lastNewTag);\n        }\n        else finalHtml += html.substring(lastIndex);\n        return finalHtml;\n    }\n\n    function transformLegacyAttributes(html){\n        if(!html || !angular.isString(html) || html.length <= 0) return html;\n        // replace all align='...' tags with text-align attributes\n        var attrElementMatch = /<([^>\\/]+?)align=(\"([^\"]+)\"|'([^']+)')([^>]*)>/ig;\n        var match, finalHtml = '', lastIndex = 0;\n        // match all attr tags\n        while(match = attrElementMatch.exec(html)){\n            // add all html before this tag\n            finalHtml += html.substring(lastIndex, match.index);\n            // record last index after this tag\n            lastIndex = match.index + match[0].length;\n            // construct tag without the align attribute\n            var newTag = '<' + match[1] + match[5];\n            // add the style attribute\n            if(/style=(\"([^\"]+)\"|'([^']+)')/ig.test(newTag)){\n                /* istanbul ignore next: quotations match */\n                newTag = newTag.replace(/style=(\"([^\"]+)\"|'([^']+)')/i, 'style=\"$2$3 text-align:' + (match[3] || match[4]) + ';\"');\n            }else{\n                /* istanbul ignore next: quotations match */\n                newTag += ' style=\"text-align:' + (match[3] || match[4]) + ';\"';\n            }\n            newTag += '>';\n            // add to html\n            finalHtml += newTag;\n        }\n        // return with remaining html\n        return finalHtml + html.substring(lastIndex);\n    }\n\n    // use precompiled regexp for speed\n    var rsb1 = new RegExp(/<span id=\"selectionBoundary_\\d+_\\d+\" class=\"rangySelectionBoundary\">[^<>]+?<\\/span>/ig);\n    var rsb2 = new RegExp(/<span class=\"rangySelectionBoundary\" id=\"selectionBoundary_\\d+_\\d+\">[^<>]+?<\\/span>/ig);\n    var rsb3 = new RegExp(/<span id=\"selectionBoundary_\\d+_\\d+\" class=\"rangySelectionBoundary\">[^<>]+?<\\/span>/ig);\n\n    return function taSanitize(unsafe, oldsafe, ignore){\n        // unsafe html should NEVER built into a DOM object via angular.element. This allows XSS to be inserted and run.\n        if ( !ignore ) {\n            try {\n                unsafe = transformLegacyStyles(unsafe);\n            } catch (e) {\n            }\n        }\n\n        // unsafe and oldsafe should be valid HTML strings\n        // any exceptions (lets say, color for example) should be made here but with great care\n        // setup unsafe element for modification\n        unsafe = transformLegacyAttributes(unsafe);\n\n        // we had an issue in the past, where we dumped a whole bunch of <span>'s into the content...\n        // so we remove them here\n        // IN A FUTURE release this can be removed after all have updated through release 1.5.9\n        if (unsafe) {\n            try {\n                unsafe = unsafe.replace(rsb1, '');\n                unsafe = unsafe.replace(rsb2, '');\n                unsafe = unsafe.replace(rsb1, '');\n                unsafe = unsafe.replace(rsb3, '');\n            } catch (e) {\n            }\n        }\n\n        var safe;\n        try {\n            safe = $sanitize(unsafe);\n            // do this afterwards, then the $sanitizer should still throw for bad markup\n            if(ignore) safe = unsafe;\n        } catch (e){\n            safe = oldsafe || '';\n        }\n\n        // Do processing for <pre> tags, removing tabs and return carriages outside of them\n\n        var _preTags = safe.match(/(<pre[^>]*>.*?<\\/pre[^>]*>)/ig);\n        var processedSafe = safe.replace(/(&#(9|10);)*/ig, '');\n        var re = /<pre[^>]*>.*?<\\/pre[^>]*>/ig;\n        var index = 0;\n        var lastIndex = 0;\n        var origTag;\n        safe = '';\n        while((origTag = re.exec(processedSafe)) !== null && index < _preTags.length){\n            safe += processedSafe.substring(lastIndex, origTag.index) + _preTags[index];\n            lastIndex = origTag.index + origTag[0].length;\n            index++;\n        }\n        return safe + processedSafe.substring(lastIndex);\n    };\n}]).factory('taToolExecuteAction', ['$q', '$log', function($q, $log){\n    // this must be called on a toolScope or instance\n    return function(editor){\n        if(editor !== undefined) this.$editor = function(){ return editor; };\n        var deferred = $q.defer(),\n            promise = deferred.promise,\n            _editor = this.$editor();\n        // pass into the action the deferred function and also the function to reload the current selection if rangy available\n        var result;\n        try{\n            result = this.action(deferred, _editor.startAction());\n            // We set the .finally callback here to make sure it doesn't get executed before any other .then callback.\n            promise['finally'](function(){\n                _editor.endAction.call(_editor);\n            });\n        }catch(exc){\n            $log.error(exc);\n        }\n        if(result || result === undefined){\n            // if true or undefined is returned then the action has finished. Otherwise the deferred action will be resolved manually.\n            deferred.resolve();\n        }\n    };\n}]);\n\nangular.module('textAngular.DOM', ['textAngular.factories'])\n    .factory('taExecCommand', ['taSelection', 'taBrowserTag', '$document', function(taSelection, taBrowserTag, $document){\n        var listToDefault = function(listElement, defaultWrap){\n            var $target, i;\n            // if all selected then we should remove the list\n            // grab all li elements and convert to taDefaultWrap tags\n            var children = listElement.find('li');\n            for(i = children.length - 1; i >= 0; i--){\n                $target = angular.element('<' + defaultWrap + '>' + children[i].innerHTML + '</' + defaultWrap + '>');\n                listElement.after($target);\n            }\n            listElement.remove();\n            taSelection.setSelectionToElementEnd($target[0]);\n        };\n        var listElementToSelfTag = function(list, listElement, selfTag, bDefault, defaultWrap){\n            var $target, i;\n            // if all selected then we should remove the list\n            // grab all li elements\n            var priorElement;\n            var nextElement;\n            var children = list.find('li');\n            var foundIndex;\n            for (i = 0; i<children.length; i++) {\n                if (children[i].outerHTML === listElement[0].outerHTML) {\n                    // found it...\n                    foundIndex = i;\n                    if (i>0) {\n                        priorElement = children[i-1];\n                    }\n                    if (i+1<children.length) {\n                        nextElement = children[i+1];\n                    }\n                    break;\n                }\n            }\n            //console.log('listElementToSelfTag', list, listElement, selfTag, bDefault, priorElement, nextElement);\n            // un-list the listElement\n            var html = '';\n            if (bDefault) {\n                html += '<' + defaultWrap + '>' + listElement[0].innerHTML + '</' + defaultWrap + '>';\n            } else {\n                html += '<' + taBrowserTag(selfTag) + '>';\n                html += '<li>' + listElement[0].innerHTML + '</li>';\n                html += '</' + taBrowserTag(selfTag) + '>';\n            }\n            $target = angular.element(html);\n            //console.log('$target', $target[0]);\n            if (!priorElement) {\n                // this is the first the list, so we just remove it...\n                listElement.remove();\n                list.after(angular.element(list[0].outerHTML));\n                list.after($target);\n                list.remove();\n                taSelection.setSelectionToElementEnd($target[0]);\n                return;\n            } else if (!nextElement) {\n                // this is the last in the list, so we just remove it..\n                listElement.remove();\n                list.after($target);\n                taSelection.setSelectionToElementEnd($target[0]);\n            } else {\n                var p = list.parent();\n                // okay it was some where in the middle... so we need to break apart the list...\n                var html1 = '';\n                var listTag = list[0].nodeName.toLowerCase();\n                html1 += '<' + listTag + '>';\n                for(i = 0; i < foundIndex; i++){\n                    html1 += '<li>' + children[i].innerHTML + '</li>';\n                }\n                html1 += '</' + listTag + '>';\n                var html2 = '';\n                html2 += '<' + listTag + '>';\n                for(i = foundIndex+1; i < children.length; i++){\n                    html2 += '<li>' + children[i].innerHTML + '</li>';\n                }\n                html2 += '</' + listTag + '>';\n                //console.log(html1, $target[0], html2);\n                list.after(angular.element(html2));\n                list.after($target);\n                list.after(angular.element(html1));\n                list.remove();\n                //console.log('parent ******XXX*****', p[0]);\n                taSelection.setSelectionToElementEnd($target[0]);\n            }\n        };\n        var listElementsToSelfTag = function(list, listElements, selfTag, bDefault, defaultWrap){\n            var $target, i, j, p;\n            // grab all li elements\n            var priorElement;\n            var afterElement;\n            //console.log('list:', list, 'listElements:', listElements, 'selfTag:', selfTag, 'bDefault:', bDefault);\n            var children = list.find('li');\n            var foundIndexes = [];\n            for (i = 0; i<children.length; i++) {\n                for (j = 0; j<listElements.length; j++) {\n                    if (children[i].isEqualNode(listElements[j])) {\n                        // found it...\n                        foundIndexes[j] = i;\n                    }\n                }\n            }\n            if (foundIndexes[0] > 0) {\n                priorElement = children[foundIndexes[0] - 1];\n            }\n            if (foundIndexes[listElements.length-1] + 1 < children.length) {\n                afterElement = children[foundIndexes[listElements.length-1] + 1];\n            }\n            //console.log('listElementsToSelfTag', list, listElements, selfTag, bDefault, !priorElement, !afterElement, foundIndexes[listElements.length-1], children.length);\n            // un-list the listElements\n            var html = '';\n            if (bDefault) {\n                for (j = 0; j < listElements.length; j++) {\n                    html += '<' + defaultWrap + '>' + listElements[j].innerHTML + '</' + defaultWrap + '>';\n                    listElements[j].remove();\n                }\n            } else {\n                html += '<' + taBrowserTag(selfTag) + '>';\n                for (j = 0; j < listElements.length; j++) {\n                    html += listElements[j].outerHTML;\n                    listElements[j].remove();\n                }\n                html += '</' + taBrowserTag(selfTag) + '>';\n            }\n            $target = angular.element(html);\n            if (!priorElement) {\n                // this is the first the list, so we just remove it...\n                list.after(angular.element(list[0].outerHTML));\n                list.after($target);\n                list.remove();\n                taSelection.setSelectionToElementEnd($target[0]);\n                return;\n            } else if (!afterElement) {\n                // this is the last in the list, so we just remove it..\n                list.after($target);\n                taSelection.setSelectionToElementEnd($target[0]);\n                return;\n            } else {\n                // okay it was some where in the middle... so we need to break apart the list...\n                var html1 = '';\n                var listTag = list[0].nodeName.toLowerCase();\n                html1 += '<' + listTag + '>';\n                for(i = 0; i < foundIndexes[0]; i++){\n                    html1 += '<li>' + children[i].innerHTML + '</li>';\n                }\n                html1 += '</' + listTag + '>';\n                var html2 = '';\n                html2 += '<' + listTag + '>';\n                for(i = foundIndexes[listElements.length-1]+1; i < children.length; i++){\n                    html2 += '<li>' + children[i].innerHTML + '</li>';\n                }\n                html2 += '</' + listTag + '>';\n                list.after(angular.element(html2));\n                list.after($target);\n                list.after(angular.element(html1));\n                list.remove();\n                //console.log('parent ******YYY*****', list.parent()[0]);\n                taSelection.setSelectionToElementEnd($target[0]);\n            }\n        };\n        var selectLi = function(liElement){\n            if(/(<br(|\\/)>)$/i.test(liElement.innerHTML.trim())) taSelection.setSelectionBeforeElement(angular.element(liElement).find(\"br\")[0]);\n            else taSelection.setSelectionToElementEnd(liElement);\n        };\n        var listToList = function(listElement, newListTag){\n            var $target = angular.element('<' + newListTag + '>' + listElement[0].innerHTML + '</' + newListTag + '>');\n            listElement.after($target);\n            listElement.remove();\n            selectLi($target.find('li')[0]);\n        };\n        var childElementsToList = function(elements, listElement, newListTag){\n            var html = '';\n            for(var i = 0; i < elements.length; i++){\n                html += '<' + taBrowserTag('li') + '>' + elements[i].innerHTML + '</' + taBrowserTag('li') + '>';\n            }\n            var $target = angular.element('<' + newListTag + '>' + html + '</' + newListTag + '>');\n            listElement.after($target);\n            listElement.remove();\n            selectLi($target.find('li')[0]);\n        };\n        var turnBlockIntoBlocks = function(element, options) {\n            for(var i = 0; i<element.childNodes.length; i++) {\n                var _n = element.childNodes[i];\n                /* istanbul ignore next - more complex testing*/\n                if (_n.tagName && _n.tagName.match(BLOCKELEMENTS)) {\n                    turnBlockIntoBlocks(_n, options);\n                }\n            }\n            /* istanbul ignore next - very rare condition that we do not test*/\n            if (element.parentNode === null) {\n                // nothing left to do..\n                return element;\n            }\n            /* istanbul ignore next - not sure have to test this */\n            if (options === '<br>'){\n                return element;\n            }\n            else {\n                var $target = angular.element(options);\n                $target[0].innerHTML = element.innerHTML;\n                element.parentNode.insertBefore($target[0], element);\n                element.parentNode.removeChild(element);\n                return $target;\n            }\n        };\n        return function(taDefaultWrap, topNode){\n            // NOTE: here we are dealing with the html directly from the browser and not the html the user sees.\n            // IF you want to modify the html the user sees, do it when the user does a switchView\n            taDefaultWrap = taBrowserTag(taDefaultWrap);\n            return function(command, showUI, options, defaultTagAttributes){\n                var i, $target, html, _nodes, next, optionsTagName, selectedElement, ourSelection;\n                var defaultWrapper = angular.element('<' + taDefaultWrap + '>');\n                try{\n                    if (taSelection.getSelection) {\n                        ourSelection = taSelection.getSelection();\n                    }\n                    selectedElement = taSelection.getSelectionElement();\n                    // special checks and fixes when we are selecting the whole container\n                    var __h, _innerNode;\n                    /* istanbul ignore next */\n                    if (selectedElement.tagName !== undefined) {\n                        if (selectedElement.tagName.toLowerCase() === 'div' &&\n                            /taTextElement.+/.test(selectedElement.id) &&\n                            ourSelection && ourSelection.start &&\n                            ourSelection.start.offset === 1 &&\n                            ourSelection.end.offset === 1) {\n                            // opps we are actually selecting the whole container!\n                            //console.log('selecting whole container!');\n                            __h = selectedElement.innerHTML;\n                            if (/<br>/i.test(__h)) {\n                                // Firefox adds <br>'s and so we remove the <br>\n                                __h = __h.replace(/<br>/i, '&#8203;');  // no space-space\n                            }\n                            if (/<br\\/>/i.test(__h)) {\n                                // Firefox adds <br/>'s and so we remove the <br/>\n                                __h = __h.replace(/<br\\/>/i, '&#8203;');  // no space-space\n                            }\n                            // remove stacked up <span>'s\n                            if (/<span>(<span>)+/i.test(__h)) {\n                                __h = __.replace(/<span>(<span>)+/i, '<span>');\n                            }\n                            // remove stacked up </span>'s\n                            if (/<\\/span>(<\\/span>)+/i.test(__h)) {\n                                __h = __.replace(/<\\/span>(<\\/span>)+/i, '<\\/span>');\n                            }\n                            if (/<span><\\/span>/i.test(__h)) {\n                                // if we end up with a <span></span> here we remove it...\n                                __h = __h.replace(/<span><\\/span>/i, '');\n                            }\n                            //console.log('inner whole container', selectedElement.childNodes);\n                            _innerNode = '<div>' + __h + '</div>';\n                            selectedElement.innerHTML = _innerNode;\n                            taSelection.setSelectionToElementEnd(selectedElement.childNodes[0]);\n                            selectedElement = taSelection.getSelectionElement();\n                        } else if (selectedElement.tagName.toLowerCase() === 'span' &&\n                            ourSelection && ourSelection.start &&\n                            ourSelection.start.offset === 1 &&\n                            ourSelection.end.offset === 1) {\n                            // just a span -- this is a problem...\n                            //console.log('selecting span!');\n                            __h = selectedElement.innerHTML;\n                            if (/<br>/i.test(__h)) {\n                                // Firefox adds <br>'s and so we remove the <br>\n                                __h = __h.replace(/<br>/i, '&#8203;');  // no space-space\n                            }\n                            if (/<br\\/>/i.test(__h)) {\n                                // Firefox adds <br/>'s and so we remove the <br/>\n                                __h = __h.replace(/<br\\/>/i, '&#8203;');  // no space-space\n                            }\n                            // remove stacked up <span>'s\n                            if (/<span>(<span>)+/i.test(__h)) {\n                                __h = __.replace(/<span>(<span>)+/i, '<span>');\n                            }\n                            // remove stacked up </span>'s\n                            if (/<\\/span>(<\\/span>)+/i.test(__h)) {\n                                __h = __.replace(/<\\/span>(<\\/span>)+/i, '<\\/span>');\n                            }\n                            if (/<span><\\/span>/i.test(__h)) {\n                                // if we end up with a <span></span> here we remove it...\n                                __h = __h.replace(/<span><\\/span>/i, '');\n                            }\n                            //console.log('inner span', selectedElement.childNodes);\n                            // we wrap this in a <div> because otherwise the browser get confused when we attempt to select the whole node\n                            // and the focus is not set correctly no matter what we do\n                            _innerNode = '<div>' + __h + '</div>';\n                            selectedElement.innerHTML = _innerNode;\n                            taSelection.setSelectionToElementEnd(selectedElement.childNodes[0]);\n                            selectedElement = taSelection.getSelectionElement();\n                            //console.log(selectedElement.innerHTML);\n                        } else if (selectedElement.tagName.toLowerCase() === 'p' &&\n                            ourSelection && ourSelection.start &&\n                            ourSelection.start.offset === 1 &&\n                            ourSelection.end.offset === 1) {\n                            //console.log('p special');\n                            // we need to remove the </br> that firefox adds!\n                            __h = selectedElement.innerHTML;\n                            if (/<br>/i.test(__h)) {\n                                // Firefox adds <br>'s and so we remove the <br>\n                                __h = __h.replace(/<br>/i, '&#8203;');  // no space-space\n                                selectedElement.innerHTML = __h;\n                            }\n                        } else if (selectedElement.tagName.toLowerCase() === 'li' &&\n                            ourSelection && ourSelection.start &&\n                            ourSelection.start.offset === ourSelection.end.offset) {\n                            // we need to remove the </br> that firefox adds!\n                            __h = selectedElement.innerHTML;\n                            if (/<br>/i.test(__h)) {\n                                // Firefox adds <br>'s and so we remove the <br>\n                                __h = __h.replace(/<br>/i, '');  // nothing\n                                selectedElement.innerHTML = __h;\n                            }\n                        }\n                    }\n                }catch(e){}\n                //console.log('************** selectedElement:', selectedElement);\n                /* istanbul ignore if: */\n                if (!selectedElement){return;}\n                var $selected = angular.element(selectedElement);\n                var tagName = (selectedElement && selectedElement.tagName && selectedElement.tagName.toLowerCase()) ||\n                    /* istanbul ignore next: */ \"\";\n                if(command.toLowerCase() === 'insertorderedlist' || command.toLowerCase() === 'insertunorderedlist'){\n                    var selfTag = taBrowserTag((command.toLowerCase() === 'insertorderedlist')? 'ol' : 'ul');\n                    var selectedElements = taSelection.getOnlySelectedElements();\n                    //console.log('PPPPPPPPPPPPP', tagName, selfTag, selectedElements, tagName.match(BLOCKELEMENTS), $selected.hasClass('ta-bind'), $selected.parent()[0].tagName);\n                    if (selectedElements.length>1 && (tagName === 'ol' ||  tagName === 'ul' )) {\n                        return listElementsToSelfTag($selected, selectedElements, selfTag, selfTag===tagName, taDefaultWrap);\n                    }\n                    if(tagName === selfTag){\n                        // if all selected then we should remove the list\n                        // grab all li elements and convert to taDefaultWrap tags\n                        //console.log('tagName===selfTag');\n                        if ($selected[0].childNodes.length !== selectedElements.length && selectedElements.length===1) {\n                            $selected = angular.element(selectedElements[0]);\n                            return listElementToSelfTag($selected.parent(), $selected, selfTag, true, taDefaultWrap);\n                        } else {\n                            return listToDefault($selected, taDefaultWrap);\n                        }\n                    }else if(tagName === 'li' &&\n                        $selected.parent()[0].tagName.toLowerCase() === selfTag &&\n                        $selected.parent().children().length === 1){\n                        // catch for the previous statement if only one li exists\n                        return listToDefault($selected.parent(), taDefaultWrap);\n                    }else if(tagName === 'li' &&\n                        $selected.parent()[0].tagName.toLowerCase() !== selfTag &&\n                        $selected.parent().children().length === 1){\n                        // catch for the previous statement if only one li exists\n                        return listToList($selected.parent(), selfTag);\n                    }else if(tagName.match(BLOCKELEMENTS) && !$selected.hasClass('ta-bind')){\n                        // if it's one of those block elements we have to change the contents\n                        // if it's a ol/ul we are changing from one to the other\n                        if (selectedElements.length) {\n                            if ($selected[0].childNodes.length !== selectedElements.length && selectedElements.length===1) {\n                                //console.log('&&&&&&&&&&&&&&& --------- &&&&&&&&&&&&&&&&', selectedElements[0], $selected[0].childNodes);\n                                $selected = angular.element(selectedElements[0]);\n                                return listElementToSelfTag($selected.parent(), $selected, selfTag, selfTag===tagName, taDefaultWrap);\n                            }\n                        }\n                        if(tagName === 'ol' || tagName === 'ul'){\n                            // now if this is a set of selected elements... behave diferently\n                            return listToList($selected, selfTag);\n                        }else{\n                            var childBlockElements = false;\n                            angular.forEach($selected.children(), function(elem){\n                                if(elem.tagName.match(BLOCKELEMENTS)) {\n                                    childBlockElements = true;\n                                }\n                            });\n                            if(childBlockElements){\n                                return childElementsToList($selected.children(), $selected, selfTag);\n                            }else{\n                                return childElementsToList([angular.element('<div>' + selectedElement.innerHTML + '</div>')[0]], $selected, selfTag);\n                            }\n                        }\n                    }else if(tagName.match(BLOCKELEMENTS)){\n                        // if we get here then the contents of the ta-bind are selected\n                        _nodes = taSelection.getOnlySelectedElements();\n                        //console.log('_nodes', _nodes, tagName);\n                        if(_nodes.length === 0){\n                            // here is if there is only text in ta-bind ie <div ta-bind>test content</div>\n                            $target = angular.element('<' + selfTag + '><li>' + selectedElement.innerHTML + '</li></' + selfTag + '>');\n                            $selected.html('');\n                            $selected.append($target);\n                        }else if(_nodes.length === 1 && (_nodes[0].tagName.toLowerCase() === 'ol' || _nodes[0].tagName.toLowerCase() === 'ul')){\n                            if(_nodes[0].tagName.toLowerCase() === selfTag){\n                                // remove\n                                return listToDefault(angular.element(_nodes[0]), taDefaultWrap);\n                            }else{\n                                return listToList(angular.element(_nodes[0]), selfTag);\n                            }\n                        }else{\n                            html = '';\n                            var $nodes = [];\n                            for(i = 0; i < _nodes.length; i++){\n                                /* istanbul ignore else: catch for real-world can't make it occur in testing */\n                                if(_nodes[i].nodeType !== 3){\n                                    var $n = angular.element(_nodes[i]);\n                                    /* istanbul ignore if: browser check only, phantomjs doesn't return children nodes but chrome at least does */\n                                    if(_nodes[i].tagName.toLowerCase() === 'li') continue;\n                                    else if(_nodes[i].tagName.toLowerCase() === 'ol' || _nodes[i].tagName.toLowerCase() === 'ul'){\n                                        html += $n[0].innerHTML; // if it's a list, add all it's children\n                                    }else if(_nodes[i].tagName.toLowerCase() === 'span' && (_nodes[i].childNodes[0].tagName.toLowerCase() === 'ol' || _nodes[i].childNodes[0].tagName.toLowerCase() === 'ul')){\n                                        html += $n[0].childNodes[0].innerHTML; // if it's a list, add all it's children\n                                    }else{\n                                        html += '<' + taBrowserTag('li') + '>' + $n[0].innerHTML + '</' + taBrowserTag('li') + '>';\n                                    }\n                                    $nodes.unshift($n);\n                                }\n                            }\n                            //console.log('$nodes', $nodes);\n                            $target = angular.element('<' + selfTag + '>' + html + '</' + selfTag + '>');\n                            $nodes.pop().replaceWith($target);\n                            angular.forEach($nodes, function($node){ $node.remove(); });\n                        }\n                        taSelection.setSelectionToElementEnd($target[0]);\n                        return;\n                    }\n                }else if(command.toLowerCase() === 'formatblock'){\n                    optionsTagName = options.toLowerCase().replace(/[<>]/ig, '');\n                    if(optionsTagName.trim() === 'default') {\n                        optionsTagName = taDefaultWrap;\n                        options = '<' + taDefaultWrap + '>';\n                    }\n                    if(tagName === 'li') {\n                        $target = $selected.parent();\n                    }\n                    else {\n                        $target = $selected;\n                    }\n                    // find the first blockElement\n                    while(!$target[0].tagName || !$target[0].tagName.match(BLOCKELEMENTS) && !$target.parent().attr('contenteditable')){\n                        $target = $target.parent();\n                        /* istanbul ignore next */\n                        tagName = ($target[0].tagName || '').toLowerCase();\n                    }\n                    if(tagName === optionsTagName){\n                        // $target is wrap element\n                        _nodes = $target.children();\n                        var hasBlock = false;\n                        for(i = 0; i < _nodes.length; i++){\n                            hasBlock = hasBlock || _nodes[i].tagName.match(BLOCKELEMENTS);\n                        }\n                        if(hasBlock){\n                            $target.after(_nodes);\n                            next = $target.next();\n                            $target.remove();\n                            $target = next;\n                        }else{\n                            defaultWrapper.append($target[0].childNodes);\n                            $target.after(defaultWrapper);\n                            $target.remove();\n                            $target = defaultWrapper;\n                        }\n                    }else if($target.parent()[0].tagName.toLowerCase() === optionsTagName &&\n                        !$target.parent().hasClass('ta-bind')){\n                        //unwrap logic for parent\n                        var blockElement = $target.parent();\n                        var contents = blockElement.contents();\n                        for(i = 0; i < contents.length; i ++){\n                            /* istanbul ignore next: can't test - some wierd thing with how phantomjs works */\n                            if(blockElement.parent().hasClass('ta-bind') && contents[i].nodeType === 3){\n                                defaultWrapper = angular.element('<' + taDefaultWrap + '>');\n                                defaultWrapper[0].innerHTML = contents[i].outerHTML;\n                                contents[i] = defaultWrapper[0];\n                            }\n                            blockElement.parent()[0].insertBefore(contents[i], blockElement[0]);\n                        }\n                        blockElement.remove();\n                    }else if(tagName.match(LISTELEMENTS)){\n                        // wrapping a list element\n                        $target.wrap(options);\n                    }else{\n                        // default wrap behaviour\n                        _nodes = taSelection.getOnlySelectedElements();\n                        if(_nodes.length === 0) {\n                            // no nodes at all....\n                            _nodes = [$target[0]];\n                        }\n                        // find the parent block element if any of the nodes are inline or text\n                        for(i = 0; i < _nodes.length; i++){\n                            if(_nodes[i].nodeType === 3 || !_nodes[i].tagName.match(BLOCKELEMENTS)){\n                                while(_nodes[i].nodeType === 3 || !_nodes[i].tagName || !_nodes[i].tagName.match(BLOCKELEMENTS)){\n                                    _nodes[i] = _nodes[i].parentNode;\n                                }\n                            }\n                        }\n                        // remove any duplicates from the array of _nodes!\n                        _nodes = _nodes.filter(function(value, index, self) {\n                            return self.indexOf(value) === index;\n                        });\n                        // remove all whole taTextElement if it is here... unless it is the only element!\n                        if (_nodes.length>1) {\n                            _nodes = _nodes.filter(function (value, index, self) {\n                                return !(value.nodeName.toLowerCase() === 'div' && /^taTextElement/.test(value.id));\n                            });\n                        }\n                        if(angular.element(_nodes[0]).hasClass('ta-bind')){\n                            $target = angular.element(options);\n                            $target[0].innerHTML = _nodes[0].innerHTML;\n                            _nodes[0].innerHTML = $target[0].outerHTML;\n                        }else if(optionsTagName === 'blockquote'){\n                            // blockquotes wrap other block elements\n                            html = '';\n                            for(i = 0; i < _nodes.length; i++){\n                                html += _nodes[i].outerHTML;\n                            }\n                            $target = angular.element(options);\n                            $target[0].innerHTML = html;\n                            _nodes[0].parentNode.insertBefore($target[0],_nodes[0]);\n                            for(i = _nodes.length - 1; i >= 0; i--){\n                                /* istanbul ignore else:  */\n                                if (_nodes[i].parentNode) _nodes[i].parentNode.removeChild(_nodes[i]);\n                            }\n                        } else /* istanbul ignore next: not tested since identical to blockquote */\n                        if (optionsTagName === 'pre' && taSelection.getStateShiftKey()) {\n                            //console.log('shift pre', _nodes);\n                            // pre wrap other block elements\n                            html = '';\n                            for (i = 0; i < _nodes.length; i++) {\n                                html += _nodes[i].outerHTML;\n                            }\n                            $target = angular.element(options);\n                            $target[0].innerHTML = html;\n                            _nodes[0].parentNode.insertBefore($target[0], _nodes[0]);\n                            for (i = _nodes.length - 1; i >= 0; i--) {\n                                /* istanbul ignore else:  */\n                                if (_nodes[i].parentNode) _nodes[i].parentNode.removeChild(_nodes[i]);\n                            }\n                        }\n                        else {\n                            //console.log(optionsTagName, _nodes);\n                            // regular block elements replace other block elements\n                            for (i = 0; i < _nodes.length; i++) {\n                                var newBlock = turnBlockIntoBlocks(_nodes[i], options);\n                                if (_nodes[i] === $target[0]) {\n                                    $target = angular.element(newBlock);\n                                }\n                            }\n                        }\n                    }\n                    taSelection.setSelectionToElementEnd($target[0]);\n                    // looses focus when we have the whole container selected and no text!\n                    // refocus on the shown display element, this fixes a bug when using firefox\n                    $target[0].focus();\n                    return;\n                }else if(command.toLowerCase() === 'createlink'){\n                    /* istanbul ignore next: firefox specific fix */\n                    if (tagName === 'a') {\n                        // already a link!!! we are just replacing it...\n                        taSelection.getSelectionElement().href = options;\n                        return;\n                    }\n                    var tagBegin = '<a href=\"' + options + '\" target=\"' +\n                            (defaultTagAttributes.a.target ? defaultTagAttributes.a.target : '') +\n                            '\">',\n                        tagEnd = '</a>',\n                        _selection = taSelection.getSelection();\n                    if(_selection.collapsed){\n                        //console.log('collapsed');\n                        // insert text at selection, then select then just let normal exec-command run\n                        taSelection.insertHtml(tagBegin + options + tagEnd, topNode);\n                    }else if(rangy.getSelection().getRangeAt(0).canSurroundContents()){\n                        var node = angular.element(tagBegin + tagEnd)[0];\n                        rangy.getSelection().getRangeAt(0).surroundContents(node);\n                    }\n                    return;\n                }else if(command.toLowerCase() === 'inserthtml'){\n                    //console.log('inserthtml');\n                    taSelection.insertHtml(options, topNode);\n                    return;\n                }\n                try{\n                    $document[0].execCommand(command, showUI, options);\n                }catch(e){}\n            };\n        };\n    }]).service('taSelection', ['$document', 'taDOM', '$log',\n    /* istanbul ignore next: all browser specifics and PhantomJS dosen't seem to support half of it */\n    function($document, taDOM, $log){\n        // need to dereference the document else the calls don't work correctly\n        var _document = $document[0];\n        var bShiftState;\n        var brException = function (element, offset) {\n            /* check if selection is a BR element at the beginning of a container. If so, get\n             * the parentNode instead.\n             * offset should be zero in this case. Otherwise, return the original\n             * element.\n             */\n            if (element.tagName && element.tagName.match(/^br$/i) && offset === 0 && !element.previousSibling) {\n                return {\n                    element: element.parentNode,\n                    offset: 0\n                };\n            } else {\n                return {\n                    element: element,\n                    offset: offset\n                };\n            }\n        };\n        var api = {\n            getSelection: function(){\n                var range;\n                try {\n                    // catch any errors from rangy and ignore the issue\n                    range = rangy.getSelection().getRangeAt(0);\n                } catch(e) {\n                    //console.info(e);\n                    return undefined;\n                }\n                var container = range.commonAncestorContainer;\n                var selection = {\n                    start: brException(range.startContainer, range.startOffset),\n                    end: brException(range.endContainer, range.endOffset),\n                    collapsed: range.collapsed\n                };\n                // This has problems under Firefox.\n                // On Firefox with\n                // <p>Try me !</p>\n                // <ul>\n                // <li>line 1</li>\n                // <li>line 2</li>\n                // </ul>\n                // <p>line 3</p>\n                // <ul>\n                // <li>line 4</li>\n                // <li>line 5</li>\n                // </ul>\n                // <p>Hello textAngular</p>\n                // WITH the cursor after the 3 on line 3, it gets the commonAncestorContainer as:\n                // <TextNode textContent='line 3'>\n                // AND Chrome gets the commonAncestorContainer as:\n                // <p>line 3</p>\n                //\n                // Check if the container is a text node and return its parent if so\n                // unless this is the whole taTextElement.  If so we return the textNode\n                if (container.nodeType === 3) {\n                    if (container.parentNode.nodeName.toLowerCase() === 'div' &&\n                        /^taTextElement/.test(container.parentNode.id)) {\n                        // textNode where the parent is the whole <div>!!!\n                        //console.log('textNode ***************** container:', container);\n                    } else {\n                        container = container.parentNode;\n                    }\n                }\n                if (container.nodeName.toLowerCase() === 'div' &&\n                    /^taTextElement/.test(container.id)) {\n                    //console.log('*********taTextElement************');\n                    //console.log('commonAncestorContainer:', container);\n                    selection.start.element = container.childNodes[selection.start.offset];\n                    selection.end.element = container.childNodes[selection.end.offset];\n                    selection.container = container;\n                } else {\n                    if (container.parentNode === selection.start.element ||\n                        container.parentNode === selection.end.element) {\n                        selection.container = container.parentNode;\n                    } else {\n                        selection.container = container;\n                    }\n                }\n                //console.log('***selection container:', selection.container.nodeName, selection.start.offset, selection.container);\n                return selection;\n            },\n            // if we use the LEFT_ARROW and we are at the special place <span>&#65279;</span> we move the cursor over by one...\n            // Chrome and Firefox behave differently so so fix this for Firefox here.  No adjustment needed for Chrome.\n            updateLeftArrowKey: function(element) {\n                var range = rangy.getSelection().getRangeAt(0);\n                if (range && range.collapsed) {\n                    var _nodes = api.getFlattenedDom(range);\n                    if (!_nodes.findIndex) return;\n                    var _node = range.startContainer;\n                    var indexStartContainer = _nodes.findIndex(function(element, index){\n                        if (element.node===_node) return true;\n                        var _indexp = element.parents.indexOf(_node);\n                        return (_indexp !== -1);\n                    });\n                    var m;\n                    var nextNodeToRight;\n                    //console.log('indexStartContainer', indexStartContainer, _nodes.length, 'startContainer:', _node, _node === _nodes[indexStartContainer].node);\n                    _nodes.forEach(function (n, i) {\n                        //console.log(i, n.node);\n                        n.parents.forEach(function (nn, j){\n                            //console.log(i, j, nn);\n                        });\n                    });\n                    if (indexStartContainer+1 < _nodes.length) {\n                        // we need the node just after this startContainer\n                        // so we can check and see it this is a special place\n                        nextNodeToRight = _nodes[indexStartContainer+1].node;\n                        //console.log(nextNodeToRight, range.startContainer);\n                    }\n                    //console.log('updateLeftArrowKey', range.startOffset, range.startContainer.textContent);\n                    // this first section handles the case for Chrome browser\n                    // if the first character of the nextNode is a \\ufeff we know that we are just before the special span...\n                    // and so we most left by one character\n                    if (nextNodeToRight && nextNodeToRight.textContent) {\n                        m = /^\\ufeff([^\\ufeff]*)$/.exec(nextNodeToRight.textContent);\n                        if (m) {\n                            // we are before the special node with begins with a \\ufeff character\n                            //console.log('LEFT ...found it...', 'startOffset:', range.startOffset, m[0].length, m[1].length);\n                            // no need to change anything in this case\n                            return;\n                        }\n                    }\n                    var nextNodeToLeft;\n                    if (indexStartContainer > 0) {\n                        // we need the node just after this startContainer\n                        // so we can check and see it this is a special place\n                        nextNodeToLeft = _nodes[indexStartContainer-1].node;\n                        //console.log(nextNodeToLeft, nextNodeToLeft);\n                    }\n                    if (range.startOffset === 0 && nextNodeToLeft) {\n                        //console.log(nextNodeToLeft, range.startOffset, nextNodeToLeft.textContent);\n                        m = /^\\ufeff([^\\ufeff]*)$/.exec(nextNodeToLeft.textContent);\n                        if (m) {\n                            //console.log('LEFT &&&&&&&&&&&&&&&&&&&...found it...&&&&&&&&&&&', nextNodeToLeft, m[0].length, m[1].length);\n                            // move over to the left my one -- Firefox triggers this case\n                            api.setSelectionToElementEnd(nextNodeToLeft);\n                            return;\n                        }\n                    }\n                }\n                return;\n            },\n            // if we use the RIGHT_ARROW and we are at the special place <span>&#65279;</span> we move the cursor over by one...\n            updateRightArrowKey: function(element) {\n                // we do not need to make any adjustments here, so we ignore all this code\n                if (false) {\n                    var range = rangy.getSelection().getRangeAt(0);\n                    if (range && range.collapsed) {\n                        var _nodes = api.getFlattenedDom(range);\n                        if (!_nodes.findIndex) return;\n                        var _node = range.startContainer;\n                        var indexStartContainer = _nodes.findIndex(function (element, index) {\n                            if (element.node === _node) return true;\n                            var _indexp = element.parents.indexOf(_node);\n                            return (_indexp !== -1);\n                        });\n                        var _sel;\n                        var i;\n                        var m;\n\n                        // if the last character is a \\ufeff we know that we are just before the special span...\n                        // and so we most right by one character\n                        var indexFound = _nodes.findIndex(function (n, index) {\n                            if (n.textContent) {\n                                var m = /^\\ufeff([^\\ufeff]*)$/.exec(n.textContent);\n                                if (m) {\n                                    return true;\n                                } else {\n                                    return false;\n                                }\n                            } else {\n                                return false;\n                            }\n                        });\n                        if (indexFound === -1) {\n                            return;\n                        }\n                        //console.log(indexFound, range.startContainer, range.startOffset);\n                        _node = _nodes[indexStartContainer];\n                        //console.log('indexStartContainer', indexStartContainer);\n                        if (_node && _node.textContent) {\n                            m = /^\\ufeff([^\\ufeff]*)$/.exec(_node.textContent);\n                            if (m && range.startOffset - 1 === m[1].length) {\n                                //console.log('RIGHT found it...&&&&&&&&&&&', range.startOffset);\n                                // no need to make any adjustment\n                                return;\n                            }\n                        }\n                        //console.log(range.startOffset);\n                        if (_nodes && range.startOffset === 0) {\n                            indexStartContainer = _nodes.indexOf(range.startContainer);\n                            if (indexStartContainer !== -1 && indexStartContainer > 0) {\n                                _node = _nodes[indexStartContainer - 1];\n                                if (_node.textContent) {\n                                    m = /\\ufeff([^\\ufeff]*)$/.exec(_node.textContent);\n                                    if (m && true || range.startOffset === m[1].length + 1) {\n                                        //console.log('RIGHT &&&&&&&&&&&&&&&&&&&...found it...&&&&&&&&&&&', range.startOffset, m[1].length);\n                                        // no need to make any adjustment\n                                        return;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            getFlattenedDom: function(range) {\n                var parent = range.commonAncestorContainer.parentNode;\n                if (!parent) {\n                    return range.commonAncestorContainer.childNodes;\n                }\n                var nodes = Array.prototype.slice.call(parent.childNodes); // converts NodeList to Array\n                var indexStartContainer = nodes.indexOf(range.startContainer);\n                // make sure that we have a big enough set of nodes\n                if (indexStartContainer+1 < nodes.length && indexStartContainer > 0) {\n                    // we are good\n                    // we can go down one node or up one node\n                } else {\n                    if (parent.parentNode) {\n                        parent = parent.parentNode;\n                    }\n                }\n                // now walk the parent\n                nodes = [];\n                function addNodes(_set) {\n                    if (_set.node.childNodes.length) {\n                        var childNodes = Array.prototype.slice.call(_set.node.childNodes); // converts NodeList to Array\n                        childNodes.forEach(function(n) {\n                            var _t = _set.parents.slice();\n                            if (_t.slice(-1)[0]!==_set.node) {\n                                _t.push(_set.node);\n                            }\n                            addNodes({parents: _t, node: n});\n                        });\n                    } else {\n                        nodes.push({parents: _set.parents, node: _set.node});\n                    }\n                }\n                addNodes({parents: [parent], node: parent});\n                return nodes;\n            },\n            getOnlySelectedElements: function(){\n                var range = rangy.getSelection().getRangeAt(0);\n                var container = range.commonAncestorContainer;\n                // Node.TEXT_NODE === 3\n                // Node.ELEMENT_NODE === 1\n                // Node.COMMENT_NODE === 8\n                // Check if the container is a text node and return its parent if so\n                container = container.nodeType === 3 ? container.parentNode : container;\n                // get the nodes in the range that are ELEMENT_NODE and are children of the container\n                // in this range...\n                return range.getNodes([1], function(node){\n                    return node.parentNode === container;\n                });\n            },\n            // this includes the container element if all children are selected\n            getAllSelectedElements: function(){\n                var range = rangy.getSelection().getRangeAt(0);\n                var container = range.commonAncestorContainer;\n                // Node.TEXT_NODE === 3\n                // Node.ELEMENT_NODE === 1\n                // Node.COMMENT_NODE === 8\n                // Check if the container is a text node and return its parent if so\n                container = container.nodeType === 3 ? container.parentNode : container;\n                // get the nodes in the range that are ELEMENT_NODE and are children of the container\n                // in this range...\n                var selectedNodes = range.getNodes([1], function(node){\n                    return node.parentNode === container;\n                });\n                var innerHtml = container.innerHTML;\n                // remove the junk that rangy has put down\n                innerHtml = innerHtml.replace(/<span id=.selectionBoundary[^>]+>\\ufeff?<\\/span>/ig, '');\n                //console.log(innerHtml);\n                //console.log(range.toHtml());\n                //console.log(innerHtml === range.toHtml());\n                if (innerHtml === range.toHtml() &&\n                    // not the whole taTextElement\n                    (!(container.nodeName.toLowerCase() === 'div' &&  /^taTextElement/.test(container.id)))\n                ) {\n                    var arr = [];\n                    for(var i = selectedNodes.length; i--; arr.unshift(selectedNodes[i]));\n                    selectedNodes = arr;\n                    selectedNodes.push(container);\n                    //$log.debug(selectedNodes);\n                }\n                return selectedNodes;\n            },\n            // Some basic selection functions\n            getSelectionElement: function () {\n                var s = api.getSelection();\n                if (s) {\n                    return api.getSelection().container;\n                } else {\n                    return undefined;\n                }\n            },\n            setSelection: function(elStart, elEnd, start, end){\n                var range = rangy.createRange();\n\n                range.setStart(elStart, start);\n                range.setEnd(elEnd, end);\n\n                rangy.getSelection().setSingleRange(range);\n            },\n            setSelectionBeforeElement: function (el){\n                var range = rangy.createRange();\n\n                range.selectNode(el);\n                range.collapse(true);\n\n                rangy.getSelection().setSingleRange(range);\n            },\n            setSelectionAfterElement: function (el){\n                var range = rangy.createRange();\n\n                range.selectNode(el);\n                range.collapse(false);\n\n                rangy.getSelection().setSingleRange(range);\n            },\n            setSelectionToElementStart: function (el){\n                var range = rangy.createRange();\n\n                range.selectNodeContents(el);\n                range.collapse(true);\n\n                rangy.getSelection().setSingleRange(range);\n            },\n            setSelectionToElementEnd: function (el){\n                var range = rangy.createRange();\n\n                range.selectNodeContents(el);\n                range.collapse(false);\n                if(el.childNodes && el.childNodes[el.childNodes.length - 1] && el.childNodes[el.childNodes.length - 1].nodeName === 'br'){\n                    range.startOffset = range.endOffset = range.startOffset - 1;\n                }\n                rangy.getSelection().setSingleRange(range);\n            },\n            setStateShiftKey: function(bS) {\n                bShiftState = bS;\n            },\n            getStateShiftKey: function() {\n                return bShiftState;\n            },\n            // from http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div\n            // topNode is the contenteditable normally, all manipulation MUST be inside this.\n            insertHtml: function(html, topNode){\n                var parent, secondParent, _childI, nodes, i, lastNode, _tempFrag;\n                var element = angular.element(\"<div>\" + html + \"</div>\");\n                var range = rangy.getSelection().getRangeAt(0);\n                var frag = _document.createDocumentFragment();\n                var children = element[0].childNodes;\n                var isInline = true;\n\n                if(children.length > 0){\n                    // NOTE!! We need to do the following:\n                    // check for blockelements - if they exist then we have to split the current element in half (and all others up to the closest block element) and insert all children in-between.\n                    // If there are no block elements, or there is a mixture we need to create textNodes for the non wrapped text (we don't want them spans messing up the picture).\n                    nodes = [];\n                    for(_childI = 0; _childI < children.length; _childI++){\n                        var _cnode = children[_childI];\n                        if (_cnode.nodeName.toLowerCase() === 'p' &&\n                            _cnode.innerHTML.trim() === '') { // empty p element\n                            continue;\n                        }\n                        /****************\n                         *  allow any text to be inserted...\n                         if((   _cnode.nodeType === 3 &&\n                         _cnode.nodeValue === '\\ufeff'[0] &&\n                         _cnode.nodeValue.trim() === '') // empty no-space space element\n                         ) {\n                        // no change to isInline\n                        nodes.push(_cnode);\n                        continue;\n                    }\n                         if(_cnode.nodeType === 3 &&\n                         _cnode.nodeValue.trim() === '') { // empty text node\n                        continue;\n                    }\n                         *****************/\n                        isInline = isInline && !BLOCKELEMENTS.test(_cnode.nodeName);\n                        nodes.push(_cnode);\n                    }\n                    for(var _n = 0; _n < nodes.length; _n++) {\n                        lastNode = frag.appendChild(nodes[_n]);\n                    }\n                    if( !isInline &&\n                        range.collapsed &&\n                        /^(|<br(|\\/)>)$/i.test(range.startContainer.innerHTML) ) {\n                        range.selectNode(range.startContainer);\n                    }\n                }else{\n                    isInline = true;\n                    // paste text of some sort\n                    lastNode = frag = _document.createTextNode(html);\n                }\n\n                // Other Edge case - selected data spans multiple blocks.\n                if(isInline){\n                    range.deleteContents();\n                }else{ // not inline insert\n                    if(range.collapsed && range.startContainer !== topNode){\n                        if(range.startContainer.innerHTML && range.startContainer.innerHTML.match(/^<[^>]*>$/i)){\n                            // this log is to catch when innerHTML is something like `<img ...>`\n                            parent = range.startContainer;\n                            if(range.startOffset === 1){\n                                // before single tag\n                                range.setStartAfter(parent);\n                                range.setEndAfter(parent);\n                            }else{\n                                // after single tag\n                                range.setStartBefore(parent);\n                                range.setEndBefore(parent);\n                            }\n                        }else{\n                            // split element into 2 and insert block element in middle\n                            if(range.startContainer.nodeType === 3 && range.startContainer.parentNode !== topNode){ // if text node\n                                parent = range.startContainer.parentNode;\n                                secondParent = parent.cloneNode();\n                                // split the nodes into two lists - before and after, splitting the node with the selection into 2 text nodes.\n                                taDOM.splitNodes(parent.childNodes, parent, secondParent, range.startContainer, range.startOffset);\n\n                                // Escape out of the inline tags like b\n                                while(!VALIDELEMENTS.test(parent.nodeName)){\n                                    angular.element(parent).after(secondParent);\n                                    parent = parent.parentNode;\n                                    var _lastSecondParent = secondParent;\n                                    secondParent = parent.cloneNode();\n                                    // split the nodes into two lists - before and after, splitting the node with the selection into 2 text nodes.\n                                    taDOM.splitNodes(parent.childNodes, parent, secondParent, _lastSecondParent);\n                                }\n                            }else{\n                                parent = range.startContainer;\n                                secondParent = parent.cloneNode();\n                                taDOM.splitNodes(parent.childNodes, parent, secondParent, undefined, undefined, range.startOffset);\n                            }\n\n                            angular.element(parent).after(secondParent);\n                            // put cursor to end of inserted content\n                            //console.log('setStartAfter', parent);\n                            range.setStartAfter(parent);\n                            range.setEndAfter(parent);\n\n                            if(/^(|<br(|\\/)>)$/i.test(parent.innerHTML.trim())){\n                                range.setStartBefore(parent);\n                                range.setEndBefore(parent);\n                                angular.element(parent).remove();\n                            }\n                            if(/^(|<br(|\\/)>)$/i.test(secondParent.innerHTML.trim())) angular.element(secondParent).remove();\n                            if(parent.nodeName.toLowerCase() === 'li'){\n                                _tempFrag = _document.createDocumentFragment();\n                                for(i = 0; i < frag.childNodes.length; i++){\n                                    element = angular.element('<li>');\n                                    taDOM.transferChildNodes(frag.childNodes[i], element[0]);\n                                    taDOM.transferNodeAttributes(frag.childNodes[i], element[0]);\n                                    _tempFrag.appendChild(element[0]);\n                                }\n                                frag = _tempFrag;\n                                if(lastNode){\n                                    lastNode = frag.childNodes[frag.childNodes.length - 1];\n                                    lastNode = lastNode.childNodes[lastNode.childNodes.length - 1];\n                                }\n                            }\n                        }\n                    }else{\n                        range.deleteContents();\n                    }\n                }\n\n                range.insertNode(frag);\n                if(lastNode){\n                    api.setSelectionToElementEnd(lastNode);\n                }\n            }\n\n            /* NOT FUNCTIONAL YET\n             // under Firefox, we may have a selection that needs to be normalized\n             isSelectionContainerWhole_taTextElement: function (){\n             var range = rangy.getSelection().getRangeAt(0);\n             var container = range.commonAncestorContainer;\n             if (container.nodeName.toLowerCase() === 'div' &&\n             /^taTextElement/.test(container.id)) {\n             // container is the whole taTextElement\n             return true;\n             }\n             return false;\n             },\n             setNormalizedSelection: function (){\n             var range = rangy.getSelection().getRangeAt(0);\n             var container = range.commonAncestorContainer;\n             console.log(range);\n             console.log(container.childNodes);\n             if (range.collapsed) {\n             // we know what to do...\n             console.log(container.childNodes[range.startOffset]);\n             api.setSelectionToElementStart(container.childNodes[range.startOffset]);\n             }\n             },\n             */\n        };\n        return api;\n    }]).service('taDOM', function(){\n    var taDOM = {\n        // recursive function that returns an array of angular.elements that have the passed attribute set on them\n        getByAttribute: function(element, attribute){\n            var resultingElements = [];\n            var childNodes = element.children();\n            if(childNodes.length){\n                angular.forEach(childNodes, function(child){\n                    resultingElements = resultingElements.concat(taDOM.getByAttribute(angular.element(child), attribute));\n                });\n            }\n            if(element.attr(attribute) !== undefined) resultingElements.push(element);\n            return resultingElements;\n        },\n\n        transferChildNodes: function(source, target){\n            // clear out target\n            target.innerHTML = '';\n            while(source.childNodes.length > 0) target.appendChild(source.childNodes[0]);\n            return target;\n        },\n\n        splitNodes: function(nodes, target1, target2, splitNode, subSplitIndex, splitIndex){\n            if(!splitNode && isNaN(splitIndex)) throw new Error('taDOM.splitNodes requires a splitNode or splitIndex');\n            var startNodes = document.createDocumentFragment();\n            var endNodes = document.createDocumentFragment();\n            var index = 0;\n\n            while(nodes.length > 0 && (isNaN(splitIndex) || splitIndex !== index) && nodes[0] !== splitNode){\n                startNodes.appendChild(nodes[0]); // this removes from the nodes array (if proper childNodes object.\n                index++;\n            }\n\n            if(!isNaN(subSplitIndex) && subSplitIndex >= 0 && nodes[0]){\n                startNodes.appendChild(document.createTextNode(nodes[0].nodeValue.substring(0, subSplitIndex)));\n                nodes[0].nodeValue = nodes[0].nodeValue.substring(subSplitIndex);\n            }\n            while(nodes.length > 0) endNodes.appendChild(nodes[0]);\n\n            taDOM.transferChildNodes(startNodes, target1);\n            taDOM.transferChildNodes(endNodes, target2);\n        },\n\n        transferNodeAttributes: function(source, target){\n            for(var i = 0; i < source.attributes.length; i++) target.setAttribute(source.attributes[i].name, source.attributes[i].value);\n            return target;\n        }\n    };\n    return taDOM;\n});\n\nangular.module('textAngular.validators', [])\n    .directive('taMaxText', function(){\n        return {\n            restrict: 'A',\n            require: 'ngModel',\n            link: function(scope, elem, attrs, ctrl){\n                var max = parseInt(scope.$eval(attrs.taMaxText));\n                if (isNaN(max)){\n                    throw('Max text must be an integer');\n                }\n                attrs.$observe('taMaxText', function(value){\n                    max = parseInt(value);\n                    if (isNaN(max)){\n                        throw('Max text must be an integer');\n                    }\n                    if (ctrl.$dirty){\n                        ctrl.$validate();\n                    }\n                });\n                ctrl.$validators.taMaxText = function(viewValue){\n                    var source = angular.element('<div/>');\n                    source.html(viewValue);\n                    return source.text().length <= max;\n                };\n            }\n        };\n    }).directive('taMinText', function(){\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function(scope, elem, attrs, ctrl){\n            var min = parseInt(scope.$eval(attrs.taMinText));\n            if (isNaN(min)){\n                throw('Min text must be an integer');\n            }\n            attrs.$observe('taMinText', function(value){\n                min = parseInt(value);\n                if (isNaN(min)){\n                    throw('Min text must be an integer');\n                }\n                if (ctrl.$dirty){\n                    ctrl.$validate();\n                }\n            });\n            ctrl.$validators.taMinText = function(viewValue){\n                var source = angular.element('<div/>');\n                source.html(viewValue);\n                return !source.text().length || source.text().length >= min;\n            };\n        }\n    };\n});\nangular.module('textAngular.taBind', ['textAngular.factories', 'textAngular.DOM'])\n    .service('_taBlankTest', [function(){\n        return function(_blankVal){\n            // we radically restructure this code.\n            // what was here before was incredibly fragile.\n            // What we do now is to check that the html is non-blank visually\n            // which we check by looking at html->text\n            if(!_blankVal) return true;\n            // find first non-tag match - ie start of string or after tag that is not whitespace\n            // var t0 = performance.now();\n            // Takes a small fraction of a mSec to do this...\n            var _text_ = stripHtmlToText(_blankVal);\n            // var t1 = performance.now();\n            // console.log('Took', (t1 - t0).toFixed(4), 'milliseconds to generate:');\n            if (_text_=== '') {\n                // img generates a visible item so it is not blank!\n                if (/<img[^>]+>/.test(_blankVal)) {\n                    return false;\n                }\n                return true;\n            } else {\n                return false;\n            }\n        };\n    }])\n    .directive('taButton', [function(){\n        return {\n            link: function(scope, element, attrs){\n                element.attr('unselectable', 'on');\n                element.on('mousedown', function(e, eventData){\n                    /* istanbul ignore else: this is for catching the jqLite testing*/\n                    if(eventData) angular.extend(e, eventData);\n                    // this prevents focusout from firing on the editor when clicking toolbar buttons\n                    e.preventDefault();\n                    return false;\n                });\n            }\n        };\n    }])\n    .directive('taBind', [\n        'taSanitize', '$timeout', '$document', 'taFixChrome', 'taBrowserTag',\n        'taSelection', 'taSelectableElements', 'taApplyCustomRenderers', 'taOptions',\n        '_taBlankTest', '$parse', 'taDOM', 'textAngularManager',\n        function(\n            taSanitize, $timeout, $document, taFixChrome, taBrowserTag,\n            taSelection, taSelectableElements, taApplyCustomRenderers, taOptions,\n            _taBlankTest, $parse, taDOM, textAngularManager){\n            // Uses for this are textarea or input with ng-model and ta-bind='text'\n            // OR any non-form element with contenteditable=\"contenteditable\" ta-bind=\"html|text\" ng-model\n            return {\n                priority: 2, // So we override validators correctly\n                require: ['ngModel','?ngModelOptions'],\n                link: function(scope, element, attrs, controller){\n                    var ngModel = controller[0];\n                    var ngModelOptions = controller[1] || {};\n                    // the option to use taBind on an input or textarea is required as it will sanitize all input into it correctly.\n                    var _isContentEditable = element.attr('contenteditable') !== undefined && element.attr('contenteditable');\n                    var _isInputFriendly = _isContentEditable || element[0].tagName.toLowerCase() === 'textarea' || element[0].tagName.toLowerCase() === 'input';\n                    var _isReadonly = false;\n                    var _focussed = false;\n                    var _skipRender = false;\n                    var _disableSanitizer = attrs.taUnsafeSanitizer || taOptions.disableSanitizer;\n                    var _keepStyles = attrs.taKeepStyles || taOptions.keepStyles;\n                    var _lastKey;\n                    // see http://www.javascripter.net/faq/keycodes.htm for good information\n                    // NOTE Mute On|Off 173 (Opera MSIE Safari Chrome) 181 (Firefox)\n                    // BLOCKED_KEYS are special keys...\n                    // Tab, pause/break, CapsLock, Esc, Page Up, End, Home,\n                    // Left arrow, Up arrow, Right arrow, Down arrow, Insert, Delete,\n                    // f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12\n                    // NumLock, ScrollLock\n                    var BLOCKED_KEYS = /^(9|19|20|27|33|34|35|36|37|38|39|40|45|112|113|114|115|116|117|118|119|120|121|122|123|144|145)$/i;\n                    // UNDO_TRIGGER_KEYS - spaces, enter, delete, backspace, all punctuation\n                    // Backspace, Enter, Space, Delete, (; :) (Firefox), (= +) (Firefox),\n                    // Numpad +, Numpad -, (; :), (= +),\n                    // (, <), (- _), (. >), (/ ?), (` ~), ([ {), (\\ |), (] }), (' \")\n                    // NOTE - Firefox: 173 = (- _) -- adding this to UNDO_TRIGGER_KEYS\n                    var UNDO_TRIGGER_KEYS = /^(8|13|32|46|59|61|107|109|173|186|187|188|189|190|191|192|219|220|221|222)$/i;\n                    var _pasteHandler;\n\n                    // defaults to the paragraph element, but we need the line-break or it doesn't allow you to type into the empty element\n                    // non IE is '<p><br/></p>', ie is '<p></p>' as for once IE gets it correct...\n                    var _defaultVal, _defaultTest;\n\n                    var _CTRL_KEY = 0x0001;\n                    var _META_KEY = 0x0002;\n                    var _ALT_KEY = 0x0004;\n                    var _SHIFT_KEY = 0x0008;\n                    // KEYCODEs we use\n                    var _ENTER_KEYCODE = 13;\n                    var _SHIFT_KEYCODE = 16;\n                    var _TAB_KEYCODE = 9;\n                    var _LEFT_ARROW_KEYCODE = 37;\n                    var _RIGHT_ARROW_KEYCODE = 39;\n                    // map events to special keys...\n                    // mappings is an array of maps from events to specialKeys as declared in textAngularSetup\n                    var _keyMappings = [\n                        //\t\tctrl/command + z\n                        {\n                            specialKey: 'UndoKey',\n                            forbiddenModifiers: _ALT_KEY + _SHIFT_KEY,\n                            mustHaveModifiers: [_META_KEY + _CTRL_KEY],\n                            keyCode: 90\n                        },\n                        //\t\tctrl/command + shift + z\n                        {\n                            specialKey: 'RedoKey',\n                            forbiddenModifiers: _ALT_KEY,\n                            mustHaveModifiers: [_META_KEY + _CTRL_KEY, _SHIFT_KEY],\n                            keyCode: 90\n                        },\n                        //\t\tctrl/command + y\n                        {\n                            specialKey: 'RedoKey',\n                            forbiddenModifiers: _ALT_KEY + _SHIFT_KEY,\n                            mustHaveModifiers: [_META_KEY + _CTRL_KEY],\n                            keyCode: 89\n                        },\n                        //\t\tTabKey\n                        {\n                            specialKey: 'TabKey',\n                            forbiddenModifiers: _META_KEY + _SHIFT_KEY + _ALT_KEY + _CTRL_KEY,\n                            mustHaveModifiers: [],\n                            keyCode: _TAB_KEYCODE\n                        },\n                        //\t\tshift + TabKey\n                        {\n                            specialKey: 'ShiftTabKey',\n                            forbiddenModifiers: _META_KEY + _ALT_KEY + _CTRL_KEY,\n                            mustHaveModifiers: [_SHIFT_KEY],\n                            keyCode: _TAB_KEYCODE\n                        }\n                    ];\n                    function _mapKeys(event) {\n                        var specialKey;\n                        _keyMappings.forEach(function (map){\n                            if (map.keyCode === event.keyCode) {\n                                var netModifiers = (event.metaKey ? _META_KEY: 0) +\n                                    (event.ctrlKey ? _CTRL_KEY: 0) +\n                                    (event.shiftKey ? _SHIFT_KEY: 0) +\n                                    (event.altKey ? _ALT_KEY: 0);\n                                if (map.forbiddenModifiers & netModifiers) return;\n                                if (map.mustHaveModifiers.every(function (modifier) { return netModifiers & modifier; })){\n                                    specialKey = map.specialKey;\n                                }\n                            }\n                        });\n                        return specialKey;\n                    }\n\n                    // set the default to be a paragraph value\n                    if(attrs.taDefaultWrap === undefined) attrs.taDefaultWrap = 'p';\n                    /* istanbul ignore next: ie specific test */\n                    if(attrs.taDefaultWrap === ''){\n                        _defaultVal = '';\n                        _defaultTest = (_browserDetect.ie === undefined)? '<div><br></div>' : (_browserDetect.ie >= 11)? '<p><br></p>' : (_browserDetect.ie <= 8)? '<P>&nbsp;</P>' : '<p>&nbsp;</p>';\n                    }else{\n                        _defaultVal = (_browserDetect.ie === undefined || _browserDetect.ie >= 11)?\n                            (attrs.taDefaultWrap.toLowerCase() === 'br' ? '<BR><BR>' : '<' + attrs.taDefaultWrap + '><br></' + attrs.taDefaultWrap + '>') :\n                            (_browserDetect.ie <= 8)?\n                            '<' + attrs.taDefaultWrap.toUpperCase() + '></' + attrs.taDefaultWrap.toUpperCase() + '>' :\n                            '<' + attrs.taDefaultWrap + '></' + attrs.taDefaultWrap + '>';\n                        _defaultTest = (_browserDetect.ie === undefined || _browserDetect.ie >= 11)?\n                            (attrs.taDefaultWrap.toLowerCase() === 'br' ? '<br><br>' : '<' + attrs.taDefaultWrap + '><br></' + attrs.taDefaultWrap + '>') :\n                            (_browserDetect.ie <= 8)?\n                            '<' + attrs.taDefaultWrap.toUpperCase() + '>&nbsp;</' + attrs.taDefaultWrap.toUpperCase() + '>' :\n                            '<' + attrs.taDefaultWrap + '>&nbsp;</' + attrs.taDefaultWrap + '>';\n                    }\n\n                    /* istanbul ignore else */\n                    if(!ngModelOptions.$options) ngModelOptions.$options = {}; // ng-model-options support\n\n                    var _ensureContentWrapped = function(value) {\n                        if (_taBlankTest(value)) return value;\n                        var domTest = angular.element(\"<div>\" + value + \"</div>\");\n                        //console.log('domTest.children().length():', domTest.children().length);\n                        //console.log('_ensureContentWrapped', domTest.children());\n                        //console.log(value, attrs.taDefaultWrap);\n                        if (domTest.children().length === 0) {\n                            // if we have a <br> and the attrs.taDefaultWrap is a <p> we need to remove the <br>\n                            //value = value.replace(/<br>/i, '');\n                            value = \"<\" + attrs.taDefaultWrap + \">\" + value + \"</\" + attrs.taDefaultWrap + \">\";\n                        } else {\n                            var _children = domTest[0].childNodes;\n                            var i;\n                            var _foundBlockElement = false;\n                            for (i = 0; i < _children.length; i++) {\n                                if (_foundBlockElement = _children[i].nodeName.toLowerCase().match(BLOCKELEMENTS)) break;\n                            }\n                            if (!_foundBlockElement) {\n                                value = \"<\" + attrs.taDefaultWrap + \">\" + value + \"</\" + attrs.taDefaultWrap + \">\";\n                            }\n                            else{\n                                value = \"\";\n                                for(i = 0; i < _children.length; i++){\n                                    var node = _children[i];\n                                    var nodeName = node.nodeName.toLowerCase();\n                                    //console.log('node#:', i, 'name:', nodeName);\n                                    if(nodeName === '#comment') {\n                                        value += '<!--' + node.nodeValue + '-->';\n                                    } else if(nodeName === '#text') {\n                                        // determine if this is all whitespace, if so, we will leave it as it is.\n                                        // otherwise, we will wrap it as it is\n                                        var text = node.textContent;\n                                        if (!text.trim()) {\n                                            // just whitespace\n                                            value += text;\n                                        } else {\n                                            // not pure white space so wrap in <p>...</p> or whatever attrs.taDefaultWrap is set to.\n                                            value += \"<\" + attrs.taDefaultWrap + \">\" + text + \"</\" + attrs.taDefaultWrap + \">\";\n                                        }\n                                    } else if(!nodeName.match(BLOCKELEMENTS)){\n                                        /* istanbul ignore  next: Doesn't seem to trigger on tests */\n                                        var _subVal = (node.outerHTML || node.nodeValue);\n                                        /* istanbul ignore else: Doesn't seem to trigger on tests, is tested though */\n                                        if(_subVal.trim() !== '')\n                                            value += \"<\" + attrs.taDefaultWrap + \">\" + _subVal + \"</\" + attrs.taDefaultWrap + \">\";\n                                        else value += _subVal;\n                                    } else {\n                                        value += node.outerHTML;\n                                    }\n                                    //console.log(value);\n                                }\n                            }\n                        }\n                        //console.log(value);\n                        return value;\n                    };\n\n                    if(attrs.taPaste) {\n                        _pasteHandler = $parse(attrs.taPaste);\n                    }\n\n                    element.addClass('ta-bind');\n\n                    var _undoKeyupTimeout;\n\n                    scope['$undoManager' + (attrs.id || '')] = ngModel.$undoManager = {\n                        _stack: [],\n                        _index: 0,\n                        _max: 1000,\n                        push: function(value){\n                            if((typeof value === \"undefined\" || value === null) ||\n                                ((typeof this.current() !== \"undefined\" && this.current() !== null) && value === this.current())) return value;\n                            if(this._index < this._stack.length - 1){\n                                this._stack = this._stack.slice(0,this._index+1);\n                            }\n                            this._stack.push(value);\n                            if(_undoKeyupTimeout) $timeout.cancel(_undoKeyupTimeout);\n                            if(this._stack.length > this._max) this._stack.shift();\n                            this._index = this._stack.length - 1;\n                            return value;\n                        },\n                        undo: function(){\n                            return this.setToIndex(this._index-1);\n                        },\n                        redo: function(){\n                            return this.setToIndex(this._index+1);\n                        },\n                        setToIndex: function(index){\n                            if(index < 0 || index > this._stack.length - 1){\n                                return undefined;\n                            }\n                            this._index = index;\n                            return this.current();\n                        },\n                        current: function(){\n                            return this._stack[this._index];\n                        }\n                    };\n\n                    // in here we are undoing the converts used elsewhere to prevent the < > and & being displayed when they shouldn't in the code.\n                    var _compileHtml = function(){\n                        if(_isContentEditable) {\n                            return element[0].innerHTML;\n                        }\n                        if(_isInputFriendly) {\n                            return element.val();\n                        }\n                        throw ('textAngular Error: attempting to update non-editable taBind');\n                    };\n\n                    var selectorClickHandler = function(event){\n                        // emit the element-select event, pass the element\n                        scope.$emit('ta-element-select', this);\n                        event.preventDefault();\n                        return false;\n                    };\n\n                    //used for updating when inserting wrapped elements\n                    var _reApplyOnSelectorHandlers = scope['reApplyOnSelectorHandlers' + (attrs.id || '')] = function(){\n                        /* istanbul ignore else */\n                        if(!_isReadonly) angular.forEach(taSelectableElements, function(selector){\n                            // check we don't apply the handler twice\n                            element.find(selector)\n                                .off('click', selectorClickHandler)\n                                .on('click', selectorClickHandler);\n                        });\n                    };\n\n                    var _setViewValue = function(_val, triggerUndo, skipRender){\n                        _skipRender = skipRender || false;\n                        if(typeof triggerUndo === \"undefined\" || triggerUndo === null) triggerUndo = true && _isContentEditable; // if not contentEditable then the native undo/redo is fine\n                        if(typeof _val === \"undefined\" || _val === null) _val = _compileHtml();\n                        if(_taBlankTest(_val)){\n                            // this avoids us from tripping the ng-pristine flag if we click in and out with out typing\n                            if(ngModel.$viewValue !== '') ngModel.$setViewValue('');\n                            if(triggerUndo && ngModel.$undoManager.current() !== '') ngModel.$undoManager.push('');\n                        }else{\n                            _reApplyOnSelectorHandlers();\n                            if(ngModel.$viewValue !== _val){\n                                ngModel.$setViewValue(_val);\n                                if(triggerUndo) ngModel.$undoManager.push(_val);\n                            }\n                        }\n                        ngModel.$render();\n                    };\n\n                    var _setInnerHTML = function(newval){\n                        element[0].innerHTML = newval;\n                    };\n\n                    var _redoUndoTimeout;\n                    var _undo = scope['$undoTaBind' + (attrs.id || '')] = function(){\n                        /* istanbul ignore else: can't really test it due to all changes being ignored as well in readonly */\n                        if(!_isReadonly && _isContentEditable){\n                            var content = ngModel.$undoManager.undo();\n                            if(typeof content !== \"undefined\" && content !== null){\n                                _setInnerHTML(content);\n                                _setViewValue(content, false);\n                                if(_redoUndoTimeout) $timeout.cancel(_redoUndoTimeout);\n                                _redoUndoTimeout = $timeout(function(){\n                                    element[0].focus();\n                                    taSelection.setSelectionToElementEnd(element[0]);\n                                }, 1);\n                            }\n                        }\n                    };\n\n                    var _redo = scope['$redoTaBind' + (attrs.id || '')] = function(){\n                        /* istanbul ignore else: can't really test it due to all changes being ignored as well in readonly */\n                        if(!_isReadonly && _isContentEditable){\n                            var content = ngModel.$undoManager.redo();\n                            if(typeof content !== \"undefined\" && content !== null){\n                                _setInnerHTML(content);\n                                _setViewValue(content, false);\n                                /* istanbul ignore next */\n                                if(_redoUndoTimeout) $timeout.cancel(_redoUndoTimeout);\n                                _redoUndoTimeout = $timeout(function(){\n                                    element[0].focus();\n                                    taSelection.setSelectionToElementEnd(element[0]);\n                                }, 1);\n                            }\n                        }\n                    };\n\n                    //used for updating when inserting wrapped elements\n                    scope['updateTaBind' + (attrs.id || '')] = function(){\n                        if(!_isReadonly) _setViewValue(undefined, undefined, true);\n                    };\n\n                    // catch DOM XSS via taSanitize\n                    // Sanitizing both ways is identical\n                    var _sanitize = function(unsafe){\n                        return (ngModel.$oldViewValue = taSanitize(taFixChrome(unsafe, _keepStyles), ngModel.$oldViewValue, _disableSanitizer));\n                    };\n\n                    // trigger the validation calls\n                    if(element.attr('required')) ngModel.$validators.required = function(modelValue, viewValue) {\n                        return !_taBlankTest(modelValue || viewValue);\n                    };\n                    // parsers trigger from the above keyup function or any other time that the viewValue is updated and parses it for storage in the ngModel\n                    ngModel.$parsers.push(_sanitize);\n                    ngModel.$parsers.unshift(_ensureContentWrapped);\n                    // because textAngular is bi-directional (which is awesome) we need to also sanitize values going in from the server\n                    ngModel.$formatters.push(_sanitize);\n                    ngModel.$formatters.unshift(_ensureContentWrapped);\n                    ngModel.$formatters.unshift(function(value){\n                        return ngModel.$undoManager.push(value || '');\n                    });\n\n                    //this code is used to update the models when data is entered/deleted\n                    if(_isInputFriendly){\n                        scope.events = {};\n                        if(!_isContentEditable){\n                            // if a textarea or input just add in change and blur handlers, everything else is done by angulars input directive\n                            element.on('change blur', scope.events.change = scope.events.blur = function(){\n                                if(!_isReadonly) ngModel.$setViewValue(_compileHtml());\n                            });\n\n                            element.on('keydown', scope.events.keydown = function(event, eventData){\n                                /* istanbul ignore else: this is for catching the jqLite testing*/\n                                if(eventData) angular.extend(event, eventData);\n                                // Reference to http://stackoverflow.com/questions/6140632/how-to-handle-tab-in-textarea\n                                /* istanbul ignore else: otherwise normal functionality */\n                                if(event.keyCode === _TAB_KEYCODE){ // tab was pressed\n                                    // get caret position/selection\n                                    var start = this.selectionStart;\n                                    var end = this.selectionEnd;\n\n                                    var value = element.val();\n                                    if(event.shiftKey){\n                                        // find \\t\n                                        var _linebreak = value.lastIndexOf('\\n', start), _tab = value.lastIndexOf('\\t', start);\n                                        if(_tab !== -1 && _tab >= _linebreak){\n                                            // set textarea value to: text before caret + tab + text after caret\n                                            element.val(value.substring(0, _tab) + value.substring(_tab + 1));\n\n                                            // put caret at right position again (add one for the tab)\n                                            this.selectionStart = this.selectionEnd = start - 1;\n                                        }\n                                    }else{\n                                        // set textarea value to: text before caret + tab + text after caret\n                                        element.val(value.substring(0, start) + \"\\t\" + value.substring(end));\n\n                                        // put caret at right position again (add one for the tab)\n                                        this.selectionStart = this.selectionEnd = start + 1;\n                                    }\n                                    // prevent the focus lose\n                                    event.preventDefault();\n                                }\n                            });\n\n                            var _repeat = function(string, n){\n                                var result = '';\n                                for(var _n = 0; _n < n; _n++) result += string;\n                                return result;\n                            };\n\n                            // add a forEach function that will work on a NodeList, etc..\n                            var forEach = function (array, callback, scope) {\n                                for (var i= 0; i<array.length; i++) {\n                                    callback.call(scope, i, array[i]);\n                                }\n                            };\n\n                            // handle <ul> or <ol> nodes\n                            var recursiveListFormat = function(listNode, tablevel){\n                                var _html = '';\n                                var _subnodes = listNode.childNodes;\n                                tablevel++;\n                                // tab out and add the <ul> or <ol> html piece\n                                _html += _repeat('\\t', tablevel-1) + listNode.outerHTML.substring(0, 4);\n                                forEach(_subnodes, function (index, node) {\n                                    /* istanbul ignore next: browser catch */\n                                    var nodeName = node.nodeName.toLowerCase();\n                                    if (nodeName === '#comment') {\n                                        _html += '<!--' + node.nodeValue + '-->';\n                                        return;\n                                    }\n                                    if (nodeName === '#text') {\n                                        _html += node.textContent;\n                                        return;\n                                    }\n                                    /* istanbul ignore next: not tested, and this was original code -- so not wanting to possibly cause an issue, leaving it... */\n                                    if(!node.outerHTML) {\n                                        // no html to add\n                                        return;\n                                    }\n                                    if(nodeName === 'ul' || nodeName === 'ol') {\n                                        _html += '\\n' + recursiveListFormat(node, tablevel);\n                                    }\n                                    else {\n                                        // no reformatting within this subnode, so just do the tabing...\n                                        _html += '\\n' + _repeat('\\t', tablevel) + node.outerHTML;\n                                    }\n                                });\n                                // now add on the </ol> or </ul> piece\n                                _html += '\\n' + _repeat('\\t', tablevel-1) + listNode.outerHTML.substring(listNode.outerHTML.lastIndexOf('<'));\n                                return _html;\n                            };\n                            // handle formating of something like:\n                            // <ol><!--First comment-->\n                            //  <li>Test Line 1<!--comment test list 1--></li>\n                            //    <ul><!--comment ul-->\n                            //      <li>Nested Line 1</li>\n                            //        <!--comment between nested lines--><li>Nested Line 2</li>\n                            //    </ul>\n                            //  <li>Test Line 3</li>\n                            // </ol>\n                            ngModel.$formatters.unshift(function(htmlValue){\n                                // tabulate the HTML so it looks nicer\n                                //\n                                // first get a list of the nodes...\n                                // we do this by using the element parser...\n                                //\n                                // doing this -- which is simpiler -- breaks our tests...\n                                //var _nodes=angular.element(htmlValue);\n                                var _nodes = angular.element('<div>' + htmlValue + '</div>')[0].childNodes;\n                                if(_nodes.length > 0){\n                                    // do the reformatting of the layout...\n                                    htmlValue = '';\n                                    forEach(_nodes, function (index, node) {\n                                        var nodeName = node.nodeName.toLowerCase();\n                                        if (nodeName === '#comment') {\n                                            htmlValue += '<!--' + node.nodeValue + '-->';\n                                            return;\n                                        }\n                                        if (nodeName === '#text') {\n                                            htmlValue += node.textContent;\n                                            return;\n                                        }\n                                        /* istanbul ignore next: not tested, and this was original code -- so not wanting to possibly cause an issue, leaving it... */\n                                        if(!node.outerHTML)\n                                        {\n                                            // nothing to format!\n                                            return;\n                                        }\n                                        if(htmlValue.length > 0) {\n                                            // we aready have some content, so drop to a new line\n                                            htmlValue += '\\n';\n                                        }\n                                        if(nodeName === 'ul' || nodeName === 'ol') {\n                                            // okay a set of list stuff we want to reformat in a nested way\n                                            htmlValue += '' + recursiveListFormat(node, 0);\n                                        }\n                                        else {\n                                            // just use the original without any additional formating\n                                            htmlValue += '' + node.outerHTML;\n                                        }\n                                    });\n                                }\n                                return htmlValue;\n                            });\n                        }else{\n                            // all the code specific to contenteditable divs\n                            var _processingPaste = false;\n                            /* istanbul ignore next: phantom js cannot test this for some reason */\n                            var processpaste = function(text) {\n                                var _isOneNote = text!==undefined? text.match(/content=[\"']*OneNote.File/i): false;\n                                /* istanbul ignore else: don't care if nothing pasted */\n                                //console.log(text);\n                                if(text && text.trim().length){\n                                    // test paste from word/microsoft product\n                                    if(text.match(/class=[\"']*Mso(Normal|List)/i) || text.match(/content=[\"']*Word.Document/i) || text.match(/content=[\"']*OneNote.File/i)){\n                                        var textFragment = text.match(/<!--StartFragment-->([\\s\\S]*?)<!--EndFragment-->/i);\n                                        if(!textFragment) textFragment = text;\n                                        else textFragment = textFragment[1];\n                                        textFragment = textFragment.replace(/<o:p>[\\s\\S]*?<\\/o:p>/ig, '').replace(/class=([\"']|)MsoNormal([\"']|)/ig, '');\n                                        var dom = angular.element(\"<div>\" + textFragment + \"</div>\");\n                                        var targetDom = angular.element(\"<div></div>\");\n                                        var _list = {\n                                            element: null,\n                                            lastIndent: [],\n                                            lastLi: null,\n                                            isUl: false\n                                        };\n                                        _list.lastIndent.peek = function(){\n                                            var n = this.length;\n                                            if (n>0) return this[n-1];\n                                        };\n                                        var _resetList = function(isUl){\n                                            _list.isUl = isUl;\n                                            _list.element = angular.element(isUl ? \"<ul>\" : \"<ol>\");\n                                            _list.lastIndent = [];\n                                            _list.lastIndent.peek = function(){\n                                                var n = this.length;\n                                                if (n>0) return this[n-1];\n                                            };\n                                            _list.lastLevelMatch = null;\n                                        };\n                                        for(var i = 0; i <= dom[0].childNodes.length; i++){\n                                            if(!dom[0].childNodes[i] || dom[0].childNodes[i].nodeName === \"#text\"){\n                                                continue;\n                                            } else {\n                                                var tagName = dom[0].childNodes[i].tagName.toLowerCase();\n                                                if(tagName !== 'p' &&\n                                                    tagName !== 'ul' &&\n                                                    tagName !== 'h1' &&\n                                                    tagName !== 'h2' &&\n                                                    tagName !== 'h3' &&\n                                                    tagName !== 'h4' &&\n                                                    tagName !== 'h5' &&\n                                                    tagName !== 'h6' &&\n                                                    tagName !== 'table'){\n                                                    continue;\n                                                }\n                                            }\n                                            var el = angular.element(dom[0].childNodes[i]);\n                                            var _listMatch = (el.attr('class') || '').match(/MsoList(Bullet|Number|Paragraph)(CxSp(First|Middle|Last)|)/i);\n\n                                            if(_listMatch){\n                                                if(el[0].childNodes.length < 2 || el[0].childNodes[1].childNodes.length < 1){\n                                                    continue;\n                                                }\n                                                var isUl = _listMatch[1].toLowerCase() === 'bullet' || (_listMatch[1].toLowerCase() !== 'number' && !(/^[^0-9a-z<]*[0-9a-z]+[^0-9a-z<>]</i.test(el[0].childNodes[1].innerHTML) || /^[^0-9a-z<]*[0-9a-z]+[^0-9a-z<>]</i.test(el[0].childNodes[1].childNodes[0].innerHTML)));\n                                                var _indentMatch = (el.attr('style') || '').match(/margin-left:([\\-\\.0-9]*)/i);\n                                                var indent = parseFloat((_indentMatch)?_indentMatch[1]:0);\n                                                var _levelMatch = (el.attr('style') || '').match(/mso-list:l([0-9]+) level([0-9]+) lfo[0-9+]($|;)/i);\n                                                // prefers the mso-list syntax\n\n                                                if(_levelMatch && _levelMatch[2]) indent = parseInt(_levelMatch[2]);\n\n                                                if ((_levelMatch && (!_list.lastLevelMatch || _levelMatch[1] !== _list.lastLevelMatch[1])) || !_listMatch[3] || _listMatch[3].toLowerCase() === 'first' || (_list.lastIndent.peek() === null) || (_list.isUl !== isUl && _list.lastIndent.peek() === indent)) {\n                                                    _resetList(isUl);\n                                                    targetDom.append(_list.element);\n                                                } else if (_list.lastIndent.peek() != null && _list.lastIndent.peek() < indent){\n                                                    _list.element = angular.element(isUl ? '<ul>' : '<ol>');\n                                                    _list.lastLi.append(_list.element);\n                                                } else if (_list.lastIndent.peek() != null && _list.lastIndent.peek() > indent){\n                                                    while(_list.lastIndent.peek() != null && _list.lastIndent.peek() > indent){\n                                                        if(_list.element.parent()[0].tagName.toLowerCase() === 'li'){\n                                                            _list.element = _list.element.parent();\n                                                            continue;\n                                                        }else if(/[uo]l/i.test(_list.element.parent()[0].tagName.toLowerCase())){\n                                                            _list.element = _list.element.parent();\n                                                        }else{ // else it's it should be a sibling\n                                                            break;\n                                                        }\n                                                        _list.lastIndent.pop();\n                                                    }\n                                                    _list.isUl = _list.element[0].tagName.toLowerCase() === 'ul';\n                                                    if (isUl !== _list.isUl) {\n                                                        _resetList(isUl);\n                                                        targetDom.append(_list.element);\n                                                    }\n                                                }\n\n                                                _list.lastLevelMatch = _levelMatch;\n                                                if(indent !== _list.lastIndent.peek()) _list.lastIndent.push(indent);\n                                                _list.lastLi = angular.element('<li>');\n                                                _list.element.append(_list.lastLi);\n                                                _list.lastLi.html(el.html().replace(/<!(--|)\\[if !supportLists\\](--|)>[\\s\\S]*?<!(--|)\\[endif\\](--|)>/ig, ''));\n                                                el.remove();\n                                            }else{\n                                                _resetList(false);\n                                                targetDom.append(el);\n                                            }\n                                        }\n                                        var _unwrapElement = function(node){\n                                            node = angular.element(node);\n                                            for(var _n = node[0].childNodes.length - 1; _n >= 0; _n--) node.after(node[0].childNodes[_n]);\n                                            node.remove();\n                                        };\n\n                                        angular.forEach(targetDom.find('span'), function(node){\n                                            node.removeAttribute('lang');\n                                            if(node.attributes.length <= 0) _unwrapElement(node);\n                                        });\n                                        angular.forEach(targetDom.find('font'), _unwrapElement);\n\n                                        text = targetDom.html();\n                                        if(_isOneNote){\n                                            text = targetDom.html() || dom.html();\n                                        }\n                                        // LF characters instead of spaces in some spots and they are replaced by '/n', so we need to just swap them to spaces\n                                        text = text.replace(/\\n/g, ' ');\n                                    }else{\n                                        // remove unnecessary chrome insert\n                                        text = text.replace(/<(|\\/)meta[^>]*?>/ig, '');\n                                        if(text.match(/<[^>]*?(ta-bind)[^>]*?>/)){\n                                            // entire text-angular or ta-bind has been pasted, REMOVE AT ONCE!!\n                                            if(text.match(/<[^>]*?(text-angular)[^>]*?>/)){\n                                                var _el = angular.element('<div>' + text + '</div>');\n                                                _el.find('textarea').remove();\n                                                for(var _b = 0; _b < binds.length; _b++){\n                                                    var _target = binds[_b][0].parentNode.parentNode;\n                                                    for(var _c = 0; _c < binds[_b][0].childNodes.length; _c++){\n                                                        _target.parentNode.insertBefore(binds[_b][0].childNodes[_c], _target);\n                                                    }\n                                                    _target.parentNode.removeChild(_target);\n                                                }\n                                                text = _el.html().replace('<br class=\"Apple-interchange-newline\">', '');\n                                            }\n                                        }else if(text.match(/^<span/)){\n                                            // in case of pasting only a span - chrome paste, remove them. THis is just some wierd formatting\n                                            // if we remove the '<span class=\"Apple-converted-space\"> </span>' here we destroy the spacing\n                                            // on paste from even ourselves!\n                                            if (!text.match(/<span class=(\\\"Apple-converted-space\\\"|\\'Apple-converted-space\\')>.<\\/span>/ig)) {\n                                                text = text.replace(/<(|\\/)span[^>]*?>/ig, '');\n                                            }\n                                        }\n                                        // Webkit on Apple tags\n                                        text = text.replace(/<br class=\"Apple-interchange-newline\"[^>]*?>/ig, '').replace(/<span class=\"Apple-converted-space\">( |&nbsp;)<\\/span>/ig, '&nbsp;');\n                                    }\n\n                                    if (/<li(\\s.*)?>/i.test(text) && /(<ul(\\s.*)?>|<ol(\\s.*)?>).*<li(\\s.*)?>/i.test(text) === false) {\n                                        // insert missing parent of li element\n                                        text = text.replace(/<li(\\s.*)?>.*<\\/li(\\s.*)?>/i, '<ul>$&</ul>');\n                                    }\n\n                                    // parse whitespace from plaintext input, starting with preceding spaces that get stripped on paste\n                                    text = text.replace(/^[ |\\u00A0]+/gm, function (match) {\n                                        var result = '';\n                                        for (var i = 0; i < match.length; i++) {\n                                            result += '&nbsp;';\n                                        }\n                                        return result;\n                                    }).replace(/\\n|\\r\\n|\\r/g, '<br />').replace(/\\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;');\n\n                                    if(_pasteHandler) text = _pasteHandler(scope, {$html: text}) || text;\n\n                                    // turn span vertical-align:super into <sup></sup>\n                                    text = text.replace(/<span style=(\"|')([^<]*?)vertical-align\\s*:\\s*super;?([^>]*?)(\"|')>([^<]+?)<\\/span>/g, \"<sup style='$2$3'>$5</sup>\");\n\n                                    text = taSanitize(text, '', _disableSanitizer);\n                                    //console.log('DONE\\n', text);\n\n                                    taSelection.insertHtml(text, element[0]);\n                                    $timeout(function(){\n                                        ngModel.$setViewValue(_compileHtml());\n                                        _processingPaste = false;\n                                        element.removeClass('processing-paste');\n                                    }, 0);\n                                }else{\n                                    _processingPaste = false;\n                                    element.removeClass('processing-paste');\n                                }\n                            };\n\n                            element.on('paste', scope.events.paste = function(e, eventData){\n                                /* istanbul ignore else: this is for catching the jqLite testing*/\n                                if(eventData) angular.extend(e, eventData);\n                                if(_isReadonly || _processingPaste){\n                                    e.stopPropagation();\n                                    e.preventDefault();\n                                    return false;\n                                }\n\n                                // Code adapted from http://stackoverflow.com/questions/2176861/javascript-get-clipboard-data-on-paste-event-cross-browser/6804718#6804718\n                                _processingPaste = true;\n                                element.addClass('processing-paste');\n                                var pastedContent;\n                                var clipboardData = (e.originalEvent || e).clipboardData;\n                                /* istanbul ignore next: Handle legacy IE paste */\n                                if ( !clipboardData && window.clipboardData && window.clipboardData.getData ){\n                                    pastedContent = window.clipboardData.getData(\"Text\");\n                                    processpaste(pastedContent);\n                                    e.stopPropagation();\n                                    e.preventDefault();\n                                    return false;\n                                }\n                                if (clipboardData && clipboardData.getData && clipboardData.types.length > 0) {// Webkit - get data from clipboard, put into editdiv, cleanup, then cancel event\n                                    var _types = \"\";\n                                    for(var _t = 0; _t < clipboardData.types.length; _t++){\n                                        _types += \" \" + clipboardData.types[_t];\n                                    }\n                                    /* istanbul ignore next: browser tests */\n                                    if (/text\\/html/i.test(_types)) {\n                                        pastedContent = clipboardData.getData('text/html');\n                                    } else if (/text\\/plain/i.test(_types)) {\n                                        pastedContent = clipboardData.getData('text/plain');\n                                    }\n                                    processpaste(pastedContent);\n                                    e.stopPropagation();\n                                    e.preventDefault();\n                                    return false;\n                                } else {// Everything else - empty editdiv and allow browser to paste content into it, then cleanup\n                                    var _savedSelection = rangy.saveSelection(),\n                                        _tempDiv = angular.element('<div class=\"ta-hidden-input\" contenteditable=\"true\"></div>');\n                                    $document.find('body').append(_tempDiv);\n                                    _tempDiv[0].focus();\n                                    $timeout(function(){\n                                        // restore selection\n                                        rangy.restoreSelection(_savedSelection);\n                                        processpaste(_tempDiv[0].innerHTML);\n                                        element[0].focus();\n                                        _tempDiv.remove();\n                                    }, 0);\n                                }\n                            });\n                            element.on('cut', scope.events.cut = function(e){\n                                // timeout to next is needed as otherwise the paste/cut event has not finished actually changing the display\n                                if(!_isReadonly) $timeout(function(){\n                                    ngModel.$setViewValue(_compileHtml());\n                                }, 0);\n                                else e.preventDefault();\n                            });\n\n                            element.on('keydown', scope.events.keydown = function(event, eventData){\n                                /* istanbul ignore else: this is for catching the jqLite testing*/\n                                if(eventData) angular.extend(event, eventData);\n                                if (event.keyCode === _SHIFT_KEYCODE) {\n                                    taSelection.setStateShiftKey(true);\n                                } else {\n                                    taSelection.setStateShiftKey(false);\n                                }\n                                event.specialKey = _mapKeys(event);\n                                var userSpecialKey;\n                                /* istanbul ignore next: difficult to test */\n                                taOptions.keyMappings.forEach(function (mapping) {\n                                    if (event.specialKey === mapping.commandKeyCode) {\n                                        // taOptions has remapped this binding... so\n                                        // we disable our own\n                                        event.specialKey = undefined;\n                                    }\n                                    if (mapping.testForKey(event)) {\n                                        userSpecialKey = mapping.commandKeyCode;\n                                    }\n                                    if ((mapping.commandKeyCode === 'UndoKey') || (mapping.commandKeyCode === 'RedoKey')) {\n                                        // this is necessary to fully stop the propagation.\n                                        if (!mapping.enablePropagation) {\n                                            event.preventDefault();\n                                        }\n                                    }\n                                });\n                                /* istanbul ignore next: difficult to test */\n                                if (typeof userSpecialKey !== 'undefined') {\n                                    event.specialKey = userSpecialKey;\n                                }\n                                /* istanbul ignore next: difficult to test as can't seem to select */\n                                if ((typeof event.specialKey !== 'undefined') && (\n                                        event.specialKey !== 'UndoKey' || event.specialKey !== 'RedoKey'\n                                    )) {\n                                    event.preventDefault();\n                                    textAngularManager.sendKeyCommand(scope, event);\n                                }\n                                /* istanbul ignore else: readonly check */\n                                if(!_isReadonly){\n                                    if (event.specialKey==='UndoKey') {\n                                        _undo();\n                                        event.preventDefault();\n                                    }\n                                    if (event.specialKey==='RedoKey') {\n                                        _redo();\n                                        event.preventDefault();\n                                    }\n                                    /* istanbul ignore next: difficult to test as can't seem to select */\n                                    if(event.keyCode === _ENTER_KEYCODE && !event.shiftKey && !event.ctrlKey && !event.metaKey && !event.altKey)\n                                    {\n                                        var contains = function(a, obj) {\n                                            for (var i = 0; i < a.length; i++) {\n                                                if (a[i] === obj) {\n                                                    return true;\n                                                }\n                                            }\n                                            return false;\n                                        };\n                                        var $selection;\n                                        var selection = taSelection.getSelectionElement();\n                                        // shifted to nodeName here from tagName since it is more widely supported see: http://stackoverflow.com/questions/4878484/difference-between-tagname-and-nodename\n                                        if(!selection.nodeName.match(VALIDELEMENTS)) return;\n                                        var _new = angular.element(_defaultVal);\n                                        // if we are in the last element of a blockquote, or ul or ol and the element is blank\n                                        // we need to pull the element outside of the said type\n                                        var moveOutsideElements = ['blockquote', 'ul', 'ol'];\n                                        if (contains(moveOutsideElements, selection.parentNode.tagName.toLowerCase())) {\n                                            if (/^<br(|\\/)>$/i.test(selection.innerHTML.trim()) && !selection.nextSibling) {\n                                                // if last element is blank, pull element outside.\n                                                $selection = angular.element(selection);\n                                                var _parent = $selection.parent();\n                                                _parent.after(_new);\n                                                $selection.remove();\n                                                if (_parent.children().length === 0) _parent.remove();\n                                                taSelection.setSelectionToElementStart(_new[0]);\n                                                event.preventDefault();\n                                            }\n                                            if (/^<[^>]+><br(|\\/)><\\/[^>]+>$/i.test(selection.innerHTML.trim())) {\n                                                $selection = angular.element(selection);\n                                                $selection.after(_new);\n                                                $selection.remove();\n                                                taSelection.setSelectionToElementStart(_new[0]);\n                                                event.preventDefault();\n                                            }\n                                        }\n                                    }\n                                }\n                            });\n                            var _keyupTimeout;\n                            element.on('keyup', scope.events.keyup = function(event, eventData){\n                                /* istanbul ignore else: this is for catching the jqLite testing*/\n                                if(eventData) angular.extend(event, eventData);\n                                taSelection.setStateShiftKey(false);\t// clear the ShiftKey state\n                                /* istanbul ignore next: FF specific bug fix */\n                                if (event.keyCode === _TAB_KEYCODE) {\n                                    var _selection = taSelection.getSelection();\n                                    if(_selection.start.element === element[0] && element.children().length) taSelection.setSelectionToElementStart(element.children()[0]);\n                                    return;\n                                }\n                                // we do this here during the 'keyup' so that the browser has already moved the slection by one character...\n                                if (event.keyCode === _LEFT_ARROW_KEYCODE && !event.shiftKey) {\n                                    taSelection.updateLeftArrowKey(element);\n                                }\n                                // we do this here during the 'keyup' so that the browser has already moved the slection by one character...\n                                if (event.keyCode === _RIGHT_ARROW_KEYCODE && !event.shiftKey) {\n                                    taSelection.updateRightArrowKey(element);\n                                }\n                                if(_undoKeyupTimeout) $timeout.cancel(_undoKeyupTimeout);\n                                if(!_isReadonly && !BLOCKED_KEYS.test(event.keyCode)){\n                                    /* istanbul ignore next: Ignore any _ENTER_KEYCODE that has ctrlKey, metaKey or alKey */\n                                    if (event.keyCode === _ENTER_KEYCODE && (event.ctrlKey || event.metaKey || event.altKey)) {\n                                        // we ignore any ENTER_\tKEYCODE that is anything but plain or a shift one...\n                                    } else {\n                                        // if enter - insert new taDefaultWrap, if shift+enter insert <br/>\n                                        if(_defaultVal !== '' && _defaultVal !== '<BR><BR>' && event.keyCode === _ENTER_KEYCODE && !event.ctrlKey && !event.metaKey && !event.altKey){\n                                            var selection = taSelection.getSelectionElement();\n                                            while(!selection.nodeName.match(VALIDELEMENTS) && selection !== element[0]){\n                                                selection = selection.parentNode;\n                                            }\n                                            if(!event.shiftKey){\n                                                // new paragraph, br should be caught correctly\n                                                // shifted to nodeName here from tagName since it is more widely supported see: http://stackoverflow.com/questions/4878484/difference-between-tagname-and-nodename\n                                                //console.log('Enter', selection.nodeName, attrs.taDefaultWrap, selection.innerHTML.trim());\n                                                if(selection.tagName.toLowerCase() !==\n                                                    attrs.taDefaultWrap &&\n                                                    selection.nodeName.toLowerCase() !== 'li' &&\n                                                    (selection.innerHTML.trim() === '' || selection.innerHTML.trim() === '<br>')\n                                                ) {\n                                                    // Chrome starts with a <div><br></div> after an EnterKey\n                                                    // so we replace this with the _defaultVal\n                                                    var _new = angular.element(_defaultVal);\n                                                    angular.element(selection).replaceWith(_new);\n                                                    taSelection.setSelectionToElementStart(_new[0]);\n                                                }\n                                            } else {\n                                                // shift + Enter\n                                                var tagName = selection.tagName.toLowerCase();\n                                                //console.log('Shift+Enter', selection.tagName, attrs.taDefaultWrap, selection.innerHTML.trim());\n                                                // For an LI: We see: LI p ....<br><br>\n                                                // For a P: We see: P p ....<br><br>\n                                                // on Safari, the browser ignores the Shift+Enter and acts just as an Enter Key\n                                                // For an LI: We see: LI p <br>\n                                                // For a P: We see: P p <br>\n                                                if((tagName === attrs.taDefaultWrap ||\n                                                    tagName === 'li' ||\n                                                    tagName === 'pre' ||\n                                                    tagName === 'div') &&\n                                                    !/.+<br><br>/.test(selection.innerHTML.trim())) {\n                                                    var ps = selection.previousSibling;\n                                                    //console.log('wrong....', ps);\n                                                    // we need to remove this selection and fix the previousSibling up...\n                                                    if (ps) {\n                                                        ps.innerHTML = ps.innerHTML + '<br><br>';\n                                                        angular.element(selection).remove();\n                                                        taSelection.setSelectionToElementEnd(ps);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        var val = _compileHtml();\n                                        if(_defaultVal !== '' && (val.trim() === '' || val.trim() === '<br>')){\n                                            _setInnerHTML(_defaultVal);\n                                            taSelection.setSelectionToElementStart(element.children()[0]);\n                                        }else if(val.substring(0, 1) !== '<' && attrs.taDefaultWrap !== ''){\n                                            /* we no longer do this, since there can be comments here and white space\n                                             var _savedSelection = rangy.saveSelection();\n                                             val = _compileHtml();\n                                             val = \"<\" + attrs.taDefaultWrap + \">\" + val + \"</\" + attrs.taDefaultWrap + \">\";\n                                             _setInnerHTML(val);\n                                             rangy.restoreSelection(_savedSelection);\n                                             */\n                                        }\n                                        var triggerUndo = _lastKey !== event.keyCode && UNDO_TRIGGER_KEYS.test(event.keyCode);\n                                        if(_keyupTimeout) $timeout.cancel(_keyupTimeout);\n                                        _keyupTimeout = $timeout(function() {\n                                            _setViewValue(val, triggerUndo, true);\n                                        }, ngModelOptions.$options.debounce || 400);\n                                        if(!triggerUndo) _undoKeyupTimeout = $timeout(function(){ ngModel.$undoManager.push(val); }, 250);\n                                        _lastKey = event.keyCode;\n                                    }\n                                }\n                            });\n\n                            // when there is a change from a spelling correction in the browser, the only\n                            // change that is seen is a 'input' and the $watch('html') sees nothing... So\n                            // we added this element.on('input') to catch this change and call the _setViewValue()\n                            // so the ngModel is updated and all works as it should.\n                            var _inputTimeout;\n                            element.on('input', function() {\n                                if (_compileHtml() !== ngModel.$viewValue) {\n                                    // we wait a time now to allow the natural $watch('html') to handle this change\n                                    // and then after a 1 second delay, if there is still a difference we will do the\n                                    // _setViewValue() call.\n                                    /* istanbul ignore if: can't test */\n                                    if(_inputTimeout) $timeout.cancel(_inputTimeout);\n                                    /* istanbul ignore next: cant' test? */\n                                    _inputTimeout = $timeout(function() {\n                                        var _savedSelection = rangy.saveSelection();\n                                        var _val = _compileHtml();\n                                        if (_val !== ngModel.$viewValue) {\n                                            //console.log('_setViewValue');\n                                            //console.log('old:', ngModel.$viewValue);\n                                            //console.log('new:', _val);\n                                            _setViewValue(_val, true);\n                                        }\n                                        // if the savedSelection marker is gone at this point, we cannot restore the selection!!!\n                                        //console.log('rangy.restoreSelection', ngModel.$viewValue.length, _savedSelection);\n                                        if (ngModel.$viewValue.length !== 0) {\n                                            rangy.restoreSelection(_savedSelection);\n                                        }\n                                    }, 1000);\n                                }\n                            });\n\n                            element.on('blur', scope.events.blur = function(){\n                                _focussed = false;\n                                /* istanbul ignore else: if readonly don't update model */\n                                if(!_isReadonly){\n                                    _setViewValue(undefined, undefined, true);\n                                }else{\n                                    _skipRender = true; // don't redo the whole thing, just check the placeholder logic\n                                    ngModel.$render();\n                                }\n                            });\n\n                            // Placeholders not supported on ie 8 and below\n                            if(attrs.placeholder && (_browserDetect.ie > 8 || _browserDetect.ie === undefined)){\n                                var rule;\n                                if(attrs.id) rule = addCSSRule('#' + attrs.id + '.placeholder-text:before', 'content: \"' + attrs.placeholder + '\"');\n                                else throw('textAngular Error: An unique ID is required for placeholders to work');\n\n                                scope.$on('$destroy', function(){\n                                    removeCSSRule(rule);\n                                });\n                            }\n\n                            element.on('focus', scope.events.focus = function(){\n                                _focussed = true;\n                                element.removeClass('placeholder-text');\n                                _reApplyOnSelectorHandlers();\n                            });\n\n                            element.on('mouseup', scope.events.mouseup = function(){\n                                var _selection = taSelection.getSelection();\n                                if(_selection && _selection.start.element === element[0] && element.children().length) taSelection.setSelectionToElementStart(element.children()[0]);\n                            });\n\n                            // prevent propagation on mousedown in editor, see #206\n                            element.on('mousedown', scope.events.mousedown = function(event, eventData){\n                                /* istanbul ignore else: this is for catching the jqLite testing*/\n                                if(eventData) angular.extend(event, eventData);\n                                event.stopPropagation();\n                            });\n                        }\n                    }\n\n                    var fileDropHandler = function(event, eventData){\n                        /* istanbul ignore else: this is for catching the jqLite testing*/\n                        if(eventData) angular.extend(event, eventData);\n                        // emit the drop event, pass the element, preventing should be done elsewhere\n                        if(!dropFired && !_isReadonly){\n                            dropFired = true;\n                            var dataTransfer;\n                            if(event.originalEvent) dataTransfer = event.originalEvent.dataTransfer;\n                            else dataTransfer = event.dataTransfer;\n                            scope.$emit('ta-drop-event', this, event, dataTransfer);\n                            $timeout(function(){\n                                dropFired = false;\n                                _setViewValue(undefined, undefined, true);\n                            }, 100);\n                        }\n                    };\n\n                    var _renderTimeout;\n                    var _renderInProgress = false;\n                    // changes to the model variable from outside the html/text inputs\n                    ngModel.$render = function(){\n                        /* istanbul ignore if: Catches rogue renders, hard to replicate in tests */\n                        if(_renderInProgress) return;\n                        else _renderInProgress = true;\n                        // catch model being null or undefined\n                        var val = ngModel.$viewValue || '';\n                        // if the editor isn't focused it needs to be updated, otherwise it's receiving user input\n                        if(!_skipRender){\n                            /* istanbul ignore else: in other cases we don't care */\n                            if(_isContentEditable && _focussed){\n                                // update while focussed\n                                element.removeClass('placeholder-text');\n                                /* istanbul ignore next: don't know how to test this */\n                                if(_renderTimeout) $timeout.cancel(_renderTimeout);\n                                _renderTimeout = $timeout(function(){\n                                    /* istanbul ignore if: Can't be bothered testing this... */\n                                    if(!_focussed){\n                                        element[0].focus();\n                                        taSelection.setSelectionToElementEnd(element.children()[element.children().length - 1]);\n                                    }\n                                    _renderTimeout = undefined;\n                                }, 1);\n                            }\n                            if(_isContentEditable){\n                                // WYSIWYG Mode\n                                if(attrs.placeholder){\n                                    if(val === ''){\n                                        // blank\n                                        _setInnerHTML(_defaultVal);\n                                    }else{\n                                        // not-blank\n                                        _setInnerHTML(val);\n                                    }\n                                }else{\n                                    _setInnerHTML((val === '') ? _defaultVal : val);\n                                }\n                                // if in WYSIWYG and readOnly we kill the use of links by clicking\n                                if(!_isReadonly){\n                                    _reApplyOnSelectorHandlers();\n                                    element.on('drop', fileDropHandler);\n                                }else{\n                                    element.off('drop', fileDropHandler);\n                                }\n                            }else if(element[0].tagName.toLowerCase() !== 'textarea' && element[0].tagName.toLowerCase() !== 'input'){\n                                // make sure the end user can SEE the html code as a display. This is a read-only display element\n                                _setInnerHTML(taApplyCustomRenderers(val));\n                            }else{\n                                // only for input and textarea inputs\n                                element.val(val);\n                            }\n                        }\n                        if(_isContentEditable && attrs.placeholder){\n                            if(val === ''){\n                                if(_focussed) element.removeClass('placeholder-text');\n                                else element.addClass('placeholder-text');\n                            }else{\n                                element.removeClass('placeholder-text');\n                            }\n                        }\n                        _renderInProgress = _skipRender = false;\n                    };\n\n                    if(attrs.taReadonly){\n                        //set initial value\n                        _isReadonly = scope.$eval(attrs.taReadonly);\n                        if(_isReadonly){\n                            element.addClass('ta-readonly');\n                            // we changed to readOnly mode (taReadonly='true')\n                            if(element[0].tagName.toLowerCase() === 'textarea' || element[0].tagName.toLowerCase() === 'input'){\n                                element.attr('disabled', 'disabled');\n                            }\n                            if(element.attr('contenteditable') !== undefined && element.attr('contenteditable')){\n                                element.removeAttr('contenteditable');\n                            }\n                        }else{\n                            element.removeClass('ta-readonly');\n                            // we changed to NOT readOnly mode (taReadonly='false')\n                            if(element[0].tagName.toLowerCase() === 'textarea' || element[0].tagName.toLowerCase() === 'input'){\n                                element.removeAttr('disabled');\n                            }else if(_isContentEditable){\n                                element.attr('contenteditable', 'true');\n                            }\n                        }\n                        // taReadonly only has an effect if the taBind element is an input or textarea or has contenteditable='true' on it.\n                        // Otherwise it is readonly by default\n                        scope.$watch(attrs.taReadonly, function(newVal, oldVal){\n                            if(oldVal === newVal) return;\n                            if(newVal){\n                                element.addClass('ta-readonly');\n                                // we changed to readOnly mode (taReadonly='true')\n                                if(element[0].tagName.toLowerCase() === 'textarea' || element[0].tagName.toLowerCase() === 'input'){\n                                    element.attr('disabled', 'disabled');\n                                }\n                                if(element.attr('contenteditable') !== undefined && element.attr('contenteditable')){\n                                    element.removeAttr('contenteditable');\n                                }\n                                // turn ON selector click handlers\n                                angular.forEach(taSelectableElements, function(selector){\n                                    element.find(selector).on('click', selectorClickHandler);\n                                });\n                                element.off('drop', fileDropHandler);\n                            }else{\n                                element.removeClass('ta-readonly');\n                                // we changed to NOT readOnly mode (taReadonly='false')\n                                if(element[0].tagName.toLowerCase() === 'textarea' || element[0].tagName.toLowerCase() === 'input'){\n                                    element.removeAttr('disabled');\n                                }else if(_isContentEditable){\n                                    element.attr('contenteditable', 'true');\n                                }\n                                // remove the selector click handlers\n                                angular.forEach(taSelectableElements, function(selector){\n                                    element.find(selector).off('click', selectorClickHandler);\n                                });\n                                element.on('drop', fileDropHandler);\n                            }\n                            _isReadonly = newVal;\n                        });\n                    }\n\n                    // Initialise the selectableElements\n                    // if in WYSIWYG and readOnly we kill the use of links by clicking\n                    if(_isContentEditable && !_isReadonly){\n                        angular.forEach(taSelectableElements, function(selector){\n                            element.find(selector).on('click', selectorClickHandler);\n                        });\n                        element.on('drop', fileDropHandler);\n                    }\n                }\n            };\n        }]);\n\n// this global var is used to prevent multiple fires of the drop event. Needs to be global to the textAngular file.\nvar dropFired = false;\nvar textAngular = angular.module(\"textAngular\", ['ngSanitize', 'textAngularSetup', 'textAngular.factories', 'textAngular.DOM', 'textAngular.validators', 'textAngular.taBind']); //This makes ngSanitize required\n\ntextAngular.config([function(){\n    // clear taTools variable. Just catches testing and any other time that this config may run multiple times...\n    angular.forEach(taTools, function(value, key){ delete taTools[key];\t});\n}]);\n\ntextAngular.directive(\"textAngular\", [\n    '$compile', '$timeout', 'taOptions', 'taSelection', 'taExecCommand',\n    'textAngularManager', '$document', '$animate', '$log', '$q', '$parse',\n    function($compile, $timeout, taOptions, taSelection, taExecCommand,\n             textAngularManager, $document, $animate, $log, $q, $parse){\n        return {\n            require: '?ngModel',\n            scope: {},\n            restrict: \"EA\",\n            priority: 2, // So we override validators correctly\n            link: function(scope, element, attrs, ngModel){\n                // all these vars should not be accessable outside this directive\n                var _keydown, _keyup, _keypress, _mouseup, _focusin, _focusout,\n                    _originalContents, _editorFunctions,\n                    _serial = (attrs.serial) ? attrs.serial : Math.floor(Math.random() * 10000000000000000),\n                    _taExecCommand, _resizeMouseDown, _updateSelectedStylesTimeout;\n                var _resizeTimeout;\n\n                scope._name = (attrs.name) ? attrs.name : 'textAngularEditor' + _serial;\n\n                var oneEvent = function(_element, event, action){\n                    $timeout(function(){\n                        _element.one(event, action);\n                    }, 100);\n                };\n                _taExecCommand = taExecCommand(attrs.taDefaultWrap);\n                // get the settings from the defaults and add our specific functions that need to be on the scope\n                angular.extend(scope, angular.copy(taOptions), {\n                    // wraps the selection in the provided tag / execCommand function. Should only be called in WYSIWYG mode.\n                    wrapSelection: function(command, opt, isSelectableElementTool){\n                        // we restore the saved selection that was saved when focus was lost\n                        /* NOT FUNCTIONAL YET */\n                        /* textAngularManager.restoreFocusSelection(scope._name, scope); */\n                        if(command.toLowerCase() === \"undo\"){\n                            scope['$undoTaBindtaTextElement' + _serial]();\n                        }else if(command.toLowerCase() === \"redo\"){\n                            scope['$redoTaBindtaTextElement' + _serial]();\n                        }else{\n                            // catch errors like FF erroring when you try to force an undo with nothing done\n                            _taExecCommand(command, false, opt, scope.defaultTagAttributes);\n                            if(isSelectableElementTool){\n                                // re-apply the selectable tool events\n                                scope['reApplyOnSelectorHandlerstaTextElement' + _serial]();\n                            }\n                            // refocus on the shown display element, this fixes a display bug when using :focus styles to outline the box.\n                            // You still have focus on the text/html input it just doesn't show up\n                            scope.displayElements.text[0].focus();\n                        }\n                    },\n                    showHtml: scope.$eval(attrs.taShowHtml) || false\n                });\n                // setup the options from the optional attributes\n                if(attrs.taFocussedClass)\t\t\tscope.classes.focussed = attrs.taFocussedClass;\n                if(attrs.taTextEditorClass)\t\t\tscope.classes.textEditor = attrs.taTextEditorClass;\n                if(attrs.taHtmlEditorClass)\t\t\tscope.classes.htmlEditor = attrs.taHtmlEditorClass;\n                if(attrs.taDefaultTagAttributes){\n                    try\t{\n                        //\tTODO: This should use angular.merge to enhance functionality once angular 1.4 is required\n                        angular.extend(scope.defaultTagAttributes, angular.fromJson(attrs.taDefaultTagAttributes));\n                    } catch (error) {\n                        $log.error(error);\n                    }\n                }\n                // optional setup functions\n                if(attrs.taTextEditorSetup)\t\t\tscope.setup.textEditorSetup = scope.$parent.$eval(attrs.taTextEditorSetup);\n                if(attrs.taHtmlEditorSetup)\t\t\tscope.setup.htmlEditorSetup = scope.$parent.$eval(attrs.taHtmlEditorSetup);\n                // optional fileDropHandler function\n                if(attrs.taFileDrop)\t\t\t\tscope.fileDropHandler = scope.$parent.$eval(attrs.taFileDrop);\n                else\t\t\t\t\t\t\t\tscope.fileDropHandler = scope.defaultFileDropHandler;\n\n                _originalContents = element[0].innerHTML;\n                // clear the original content\n                element[0].innerHTML = '';\n\n                // Setup the HTML elements as variable references for use later\n                scope.displayElements = {\n                    // we still need the hidden input even with a textarea as the textarea may have invalid/old input in it,\n                    // wheras the input will ALLWAYS have the correct value.\n                    forminput: angular.element(\"<input type='hidden' tabindex='-1' style='display: none;'>\"),\n                    html: angular.element(\"<textarea></textarea>\"),\n                    text: angular.element(\"<div></div>\"),\n                    // other toolbased elements\n                    scrollWindow: angular.element(\"<div class='ta-scroll-window'></div>\"),\n                    popover: angular.element('<div class=\"popover fade bottom\" style=\"max-width: none; width: 305px;\"></div>'),\n                    popoverArrow: angular.element('<div class=\"arrow\"></div>'),\n                    popoverContainer: angular.element('<div class=\"popover-content\"></div>'),\n                    resize: {\n                        overlay: angular.element('<div class=\"ta-resizer-handle-overlay\"></div>'),\n                        background: angular.element('<div class=\"ta-resizer-handle-background\"></div>'),\n                        anchors: [\n                            angular.element('<div class=\"ta-resizer-handle-corner ta-resizer-handle-corner-tl\"></div>'),\n                            angular.element('<div class=\"ta-resizer-handle-corner ta-resizer-handle-corner-tr\"></div>'),\n                            angular.element('<div class=\"ta-resizer-handle-corner ta-resizer-handle-corner-bl\"></div>'),\n                            angular.element('<div class=\"ta-resizer-handle-corner ta-resizer-handle-corner-br\"></div>')\n                        ],\n                        info: angular.element('<div class=\"ta-resizer-handle-info\"></div>')\n                    }\n                };\n\n                // Setup the popover\n                scope.displayElements.popover.append(scope.displayElements.popoverArrow);\n                scope.displayElements.popover.append(scope.displayElements.popoverContainer);\n                scope.displayElements.scrollWindow.append(scope.displayElements.popover);\n\n                scope.displayElements.popover.on('mousedown', function(e, eventData){\n                    /* istanbul ignore else: this is for catching the jqLite testing*/\n                    if(eventData) angular.extend(e, eventData);\n                    // this prevents focusout from firing on the editor when clicking anything in the popover\n                    e.preventDefault();\n                    return false;\n                });\n\n                /* istanbul ignore next: popover resize and scroll events handled */\n                scope.handlePopoverEvents = function() {\n                    if (scope.displayElements.popover.css('display')==='block') {\n                        if(_resizeTimeout) $timeout.cancel(_resizeTimeout);\n                        _resizeTimeout = $timeout(function() {\n                            //console.log('resize', scope.displayElements.popover.css('display'));\n                            scope.reflowPopover(scope.resizeElement);\n                            scope.reflowResizeOverlay(scope.resizeElement);\n                        }, 100);\n                    }\n                };\n\n                /* istanbul ignore next: browser resize check */\n                angular.element(window).on('resize', scope.handlePopoverEvents);\n\n                /* istanbul ignore next: browser scroll check */\n                angular.element(window).on('scroll', scope.handlePopoverEvents);\n\n                // we want to know if a given node has a scrollbar!\n                // credit to lotif on http://stackoverflow.com/questions/4880381/check-whether-html-element-has-scrollbars\n                var isScrollable = function(node) {\n                    var cs;\n                    var _notScrollable = {\n                        vertical: false,\n                        horizontal: false,\n                    };\n                    try {\n                        cs = window.getComputedStyle(node);\n                        if (cs === null) {\n                            return _notScrollable;\n                        }\n                    } catch (e) {\n                        /* istanbul ignore next: error handler */\n                        return _notScrollable;\n                    }\n                    var overflowY = cs['overflow-y'];\n                    var overflowX = cs['overflow-x'];\n                    return {\n                        vertical: (overflowY === 'scroll' || overflowY === 'auto') &&\n                        /* istanbul ignore next: not tested */\n                        node.scrollHeight > node.clientHeight,\n                        horizontal: (overflowX === 'scroll' || overflowX === 'auto') &&\n                        /* istanbul ignore next: not tested */\n                        node.scrollWidth > node.clientWidth,\n                    };\n                };\n\n                // getScrollTop\n                //\n                // we structure this so that it can climb the parents of the _el and when it finds\n                // one with scrollbars, it adds an EventListener, so that no matter how the\n                // DOM is structured in the user APP, if there is a scrollbar not as part of the\n                // ta-scroll-window, we will still capture the 'scroll' events...\n                // and handle the scroll event properly and do the resize, etc.\n                //\n                scope.getScrollTop = function (_el, bAddListener) {\n                    var scrollTop = _el.scrollTop;\n                    if (typeof scrollTop === 'undefined') {\n                        scrollTop = 0;\n                    }\n                    /* istanbul ignore next: triggered only if has scrollbar */\n                    if (bAddListener && isScrollable(_el).vertical) {\n                        // remove element eventListener\n                        _el.removeEventListener('scroll', scope._scrollListener, false);\n                        _el.addEventListener('scroll', scope._scrollListener, false);\n                    }\n                    /* istanbul ignore next: triggered only if has scrollbar and scrolled */\n                    if (scrollTop !== 0) {\n                        return { node:_el.nodeName, top:scrollTop };\n                    }\n                    /* istanbul ignore else: catches only if no scroll */\n                    if (_el.parentNode) {\n                        return scope.getScrollTop(_el.parentNode, bAddListener);\n                    } else {\n                        return { node:'<none>', top:0 };\n                    }\n                };\n\n                // define the popover show and hide functions\n                scope.showPopover = function(_el){\n                    scope.getScrollTop(scope.displayElements.scrollWindow[0], true);\n                    scope.displayElements.popover.css('display', 'block');\n                    // we must use a $timeout here, or the css change to the\n                    // displayElements.resize.overlay will not take!!!\n                    // WHY???\n                    $timeout(function() {\n                        scope.displayElements.resize.overlay.css('display', 'block');\n                    });\n                    scope.resizeElement = _el;\n                    scope.reflowPopover(_el);\n                    $animate.addClass(scope.displayElements.popover, 'in');\n                    oneEvent($document.find('body'), 'click keyup', function(){scope.hidePopover();});\n                };\n\n                /* istanbul ignore next: browser scroll event handler */\n                scope._scrollListener = function (e, eventData){\n                    scope.handlePopoverEvents();\n                };\n\n                scope.reflowPopover = function(_el){\n                    var scrollTop = scope.getScrollTop(scope.displayElements.scrollWindow[0], false);\n                    var spaceAboveImage = _el[0].offsetTop-scrollTop.top;\n                    //var spaceBelowImage = scope.displayElements.text[0].offsetHeight - _el[0].offsetHeight - spaceAboveImage;\n                    //console.log(spaceAboveImage, spaceBelowImage);\n\n                    /* istanbul ignore if: catches only if near bottom of editor */\n                    if(spaceAboveImage < 51) {\n                        scope.displayElements.popover.css('top', _el[0].offsetTop + _el[0].offsetHeight + scope.displayElements.scrollWindow[0].scrollTop + 'px');\n                        scope.displayElements.popover.removeClass('top').addClass('bottom');\n                    } else {\n                        scope.displayElements.popover.css('top', _el[0].offsetTop - 54 + scope.displayElements.scrollWindow[0].scrollTop + 'px');\n                        scope.displayElements.popover.removeClass('bottom').addClass('top');\n                    }\n                    var _maxLeft = scope.displayElements.text[0].offsetWidth - scope.displayElements.popover[0].offsetWidth;\n                    var _targetLeft = _el[0].offsetLeft + (_el[0].offsetWidth / 2.0) - (scope.displayElements.popover[0].offsetWidth / 2.0);\n                    var _rleft = Math.max(0, Math.min(_maxLeft, _targetLeft));\n                    var _marginLeft = (Math.min(_targetLeft, (Math.max(0, _targetLeft - _maxLeft))) - 11);\n                    _rleft += window.scrollX;\n                    _marginLeft -= window.scrollX;\n                    scope.displayElements.popover.css('left', _rleft + 'px');\n                    scope.displayElements.popoverArrow.css('margin-left', _marginLeft + 'px');\n                };\n                scope.hidePopover = function(){\n                    scope.displayElements.popover.css('display', 'none');\n                    scope.displayElements.popoverContainer.attr('style', '');\n                    scope.displayElements.popoverContainer.attr('class', 'popover-content');\n                    scope.displayElements.popover.removeClass('in');\n                    scope.displayElements.resize.overlay.css('display', 'none');\n                };\n\n                // setup the resize overlay\n                scope.displayElements.resize.overlay.append(scope.displayElements.resize.background);\n                angular.forEach(scope.displayElements.resize.anchors, function(anchor){ scope.displayElements.resize.overlay.append(anchor);});\n                scope.displayElements.resize.overlay.append(scope.displayElements.resize.info);\n                scope.displayElements.scrollWindow.append(scope.displayElements.resize.overlay);\n\n                // A click event on the resize.background will now shift the focus to the editor\n                /* istanbul ignore next: click on the resize.background to focus back to editor */\n                scope.displayElements.resize.background.on('click', function(e) {\n                    scope.displayElements.text[0].focus();\n                });\n\n                // define the show and hide events\n                scope.reflowResizeOverlay = function(_el){\n                    _el = angular.element(_el)[0];\n                    scope.displayElements.resize.overlay.css({\n                        'display': 'block',\n                        'left': _el.offsetLeft - 5 + 'px',\n                        'top': _el.offsetTop - 5 + 'px',\n                        'width': _el.offsetWidth + 10 + 'px',\n                        'height': _el.offsetHeight + 10 + 'px'\n                    });\n                    scope.displayElements.resize.info.text(_el.offsetWidth + ' x ' + _el.offsetHeight);\n                };\n                /* istanbul ignore next: pretty sure phantomjs won't test this */\n                scope.showResizeOverlay = function(_el){\n                    var _body = $document.find('body');\n                    _resizeMouseDown = function(event){\n                        var startPosition = {\n                            width: parseInt(_el.attr('width')),\n                            height: parseInt(_el.attr('height')),\n                            x: event.clientX,\n                            y: event.clientY\n                        };\n                        if(startPosition.width === undefined || isNaN(startPosition.width)) startPosition.width = _el[0].offsetWidth;\n                        if(startPosition.height === undefined || isNaN(startPosition.height)) startPosition.height = _el[0].offsetHeight;\n                        scope.hidePopover();\n                        var ratio = startPosition.height / startPosition.width;\n                        var mousemove = function(event){\n                            // calculate new size\n                            var pos = {\n                                x: Math.max(0, startPosition.width + (event.clientX - startPosition.x)),\n                                y: Math.max(0, startPosition.height + (event.clientY - startPosition.y))\n                            };\n\n                            // DEFAULT: the aspect ratio is not locked unless the Shift key is pressed.\n                            //\n                            // attribute: ta-resize-force-aspect-ratio -- locks resize into maintaing the aspect ratio\n                            var bForceAspectRatio = (attrs.taResizeForceAspectRatio !== undefined);\n                            // attribute: ta-resize-maintain-aspect-ratio=true causes the space ratio to remain locked\n                            // unless the Shift key is pressed\n                            var bFlipKeyBinding = attrs.taResizeMaintainAspectRatio;\n                            var bKeepRatio =  bForceAspectRatio || (bFlipKeyBinding && !event.shiftKey);\n                            if(bKeepRatio) {\n                                var newRatio = pos.y / pos.x;\n                                pos.x = ratio > newRatio ? pos.x : pos.y / ratio;\n                                pos.y = ratio > newRatio ? pos.x * ratio : pos.y;\n                            }\n                            var el = angular.element(_el);\n                            function roundedMaxVal(val) {\n                                return Math.round(Math.max(0, val));\n                            }\n                            el.css('height', roundedMaxVal(pos.y) + 'px');\n                            el.css('width', roundedMaxVal(pos.x) + 'px');\n\n                            // reflow the popover tooltip\n                            scope.reflowResizeOverlay(_el);\n                        };\n                        _body.on('mousemove', mousemove);\n                        oneEvent(_body, 'mouseup', function(event){\n                            event.preventDefault();\n                            event.stopPropagation();\n                            _body.off('mousemove', mousemove);\n                            // at this point, we need to force the model to update! since the css has changed!\n                            // this fixes bug: #862 - we now hide the popover -- as this seems more consitent.\n                            // there are still issues under firefox, the window does not repaint. -- not sure\n                            // how best to resolve this, but clicking anywhere works.\n                            scope.$apply(function (){\n                                scope.hidePopover();\n                                scope.updateTaBindtaTextElement();\n                            }, 100);\n                        });\n                        event.stopPropagation();\n                        event.preventDefault();\n                    };\n\n                    scope.displayElements.resize.anchors[3].off('mousedown');\n                    scope.displayElements.resize.anchors[3].on('mousedown', _resizeMouseDown);\n\n                    scope.reflowResizeOverlay(_el);\n                    oneEvent(_body, 'click', function(){scope.hideResizeOverlay();});\n                };\n                /* istanbul ignore next: pretty sure phantomjs won't test this */\n                scope.hideResizeOverlay = function(){\n                    scope.displayElements.resize.anchors[3].off('mousedown', _resizeMouseDown);\n                    scope.displayElements.resize.overlay.css('display', 'none');\n                };\n\n                // allow for insertion of custom directives on the textarea and div\n                scope.setup.htmlEditorSetup(scope.displayElements.html);\n                scope.setup.textEditorSetup(scope.displayElements.text);\n                scope.displayElements.html.attr({\n                    'id': 'taHtmlElement' + _serial,\n                    'ng-show': 'showHtml',\n                    'ta-bind': 'ta-bind',\n                    'ng-model': 'html',\n                    'ng-model-options': element.attr('ng-model-options')\n                });\n                scope.displayElements.text.attr({\n                    'id': 'taTextElement' + _serial,\n                    'contentEditable': 'true',\n                    'ta-bind': 'ta-bind',\n                    'ng-model': 'html',\n                    'ng-model-options': element.attr('ng-model-options')\n                });\n                scope.displayElements.scrollWindow.attr({'ng-hide': 'showHtml'});\n                if(attrs.taDefaultWrap) {\n                    // taDefaultWrap is only applied to the text and not the html view\n                    scope.displayElements.text.attr('ta-default-wrap', attrs.taDefaultWrap);\n                }\n\n                if(attrs.taUnsafeSanitizer){\n                    scope.displayElements.text.attr('ta-unsafe-sanitizer', attrs.taUnsafeSanitizer);\n                    scope.displayElements.html.attr('ta-unsafe-sanitizer', attrs.taUnsafeSanitizer);\n                }\n\n                if(attrs.taKeepStyles){\n                    scope.displayElements.text.attr('ta-keep-styles', attrs.taKeepStyles);\n                    scope.displayElements.html.attr('ta-keep-styles', attrs.taKeepStyles);\n                }\n\n                // add the main elements to the origional element\n                scope.displayElements.scrollWindow.append(scope.displayElements.text);\n                element.append(scope.displayElements.scrollWindow);\n                element.append(scope.displayElements.html);\n\n                scope.displayElements.forminput.attr('name', scope._name);\n                element.append(scope.displayElements.forminput);\n\n                if(attrs.tabindex){\n                    element.removeAttr('tabindex');\n                    scope.displayElements.text.attr('tabindex', attrs.tabindex);\n                    scope.displayElements.html.attr('tabindex', attrs.tabindex);\n                }\n\n                if (attrs.placeholder) {\n                    scope.displayElements.text.attr('placeholder', attrs.placeholder);\n                    scope.displayElements.html.attr('placeholder', attrs.placeholder);\n                }\n\n                if(attrs.taDisabled){\n                    scope.displayElements.text.attr('ta-readonly', 'disabled');\n                    scope.displayElements.html.attr('ta-readonly', 'disabled');\n                    scope.disabled = scope.$parent.$eval(attrs.taDisabled);\n                    scope.$parent.$watch(attrs.taDisabled, function(newVal){\n                        scope.disabled = newVal;\n                        if(scope.disabled){\n                            element.addClass(scope.classes.disabled);\n                        }else{\n                            element.removeClass(scope.classes.disabled);\n                        }\n                    });\n                }\n\n                if(attrs.taPaste){\n                    scope._pasteHandler = function(_html){\n                        return $parse(attrs.taPaste)(scope.$parent, {$html: _html});\n                    };\n                    scope.displayElements.text.attr('ta-paste', '_pasteHandler($html)');\n                }\n\n                // compile the scope with the text and html elements only - if we do this with the main element it causes a compile loop\n                $compile(scope.displayElements.scrollWindow)(scope);\n                $compile(scope.displayElements.html)(scope);\n\n                scope.updateTaBindtaTextElement = scope['updateTaBindtaTextElement' + _serial];\n                scope.updateTaBindtaHtmlElement = scope['updateTaBindtaHtmlElement' + _serial];\n\n                // add the classes manually last\n                element.addClass(\"ta-root\");\n                scope.displayElements.scrollWindow.addClass(\"ta-text ta-editor \" + scope.classes.textEditor);\n                scope.displayElements.html.addClass(\"ta-html ta-editor \" + scope.classes.htmlEditor);\n\n                var testAndSet = function(choice, beforeState) {\n                    /* istanbul ignore next: this is only here because of a bug in rangy where rangy.saveSelection() has cleared the state */\n                    if (beforeState !== $document[0].queryCommandState(choice)) {\n                        $document[0].execCommand(choice, false, null);\n                    }\n                };\n                // used in the toolbar actions\n                scope._actionRunning = false;\n                var _savedSelection = false;\n                scope.startAction = function(){\n                    var _beforeStateBold = false;\n                    var _beforeStateItalic = false;\n                    var _beforeStateUnderline = false;\n                    var _beforeStateStrikethough = false;\n                    scope._actionRunning = true;\n                    _beforeStateBold = $document[0].queryCommandState('bold');\n                    _beforeStateItalic = $document[0].queryCommandState('italic');\n                    _beforeStateUnderline = $document[0].queryCommandState('underline');\n                    _beforeStateStrikethough = $document[0].queryCommandState('strikeThrough');\n                    //console.log('B', _beforeStateBold, 'I', _beforeStateItalic, '_', _beforeStateUnderline, 'S', _beforeStateStrikethough);\n                    // if rangy library is loaded return a function to reload the current selection\n                    _savedSelection = rangy.saveSelection();\n                    // rangy.saveSelection() clear the state of bold, italic, underline, strikethrough\n                    // so we reset them here....!!!\n                    // this fixes bugs #423, #1129, #1105, #693 which are actually rangy bugs!\n                    testAndSet('bold', _beforeStateBold);\n                    testAndSet('italic', _beforeStateItalic);\n                    testAndSet('underline', _beforeStateUnderline);\n                    testAndSet('strikeThrough', _beforeStateStrikethough);\n                    //console.log('B', $document[0].queryCommandState('bold'), 'I', $document[0].queryCommandState('italic'), '_', $document[0].queryCommandState('underline'), 'S', $document[0].queryCommandState('strikeThrough') );\n                    return function(){\n                        if(_savedSelection) rangy.restoreSelection(_savedSelection);\n                        // perhaps if we restore the selections here, we would do better overall???\n                        // BUT what we do above does well in 90% of the cases...\n                    };\n                };\n                scope.endAction = function(){\n                    scope._actionRunning = false;\n                    if(_savedSelection){\n                        if(scope.showHtml){\n                            scope.displayElements.html[0].focus();\n                        }else{\n                            scope.displayElements.text[0].focus();\n                        }\n                        // rangy.restoreSelection(_savedSelection);\n                        rangy.removeMarkers(_savedSelection);\n                    }\n                    _savedSelection = false;\n                    scope.updateSelectedStyles();\n                    // only update if in text or WYSIWYG mode\n                    if(!scope.showHtml) scope['updateTaBindtaTextElement' + _serial]();\n                };\n\n                // note that focusout > focusin is called everytime we click a button - except bad support: http://www.quirksmode.org/dom/events/blurfocus.html\n                // cascades to displayElements.text and displayElements.html automatically.\n                _focusin = function(e){\n                    scope.focussed = true;\n                    element.addClass(scope.classes.focussed);\n                    /*******  NOT FUNCTIONAL YET\n                     if (e.target.id === 'taTextElement' + _serial) {\n                        console.log('_focusin taTextElement');\n                        // we only do this if NOT focussed\n                        textAngularManager.restoreFocusSelection(scope._name);\n                    }\n                     *******/\n                    _editorFunctions.focus();\n                    element.triggerHandler('focus');\n                    // we call editorScope.updateSelectedStyles() here because we want the toolbar to be focussed\n                    // as soon as we have focus.  Otherwise this only happens on mousedown or keydown etc...\n                    /* istanbul ignore else: don't run if already running */\n                    if(scope.updateSelectedStyles && !scope._bUpdateSelectedStyles){\n                        // we don't set editorScope._bUpdateSelectedStyles here, because we do not want the\n                        // updateSelectedStyles() to run twice which it will do after 200 msec if we have\n                        // set editorScope._bUpdateSelectedStyles\n                        //\n                        // WOW, normally I would do a scope.$apply here, but this causes ERRORs when doing tests!\n                        $timeout(function () {\n                            scope.updateSelectedStyles();\n                        }, 0);\n                    }\n                };\n                scope.displayElements.html.on('focus', _focusin);\n                scope.displayElements.text.on('focus', _focusin);\n                _focusout = function(e){\n                    /****************** NOT FUNCTIONAL YET\n                     try {\n                        var _s = rangy.getSelection();\n                        if (_s) {\n                            // we save the selection when we loose focus so that if do a wrapSelection, the\n                            // apropriate selection in the editor is restored before action.\n                            var _savedFocusRange = rangy.saveRange(_s.getRangeAt(0));\n                            textAngularManager.saveFocusSelection(scope._name, _savedFocusRange);\n                        }\n                    } catch(error) { }\n                     *****************/\n                    // if we are NOT runnig an action and have NOT focussed again on the text etc then fire the blur events\n                    if(!scope._actionRunning &&\n                        $document[0].activeElement !== scope.displayElements.html[0] &&\n                        $document[0].activeElement !== scope.displayElements.text[0])\n                    {\n                        element.removeClass(scope.classes.focussed);\n                        _editorFunctions.unfocus();\n                        // to prevent multiple apply error defer to next seems to work.\n                        $timeout(function(){\n                            scope._bUpdateSelectedStyles = false;\n                            element.triggerHandler('blur');\n                            scope.focussed = false;\n                        }, 0);\n                    }\n                    e.preventDefault();\n                    return false;\n                };\n                scope.displayElements.html.on('blur', _focusout);\n                scope.displayElements.text.on('blur', _focusout);\n\n                scope.displayElements.text.on('paste', function(event){\n                    element.triggerHandler('paste', event);\n                });\n\n                // Setup the default toolbar tools, this way allows the user to add new tools like plugins.\n                // This is on the editor for future proofing if we find a better way to do this.\n                scope.queryFormatBlockState = function(command){\n                    // $document[0].queryCommandValue('formatBlock') errors in Firefox if we call this when focussed on the textarea\n                    return !scope.showHtml && command.toLowerCase() === $document[0].queryCommandValue('formatBlock').toLowerCase();\n                };\n                scope.queryCommandState = function(command){\n                    // $document[0].queryCommandValue('formatBlock') errors in Firefox if we call this when focussed on the textarea\n                    return (!scope.showHtml) ? $document[0].queryCommandState(command) : '';\n                };\n                scope.switchView = function(){\n                    scope.showHtml = !scope.showHtml;\n                    $animate.enabled(false, scope.displayElements.html);\n                    $animate.enabled(false, scope.displayElements.text);\n                    //Show the HTML view\n                    /* istanbul ignore next: ngModel exists check */\n                    /* THIS is not the correct thing to do, here....\n                     The ngModel is correct, but it is not formatted as the user as done it...\n                     var _model;\n                     if (ngModel) {\n                     _model = ngModel.$viewValue;\n                     } else {\n                     _model = scope.html;\n                     }\n                     var _html = scope.displayElements.html[0].value;\n                     if (getDomFromHtml(_html).childElementCount !== getDomFromHtml(_model).childElementCount) {\n                     // the model and the html do not agree\n                     // they can get out of sync and when they do, we correct that here...\n                     scope.displayElements.html.val(_model);\n                     }\n                     */\n                    if(scope.showHtml){\n                        //defer until the element is visible\n                        $timeout(function(){\n                            $animate.enabled(true, scope.displayElements.html);\n                            $animate.enabled(true, scope.displayElements.text);\n                            // [0] dereferences the DOM object from the angular.element\n                            return scope.displayElements.html[0].focus();\n                        }, 100);\n                    }else{\n                        //Show the WYSIWYG view\n                        //defer until the element is visible\n                        $timeout(function(){\n                            $animate.enabled(true, scope.displayElements.html);\n                            $animate.enabled(true, scope.displayElements.text);\n                            // [0] dereferences the DOM object from the angular.element\n                            return scope.displayElements.text[0].focus();\n                        }, 100);\n                    }\n                };\n\n                // changes to the model variable from outside the html/text inputs\n                // if no ngModel, then the only input is from inside text-angular\n                if(attrs.ngModel){\n                    var _firstRun = true;\n                    ngModel.$render = function(){\n                        if(_firstRun){\n                            // we need this firstRun to set the originalContents otherwise it gets overrided by the setting of ngModel to undefined from NaN\n                            _firstRun = false;\n                            // if view value is null or undefined initially and there was original content, set to the original content\n                            var _initialValue = scope.$parent.$eval(attrs.ngModel);\n                            if((_initialValue === undefined || _initialValue === null) && (_originalContents && _originalContents !== '')){\n                                // on passing through to taBind it will be sanitised\n                                ngModel.$setViewValue(_originalContents);\n                            }\n                        }\n                        scope.displayElements.forminput.val(ngModel.$viewValue);\n                        // if the editors aren't focused they need to be updated, otherwise they are doing the updating\n                        scope.html = ngModel.$viewValue || '';\n                    };\n                    // trigger the validation calls\n                    if(element.attr('required')) ngModel.$validators.required = function(modelValue, viewValue) {\n                        var value = modelValue || viewValue;\n                        return !(!value || value.trim() === '');\n                    };\n                }else{\n                    // if no ngModel then update from the contents of the origional html.\n                    scope.displayElements.forminput.val(_originalContents);\n                    scope.html = _originalContents;\n                }\n\n                // changes from taBind back up to here\n                scope.$watch('html', function(newValue, oldValue){\n                    if(newValue !== oldValue){\n                        if(attrs.ngModel && ngModel.$viewValue !== newValue) {\n                            ngModel.$setViewValue(newValue);\n                        }\n                        scope.displayElements.forminput.val(newValue);\n                    }\n                });\n\n                if(attrs.taTargetToolbars) {\n                    _editorFunctions = textAngularManager.registerEditor(scope._name, scope, attrs.taTargetToolbars.split(','));\n                }\n                else{\n                    var _toolbar = angular.element('<div text-angular-toolbar name=\"textAngularToolbar' + _serial + '\">');\n                    // passthrough init of toolbar options\n                    if(attrs.taToolbar)\t\t\t\t\t\t_toolbar.attr('ta-toolbar', attrs.taToolbar);\n                    if(attrs.taToolbarClass)\t\t\t\t_toolbar.attr('ta-toolbar-class', attrs.taToolbarClass);\n                    if(attrs.taToolbarGroupClass)\t\t\t_toolbar.attr('ta-toolbar-group-class', attrs.taToolbarGroupClass);\n                    if(attrs.taToolbarButtonClass)\t\t\t_toolbar.attr('ta-toolbar-button-class', attrs.taToolbarButtonClass);\n                    if(attrs.taToolbarActiveButtonClass)\t_toolbar.attr('ta-toolbar-active-button-class', attrs.taToolbarActiveButtonClass);\n                    if(attrs.taFocussedClass)\t\t\t\t_toolbar.attr('ta-focussed-class', attrs.taFocussedClass);\n\n                    element.prepend(_toolbar);\n                    $compile(_toolbar)(scope.$parent);\n                    _editorFunctions = textAngularManager.registerEditor(scope._name, scope, ['textAngularToolbar' + _serial]);\n                }\n\n                scope.$on('$destroy', function(){\n                    textAngularManager.unregisterEditor(scope._name);\n                    angular.element(window).off('blur');\n                    angular.element(window).off('resize', scope.handlePopoverEvents);\n                    angular.element(window).off('scroll', scope.handlePopoverEvents);\n                });\n\n                // catch element select event and pass to toolbar tools\n                scope.$on('ta-element-select', function(event, element){\n                    if(_editorFunctions.triggerElementSelect(event, element)){\n                        scope['reApplyOnSelectorHandlerstaTextElement' + _serial]();\n                    }\n                });\n\n                /******************* no working fully\n                 var distanceFromPoint = function (px, py, x, y) {\n                    return Math.sqrt((px-x)*(px-x)+(py-y)*(py-y));\n                };\n                 // because each object is a rectangle and we have a single point,\n                 // we need to give priority if the point is inside the rectangle\n                 var getPositionDistance = function(el, x, y) {\n                    var range = document.createRange();\n                    range.selectNode(el);\n                    var rect = range.getBoundingClientRect();\n                    console.log(el, rect);\n                    range.detach();\n                    var bcr = rect;\n                    // top left\n                    var d1 = distanceFromPoint(bcr.left, bcr.top, x, y);\n                    // bottom left\n                    var d2 = distanceFromPoint(bcr.left, bcr.bottom, x, y);\n                    // top right\n                    var d3 = distanceFromPoint(bcr.right, bcr.top, x, y);\n                    // bottom right\n                    var d4 = distanceFromPoint(bcr.right, bcr.bottom, x, y);\n                    return Math.min(d1, d2, d3, d4);\n                };\n                 var findClosest = function(el, minElement, maxDistance, x, y) {\n                    var _d=0;\n                    for (var i = 0; i < el.childNodes.length; i++) {\n                        var _n = el.childNodes[i];\n                        if (!_n.childNodes.length) {\n                            _d = getPositionDistance(_n, x, y);\n                            //console.log(_n, _n.childNodes, _d);\n                            if (_d < maxDistance) {\n                                maxDistance = _d;\n                                minElement = _n;\n                            }\n                        }\n                        var res = findClosest(_n, minElement, maxDistance, x, y);\n                        if (res.max < maxDistance) {\n                            maxDistance = res.max;\n                            minElement = res.min;\n                        }\n                    }\n                    return { max: maxDistance, min: minElement };\n                };\n                 var getClosestElement = function (el, x, y) {\n                    return findClosest(el, null, 12341234124, x, y);\n                };\n                 ****************/\n\n                scope.$on('ta-drop-event', function(event, element, dropEvent, dataTransfer){\n                    if(dataTransfer && dataTransfer.files && dataTransfer.files.length > 0){\n                        scope.displayElements.text[0].focus();\n                        // we must set the location of the drop!\n                        //console.log(dropEvent.clientX, dropEvent.clientY, dropEvent.target);\n                        taSelection.setSelectionToElementEnd(dropEvent.target);\n                        angular.forEach(dataTransfer.files, function(file){\n                            // taking advantage of boolean execution, if the fileDropHandler returns true, nothing else after it is executed\n                            // If it is false then execute the defaultFileDropHandler if the fileDropHandler is NOT the default one\n                            // Once one of these has been executed wrap the result as a promise, if undefined or variable update the taBind, else we should wait for the promise\n                            try{\n                                $q.when(scope.fileDropHandler(file, scope.wrapSelection) ||\n                                    (scope.fileDropHandler !== scope.defaultFileDropHandler &&\n                                    $q.when(scope.defaultFileDropHandler(file, scope.wrapSelection)))).then(function(){\n                                    scope['updateTaBindtaTextElement' + _serial]();\n                                });\n                            }catch(error){\n                                $log.error(error);\n                            }\n                        });\n                        dropEvent.preventDefault();\n                        dropEvent.stopPropagation();\n                        /* istanbul ignore else, the updates if moved text */\n                    }else{\n                        $timeout(function(){\n                            scope['updateTaBindtaTextElement' + _serial]();\n                        }, 0);\n                    }\n                });\n\n                // the following is for applying the active states to the tools that support it\n                scope._bUpdateSelectedStyles = false;\n                /* istanbul ignore next: browser window/tab leave check */\n                angular.element(window).on('blur', function(){\n                    scope._bUpdateSelectedStyles = false;\n                    scope.focussed = false;\n                });\n                // loop through all the tools polling their activeState function if it exists\n                scope.updateSelectedStyles = function(){\n                    var _selection;\n                    /* istanbul ignore next: This check is to ensure multiple timeouts don't exist */\n                    if(_updateSelectedStylesTimeout) $timeout.cancel(_updateSelectedStylesTimeout);\n                    // test if the common element ISN'T the root ta-text node\n                    if((_selection = taSelection.getSelectionElement()) !== undefined && _selection.parentNode !== scope.displayElements.text[0]){\n                        _editorFunctions.updateSelectedStyles(angular.element(_selection));\n                    }else _editorFunctions.updateSelectedStyles();\n                    // used to update the active state when a key is held down, ie the left arrow\n                    /* istanbul ignore else: browser only check */\n                    if(scope._bUpdateSelectedStyles) _updateSelectedStylesTimeout = $timeout(scope.updateSelectedStyles, 200);\n                };\n                // start updating on keydown\n                _keydown = function(){\n                    /* istanbul ignore next: ie catch */\n                    if(!scope.focussed){\n                        scope._bUpdateSelectedStyles = false;\n                        return;\n                    }\n                    /* istanbul ignore else: don't run if already running */\n                    if(!scope._bUpdateSelectedStyles){\n                        scope._bUpdateSelectedStyles = true;\n                        scope.$apply(function(){\n                            scope.updateSelectedStyles();\n                        });\n                    }\n                };\n                scope.displayElements.html.on('keydown', _keydown);\n                scope.displayElements.text.on('keydown', _keydown);\n                // stop updating on key up and update the display/model\n                _keyup = function(){\n                    scope._bUpdateSelectedStyles = false;\n                };\n                scope.displayElements.html.on('keyup', _keyup);\n                scope.displayElements.text.on('keyup', _keyup);\n                // stop updating on key up and update the display/model\n                _keypress = function(event, eventData){\n                    // bug fix for Firefox.  If we are selecting a <a> already, any characters will\n                    // be added within the <a> which is bad!\n                    /* istanbul ignore next: don't see how to test this... */\n                    if (taSelection.getSelection) {\n                        var _selection = taSelection.getSelection();\n                        // in a weird case (can't reproduce) taSelection.getSelectionElement() can be undefined!!\n                        // this comes from range.commonAncestorContainer;\n                        // so I check for this here which fixes the error case\n                        if (taSelection.getSelectionElement() && taSelection.getSelectionElement().nodeName.toLowerCase() === 'a') {\n                            // check and see if we are at the edge of the <a>\n                            if (_selection.start.element.nodeType === 3 &&\n                                _selection.start.element.textContent.length === _selection.end.offset) {\n                                // we are at the end of the <a>!!!\n                                // so move the selection to after the <a>!!\n                                taSelection.setSelectionAfterElement(taSelection.getSelectionElement());\n                            }\n                            if (_selection.start.element.nodeType === 3 &&\n                                _selection.start.offset === 0) {\n                                // we are at the start of the <a>!!!\n                                // so move the selection before the <a>!!\n                                taSelection.setSelectionBeforeElement(taSelection.getSelectionElement());\n                            }\n                        }\n                    }\n                    /* istanbul ignore else: this is for catching the jqLite testing*/\n                    if(eventData) angular.extend(event, eventData);\n                    scope.$apply(function(){\n                        if(_editorFunctions.sendKeyCommand(event)){\n                            /* istanbul ignore else: don't run if already running */\n                            if(!scope._bUpdateSelectedStyles){\n                                scope.updateSelectedStyles();\n                            }\n                            event.preventDefault();\n                            return false;\n                        }\n                    });\n                };\n                scope.displayElements.html.on('keypress', _keypress);\n                scope.displayElements.text.on('keypress', _keypress);\n                // update the toolbar active states when we click somewhere in the text/html boxed\n                _mouseup = function(){\n                    // ensure only one execution of updateSelectedStyles()\n                    scope._bUpdateSelectedStyles = false;\n                    // for some reason, unless we do a $timeout here, after a _mouseup when the line is\n                    // highlighted, and instead use a scope.$apply(function(){ scope.updateSelectedStyles(); });\n                    // doesn't work properly, so we replaced this with:\n                    /* istanbul ignore next: not tested  */\n                    $timeout(function() { scope.updateSelectedStyles(); }, 0);\n                };\n                scope.displayElements.html.on('mouseup', _mouseup);\n                scope.displayElements.text.on('mouseup', _mouseup);\n            }\n        };\n    }\n]);\ntextAngular.service('textAngularManager', ['taToolExecuteAction', 'taTools', 'taRegisterTool', '$interval', '$rootScope', '$log',\n    function(taToolExecuteAction, taTools, taRegisterTool, $interval, $rootScope, $log){\n        // this service is used to manage all textAngular editors and toolbars.\n        // All publicly published functions that modify/need to access the toolbar or editor scopes should be in here\n        // these contain references to all the editors and toolbars that have been initialised in this app\n        var toolbars = {}, editors = {};\n        // we touch the time any change occurs through register of an editor or tool so that we\n        // in the future will fire and event to trigger an updateSelection\n        var timeRecentModification = 0;\n        var updateStyles = function(selectedElement){\n            angular.forEach(editors, function(editor) {\n                editor.editorFunctions.updateSelectedStyles(selectedElement);\n            });\n        };\n        var triggerInterval = 50;\n        var triggerIntervalTimer;\n        var setupTriggerUpdateStyles = function() {\n            timeRecentModification = Date.now();\n            /* istanbul ignore next: setup a one time updateStyles() */\n            triggerIntervalTimer = $interval(function() {\n                updateStyles();\n                triggerIntervalTimer = undefined;\n            }, triggerInterval, 1); // only trigger once\n        };\n        /* istanbul ignore next: make sure clean up on destroy */\n        $rootScope.$on('destroy', function() {\n            if (triggerIntervalTimer) {\n                $interval.cancel(triggerIntervalTimer);\n                triggerIntervalTimer = undefined;\n            }\n        });\n        var touchModification = function() {\n            if (Math.abs(Date.now() - timeRecentModification) > triggerInterval) {\n                // we have already triggered the updateStyles a long time back... so setup it again...\n                setupTriggerUpdateStyles();\n            }\n        };\n        // when we focus into a toolbar, we need to set the TOOLBAR's $parent to be the toolbars it's linked to.\n        // We also need to set the tools to be updated to be the toolbars...\n        return {\n            // register an editor and the toolbars that it is affected by\n            registerEditor: function(editorName, editorScope, targetToolbars){\n                // NOTE: name === editorScope._name\n                // targetToolbars is an [] of 'toolbar name's\n                // targetToolbars are optional, we don't require a toolbar to function\n                if(!editorName || editorName === '') throw('textAngular Error: An editor requires a name');\n                if(!editorScope) throw('textAngular Error: An editor requires a scope');\n                if(editors[editorName]) throw('textAngular Error: An Editor with name \"' + editorName + '\" already exists');\n                editors[editorName] = {\n                    scope: editorScope,\n                    toolbars: targetToolbars,\n                    // toolbarScopes used by this editor\n                    toolbarScopes: [],\n                    _registerToolbarScope: function(toolbarScope){\n                        // add to the list late\n                        if(this.toolbars.indexOf(toolbarScope.name) >= 0) {\n                            // if this toolbarScope is being used by this editor we add it as one of the scopes\n                            this.toolbarScopes.push(toolbarScope);\n                        }\n                    },\n                    // this is a suite of functions the editor should use to update all it's linked toolbars\n                    editorFunctions: {\n                        disable: function(){\n                            // disable all linked toolbars\n                            angular.forEach(editors[editorName].toolbarScopes, function(toolbarScope){\n                                toolbarScope.disabled = true;\n                            });\n                        },\n                        enable: function(){\n                            // enable all linked toolbars\n                            angular.forEach(editors[editorName].toolbarScopes, function(toolbarScope){\n                                toolbarScope.disabled = false;\n                            });\n                        },\n                        focus: function(){\n                            // this should be called when the editor is focussed\n                            angular.forEach(editors[editorName].toolbarScopes, function(toolbarScope){\n                                toolbarScope._parent = editorScope;\n                                toolbarScope.disabled = false;\n                                toolbarScope.focussed = true;\n                            });\n                            editorScope.focussed = true;\n                        },\n                        unfocus: function(){\n                            // this should be called when the editor becomes unfocussed\n                            angular.forEach(editors[editorName].toolbarScopes, function(toolbarScope){\n                                toolbarScope.disabled = true;\n                                toolbarScope.focussed = false;\n                            });\n                            editorScope.focussed = false;\n                        },\n                        updateSelectedStyles: function(selectedElement){\n                            // update the active state of all buttons on liked toolbars\n                            angular.forEach(editors[editorName].toolbarScopes, function(toolbarScope){\n                                angular.forEach(toolbarScope.tools, function(toolScope){\n                                    if(toolScope.activeState){\n                                        toolbarScope._parent = editorScope;\n                                        // selectedElement may be undefined if nothing selected\n                                        toolScope.active = toolScope.activeState(selectedElement);\n                                    }\n                                });\n                            });\n                        },\n                        sendKeyCommand: function(event){\n                            // we return true if we applied an action, false otherwise\n                            var result = false;\n                            if(event.ctrlKey || event.metaKey || event.specialKey) angular.forEach(taTools, function(tool, name){\n                                if(tool.commandKeyCode && (tool.commandKeyCode === event.which || tool.commandKeyCode === event.specialKey)){\n                                    for(var _t = 0; _t < editors[editorName].toolbarScopes.length; _t++){\n                                        if(editors[editorName].toolbarScopes[_t].tools[name] !== undefined){\n                                            taToolExecuteAction.call(editors[editorName].toolbarScopes[_t].tools[name], editorScope);\n                                            result = true;\n                                            break;\n                                        }\n                                    }\n                                }\n                            });\n                            return result;\n                        },\n                        triggerElementSelect: function(event, element){\n                            // search through the taTools to see if a match for the tag is made.\n                            // if there is, see if the tool is on a registered toolbar and not disabled.\n                            // NOTE: This can trigger on MULTIPLE tools simultaneously.\n                            var elementHasAttrs = function(_element, attrs){\n                                var result = true;\n                                for(var i = 0; i < attrs.length; i++) result = result && _element.attr(attrs[i]);\n                                return result;\n                            };\n                            var workerTools = [];\n                            var unfilteredTools = {};\n                            var result = false;\n                            element = angular.element(element);\n                            // get all valid tools by element name, keep track if one matches the\n                            var onlyWithAttrsFilter = false;\n                            angular.forEach(taTools, function(tool, name){\n                                if(\n                                    tool.onElementSelect &&\n                                    tool.onElementSelect.element &&\n                                    tool.onElementSelect.element.toLowerCase() === element[0].tagName.toLowerCase() &&\n                                    (!tool.onElementSelect.filter || tool.onElementSelect.filter(element))\n                                ){\n                                    // this should only end up true if the element matches the only attributes\n                                    onlyWithAttrsFilter = onlyWithAttrsFilter ||\n                                        (angular.isArray(tool.onElementSelect.onlyWithAttrs) && elementHasAttrs(element, tool.onElementSelect.onlyWithAttrs));\n                                    if(!tool.onElementSelect.onlyWithAttrs || elementHasAttrs(element, tool.onElementSelect.onlyWithAttrs)) unfilteredTools[name] = tool;\n                                }\n                            });\n                            // if we matched attributes to filter on, then filter, else continue\n                            if(onlyWithAttrsFilter){\n                                angular.forEach(unfilteredTools, function(tool, name){\n                                    if(tool.onElementSelect.onlyWithAttrs && elementHasAttrs(element, tool.onElementSelect.onlyWithAttrs)) workerTools.push({'name': name, 'tool': tool});\n                                });\n                                // sort most specific (most attrs to find) first\n                                workerTools.sort(function(a,b){\n                                    return b.tool.onElementSelect.onlyWithAttrs.length - a.tool.onElementSelect.onlyWithAttrs.length;\n                                });\n                            }else{\n                                angular.forEach(unfilteredTools, function(tool, name){\n                                    workerTools.push({'name': name, 'tool': tool});\n                                });\n                            }\n                            // Run the actions on the first visible filtered tool only\n                            if(workerTools.length > 0){\n                                for(var _i = 0; _i < workerTools.length; _i++){\n                                    var tool = workerTools[_i].tool;\n                                    var name = workerTools[_i].name;\n                                    for(var _t = 0; _t < editors[editorName].toolbarScopes.length; _t++){\n                                        if(editors[editorName].toolbarScopes[_t].tools[name] !== undefined){\n                                            tool.onElementSelect.action.call(editors[editorName].toolbarScopes[_t].tools[name], event, element, editorScope);\n                                            result = true;\n                                            break;\n                                        }\n                                    }\n                                    if(result) break;\n                                }\n                            }\n                            return result;\n                        }\n                    }\n                };\n                angular.forEach(targetToolbars, function(_name){\n                    if(toolbars[_name]) {\n                        editors[editorName].toolbarScopes.push(toolbars[_name]);\n                    }\n                    // if it doesn't exist it may not have been compiled yet and it will be added later\n                });\n                touchModification();\n                return editors[editorName].editorFunctions;\n            },\n            // retrieve editor by name, largely used by testing suites only\n            retrieveEditor: function(name){\n                return editors[name];\n            },\n            unregisterEditor: function(name){\n                delete editors[name];\n                touchModification();\n            },\n            // registers a toolbar such that it can be linked to editors\n            registerToolbar: function(toolbarScope){\n                if(!toolbarScope) throw('textAngular Error: A toolbar requires a scope');\n                if(!toolbarScope.name || toolbarScope.name === '') throw('textAngular Error: A toolbar requires a name');\n                if(toolbars[toolbarScope.name]) throw('textAngular Error: A toolbar with name \"' + toolbarScope.name + '\" already exists');\n                toolbars[toolbarScope.name] = toolbarScope;\n                // walk all the editors and connect this toolbarScope to the editors.... if we need to.  This way, it does\n                // not matter if we register the editors after the toolbars or not\n                // Note the editor will ignore this toolbarScope if it is not connected to it...\n                angular.forEach(editors, function(_editor){\n                    _editor._registerToolbarScope(toolbarScope);\n                });\n                touchModification();\n            },\n            // retrieve toolbar by name, largely used by testing suites only\n            retrieveToolbar: function(name){\n                return toolbars[name];\n            },\n            // retrieve toolbars by editor name, largely used by testing suites only\n            retrieveToolbarsViaEditor: function(name){\n                var result = [], _this = this;\n                angular.forEach(this.retrieveEditor(name).toolbars, function(name){\n                    result.push(_this.retrieveToolbar(name));\n                });\n                return result;\n            },\n            unregisterToolbar: function(name){\n                delete toolbars[name];\n                touchModification();\n            },\n            // functions for updating the toolbar buttons display\n            updateToolsDisplay: function(newTaTools){\n                // pass a partial struct of the taTools, this allows us to update the tools on the fly, will not change the defaults.\n                var _this = this;\n                angular.forEach(newTaTools, function(_newTool, key){\n                    _this.updateToolDisplay(key, _newTool);\n                });\n            },\n            // this function resets all toolbars to their default tool definitions\n            resetToolsDisplay: function(){\n                var _this = this;\n                angular.forEach(taTools, function(_newTool, key){\n                    _this.resetToolDisplay(key);\n                });\n                touchModification();\n            },\n            // update a tool on all toolbars\n            updateToolDisplay: function(toolKey, _newTool){\n                var _this = this;\n                angular.forEach(toolbars, function(toolbarScope, toolbarKey){\n                    _this.updateToolbarToolDisplay(toolbarKey, toolKey, _newTool);\n                });\n                touchModification();\n            },\n            // resets a tool to the default/starting state on all toolbars\n            resetToolDisplay: function(toolKey){\n                var _this = this;\n                angular.forEach(toolbars, function(toolbarScope, toolbarKey){\n                    _this.resetToolbarToolDisplay(toolbarKey, toolKey);\n                });\n                touchModification();\n            },\n            // update a tool on a specific toolbar\n            updateToolbarToolDisplay: function(toolbarKey, toolKey, _newTool){\n                if(toolbars[toolbarKey]) toolbars[toolbarKey].updateToolDisplay(toolKey, _newTool);\n                else throw('textAngular Error: No Toolbar with name \"' + toolbarKey + '\" exists');\n            },\n            // reset a tool on a specific toolbar to it's default starting value\n            resetToolbarToolDisplay: function(toolbarKey, toolKey){\n                if(toolbars[toolbarKey]) toolbars[toolbarKey].updateToolDisplay(toolKey, taTools[toolKey], true);\n                else throw('textAngular Error: No Toolbar with name \"' + toolbarKey + '\" exists');\n            },\n            // removes a tool from all toolbars and it's definition\n            removeTool: function(toolKey){\n                delete taTools[toolKey];\n                angular.forEach(toolbars, function(toolbarScope){\n                    delete toolbarScope.tools[toolKey];\n                    for(var i = 0; i < toolbarScope.toolbar.length; i++){\n                        var toolbarIndex;\n                        for(var j = 0; j < toolbarScope.toolbar[i].length; j++){\n                            if(toolbarScope.toolbar[i][j] === toolKey){\n                                toolbarIndex = {\n                                    group: i,\n                                    index: j\n                                };\n                                break;\n                            }\n                            if(toolbarIndex !== undefined) break;\n                        }\n                        if(toolbarIndex !== undefined){\n                            toolbarScope.toolbar[toolbarIndex.group].slice(toolbarIndex.index, 1);\n                            toolbarScope._$element.children().eq(toolbarIndex.group).children().eq(toolbarIndex.index).remove();\n                        }\n                    }\n                });\n                touchModification();\n            },\n            // toolkey, toolDefinition are required. If group is not specified will pick the last group, if index isnt defined will append to group\n            addTool: function(toolKey, toolDefinition, group, index){\n                taRegisterTool(toolKey, toolDefinition);\n                angular.forEach(toolbars, function(toolbarScope){\n                    toolbarScope.addTool(toolKey, toolDefinition, group, index);\n                });\n                touchModification();\n            },\n            // adds a Tool but only to one toolbar not all\n            addToolToToolbar: function(toolKey, toolDefinition, toolbarKey, group, index){\n                taRegisterTool(toolKey, toolDefinition);\n                toolbars[toolbarKey].addTool(toolKey, toolDefinition, group, index);\n                touchModification();\n            },\n            // this is used when externally the html of an editor has been changed and textAngular needs to be notified to update the model.\n            // this will call a $digest if not already happening\n            refreshEditor: function(name){\n                if(editors[name]){\n                    editors[name].scope.updateTaBindtaTextElement();\n                    /* istanbul ignore else: phase catch */\n                    if(!editors[name].scope.$$phase) editors[name].scope.$digest();\n                }else throw('textAngular Error: No Editor with name \"' + name + '\" exists');\n                touchModification();\n            },\n            // this is used by taBind to send a key command in response to a special key event\n            sendKeyCommand: function(scope, event){\n                var _editor = editors[scope._name];\n                /* istanbul ignore else: if nothing to do, do nothing */\n                if (_editor && _editor.editorFunctions.sendKeyCommand(event)) {\n                    /* istanbul ignore else: don't run if already running */\n                    if(!scope._bUpdateSelectedStyles){\n                        scope.updateSelectedStyles();\n                    }\n                    event.preventDefault();\n                    return false;\n                }\n            },\n            //\n            // When a toolbar and tools are created, it isn't until there is a key event or mouse event\n            // that the updateSelectedStyles() is called behind the scenes.\n            // This function forces an update through the existing editors to help the application make sure\n            // the inital state is correct.\n            //\n            updateStyles: updateStyles,\n            // return the current version of textAngular in use to the user\n            getVersion: function () { return textAngularVersion; },\n            // for testing\n            getToolbarScopes: function () {\n                var tmp=[];\n                angular.forEach(editors, function (_editor) {\n                    tmp = tmp.concat(_editor.toolbarScopes);\n                });\n                return tmp;\n            }\n            /********************** not functional yet\n             // save the selection ('range') for the given editor\n             saveFocusSelection: function (name, range) {\n            editors[name].savedFocusRange = range;\n        },\n             // restore the saved selection from when the focus was lost\n             restoreFocusSelection: function(name, scope) {\n            // we only do this if NOT focussed and saved...\n            if (editors[name].savedFocusRange && !scope.focussed) {\n                try {\n                    var _r = rangy.restoreRange(editors[name].savedFocusRange);\n                    var _sel = rangy.getSelection();\n                    _sel.addRange(_r);\n                } catch(e) {}\n            }\n        }\n             *************/\n        };\n    }]);\ntextAngular.directive('textAngularToolbar', [\n    '$compile', 'textAngularManager', 'taOptions', 'taTools', 'taToolExecuteAction', '$window',\n    function($compile, textAngularManager, taOptions, taTools, taToolExecuteAction, $window){\n        return {\n            scope: {\n                name: '@' // a name IS required\n            },\n            restrict: \"EA\",\n            link: function(scope, element, attrs){\n                if(!scope.name || scope.name === '') throw('textAngular Error: A toolbar requires a name');\n                angular.extend(scope, angular.copy(taOptions));\n                if(attrs.taToolbar)\t\t\t\t\t\tscope.toolbar = scope.$parent.$eval(attrs.taToolbar);\n                if(attrs.taToolbarClass)\t\t\t\tscope.classes.toolbar = attrs.taToolbarClass;\n                if(attrs.taToolbarGroupClass)\t\t\tscope.classes.toolbarGroup = attrs.taToolbarGroupClass;\n                if(attrs.taToolbarButtonClass)\t\t\tscope.classes.toolbarButton = attrs.taToolbarButtonClass;\n                if(attrs.taToolbarActiveButtonClass)\tscope.classes.toolbarButtonActive = attrs.taToolbarActiveButtonClass;\n                if(attrs.taFocussedClass)\t\t\t\tscope.classes.focussed = attrs.taFocussedClass;\n\n                scope.disabled = true;\n                scope.focussed = false;\n                scope._$element = element;\n                element[0].innerHTML = '';\n                element.addClass(\"ta-toolbar \" + scope.classes.toolbar);\n\n                scope.$watch('focussed', function(){\n                    if(scope.focussed) element.addClass(scope.classes.focussed);\n                    else element.removeClass(scope.classes.focussed);\n                });\n\n                var setupToolElement = function(toolDefinition, toolScope){\n                    var toolElement;\n                    if(toolDefinition && toolDefinition.display){\n                        toolElement = angular.element(toolDefinition.display);\n                    }\n                    else toolElement = angular.element(\"<button type='button'>\");\n\n                    if(toolDefinition && toolDefinition[\"class\"]) toolElement.addClass(toolDefinition[\"class\"]);\n                    else toolElement.addClass(scope.classes.toolbarButton);\n\n                    toolElement.attr('name', toolScope.name);\n                    // important to not take focus from the main text/html entry\n                    toolElement.attr('ta-button', 'ta-button');\n                    toolElement.attr('ng-disabled', 'isDisabled()');\n                    toolElement.attr('tabindex', '-1');\n                    toolElement.attr('ng-click', 'executeAction()');\n                    toolElement.attr('ng-class', 'displayActiveToolClass(active)');\n\n                    if (toolDefinition && toolDefinition.tooltiptext) {\n                        toolElement.attr('title', toolDefinition.tooltiptext);\n                    }\n                    if(toolDefinition && !toolDefinition.display && !toolScope._display){\n                        // first clear out the current contents if any\n                        toolElement[0].innerHTML = '';\n                        // add the buttonText\n                        if(toolDefinition.buttontext) toolElement[0].innerHTML = toolDefinition.buttontext;\n                        // add the icon to the front of the button if there is content\n                        if(toolDefinition.iconclass){\n                            var icon = angular.element('<i>'), content = toolElement[0].innerHTML;\n                            icon.addClass(toolDefinition.iconclass);\n                            toolElement[0].innerHTML = '';\n                            toolElement.append(icon);\n                            if(content && content !== '') toolElement.append('&nbsp;' + content);\n                        }\n                    }\n\n                    toolScope._lastToolDefinition = angular.copy(toolDefinition);\n\n                    return $compile(toolElement)(toolScope);\n                };\n\n                // Keep a reference for updating the active states later\n                scope.tools = {};\n                // create the tools in the toolbar\n                // default functions and values to prevent errors in testing and on init\n                scope._parent = {\n                    disabled: true,\n                    showHtml: false,\n                    queryFormatBlockState: function(){ return false; },\n                    queryCommandState: function(){ return false; }\n                };\n                var defaultChildScope = {\n                    $window: $window,\n                    $editor: function(){\n                        // dynamically gets the editor as it is set\n                        return scope._parent;\n                    },\n                    isDisabled: function(){\n                        // view selection button is always enabled since it doesn not depend on a selction!\n                        if (this.name === 'html' && scope._parent.startAction) {\n                            return false;\n                        }\n                        // to set your own disabled logic set a function or boolean on the tool called 'disabled'\n                        return ( // this bracket is important as without it it just returns the first bracket and ignores the rest\n                            // when the button's disabled function/value evaluates to true\n                            (typeof this.$eval('disabled') !== 'function' && this.$eval('disabled')) || this.$eval('disabled()') ||\n                            // all buttons except the HTML Switch button should be disabled in the showHtml (RAW html) mode\n                            (this.name !== 'html' && this.$editor().showHtml) ||\n                            // if the toolbar is disabled\n                            this.$parent.disabled ||\n                            // if the current editor is disabled\n                            this.$editor().disabled\n                        );\n                    },\n                    displayActiveToolClass: function(active){\n                        return (active)? scope.classes.toolbarButtonActive : '';\n                    },\n                    executeAction: taToolExecuteAction\n                };\n\n                angular.forEach(scope.toolbar, function(group){\n                    // setup the toolbar group\n                    var groupElement = angular.element(\"<div>\");\n                    groupElement.addClass(scope.classes.toolbarGroup);\n                    angular.forEach(group, function(tool){\n                        // init and add the tools to the group\n                        // a tool name (key name from taTools struct)\n                        //creates a child scope of the main angularText scope and then extends the childScope with the functions of this particular tool\n                        // reference to the scope and element kept\n                        scope.tools[tool] = angular.extend(scope.$new(true), taTools[tool], defaultChildScope, {name: tool});\n                        scope.tools[tool].$element = setupToolElement(taTools[tool], scope.tools[tool]);\n                        // append the tool compiled with the childScope to the group element\n                        groupElement.append(scope.tools[tool].$element);\n                    });\n                    // append the group to the toolbar\n                    element.append(groupElement);\n                });\n\n                // update a tool\n                // if a value is set to null, remove from the display\n                // when forceNew is set to true it will ignore all previous settings, used to reset to taTools definition\n                // to reset to defaults pass in taTools[key] as _newTool and forceNew as true, ie `updateToolDisplay(key, taTools[key], true);`\n                scope.updateToolDisplay = function(key, _newTool, forceNew){\n                    var toolInstance = scope.tools[key];\n                    if(toolInstance){\n                        // get the last toolDefinition, then override with the new definition\n                        if(toolInstance._lastToolDefinition && !forceNew) _newTool = angular.extend({}, toolInstance._lastToolDefinition, _newTool);\n                        if(_newTool.buttontext === null && _newTool.iconclass === null && _newTool.display === null)\n                            throw('textAngular Error: Tool Definition for updating \"' + key + '\" does not have a valid display/iconclass/buttontext value');\n\n                        // if tool is defined on this toolbar, update/redo the tool\n                        if(_newTool.buttontext === null){\n                            delete _newTool.buttontext;\n                        }\n                        if(_newTool.iconclass === null){\n                            delete _newTool.iconclass;\n                        }\n                        if(_newTool.display === null){\n                            delete _newTool.display;\n                        }\n\n                        var toolElement = setupToolElement(_newTool, toolInstance);\n                        toolInstance.$element.replaceWith(toolElement);\n                        toolInstance.$element = toolElement;\n                    }\n                };\n\n                // we assume here that all values passed are valid and correct\n                scope.addTool = function(key, _newTool, groupIndex, index){\n                    scope.tools[key] = angular.extend(scope.$new(true), taTools[key], defaultChildScope, {name: key});\n                    scope.tools[key].$element = setupToolElement(taTools[key], scope.tools[key]);\n                    var group;\n                    if(groupIndex === undefined) groupIndex = scope.toolbar.length - 1;\n                    group = angular.element(element.children()[groupIndex]);\n\n                    if(index === undefined){\n                        group.append(scope.tools[key].$element);\n                        scope.toolbar[groupIndex][scope.toolbar[groupIndex].length - 1] = key;\n                    }else{\n                        group.children().eq(index).after(scope.tools[key].$element);\n                        scope.toolbar[groupIndex][index] = key;\n                    }\n                };\n\n                textAngularManager.registerToolbar(scope);\n\n                scope.$on('$destroy', function(){\n                    textAngularManager.unregisterToolbar(scope.name);\n                });\n            }\n        };\n    }\n]);\ntextAngular.directive('textAngularVersion', ['textAngularManager',\n    function(textAngularManager) {\n        var version = textAngularManager.getVersion();\n        return {\n            restrict: \"EA\",\n            link: function (scope, element, attrs) {\n                element.html(version);\n            }\n        };\n    }\n]);","\n// tests against the current jqLite/jquery implementation if this can be an element\nfunction validElementString(string){\n    try{\n        return angular.element(string).length !== 0;\n    }catch(any){\n        return false;\n    }\n}\n// setup the global contstant functions for setting up the toolbar\n\n// all tool definitions\nvar taTools = {};\n/*\n A tool definition is an object with the following key/value parameters:\n action: [function(deferred, restoreSelection)]\n a function that is executed on clicking on the button - this will allways be executed using ng-click and will\n overwrite any ng-click value in the display attribute.\n The function is passed a deferred object ($q.defer()), if this is wanted to be used `return false;` from the action and\n manually call `deferred.resolve();` elsewhere to notify the editor that the action has finished.\n restoreSelection is only defined if the rangy library is included and it can be called as `restoreSelection()` to restore the users\n selection in the WYSIWYG editor.\n display: [string]?\n Optional, an HTML element to be displayed as the button. The `scope` of the button is the tool definition object with some additional functions\n If set this will cause buttontext and iconclass to be ignored\n class: [string]?\n Optional, if set will override the taOptions.classes.toolbarButton class.\n buttontext: [string]?\n if this is defined it will replace the contents of the element contained in the `display` element\n iconclass: [string]?\n if this is defined an icon (<i>) will be appended to the `display` element with this string as it's class\n tooltiptext: [string]?\n Optional, a plain text description of the action, used for the title attribute of the action button in the toolbar by default.\n activestate: [function(commonElement)]?\n this function is called on every caret movement, if it returns true then the class taOptions.classes.toolbarButtonActive\n will be applied to the `display` element, else the class will be removed\n disabled: [function()]?\n if this function returns true then the tool will have the class taOptions.classes.disabled applied to it, else it will be removed\n Other functions available on the scope are:\n name: [string]\n the name of the tool, this is the first parameter passed into taRegisterTool\n isDisabled: [function()]\n returns true if the tool is disabled, false if it isn't\n displayActiveToolClass: [function(boolean)]\n returns true if the tool is 'active' in the currently focussed toolbar\n onElementSelect: [Object]\n This object contains the following key/value pairs and is used to trigger the ta-element-select event\n element: [String]\n an element name, will only trigger the onElementSelect action if the tagName of the element matches this string\n filter: [function(element)]?\n an optional filter that returns a boolean, if true it will trigger the onElementSelect.\n action: [function(event, element, editorScope)]\n the action that should be executed if the onElementSelect function runs\n */\n// name and toolDefinition to add into the tools available to be added on the toolbar\nfunction registerTextAngularTool(name, toolDefinition){\n    if(!name || name === '' || taTools.hasOwnProperty(name)) throw('textAngular Error: A unique name is required for a Tool Definition');\n    if(\n        (toolDefinition.display && (toolDefinition.display === '' || !validElementString(toolDefinition.display))) ||\n        (!toolDefinition.display && !toolDefinition.buttontext && !toolDefinition.iconclass)\n    )\n        throw('textAngular Error: Tool Definition for \"' + name + '\" does not have a valid display/iconclass/buttontext value');\n    taTools[name] = toolDefinition;\n}\n\nangular.module('textAngularSetup', [])\n    .constant('taRegisterTool', registerTextAngularTool)\n    .value('taTools', taTools)\n    // Here we set up the global display defaults, to set your own use a angular $provider#decorator.\n    .value('taOptions',  {\n        //////////////////////////////////////////////////////////////////////////////////////\n        // forceTextAngularSanitize\n        // set false to allow the textAngular-sanitize provider to be replaced\n        // with angular-sanitize or a custom provider.\n        forceTextAngularSanitize: true,\n        ///////////////////////////////////////////////////////////////////////////////////////\n        // keyMappings\n        // allow customizable keyMappings for specialized key boards or languages\n        //\n        // keyMappings provides key mappings that are attached to a given commandKeyCode.\n        // To modify a specific keyboard binding, simply provide function which returns true\n        // for the event you wish to map to.\n        // Or to disable a specific keyboard binding, provide a function which returns false.\n        // Note: 'RedoKey' and 'UndoKey' are internally bound to the redo and undo functionality.\n        // At present, the following commandKeyCodes are in use:\n        // 98, 'TabKey', 'ShiftTabKey', 105, 117, 'UndoKey', 'RedoKey'\n        //\n        // To map to an new commandKeyCode, add a new key mapping such as:\n        // {commandKeyCode: 'CustomKey', testForKey: function (event) {\n        //  if (event.keyCode=57 && event.ctrlKey && !event.shiftKey && !event.altKey) return true;\n        // } }\n        // to the keyMappings. This example maps ctrl+9 to 'CustomKey'\n        // Then where taRegisterTool(...) is called, add a commandKeyCode: 'CustomKey' and your\n        // tool will be bound to ctrl+9.\n        //\n        // To disble one of the already bound commandKeyCodes such as 'RedoKey' or 'UndoKey' add:\n        // {commandKeyCode: 'RedoKey', testForKey: function (event) { return false; } },\n        // {commandKeyCode: 'UndoKey', testForKey: function (event) { return false; } },\n        // to disable them.\n        //\n        keyMappings : [],\n        toolbar: [\n            ['bold', 'italics', 'underline', 'strikeThrough', 'ul', 'ol', 'redo', 'undo', 'clear'],\n            ['insertLink', 'wordcount', 'charcount']\n        ],\n        classes: {\n            focussed: \"focussed\",\n            toolbar: \"btn-toolbar\",\n            toolbarGroup: \"btn-group\",\n            toolbarButton: \"btn btn-default\",\n            toolbarButtonActive: \"active\",\n            disabled: \"disabled\",\n            textEditor: 'form-control',\n            htmlEditor: 'form-control'\n        },\n        defaultTagAttributes : {\n            a: {target:\"\"}\n        },\n        setup: {\n            // wysiwyg mode\n            textEditorSetup: function($element){ /* Do some processing here */ },\n            // raw html\n            htmlEditorSetup: function($element){ /* Do some processing here */ }\n        },\n        defaultFileDropHandler:\n        /* istanbul ignore next: untestable image processing */\n            function(file, insertAction){\n                var reader = new FileReader();\n                if(file.type.substring(0, 5) === 'image'){\n                    reader.onload = function() {\n                        if(reader.result !== '') insertAction('insertImage', reader.result, true);\n                    };\n\n                    reader.readAsDataURL(file);\n                    // NOTE: For async procedures return a promise and resolve it when the editor should update the model.\n                    return true;\n                }\n                return false;\n            }\n    })\n\n    // This is the element selector string that is used to catch click events within a taBind, prevents the default and $emits a 'ta-element-select' event\n    // these are individually used in an angular.element().find() call. What can go here depends on whether you have full jQuery loaded or just jQLite with angularjs.\n    // div is only used as div.ta-insert-video caught in filter.\n    .value('taSelectableElements', ['a','img'])\n\n    // This is an array of objects with the following options:\n    //\t\t\t\tselector: <string> a jqLite or jQuery selector string\n    //\t\t\t\tcustomAttribute: <string> an attribute to search for\n    //\t\t\t\trenderLogic: <function(element)>\n    // Both or one of selector and customAttribute must be defined.\n    .value('taCustomRenderers', [\n        {\n            // Parse back out: '<div class=\"ta-insert-video\" ta-insert-video src=\"' + urlLink + '\" allowfullscreen=\"true\" width=\"300\" frameborder=\"0\" height=\"250\"></div>'\n            // To correct video element. For now only support youtube\n            selector: 'img',\n            customAttribute: 'ta-insert-video',\n            renderLogic: function(element){\n                var iframe = angular.element('<iframe></iframe>');\n                var attributes = element.prop(\"attributes\");\n                // loop through element attributes and apply them on iframe\n                angular.forEach(attributes, function(attr) {\n                    iframe.attr(attr.name, attr.value);\n                });\n                iframe.attr('src', iframe.attr('ta-insert-video'));\n                element.replaceWith(iframe);\n            }\n        }\n    ])\n\n    .value('taTranslations', {\n        // moved to sub-elements\n        //toggleHTML: \"Toggle HTML\",\n        //insertImage: \"Please enter a image URL to insert\",\n        //insertLink: \"Please enter a URL to insert\",\n        //insertVideo: \"Please enter a youtube URL to embed\",\n        html: {\n            tooltip: 'Toggle html / Rich Text'\n        },\n        // tooltip for heading - might be worth splitting\n        heading: {\n            tooltip: 'Heading '\n        },\n        p: {\n            tooltip: 'Paragraph'\n        },\n        pre: {\n            tooltip: 'Preformatted text'\n        },\n        ul: {\n            tooltip: 'Unordered List'\n        },\n        ol: {\n            tooltip: 'Ordered List'\n        },\n        quote: {\n            tooltip: 'Quote/unquote selection or paragraph'\n        },\n        undo: {\n            tooltip: 'Undo'\n        },\n        redo: {\n            tooltip: 'Redo'\n        },\n        bold: {\n            tooltip: 'Bold'\n        },\n        italic: {\n            tooltip: 'Italic'\n        },\n        underline: {\n            tooltip: 'Underline'\n        },\n        strikeThrough:{\n            tooltip: 'Strikethrough'\n        },\n        justifyLeft: {\n            tooltip: 'Align text left'\n        },\n        justifyRight: {\n            tooltip: 'Align text right'\n        },\n        justifyFull: {\n            tooltip: 'Justify text'\n        },\n        justifyCenter: {\n            tooltip: 'Center'\n        },\n        indent: {\n            tooltip: 'Increase indent'\n        },\n        outdent: {\n            tooltip: 'Decrease indent'\n        },\n        clear: {\n            tooltip: 'Clear formatting'\n        },\n        insertImage: {\n            dialogPrompt: 'Please enter an image URL to insert',\n            tooltip: 'Insert image',\n            hotkey: 'the - possibly language dependent hotkey ... for some future implementation'\n        },\n        insertVideo: {\n            tooltip: 'Insert video',\n            dialogPrompt: 'Please enter a youtube URL to embed'\n        },\n        insertLink: {\n            tooltip: 'Insert / edit link',\n            dialogPrompt: \"Please enter a URL to insert\"\n        },\n        editLink: {\n            reLinkButton: {\n                tooltip: \"Relink\"\n            },\n            unLinkButton: {\n                tooltip: \"Unlink\"\n            },\n            targetToggle: {\n                buttontext: \"Open in New Window\"\n            }\n        },\n        wordcount: {\n            tooltip: 'Display words Count'\n        },\n        charcount: {\n            tooltip: 'Display characters Count'\n        }\n    })\n    .factory('taToolFunctions', ['$window','taTranslations', function($window, taTranslations) {\n        return {\n            imgOnSelectAction: function(event, $element, editorScope){\n                // setup the editor toolbar\n                // Credit to the work at http://hackerwins.github.io/summernote/ for this editbar logic/display\n                var finishEdit = function(){\n                    editorScope.updateTaBindtaTextElement();\n                    editorScope.hidePopover();\n                };\n                event.preventDefault();\n                editorScope.displayElements.popover.css('width', '375px');\n                var container = editorScope.displayElements.popoverContainer;\n                container.empty();\n                var buttonGroup = angular.element('<div class=\"btn-group\" style=\"padding-right: 6px;\">');\n                var fullButton = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\">100% </button>');\n                fullButton.on('click', function(event){\n                    event.preventDefault();\n                    $element.css({\n                        'width': '100%',\n                        'height': ''\n                    });\n                    finishEdit();\n                });\n                var halfButton = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\">50% </button>');\n                halfButton.on('click', function(event){\n                    event.preventDefault();\n                    $element.css({\n                        'width': '50%',\n                        'height': ''\n                    });\n                    finishEdit();\n                });\n                var quartButton = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\">25% </button>');\n                quartButton.on('click', function(event){\n                    event.preventDefault();\n                    $element.css({\n                        'width': '25%',\n                        'height': ''\n                    });\n                    finishEdit();\n                });\n                var resetButton = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\">Reset</button>');\n                resetButton.on('click', function(event){\n                    event.preventDefault();\n                    $element.css({\n                        width: '',\n                        height: ''\n                    });\n                    finishEdit();\n                });\n                buttonGroup.append(fullButton);\n                buttonGroup.append(halfButton);\n                buttonGroup.append(quartButton);\n                buttonGroup.append(resetButton);\n                container.append(buttonGroup);\n\n                buttonGroup = angular.element('<div class=\"btn-group\" style=\"padding-right: 6px;\">');\n                var floatLeft = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\"><i class=\"fa fa-align-left\"></i></button>');\n                floatLeft.on('click', function(event){\n                    event.preventDefault();\n                    // webkit\n                    $element.css('float', 'left');\n                    // firefox\n                    $element.css('cssFloat', 'left');\n                    // IE < 8\n                    $element.css('styleFloat', 'left');\n                    finishEdit();\n                });\n                var floatRight = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\"><i class=\"fa fa-align-right\"></i></button>');\n                floatRight.on('click', function(event){\n                    event.preventDefault();\n                    // webkit\n                    $element.css('float', 'right');\n                    // firefox\n                    $element.css('cssFloat', 'right');\n                    // IE < 8\n                    $element.css('styleFloat', 'right');\n                    finishEdit();\n                });\n                var floatNone = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\"><i class=\"fa fa-align-justify\"></i></button>');\n                floatNone.on('click', function(event){\n                    event.preventDefault();\n                    // webkit\n                    $element.css('float', '');\n                    // firefox\n                    $element.css('cssFloat', '');\n                    // IE < 8\n                    $element.css('styleFloat', '');\n                    finishEdit();\n                });\n                buttonGroup.append(floatLeft);\n                buttonGroup.append(floatNone);\n                buttonGroup.append(floatRight);\n                container.append(buttonGroup);\n\n                buttonGroup = angular.element('<div class=\"btn-group\">');\n                var remove = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\"><i class=\"fa fa-trash-o\"></i></button>');\n                remove.on('click', function(event){\n                    event.preventDefault();\n                    $element.remove();\n                    finishEdit();\n                });\n                buttonGroup.append(remove);\n                container.append(buttonGroup);\n\n                editorScope.showPopover($element);\n                editorScope.showResizeOverlay($element);\n            },\n            aOnSelectAction: function(event, $element, editorScope){\n                // setup the editor toolbar\n                // Credit to the work at http://hackerwins.github.io/summernote/ for this editbar logic\n                event.preventDefault();\n                editorScope.displayElements.popover.css('width', '436px');\n                var container = editorScope.displayElements.popoverContainer;\n                container.empty();\n                container.css('line-height', '28px');\n                var link = angular.element('<a href=\"' + $element.attr('href') + '\" target=\"_blank\">' + $element.attr('href') + '</a>');\n                link.css({\n                    'display': 'inline-block',\n                    'max-width': '200px',\n                    'overflow': 'hidden',\n                    'text-overflow': 'ellipsis',\n                    'white-space': 'nowrap',\n                    'vertical-align': 'middle'\n                });\n                container.append(link);\n                var buttonGroup = angular.element('<div class=\"btn-group pull-right\">');\n                var reLinkButton = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" tabindex=\"-1\" unselectable=\"on\" title=\"' + taTranslations.editLink.reLinkButton.tooltip + '\"><i class=\"fa fa-edit icon-edit\"></i></button>');\n                reLinkButton.on('click', function(event){\n                    event.preventDefault();\n                    var urlLink = $window.prompt(taTranslations.insertLink.dialogPrompt, $element.attr('href'));\n                    if(urlLink && urlLink !== '' && urlLink !== 'http://'){\n                        $element.attr('href', urlLink);\n                        editorScope.updateTaBindtaTextElement();\n                    }\n                    editorScope.hidePopover();\n                });\n                buttonGroup.append(reLinkButton);\n                var unLinkButton = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" tabindex=\"-1\" unselectable=\"on\" title=\"' + taTranslations.editLink.unLinkButton.tooltip + '\"><i class=\"fa fa-unlink icon-unlink\"></i></button>');\n                // directly before this click event is fired a digest is fired off whereby the reference to $element is orphaned off\n                unLinkButton.on('click', function(event){\n                    event.preventDefault();\n                    $element.replaceWith($element.contents());\n                    editorScope.updateTaBindtaTextElement();\n                    editorScope.hidePopover();\n                });\n                buttonGroup.append(unLinkButton);\n                var targetToggle = angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" tabindex=\"-1\" unselectable=\"on\">' + taTranslations.editLink.targetToggle.buttontext + '</button>');\n                if($element.attr('target') === '_blank'){\n                    targetToggle.addClass('active');\n                }\n                targetToggle.on('click', function(event){\n                    event.preventDefault();\n                    $element.attr('target', ($element.attr('target') === '_blank') ? '' : '_blank');\n                    targetToggle.toggleClass('active');\n                    editorScope.updateTaBindtaTextElement();\n                });\n                buttonGroup.append(targetToggle);\n                container.append(buttonGroup);\n                editorScope.showPopover($element);\n            },\n            extractYoutubeVideoId: function(url) {\n                var re = /(?:youtube(?:-nocookie)?\\.com\\/(?:[^\\/\\n\\s]+\\/\\S+\\/|(?:v|e(?:mbed)?)\\/|\\S*?[?&]v=)|youtu\\.be\\/)([a-zA-Z0-9_-]{11})/i;\n                var match = url.match(re);\n                return (match && match[1]) || null;\n            }\n        };\n    }])\n    .run(['taRegisterTool', '$window', 'taTranslations', 'taSelection', 'taToolFunctions', '$sanitize', 'taOptions', '$log',\n        function(taRegisterTool, $window, taTranslations, taSelection, taToolFunctions, $sanitize, taOptions, $log){\n            // test for the version of $sanitize that is in use\n            // You can disable this check by setting taOptions.textAngularSanitize == false\n            var gv = {}; $sanitize('', gv);\n            /* istanbul ignore next, throws error */\n            if ((taOptions.forceTextAngularSanitize===true) && (gv.version !== 'taSanitize')) {\n                throw angular.$$minErr('textAngular')(\"textAngularSetup\", \"The textAngular-sanitize provider has been replaced by another -- have you included angular-sanitize by mistake?\");\n            }\n            taRegisterTool(\"html\", {\n                iconclass: 'fa fa-code',\n                tooltiptext: taTranslations.html.tooltip,\n                action: function(){\n                    this.$editor().switchView();\n                },\n                activeState: function(){\n                    return this.$editor().showHtml;\n                }\n            });\n            // add the Header tools\n            // convenience functions so that the loop works correctly\n            var _retActiveStateFunction = function(q){\n                return function(){ return this.$editor().queryFormatBlockState(q); };\n            };\n            var headerAction = function(){\n                return this.$editor().wrapSelection(\"formatBlock\", \"<\" + this.name.toUpperCase() +\">\");\n            };\n            angular.forEach(['h1','h2','h3','h4','h5','h6'], function(h){\n                taRegisterTool(h.toLowerCase(), {\n                    buttontext: h.toUpperCase(),\n                    tooltiptext: taTranslations.heading.tooltip + h.charAt(1),\n                    action: headerAction,\n                    activeState: _retActiveStateFunction(h.toLowerCase())\n                });\n            });\n            taRegisterTool('p', {\n                buttontext: 'P',\n                tooltiptext: taTranslations.p.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"formatBlock\", \"<P>\");\n                },\n                activeState: function(){ return this.$editor().queryFormatBlockState('p'); }\n            });\n            // key: pre -> taTranslations[key].tooltip, taTranslations[key].buttontext\n            taRegisterTool('pre', {\n                buttontext: 'pre',\n                tooltiptext: taTranslations.pre.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"formatBlock\", \"<PRE>\");\n                },\n                activeState: function(){ return this.$editor().queryFormatBlockState('pre'); }\n            });\n            taRegisterTool('ul', {\n                iconclass: 'fa fa-list-ul',\n                tooltiptext: taTranslations.ul.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"insertUnorderedList\", null);\n                },\n                activeState: function(){ return this.$editor().queryCommandState('insertUnorderedList'); }\n            });\n            taRegisterTool('ol', {\n                iconclass: 'fa fa-list-ol',\n                tooltiptext: taTranslations.ol.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"insertOrderedList\", null);\n                },\n                activeState: function(){ return this.$editor().queryCommandState('insertOrderedList'); }\n            });\n            taRegisterTool('quote', {\n                iconclass: 'fa fa-quote-right',\n                tooltiptext: taTranslations.quote.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"formatBlock\", \"<BLOCKQUOTE>\");\n                },\n                activeState: function(){ return this.$editor().queryFormatBlockState('blockquote'); }\n            });\n            taRegisterTool('undo', {\n                iconclass: 'fa fa-undo',\n                tooltiptext: taTranslations.undo.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"undo\", null);\n                }\n            });\n            taRegisterTool('redo', {\n                iconclass: 'fa fa-repeat',\n                tooltiptext: taTranslations.redo.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"redo\", null);\n                }\n            });\n            taRegisterTool('bold', {\n                iconclass: 'fa fa-bold',\n                tooltiptext: taTranslations.bold.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"bold\", null);\n                },\n                activeState: function(){\n                    return this.$editor().queryCommandState('bold');\n                },\n                commandKeyCode: 98\n            });\n            taRegisterTool('justifyLeft', {\n                iconclass: 'fa fa-align-left',\n                tooltiptext: taTranslations.justifyLeft.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"justifyLeft\", null);\n                },\n                activeState: function(commonElement){\n                    /* istanbul ignore next: */\n                    if (commonElement && commonElement.nodeName === '#document') return false;\n                    var result = false;\n                    if (commonElement) {\n                        // commonELement.css('text-align') can throw an error 'Cannot read property 'defaultView' of null' in rare conditions\n                        // so we do try catch here...\n                        try {\n                            result =\n                                commonElement.css('text-align') === 'left' ||\n                                commonElement.attr('align') === 'left' ||\n                                (\n                                    commonElement.css('text-align') !== 'right' &&\n                                    commonElement.css('text-align') !== 'center' &&\n                                    commonElement.css('text-align') !== 'justify' && !this.$editor().queryCommandState('justifyRight') && !this.$editor().queryCommandState('justifyCenter')\n                                ) && !this.$editor().queryCommandState('justifyFull');\n                        } catch(e) {\n                            /* istanbul ignore next: error handler */\n                            //console.log(e);\n                            result = false;\n                        }\n                    }\n                    result = result || this.$editor().queryCommandState('justifyLeft');\n                    return result;\n                }\n            });\n            taRegisterTool('justifyRight', {\n                iconclass: 'fa fa-align-right',\n                tooltiptext: taTranslations.justifyRight.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"justifyRight\", null);\n                },\n                activeState: function(commonElement){\n                    /* istanbul ignore next: */\n                    if (commonElement && commonElement.nodeName === '#document') return false;\n                    var result = false;\n                    if(commonElement) {\n                        // commonELement.css('text-align') can throw an error 'Cannot read property 'defaultView' of null' in rare conditions\n                        // so we do try catch here...\n                        try {\n                            result = commonElement.css('text-align') === 'right';\n                        } catch(e) {\n                            /* istanbul ignore next: error handler */\n                            //console.log(e);\n                            result = false;\n                        }\n                    }\n                    result = result || this.$editor().queryCommandState('justifyRight');\n                    return result;\n                }\n            });\n            taRegisterTool('justifyFull', {\n                iconclass: 'fa fa-align-justify',\n                tooltiptext: taTranslations.justifyFull.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"justifyFull\", null);\n                },\n                activeState: function(commonElement){\n                    var result = false;\n                    if(commonElement) {\n                        // commonELement.css('text-align') can throw an error 'Cannot read property 'defaultView' of null' in rare conditions\n                        // so we do try catch here...\n                        try {\n                            result = commonElement.css('text-align') === 'justify';\n                        } catch(e) {\n                            /* istanbul ignore next: error handler */\n                            //console.log(e);\n                            result = false;\n                        }\n                    }\n                    result = result || this.$editor().queryCommandState('justifyFull');\n                    return result;\n                }\n            });\n            taRegisterTool('justifyCenter', {\n                iconclass: 'fa fa-align-center',\n                tooltiptext: taTranslations.justifyCenter.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"justifyCenter\", null);\n                },\n                activeState: function(commonElement){\n                    /* istanbul ignore next: */\n                    if (commonElement && commonElement.nodeName === '#document') return false;\n                    var result = false;\n                    if(commonElement) {\n                        // commonELement.css('text-align') can throw an error 'Cannot read property 'defaultView' of null' in rare conditions\n                        // so we do try catch here...\n                        try {\n                            result = commonElement.css('text-align') === 'center';\n                        } catch(e) {\n                            /* istanbul ignore next: error handler */\n                            //console.log(e);\n                            result = false;\n                        }\n\n                    }\n                    result = result || this.$editor().queryCommandState('justifyCenter');\n                    return result;\n                }\n            });\n            taRegisterTool('indent', {\n                iconclass: 'fa fa-indent',\n                tooltiptext: taTranslations.indent.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"indent\", null);\n                },\n                activeState: function(){\n                    return this.$editor().queryFormatBlockState('blockquote');\n                },\n                commandKeyCode: 'TabKey'\n            });\n            taRegisterTool('outdent', {\n                iconclass: 'fa fa-outdent',\n                tooltiptext: taTranslations.outdent.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"outdent\", null);\n                },\n                activeState: function(){\n                    return false;\n                },\n                commandKeyCode: 'ShiftTabKey'\n            });\n            taRegisterTool('italics', {\n                iconclass: 'fa fa-italic',\n                tooltiptext: taTranslations.italic.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"italic\", null);\n                },\n                activeState: function(){\n                    return this.$editor().queryCommandState('italic');\n                },\n                commandKeyCode: 105\n            });\n            taRegisterTool('underline', {\n                iconclass: 'fa fa-underline',\n                tooltiptext: taTranslations.underline.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"underline\", null);\n                },\n                activeState: function(){\n                    return this.$editor().queryCommandState('underline');\n                },\n                commandKeyCode: 117\n            });\n            taRegisterTool('strikeThrough', {\n                iconclass: 'fa fa-strikethrough',\n                tooltiptext: taTranslations.strikeThrough.tooltip,\n                action: function(){\n                    return this.$editor().wrapSelection(\"strikeThrough\", null);\n                },\n                activeState: function(){\n                    return document.queryCommandState('strikeThrough');\n                }\n            });\n            taRegisterTool('clear', {\n                iconclass: 'fa fa-ban',\n                tooltiptext: taTranslations.clear.tooltip,\n                action: function(deferred, restoreSelection){\n                    var i, selectedElements, elementsSeen;\n\n                    this.$editor().wrapSelection(\"removeFormat\", null);\n                    var possibleNodes = angular.element(taSelection.getSelectionElement());\n                    selectedElements = taSelection.getAllSelectedElements();\n                    //$log.log('selectedElements:', selectedElements);\n                    // remove lists\n                    var removeListElements = function(list, pe){\n                        list = angular.element(list);\n                        var prevElement = pe;\n                        if (!pe) {\n                            prevElement = list;\n                        }\n                        angular.forEach(list.children(), function(liElem){\n                            if (liElem.tagName.toLowerCase() === 'ul' ||\n                                liElem.tagName.toLowerCase() === 'ol') {\n                                prevElement = removeListElements(liElem, prevElement);\n                            } else {\n                                var newElem = angular.element('<p></p>');\n                                newElem.html(angular.element(liElem).html());\n                                prevElement.after(newElem);\n                                prevElement = newElem;\n                            }\n                        });\n                        list.remove();\n                        return prevElement;\n                    };\n\n                    angular.forEach(selectedElements, function(element) {\n                        if (element.nodeName.toLowerCase() === 'ul' ||\n                            element.nodeName.toLowerCase() === 'ol') {\n                            //console.log('removeListElements', element);\n                            removeListElements(element);\n                        }\n                    });\n\n                    angular.forEach(possibleNodes.find(\"ul\"), removeListElements);\n                    angular.forEach(possibleNodes.find(\"ol\"), removeListElements);\n\n                    // clear out all class attributes. These do not seem to be cleared via removeFormat\n                    var $editor = this.$editor();\n                    var recursiveRemoveClass = function(node){\n                        node = angular.element(node);\n                        /* istanbul ignore next: this is not triggered in tests any longer since we now never select the whole displayELement */\n                        if(node[0] !== $editor.displayElements.text[0]) {\n                            node.removeAttr('class');\n                        }\n                        angular.forEach(node.children(), recursiveRemoveClass);\n                    };\n                    angular.forEach(possibleNodes, recursiveRemoveClass);\n                    // check if in list. If not in list then use formatBlock option\n                    if(possibleNodes[0] && possibleNodes[0].tagName.toLowerCase() !== 'li' &&\n                        possibleNodes[0].tagName.toLowerCase() !== 'ol' &&\n                        possibleNodes[0].tagName.toLowerCase() !== 'ul' &&\n                        possibleNodes[0].getAttribute(\"contenteditable\") !== \"true\") {\n                        this.$editor().wrapSelection(\"formatBlock\", \"default\");\n                    }\n                    restoreSelection();\n                }\n            });\n\n            /* jshint -W099 */\n            /****************************\n             //  we don't use this code - since the previous way CLEAR is expected to work does not clear partially selected <li>\n\n             var removeListElement = function(listE){\n                console.log(listE);\n                var _list = listE.parentNode.childNodes;\n                console.log('_list', _list);\n                var _preLis = [], _postLis = [], _found = false;\n                for (i = 0; i < _list.length; i++) {\n                    if (_list[i] === listE) {\n                        _found = true;\n                    } else if (!_found) _preLis.push(_list[i]);\n                    else _postLis.push(_list[i]);\n                }\n                var _parent = angular.element(listE.parentNode);\n                var newElem = angular.element('<p></p>');\n                newElem.html(angular.element(listE).html());\n                if (_preLis.length === 0 || _postLis.length === 0) {\n                    if (_postLis.length === 0) _parent.after(newElem);\n                    else _parent[0].parentNode.insertBefore(newElem[0], _parent[0]);\n\n                    if (_preLis.length === 0 && _postLis.length === 0) _parent.remove();\n                    else angular.element(listE).remove();\n                } else {\n                    var _firstList = angular.element('<' + _parent[0].tagName + '></' + _parent[0].tagName + '>');\n                    var _secondList = angular.element('<' + _parent[0].tagName + '></' + _parent[0].tagName + '>');\n                    for (i = 0; i < _preLis.length; i++) _firstList.append(angular.element(_preLis[i]));\n                    for (i = 0; i < _postLis.length; i++) _secondList.append(angular.element(_postLis[i]));\n                    _parent.after(_secondList);\n                    _parent.after(newElem);\n                    _parent.after(_firstList);\n                    _parent.remove();\n                }\n                taSelection.setSelectionToElementEnd(newElem[0]);\n            };\n\n             elementsSeen = [];\n             if (selectedElements.length !==0) console.log(selectedElements);\n             angular.forEach(selectedElements, function (element) {\n                if (elementsSeen.indexOf(element) !== -1 || elementsSeen.indexOf(element.parentElement) !== -1) {\n                    return;\n                }\n                elementsSeen.push(element);\n                if (element.nodeName.toLowerCase() === 'li') {\n                    console.log('removeListElement', element);\n                    removeListElement(element);\n                }\n                else if (element.parentElement && element.parentElement.nodeName.toLowerCase() === 'li') {\n                    console.log('removeListElement', element.parentElement);\n                    elementsSeen.push(element.parentElement);\n                    removeListElement(element.parentElement);\n                }\n            });\n             **********************/\n\n            /**********************\n             if(possibleNodes[0].tagName.toLowerCase() === 'li'){\n                var _list = possibleNodes[0].parentNode.childNodes;\n                var _preLis = [], _postLis = [], _found = false;\n                for(i = 0; i < _list.length; i++){\n                    if(_list[i] === possibleNodes[0]){\n                        _found = true;\n                    }else if(!_found) _preLis.push(_list[i]);\n                    else _postLis.push(_list[i]);\n                }\n                var _parent = angular.element(possibleNodes[0].parentNode);\n                var newElem = angular.element('<p></p>');\n                newElem.html(angular.element(possibleNodes[0]).html());\n                if(_preLis.length === 0 || _postLis.length === 0){\n                    if(_postLis.length === 0) _parent.after(newElem);\n                    else _parent[0].parentNode.insertBefore(newElem[0], _parent[0]);\n\n                    if(_preLis.length === 0 && _postLis.length === 0) _parent.remove();\n                    else angular.element(possibleNodes[0]).remove();\n                }else{\n                    var _firstList = angular.element('<'+_parent[0].tagName+'></'+_parent[0].tagName+'>');\n                    var _secondList = angular.element('<'+_parent[0].tagName+'></'+_parent[0].tagName+'>');\n                    for(i = 0; i < _preLis.length; i++) _firstList.append(angular.element(_preLis[i]));\n                    for(i = 0; i < _postLis.length; i++) _secondList.append(angular.element(_postLis[i]));\n                    _parent.after(_secondList);\n                    _parent.after(newElem);\n                    _parent.after(_firstList);\n                    _parent.remove();\n                }\n                taSelection.setSelectionToElementEnd(newElem[0]);\n            }\n             *******************/\n\n\n            /* istanbul ignore next: if it's javascript don't worry - though probably should show some kind of error message */\n            var blockJavascript = function (link) {\n                if (link.toLowerCase().indexOf('javascript')!==-1) {\n                    return true;\n                }\n                return false;\n            };\n\n            taRegisterTool('insertImage', {\n                iconclass: 'fa fa-picture-o',\n                tooltiptext: taTranslations.insertImage.tooltip,\n                action: function(){\n                    var imageLink;\n                    imageLink = $window.prompt(taTranslations.insertImage.dialogPrompt, 'http://');\n                    if(imageLink && imageLink !== '' && imageLink !== 'http://'){\n                        /* istanbul ignore next: don't know how to test this... since it needs a dialogPrompt */\n                        // block javascript here\n                        if (!blockJavascript(imageLink)) {\n                            if (taSelection.getSelectionElement().tagName && taSelection.getSelectionElement().tagName.toLowerCase() === 'a') {\n                                // due to differences in implementation between FireFox and Chrome, we must move the\n                                // insertion point past the <a> element, otherwise FireFox inserts inside the <a>\n                                // With this change, both FireFox and Chrome behave the same way!\n                                taSelection.setSelectionAfterElement(taSelection.getSelectionElement());\n                            }\n                            // In the past we used the simple statement:\n                            //return this.$editor().wrapSelection('insertImage', imageLink, true);\n                            //\n                            // However on Firefox only, when the content is empty this is a problem\n                            // See Issue #1201\n                            // Investigation reveals that Firefox only inserts a <p> only!!!!\n                            // So now we use insertHTML here and all is fine.\n                            // NOTE: this is what 'insertImage' is supposed to do anyway!\n                            var embed = '<img src=\"' + imageLink + '\">';\n                            return this.$editor().wrapSelection('insertHTML', embed, true);\n                        }\n                    }\n                },\n                onElementSelect: {\n                    element: 'img',\n                    action: taToolFunctions.imgOnSelectAction\n                }\n            });\n            taRegisterTool('insertVideo', {\n                iconclass: 'fa fa-youtube-play',\n                tooltiptext: taTranslations.insertVideo.tooltip,\n                action: function(){\n                    var urlPrompt;\n                    urlPrompt = $window.prompt(taTranslations.insertVideo.dialogPrompt, 'https://');\n                    // block javascript here\n                    /* istanbul ignore else: if it's javascript don't worry - though probably should show some kind of error message */\n                    if (!blockJavascript(urlPrompt)) {\n\n                        if (urlPrompt && urlPrompt !== '' && urlPrompt !== 'https://') {\n\n                            videoId = taToolFunctions.extractYoutubeVideoId(urlPrompt);\n\n                            /* istanbul ignore else: if it's invalid don't worry - though probably should show some kind of error message */\n                            if (videoId) {\n                                // create the embed link\n                                var urlLink = \"https://www.youtube.com/embed/\" + videoId;\n                                // create the HTML\n                                // for all options see: http://stackoverflow.com/questions/2068344/how-do-i-get-a-youtube-video-thumbnail-from-the-youtube-api\n                                // maxresdefault.jpg seems to be undefined on some.\n                                var embed = '<img class=\"ta-insert-video\" src=\"https://img.youtube.com/vi/' + videoId + '/hqdefault.jpg\" ta-insert-video=\"' + urlLink + '\" contenteditable=\"false\" allowfullscreen=\"true\" frameborder=\"0\" />';\n                                /* istanbul ignore next: don't know how to test this... since it needs a dialogPrompt */\n                                if (taSelection.getSelectionElement().tagName && taSelection.getSelectionElement().tagName.toLowerCase() === 'a') {\n                                    // due to differences in implementation between FireFox and Chrome, we must move the\n                                    // insertion point past the <a> element, otherwise FireFox inserts inside the <a>\n                                    // With this change, both FireFox and Chrome behave the same way!\n                                    taSelection.setSelectionAfterElement(taSelection.getSelectionElement());\n                                }\n                                // insert\n                                return this.$editor().wrapSelection('insertHTML', embed, true);\n                            }\n                        }\n                    }\n                },\n                onElementSelect: {\n                    element: 'img',\n                    onlyWithAttrs: ['ta-insert-video'],\n                    action: taToolFunctions.imgOnSelectAction\n                }\n            });\n            taRegisterTool('insertLink', {\n                tooltiptext: taTranslations.insertLink.tooltip,\n                iconclass: 'fa fa-link',\n                action: function(){\n                    var urlLink;\n                    // if this link has already been set, we need to just edit the existing link\n                    /* istanbul ignore if: we do not test this */\n                    if (taSelection.getSelectionElement().tagName && taSelection.getSelectionElement().tagName.toLowerCase() === 'a') {\n                        urlLink = $window.prompt(taTranslations.insertLink.dialogPrompt, taSelection.getSelectionElement().href);\n                    } else {\n                        urlLink = $window.prompt(taTranslations.insertLink.dialogPrompt, 'http://');\n                    }\n                    if(urlLink && urlLink !== '' && urlLink !== 'http://'){\n                        // block javascript here\n                        /* istanbul ignore else: if it's javascript don't worry - though probably should show some kind of error message */\n                        if (!blockJavascript(urlLink)) {\n                            return this.$editor().wrapSelection('createLink', urlLink, true);\n                        }\n                    }\n                },\n                activeState: function(commonElement){\n                    if(commonElement) return commonElement[0].tagName === 'A';\n                    return false;\n                },\n                onElementSelect: {\n                    element: 'a',\n                    action: taToolFunctions.aOnSelectAction\n                }\n            });\n            taRegisterTool('wordcount', {\n                display: '<div id=\"toolbarWC\" style=\"display:block; min-width:100px;\">Words: <span ng-bind=\"wordcount\"></span></div>',\n                disabled: true,\n                wordcount: 0,\n                activeState: function(){ // this fires on keyup\n                    var textElement = this.$editor().displayElements.text;\n                    /* istanbul ignore next: will default to '' when undefined */\n                    var workingHTML = textElement[0].innerHTML || '';\n                    var noOfWords = 0;\n\n                    /* istanbul ignore if: will default to '' when undefined */\n                    if (workingHTML.replace(/\\s*<[^>]*?>\\s*/g, '') !== '') {\n                        if (workingHTML.trim() !== '') {\n                            noOfWords = workingHTML.replace(/<\\/?(b|i|em|strong|span|u|strikethrough|a|img|small|sub|sup|label)( [^>*?])?>/gi, '') // remove inline tags without adding spaces\n                                .replace(/(<[^>]*?>\\s*<[^>]*?>)/ig, ' ') // replace adjacent tags with possible space between with a space\n                                .replace(/(<[^>]*?>)/ig, '') // remove any singular tags\n                                .replace(/\\s+/ig, ' ') // condense spacing\n                                .match(/\\S+/g).length; // count remaining non-space strings\n                        }\n                    }\n\n                    //Set current scope\n                    this.wordcount = noOfWords;\n                    //Set editor scope\n                    this.$editor().wordcount = noOfWords;\n\n                    return false;\n                }\n            });\n            taRegisterTool('charcount', {\n                display: '<div id=\"toolbarCC\" style=\"display:block; min-width:120px;\">Characters: <span ng-bind=\"charcount\"></span></div>',\n                disabled: true,\n                charcount: 0,\n                activeState: function(){ // this fires on keyup\n                    var textElement = this.$editor().displayElements.text;\n                    var sourceText = textElement[0].innerText || textElement[0].textContent; // to cover the non-jquery use case.\n\n                    // Caculate number of chars\n                    var noOfChars = sourceText.replace(/(\\r\\n|\\n|\\r)/gm,\"\").replace(/^\\s+/g,' ').replace(/\\s+$/g, ' ').length;\n                    //Set current scope\n                    this.charcount = noOfChars;\n                    //Set editor scope\n                    this.$editor().charcount = noOfChars;\n                    return false;\n                }\n            });\n        }]);","(function() {\n  'use strict';\n\n  angular.module('toastr', [])\n    .factory('toastr', toastr);\n\n  toastr.$inject = ['$animate', '$injector', '$rootScope', '$sce', 'toastrConfig', '$q'];\n\n  function toastr($animate, $injector, $rootScope, $sce, toastrConfig, $q) {\n    var container;\n    var index = 0;\n    var toasts = [];\n\n    var previousToastMessage = '';\n    var openToasts = {};\n\n    var containerDefer = $q.defer();\n\n    var toast = {\n      active: active,\n      clear: clear,\n      error: error,\n      info: info,\n      remove: remove,\n      success: success,\n      warning: warning,\n      refreshTimer: refreshTimer\n    };\n\n    return toast;\n\n    /* Public API */\n    function active() {\n      return toasts.length;\n    }\n\n    function clear(toast) {\n      // Bit of a hack, I will remove this soon with a BC\n      if (arguments.length === 1 && !toast) { return; }\n\n      if (toast) {\n        remove(toast.toastId);\n      } else {\n        for (var i = 0; i < toasts.length; i++) {\n          remove(toasts[i].toastId);\n        }\n      }\n    }\n\n    function error(message, title, optionsOverride) {\n      var type = _getOptions().iconClasses.error;\n      return _buildNotification(type, message, title, optionsOverride);\n    }\n\n    function info(message, title, optionsOverride) {\n      var type = _getOptions().iconClasses.info;\n      return _buildNotification(type, message, title, optionsOverride);\n    }\n\n    function success(message, title, optionsOverride) {\n      var type = _getOptions().iconClasses.success;\n      return _buildNotification(type, message, title, optionsOverride);\n    }\n\n    function warning(message, title, optionsOverride) {\n      var type = _getOptions().iconClasses.warning;\n      return _buildNotification(type, message, title, optionsOverride);\n    }\n\n    function refreshTimer(toast, newTime) {\n      if (toast && toast.isOpened && toasts.indexOf(toast) >= 0) {\n          toast.scope.refreshTimer(newTime);\n      }\n    }\n\n    function remove(toastId, wasClicked) {\n      var toast = findToast(toastId);\n\n      if (toast && ! toast.deleting) { // Avoid clicking when fading out\n        toast.deleting = true;\n        toast.isOpened = false;\n        $animate.leave(toast.el).then(function() {\n          if (toast.scope.options.onHidden) {\n            toast.scope.options.onHidden(!!wasClicked, toast);\n          }\n          toast.scope.$destroy();\n          var index = toasts.indexOf(toast);\n          delete openToasts[toast.scope.message];\n          toasts.splice(index, 1);\n          var maxOpened = toastrConfig.maxOpened;\n          if (maxOpened && toasts.length >= maxOpened) {\n            toasts[maxOpened - 1].open.resolve();\n          }\n          if (lastToast()) {\n            container.remove();\n            container = null;\n            containerDefer = $q.defer();\n          }\n        });\n      }\n\n      function findToast(toastId) {\n        for (var i = 0; i < toasts.length; i++) {\n          if (toasts[i].toastId === toastId) {\n            return toasts[i];\n          }\n        }\n      }\n\n      function lastToast() {\n        return !toasts.length;\n      }\n    }\n\n    /* Internal functions */\n    function _buildNotification(type, message, title, optionsOverride) {\n      if (angular.isObject(title)) {\n        optionsOverride = title;\n        title = null;\n      }\n\n      return _notify({\n        iconClass: type,\n        message: message,\n        optionsOverride: optionsOverride,\n        title: title\n      });\n    }\n\n    function _getOptions() {\n      return angular.extend({}, toastrConfig);\n    }\n\n    function _createOrGetContainer(options) {\n      if(container) { return containerDefer.promise; }\n\n      container = angular.element('<div></div>');\n      container.attr('id', options.containerId);\n      container.addClass(options.positionClass);\n      container.css({'pointer-events': 'auto'});\n\n      var target = angular.element(document.querySelector(options.target));\n\n      if ( ! target || ! target.length) {\n        throw 'Target for toasts doesn\\'t exist';\n      }\n\n      $animate.enter(container, target).then(function() {\n        containerDefer.resolve();\n      });\n\n      return containerDefer.promise;\n    }\n\n    function _notify(map) {\n      var options = _getOptions();\n\n      if (shouldExit()) { return; }\n\n      var newToast = createToast();\n\n      toasts.push(newToast);\n\n      if (ifMaxOpenedAndAutoDismiss()) {\n        var oldToasts = toasts.slice(0, (toasts.length - options.maxOpened));\n        for (var i = 0, len = oldToasts.length; i < len; i++) {\n          remove(oldToasts[i].toastId);\n        }\n      }\n\n      if (maxOpenedNotReached()) {\n        newToast.open.resolve();\n      }\n\n      newToast.open.promise.then(function() {\n        _createOrGetContainer(options).then(function() {\n          newToast.isOpened = true;\n          if (options.newestOnTop) {\n            $animate.enter(newToast.el, container).then(function() {\n              newToast.scope.init();\n            });\n          } else {\n            var sibling = container[0].lastChild ? angular.element(container[0].lastChild) : null;\n            $animate.enter(newToast.el, container, sibling).then(function() {\n              newToast.scope.init();\n            });\n          }\n        });\n      });\n\n      return newToast;\n\n      function ifMaxOpenedAndAutoDismiss() {\n        return options.autoDismiss && options.maxOpened && toasts.length > options.maxOpened;\n      }\n\n      function createScope(toast, map, options) {\n        if (options.allowHtml) {\n          toast.scope.allowHtml = true;\n          toast.scope.title = $sce.trustAsHtml(map.title);\n          toast.scope.message = $sce.trustAsHtml(map.message);\n        } else {\n          toast.scope.title = map.title;\n          toast.scope.message = map.message;\n        }\n\n        toast.scope.toastType = toast.iconClass;\n        toast.scope.toastId = toast.toastId;\n        toast.scope.extraData = options.extraData;\n\n        toast.scope.options = {\n          extendedTimeOut: options.extendedTimeOut,\n          messageClass: options.messageClass,\n          onHidden: options.onHidden,\n          onShown: generateEvent('onShown'),\n          onTap: generateEvent('onTap'),\n          progressBar: options.progressBar,\n          tapToDismiss: options.tapToDismiss,\n          timeOut: options.timeOut,\n          titleClass: options.titleClass,\n          toastClass: options.toastClass\n        };\n\n        if (options.closeButton) {\n          toast.scope.options.closeHtml = options.closeHtml;\n        }\n\n        function generateEvent(event) {\n          if (options[event]) {\n            return function() {\n              options[event](toast);\n            };\n          }\n        }\n      }\n\n      function createToast() {\n        var newToast = {\n          toastId: index++,\n          isOpened: false,\n          scope: $rootScope.$new(),\n          open: $q.defer()\n        };\n        newToast.iconClass = map.iconClass;\n        if (map.optionsOverride) {\n          angular.extend(options, cleanOptionsOverride(map.optionsOverride));\n          newToast.iconClass = map.optionsOverride.iconClass || newToast.iconClass;\n        }\n\n        createScope(newToast, map, options);\n\n        newToast.el = createToastEl(newToast.scope);\n\n        return newToast;\n\n        function cleanOptionsOverride(options) {\n          var badOptions = ['containerId', 'iconClasses', 'maxOpened', 'newestOnTop',\n                            'positionClass', 'preventDuplicates', 'preventOpenDuplicates', 'templates'];\n          for (var i = 0, l = badOptions.length; i < l; i++) {\n            delete options[badOptions[i]];\n          }\n\n          return options;\n        }\n      }\n\n      function createToastEl(scope) {\n        var angularDomEl = angular.element('<div toast></div>'),\n          $compile = $injector.get('$compile');\n        return $compile(angularDomEl)(scope);\n      }\n\n      function maxOpenedNotReached() {\n        return options.maxOpened && toasts.length <= options.maxOpened || !options.maxOpened;\n      }\n\n      function shouldExit() {\n        var isDuplicateOfLast = options.preventDuplicates && map.message === previousToastMessage;\n        var isDuplicateOpen = options.preventOpenDuplicates && openToasts[map.message];\n\n        if (isDuplicateOfLast || isDuplicateOpen) {\n          return true;\n        }\n\n        previousToastMessage = map.message;\n        openToasts[map.message] = true;\n\n        return false;\n      }\n    }\n  }\n}());\n\n(function() {\n  'use strict';\n\n  angular.module('toastr')\n    .constant('toastrConfig', {\n      allowHtml: false,\n      autoDismiss: false,\n      closeButton: false,\n      closeHtml: '<button>&times;</button>',\n      containerId: 'toast-container',\n      extendedTimeOut: 1000,\n      iconClasses: {\n        error: 'toast-error',\n        info: 'toast-info',\n        success: 'toast-success',\n        warning: 'toast-warning'\n      },\n      maxOpened: 0,\n      messageClass: 'toast-message',\n      newestOnTop: true,\n      onHidden: null,\n      onShown: null,\n      onTap: null,\n      positionClass: 'toast-top-right',\n      preventDuplicates: false,\n      preventOpenDuplicates: false,\n      progressBar: false,\n      tapToDismiss: true,\n      target: 'body',\n      templates: {\n        toast: 'directives/toast/toast.html',\n        progressbar: 'directives/progressbar/progressbar.html'\n      },\n      timeOut: 5000,\n      titleClass: 'toast-title',\n      toastClass: 'toast'\n    });\n}());\n\n(function() {\n  'use strict';\n\n  angular.module('toastr')\n    .directive('progressBar', progressBar);\n\n  progressBar.$inject = ['toastrConfig'];\n\n  function progressBar(toastrConfig) {\n    return {\n      require: '^toast',\n      templateUrl: function() {\n        return toastrConfig.templates.progressbar;\n      },\n      link: linkFunction\n    };\n\n    function linkFunction(scope, element, attrs, toastCtrl) {\n      var intervalId, currentTimeOut, hideTime;\n\n      toastCtrl.progressBar = scope;\n\n      scope.start = function(duration) {\n        if (intervalId) {\n          clearInterval(intervalId);\n        }\n\n        currentTimeOut = parseFloat(duration);\n        hideTime = new Date().getTime() + currentTimeOut;\n        intervalId = setInterval(updateProgress, 10);\n      };\n\n      scope.stop = function() {\n        if (intervalId) {\n          clearInterval(intervalId);\n        }\n      };\n\n      function updateProgress() {\n        var percentage = ((hideTime - (new Date().getTime())) / currentTimeOut) * 100;\n        element.css('width', percentage + '%');\n      }\n\n      scope.$on('$destroy', function() {\n        // Failsafe stop\n        clearInterval(intervalId);\n      });\n    }\n  }\n}());\n\n(function() {\n  'use strict';\n\n  angular.module('toastr')\n    .controller('ToastController', ToastController);\n\n  function ToastController() {\n    this.progressBar = null;\n\n    this.startProgressBar = function(duration) {\n      if (this.progressBar) {\n        this.progressBar.start(duration);\n      }\n    };\n\n    this.stopProgressBar = function() {\n      if (this.progressBar) {\n        this.progressBar.stop();\n      }\n    };\n  }\n}());\n\n(function() {\n  'use strict';\n\n  angular.module('toastr')\n    .directive('toast', toast);\n\n  toast.$inject = ['$injector', '$interval', 'toastrConfig', 'toastr'];\n\n  function toast($injector, $interval, toastrConfig, toastr) {\n    return {\n      templateUrl: function() {\n        return toastrConfig.templates.toast;\n      },\n      controller: 'ToastController',\n      link: toastLinkFunction\n    };\n\n    function toastLinkFunction(scope, element, attrs, toastCtrl) {\n      var timeout;\n\n      scope.toastClass = scope.options.toastClass;\n      scope.titleClass = scope.options.titleClass;\n      scope.messageClass = scope.options.messageClass;\n      scope.progressBar = scope.options.progressBar;\n\n      if (wantsCloseButton()) {\n        var button = angular.element(scope.options.closeHtml),\n          $compile = $injector.get('$compile');\n        button.addClass('toast-close-button');\n        button.attr('ng-click', 'close(true, $event)');\n        $compile(button)(scope);\n        element.children().prepend(button);\n      }\n\n      scope.init = function() {\n        if (scope.options.timeOut) {\n          timeout = createTimeout(scope.options.timeOut);\n        }\n        if (scope.options.onShown) {\n          scope.options.onShown();\n        }\n      };\n\n      element.on('mouseenter', function() {\n        hideAndStopProgressBar();\n        if (timeout) {\n          $interval.cancel(timeout);\n        }\n      });\n\n      scope.tapToast = function () {\n        if (angular.isFunction(scope.options.onTap)) {\n          scope.options.onTap();\n        }\n        if (scope.options.tapToDismiss) {\n          scope.close(true);\n        }\n      };\n\n      scope.close = function (wasClicked, $event) {\n        if ($event && angular.isFunction($event.stopPropagation)) {\n          $event.stopPropagation();\n        }\n        toastr.remove(scope.toastId, wasClicked);\n      };\n      \n      scope.refreshTimer = function(newTime) {\n        if (timeout) {\n          $interval.cancel(timeout);\n          timeout = createTimeout(newTime || scope.options.timeOut);\n        }\n      };\n\n      element.on('mouseleave', function() {\n        if (scope.options.timeOut === 0 && scope.options.extendedTimeOut === 0) { return; }\n        scope.$apply(function() {\n          scope.progressBar = scope.options.progressBar;\n        });\n        timeout = createTimeout(scope.options.extendedTimeOut);\n      });\n\n      function createTimeout(time) {\n        toastCtrl.startProgressBar(time);\n        return $interval(function() {\n          toastCtrl.stopProgressBar();\n          toastr.remove(scope.toastId);\n        }, time, 1);\n      }\n\n      function hideAndStopProgressBar() {\n        scope.progressBar = false;\n        toastCtrl.stopProgressBar();\n      }\n\n      function wantsCloseButton() {\n        return scope.options.closeHtml;\n      }\n    }\n  }\n}());\n\nangular.module(\"toastr\").run([\"$templateCache\", function($templateCache) {$templateCache.put(\"directives/progressbar/progressbar.html\",\"<div class=\\\"toast-progress\\\"></div>\\n\");\n$templateCache.put(\"directives/toast/toast.html\",\"<div class=\\\"{{toastClass}} {{toastType}}\\\" ng-click=\\\"tapToast()\\\">\\n  <div ng-switch on=\\\"allowHtml\\\">\\n    <div ng-switch-default ng-if=\\\"title\\\" class=\\\"{{titleClass}}\\\" aria-label=\\\"{{title}}\\\">{{title}}</div>\\n    <div ng-switch-default class=\\\"{{messageClass}}\\\" aria-label=\\\"{{message}}\\\">{{message}}</div>\\n    <div ng-switch-when=\\\"true\\\" ng-if=\\\"title\\\" class=\\\"{{titleClass}}\\\" ng-bind-html=\\\"title\\\"></div>\\n    <div ng-switch-when=\\\"true\\\" class=\\\"{{messageClass}}\\\" ng-bind-html=\\\"message\\\"></div>\\n  </div>\\n  <progress-bar ng-if=\\\"progressBar\\\"></progress-bar>\\n</div>\\n\");}]);","/*\n * angular-tooltips\n * 1.1.10\n *\n * Angular.js tooltips module.\n * http://720kb.github.io/angular-tooltips\n *\n * MIT license\n * Wed Jan 25 2017\n */\n/*global angular,window*/\n(function withAngular(angular, window) {\n  'use strict';\n\n  var directiveName = 'tooltips'\n  , resizeObserver = (function resizeObserver() {\n\n    var callbacks = []\n      , lastTime = 0\n      , runCallbacks = function runCallbacks(currentTime) {\n\n        if (currentTime - lastTime >= 15) {\n\n          callbacks.forEach(function iterator(callback) {\n\n            callback();\n          });\n          lastTime = currentTime;\n        } else {\n\n          window.console.log('Skipped!');\n        }\n      }\n      , resizeTimeout\n      , resize = function resize() {\n        window.clearTimeout(resizeTimeout);\n        resizeTimeout = window.setTimeout(function onResizeTimeout() {\n          window.requestAnimationFrame(runCallbacks);\n        }, 500);\n      }\n      , addCallback = function addCallback(callback) {\n\n        if (callback) {\n\n          callbacks.push(callback);\n        }\n      };\n\n    return {\n      'add': function add(callback) {\n\n        if (!callbacks.length) {\n\n          window.addEventListener('resize', resize);\n        }\n        addCallback(callback);\n      },\n      'remove': function remove() {\n        if (!callbacks.length) {\n          window.clearTimeout(resizeTimeout);\n          window.removeEventListener('resize', resize);\n        }\n      }\n    };\n  }())\n  , getAttributesToAdd = function getAttributesToAdd(element) {\n    var attributesToAdd = {};\n\n    element.removeAttr(directiveName);\n    if (element.attr('tooltip-template') !== undefined) {\n\n      attributesToAdd['tooltip-template'] = element.attr('tooltip-template');\n      element.removeAttr('tooltip-template');\n    }\n\n    if (element.attr('tooltip-template-url') !== undefined) {\n\n      attributesToAdd['tooltip-template-url'] = element.attr('tooltip-template-url');\n      element.removeAttr('tooltip-template-url');\n    }\n\n    if (element.attr('tooltip-template-url-cache') !== undefined) {\n\n      attributesToAdd['tooltip-template-url-cache'] = element.attr('tooltip-template-url-cache');\n      element.removeAttr('tooltip-template-url-cache');\n    }\n\n    if (element.attr('tooltip-controller') !== undefined) {\n\n      attributesToAdd['tooltip-controller'] = element.attr('tooltip-controller');\n      element.removeAttr('tooltip-controller');\n    }\n\n    if (element.attr('tooltip-side') !== undefined) {\n\n      attributesToAdd['tooltip-side'] = element.attr('tooltip-side');\n      element.removeAttr('tooltip-side');\n    }\n\n    if (element.attr('tooltip-show-trigger') !== undefined) {\n\n      attributesToAdd['tooltip-show-trigger'] = element.attr('tooltip-show-trigger');\n      element.removeAttr('tooltip-show-trigger');\n    }\n\n    if (element.attr('tooltip-hide-trigger') !== undefined) {\n\n      attributesToAdd['tooltip-hide-trigger'] = element.attr('tooltip-hide-trigger');\n      element.removeAttr('tooltip-hide-trigger');\n    }\n\n    if (element.attr('tooltip-smart') !== undefined) {\n\n      attributesToAdd['tooltip-smart'] = element.attr('tooltip-smart');\n      element.removeAttr('tooltip-smart');\n    }\n\n    if (element.attr('tooltip-class') !== undefined) {\n\n      attributesToAdd['tooltip-class'] = element.attr('tooltip-class');\n      element.removeAttr('tooltip-class');\n    }\n\n    if (element.attr('tooltip-close-button') !== undefined) {\n\n      attributesToAdd['tooltip-close-button'] = element.attr('tooltip-close-button');\n      element.removeAttr('tooltip-close-button');\n    }\n\n    if (element.attr('tooltip-size') !== undefined) {\n\n      attributesToAdd['tooltip-size'] = element.attr('tooltip-size');\n      element.removeAttr('tooltip-size');\n    }\n\n    if (element.attr('tooltip-speed') !== undefined) {\n\n      attributesToAdd['tooltip-speed'] = element.attr('tooltip-speed');\n      element.removeAttr('tooltip-speed');\n    }\n\n    return attributesToAdd;\n  }\n  , getStyle = function getStyle(anElement) {\n\n    if (window.getComputedStyle) {\n\n      return window.getComputedStyle(anElement, '');\n    } else if (anElement.currentStyle) {\n\n      return anElement.currentStyle;\n    }\n  }\n  , getAppendedTip = function getAppendedTip(theTooltipElement) {\n    var tipsInBody = window.document.querySelectorAll('._exradicated-tooltip')\n      , aTipInBody\n      , tipsInBodyIndex = 0\n      , tipsInBodyLength = tipsInBody.length\n      , angularizedElement;\n\n    for (; tipsInBodyIndex < tipsInBodyLength; tipsInBodyIndex += 1) {\n\n      aTipInBody = tipsInBody.item(tipsInBodyIndex);\n      if (aTipInBody) {\n\n        angularizedElement = angular.element(aTipInBody);\n        if (angularizedElement.data('_tooltip-parent') &&\n          angularizedElement.data('_tooltip-parent') === theTooltipElement) {\n\n          return angularizedElement;\n        }\n      }\n    }\n  }\n  , removeAppendedTip = function removeAppendedTip(theTooltipElement) {\n    var tipElement = getAppendedTip(theTooltipElement);\n\n    if (tipElement) {\n\n      tipElement.remove();\n    }\n  }\n  , isOutOfPage = function isOutOfPage(theTipElement) {\n\n    if (theTipElement) {\n      var squarePosition = theTipElement[0].getBoundingClientRect();\n\n      if (squarePosition.top < 0 ||\n        squarePosition.top > window.document.body.offsetHeight ||\n        squarePosition.left < 0 ||\n        squarePosition.left > window.document.body.offsetWidth ||\n        squarePosition.bottom < 0 ||\n        squarePosition.bottom > window.document.body.offsetHeight ||\n        squarePosition.right < 0 ||\n        squarePosition.right > window.document.body.offsetWidth) {\n\n        theTipElement.css({\n          'top': '',\n          'left': '',\n          'bottom': '',\n          'right': ''\n        });\n        return true;\n      }\n\n      return false;\n    }\n\n    throw new Error('You must provide a position');\n  }\n  , tooltipConfigurationProvider = function tooltipConfigurationProvider() {\n\n    var tooltipConfiguration = {\n      'side': 'top',\n      'showTrigger': 'mouseenter',\n      'hideTrigger': 'mouseleave',\n      'class': '',\n      'smart': false,\n      'closeButton': false,\n      'size': '',\n      'speed': 'steady',\n      'tooltipTemplateUrlCache': false\n    };\n\n    return {\n      'configure': function configure(configuration) {\n        var configurationKeys = Object.keys(tooltipConfiguration)\n          , configurationIndex = 0\n          , aConfigurationKey;\n\n        if (configuration) {\n\n          for (; configurationIndex < configurationKeys.length; configurationIndex += 1) {\n\n            aConfigurationKey = configurationKeys[configurationIndex];\n            if (aConfigurationKey &&\n              configuration[aConfigurationKey]) {\n\n              tooltipConfiguration[aConfigurationKey] = configuration[aConfigurationKey];\n            }\n          }\n        }\n      },\n      '$get': /*@ngInject*/ function instantiateProvider() {\n\n        return tooltipConfiguration;\n      }\n    };\n  }\n  , tooltipDirective = /*@ngInject*/ ['$log', '$http', '$compile', '$timeout', '$controller', '$injector', 'tooltipsConf', '$templateCache', function tooltipDirective($log, $http, $compile, $timeout, $controller, $injector, tooltipsConf, $templateCache) {\n\n    var linkingFunction = function linkingFunction($scope, $element, $attrs, $controllerDirective, $transcludeFunc) {\n\n      if ($attrs.tooltipTemplate &&\n        $attrs.tooltipTemplateUrl) {\n\n        throw new Error('You can not define tooltip-template and tooltip-template-url together');\n      }\n\n      if (!($attrs.tooltipTemplateUrl || $attrs.tooltipTemplate) &&\n        $attrs.tooltipController) {\n\n        throw new Error('You can not have a controller without a template or templateUrl defined');\n      }\n\n      var oldTooltipSide = '_' + tooltipsConf.side\n        , oldTooltipShowTrigger = tooltipsConf.showTrigger\n        , oldTooltipHideTrigger = tooltipsConf.hideTrigger\n        , oldTooltipClass\n        , oldSize = tooltipsConf.size\n        , oldSpeed = '_' + tooltipsConf.speed;\n\n      $attrs.tooltipSide = $attrs.tooltipSide || tooltipsConf.side;\n      $attrs.tooltipShowTrigger = $attrs.tooltipShowTrigger || tooltipsConf.showTrigger;\n      $attrs.tooltipHideTrigger = $attrs.tooltipHideTrigger || tooltipsConf.hideTrigger;\n      $attrs.tooltipClass = $attrs.tooltipClass || tooltipsConf.class;\n      $attrs.tooltipSmart = $attrs.tooltipSmart === 'true' || tooltipsConf.smart;\n      $attrs.tooltipCloseButton = $attrs.tooltipCloseButton || tooltipsConf.closeButton.toString();\n      $attrs.tooltipSize = $attrs.tooltipSize || tooltipsConf.size;\n      $attrs.tooltipSpeed = $attrs.tooltipSpeed || tooltipsConf.speed;\n      $attrs.tooltipAppendToBody = $attrs.tooltipAppendToBody === 'true';\n\n      $transcludeFunc($scope, function onTransclusionDone(element, scope) {\n        var attributes = getAttributesToAdd(element)\n          , tooltipElement = angular.element(window.document.createElement('tooltip'))\n          , tipContElement = angular.element(window.document.createElement('tip-cont'))\n          , tipElement = angular.element(window.document.createElement('tip'))\n          , tipTipElement = angular.element(window.document.createElement('tip-tip'))\n          , closeButtonElement = angular.element(window.document.createElement('span'))\n          , tipArrowElement = angular.element(window.document.createElement('tip-arrow'))\n          , whenActivateMultilineCalculation = function whenActivateMultilineCalculation() {\n\n            return tipContElement.html();\n          }\n          , calculateIfMultiLine = function calculateIfMultiLine(newValue) {\n\n            if (newValue !== undefined &&\n              tipContElement[0].getClientRects().length > 1) {\n\n              tooltipElement.addClass('_multiline');\n            } else {\n\n              tooltipElement.removeClass('_multiline');\n            }\n          }\n          , onTooltipShow = function onTooltipShow(event) {\n\n            tipElement.addClass('_hidden');\n            if ($attrs.tooltipSmart) {\n\n              switch ($attrs.tooltipSide) {\n                case 'top': {\n\n                  if (isOutOfPage(tipElement)) {\n\n                    tooltipElement.removeClass('_top');\n                    tooltipElement.addClass('_left');\n                    if (isOutOfPage(tipElement)) {\n\n                      tooltipElement.removeClass('_left');\n                      tooltipElement.addClass('_bottom');\n                      if (isOutOfPage(tipElement)) {\n\n                        tooltipElement.removeClass('_bottom');\n                        tooltipElement.addClass('_right');\n                        if (isOutOfPage(tipElement)) {\n\n                          tooltipElement.removeClass('_right');\n                          tooltipElement.addClass('_top');\n                        }\n                      }\n                    }\n                  }\n                  break;\n                }\n\n                case 'left': {\n\n                  if (isOutOfPage(tipElement)) {\n\n                    tooltipElement.removeClass('_left');\n                    tooltipElement.addClass('_bottom');\n                    if (isOutOfPage(tipElement)) {\n\n                      tooltipElement.removeClass('_bottom');\n                      tooltipElement.addClass('_right');\n                      if (isOutOfPage(tipElement)) {\n\n                        tooltipElement.removeClass('_right');\n                        tooltipElement.addClass('_top');\n                        if (isOutOfPage(tipElement)) {\n\n                          tooltipElement.removeClass('_top');\n                          tooltipElement.addClass('_left');\n                        }\n                      }\n                    }\n                  }\n                  break;\n                }\n\n                case 'bottom': {\n\n                  if (isOutOfPage(tipElement)) {\n\n                    tooltipElement.removeClass('_bottom');\n                    tooltipElement.addClass('_left');\n                    if (isOutOfPage(tipElement)) {\n\n                      tooltipElement.removeClass('_left');\n                      tooltipElement.addClass('_top');\n                      if (isOutOfPage(tipElement)) {\n\n                        tooltipElement.removeClass('_top');\n                        tooltipElement.addClass('_right');\n                        if (isOutOfPage(tipElement)) {\n\n                          tooltipElement.removeClass('_right');\n                          tooltipElement.addClass('_bottom');\n                        }\n                      }\n                    }\n                  }\n                  break;\n                }\n\n                case 'right': {\n\n                  if (isOutOfPage(tipElement)) {\n\n                    tooltipElement.removeClass('_right');\n                    tooltipElement.addClass('_top');\n                    if (isOutOfPage(tipElement)) {\n\n                      tooltipElement.removeClass('_top');\n                      tooltipElement.addClass('_left');\n                      if (isOutOfPage(tipElement)) {\n\n                        tooltipElement.removeClass('_left');\n                        tooltipElement.addClass('_bottom');\n                        if (isOutOfPage(tipElement)) {\n\n                          tooltipElement.removeClass('_bottom');\n                          tooltipElement.addClass('_right');\n                        }\n                      }\n                    }\n                  }\n                  break;\n                }\n                default: {\n\n                  throw new Error('Position not supported');\n                }\n              }\n            }\n\n            if ($attrs.tooltipAppendToBody) {\n\n              var tipTipElementStyle = getStyle(tipTipElement[0])\n                , tipArrowElementStyle = getStyle(tipArrowElement[0])\n                , tipElementStyle = getStyle(tipElement[0])\n                , tipElementBoundingClientRect = tipElement[0].getBoundingClientRect()\n                , exradicatedTipElement = angular.copy(tipElement)\n                , tipTipStyleIndex = 0\n                , tipTipStyleLength = tipTipElementStyle.length\n                , tipArrowStyleIndex = 0\n                , tipArrowStyleLength = tipArrowElementStyle.length\n                , tipStyleIndex = 0\n                , tipStyleLength = tipElementStyle.length\n                , aStyleKey\n                , tipTipCssToSet = {}\n                , tipCssToSet = {}\n                , tipArrowCssToSet = {}\n                , paddingTopValue\n                , paddingBottomValue\n                , paddingLeftValue\n                , paddingRightValue;\n\n              tipElement.removeClass('_hidden');\n              exradicatedTipElement.removeClass('_hidden');\n              exradicatedTipElement.data('_tooltip-parent', tooltipElement);\n              removeAppendedTip(tooltipElement);\n\n              for (; tipTipStyleIndex < tipTipStyleLength; tipTipStyleIndex += 1) {\n\n                aStyleKey = tipTipElementStyle[tipTipStyleIndex];\n                if (aStyleKey &&\n                  tipTipElementStyle.getPropertyValue(aStyleKey)) {\n\n                  tipTipCssToSet[aStyleKey] = tipTipElementStyle.getPropertyValue(aStyleKey);\n                }\n              }\n\n              for (; tipArrowStyleIndex < tipArrowStyleLength; tipArrowStyleIndex += 1) {\n\n                aStyleKey = tipArrowElementStyle[tipArrowStyleIndex];\n                if (aStyleKey &&\n                  tipArrowElementStyle.getPropertyValue(aStyleKey)) {\n\n                  tipArrowCssToSet[aStyleKey] = tipArrowElementStyle.getPropertyValue(aStyleKey);\n                }\n              }\n\n              for (; tipStyleIndex < tipStyleLength; tipStyleIndex += 1) {\n\n                aStyleKey = tipElementStyle[tipStyleIndex];\n                if (aStyleKey &&\n                    aStyleKey !== 'position' &&\n                    aStyleKey !== 'display' &&\n                    aStyleKey !== 'opacity' &&\n                    aStyleKey !== 'z-index' &&\n                    aStyleKey !== 'bottom' &&\n                    aStyleKey !== 'height' &&\n                    aStyleKey !== 'left' &&\n                    aStyleKey !== 'right' &&\n                    aStyleKey !== 'top' &&\n                    aStyleKey !== 'width' &&\n                  tipElementStyle.getPropertyValue(aStyleKey)) {\n\n                  tipCssToSet[aStyleKey] = tipElementStyle.getPropertyValue(aStyleKey);\n                }\n              }\n              paddingTopValue = window.parseInt(tipElementStyle.getPropertyValue('padding-top'), 10);\n              paddingBottomValue = window.parseInt(tipElementStyle.getPropertyValue('padding-bottom'), 10);\n              paddingLeftValue = window.parseInt(tipElementStyle.getPropertyValue('padding-left'), 10);\n              paddingRightValue = window.parseInt(tipElementStyle.getPropertyValue('padding-right'), 10);\n\n              tipCssToSet.top = tipElementBoundingClientRect.top + window.pageYOffset + 'px';\n              tipCssToSet.left = tipElementBoundingClientRect.left + window.pageXOffset + 'px';\n              tipCssToSet.height = tipElementBoundingClientRect.height - (paddingTopValue + paddingBottomValue) + 'px';\n              tipCssToSet.width = tipElementBoundingClientRect.width - (paddingLeftValue + paddingRightValue) + 'px';\n\n              exradicatedTipElement.css(tipCssToSet);\n\n              exradicatedTipElement.children().css(tipTipCssToSet);\n              exradicatedTipElement.children().next().css(tipArrowCssToSet);\n              if (event &&\n                $attrs.tooltipHidden !== 'true') {\n\n                exradicatedTipElement.addClass('_exradicated-tooltip');\n                angular.element(window.document.body).append(exradicatedTipElement);\n              }\n            } else {\n\n              tipElement.removeClass('_hidden');\n              if (event &&\n                $attrs.tooltipHidden !== 'true') {\n\n                tooltipElement.addClass('active');\n              }\n            }\n          }\n          , onTooltipHide = function onTooltipHide() {\n\n            if ($attrs.tooltipAppendToBody) {\n\n              removeAppendedTip(tooltipElement);\n            } else {\n\n              tooltipElement.removeClass('active');\n            }\n          }\n          , registerOnScrollFrom = function registerOnScrollFrom(theElement) {\n            var parentElement = theElement.parent()\n              , timer;\n\n            if (theElement[0] &&\n              (theElement[0].scrollHeight > theElement[0].clientHeight ||\n              theElement[0].scrollWidth > theElement[0].clientWidth)) {\n\n              theElement.on('scroll', function onScroll() {\n                var that = this;\n\n                if (timer) {\n\n                  $timeout.cancel(timer);\n                }\n\n                timer = $timeout(function doLater() {\n\n                  var theTipElement = getAppendedTip(tooltipElement)\n                    , tooltipBoundingRect = tooltipElement[0].getBoundingClientRect()\n                    , thatBoundingRect = that.getBoundingClientRect();\n\n                  if (tooltipBoundingRect.top < thatBoundingRect.top ||\n                    tooltipBoundingRect.bottom > thatBoundingRect.bottom ||\n                    tooltipBoundingRect.left < thatBoundingRect.left ||\n                    tooltipBoundingRect.right > thatBoundingRect.right) {\n\n                    removeAppendedTip(tooltipElement);\n                  } else if (theTipElement) {\n\n                    onTooltipShow(true);\n                  }\n                });\n              });\n            }\n\n            if (parentElement &&\n              parentElement.length) {\n\n              registerOnScrollFrom(parentElement);\n            }\n          }\n          , onTooltipTemplateChange = function onTooltipTemplateChange(newValue) {\n            if (newValue) {\n              tooltipElement.removeClass('_force-hidden'); //see lines below, this forces to hide tooltip when is empty\n              tipTipElement.empty();\n              tipTipElement.append(closeButtonElement);\n              tipTipElement.append(newValue);\n              $timeout(function doLaterShow() {\n\n                onTooltipShow();\n              });\n            } else {\n              //hide tooltip because is empty\n              tipTipElement.empty();\n              tooltipElement.addClass('_force-hidden'); //force to be hidden if empty\n            }\n          }\n          , onTooltipTemplateUrlChange = function onTooltipTemplateUrlChange(newValue) {\n            if (newValue && !$attrs.tooltipTemplateUrlCache) {\n\n              $http.get(newValue).then(function onResponse(response) {\n\n                if (response &&\n                  response.data) {\n\n                  tooltipElement.removeClass('_force-hidden'); //see lines below, this forces to hide tooltip when is empty\n                  tipTipElement.empty();\n                  tipTipElement.append(closeButtonElement);\n                  tipTipElement.append($compile(response.data)(scope));\n                  $timeout(function doLater() {\n\n                    onTooltipShow();\n                  });\n                }\n              });\n            } else {\n              //hide tooltip because is empty\n              tipTipElement.empty();\n              tooltipElement.addClass('_force-hidden'); //force to be hidden if empty\n            }\n          }\n          , onTooltipTemplateUrlCacheChange = function onTooltipTemplateUrlCacheChange(newValue) {\n            if (newValue && $attrs.tooltipTemplateUrl) {\n\n              var template = $templateCache.get($attrs.tooltipTemplateUrl);\n\n              if (typeof template !== 'undefined') {\n\n                tooltipElement.removeClass('_force-hidden'); //see lines below, this forces to hide tooltip when is empty\n                tipTipElement.empty();\n                tipTipElement.append(closeButtonElement);\n                tipTipElement.append($compile(template)(scope));\n                $timeout(function doLater() {\n                  onTooltipShow();\n                });\n              }\n            } else {\n              //hide tooltip because is empty\n              tipTipElement.empty();\n              tooltipElement.addClass('_force-hidden'); //force to be hidden if empty\n            }\n          }\n          , onTooltipSideChange = function onTooltipSideChange(newValue) {\n\n            if (newValue) {\n\n              if (oldTooltipSide) {\n\n                tooltipElement.removeAttr('_' + oldTooltipSide);\n              }\n              tooltipElement.addClass('_' + newValue);\n              oldTooltipSide = newValue;\n            }\n          }\n          , onTooltipShowTrigger = function onTooltipShowTrigger(newValue) {\n\n            if (newValue) {\n\n              if (oldTooltipShowTrigger) {\n\n                tooltipElement.off(oldTooltipShowTrigger);\n              }\n              tooltipElement.on(newValue, onTooltipShow);\n              oldTooltipShowTrigger = newValue;\n            }\n          }\n          , onTooltipHideTrigger = function onTooltipHideTrigger(newValue) {\n\n            if (newValue) {\n\n              if (oldTooltipHideTrigger) {\n\n                tooltipElement.off(oldTooltipHideTrigger);\n              }\n              tooltipElement.on(newValue, onTooltipHide);\n              oldTooltipHideTrigger = newValue;\n            }\n          }\n          , onTooltipClassChange = function onTooltipClassChange(newValue) {\n\n            if (newValue) {\n\n              if (oldTooltipClass) {\n\n                tipElement.removeClass(oldTooltipClass);\n              }\n              tipElement.addClass(newValue);\n              oldTooltipClass = newValue;\n            }\n          }\n          , onTooltipSmartChange = function onTooltipSmartChange() {\n\n            if (typeof $attrs.tooltipSmart !== 'boolean') {\n\n              $attrs.tooltipSmart = $attrs.tooltipSmart === 'true';\n            }\n          }\n          , onTooltipCloseButtonChange = function onTooltipCloseButtonChange(newValue) {\n            var enableButton = newValue === 'true';\n\n            if (enableButton) {\n\n              closeButtonElement.on('click', onTooltipHide);\n              closeButtonElement.css('display', 'block');\n            } else {\n\n              closeButtonElement.off('click');\n              closeButtonElement.css('display', 'none');\n            }\n          }\n          , onTooltipTemplateControllerChange = function onTooltipTemplateControllerChange(newValue) {\n\n            if (newValue) {\n\n              var tipController = $controller(newValue, {\n                  '$scope': scope\n                })\n                , newScope = scope.$new(false, scope)\n                , indexOfAs = newValue.indexOf('as')\n                , controllerName;\n\n              if (indexOfAs >= 0) {\n\n                controllerName = newValue.substr(indexOfAs + 3);\n                newScope[controllerName] = tipController;\n              } else {\n\n                angular.extend(newScope, tipController);\n              }\n\n              tipTipElement.replaceWith($compile(tipTipElement)(newScope));\n              /*eslint-disable no-use-before-define*/\n              unregisterOnTooltipControllerChange();\n              /*eslint-enable no-use-before-define*/\n            }\n          }\n          , onTooltipSizeChange = function onTooltipSizeChange(newValue) {\n\n            if (newValue) {\n\n              if (oldSize) {\n\n                tipTipElement.removeClass('_' + oldSize);\n              }\n              tipTipElement.addClass('_' + newValue);\n              oldSize = newValue;\n            }\n          }\n          , onTooltipSpeedChange = function onTooltipSpeedChange(newValue) {\n\n            if (newValue) {\n\n              if (oldSpeed) {\n\n                tooltipElement.removeClass('_' + oldSpeed);\n              }\n              tooltipElement.addClass('_' + newValue);\n              oldSpeed = newValue;\n            }\n          }\n          , unregisterOnTooltipTemplateChange = $attrs.$observe('tooltipTemplate', onTooltipTemplateChange)\n          , unregisterOnTooltipTemplateUrlChange = $attrs.$observe('tooltipTemplateUrl', onTooltipTemplateUrlChange)\n          , unregisterOnTooltipTemplateUrlCacheChange = $attrs.$observe('tooltipTemplateUrlCache', onTooltipTemplateUrlCacheChange)\n          , unregisterOnTooltipSideChangeObserver = $attrs.$observe('tooltipSide', onTooltipSideChange)\n          , unregisterOnTooltipShowTrigger = $attrs.$observe('tooltipShowTrigger', onTooltipShowTrigger)\n          , unregisterOnTooltipHideTrigger = $attrs.$observe('tooltipHideTrigger', onTooltipHideTrigger)\n          , unregisterOnTooltipClassChange = $attrs.$observe('tooltipClass', onTooltipClassChange)\n          , unregisterOnTooltipSmartChange = $attrs.$observe('tooltipSmart', onTooltipSmartChange)\n          , unregisterOnTooltipCloseButtonChange = $attrs.$observe('tooltipCloseButton', onTooltipCloseButtonChange)\n          , unregisterOnTooltipControllerChange = $attrs.$observe('tooltipController', onTooltipTemplateControllerChange)\n          , unregisterOnTooltipSizeChange = $attrs.$observe('tooltipSize', onTooltipSizeChange)\n          , unregisterOnTooltipSpeedChange = $attrs.$observe('tooltipSpeed', onTooltipSpeedChange)\n          , unregisterTipContentChangeWatcher = scope.$watch(whenActivateMultilineCalculation, calculateIfMultiLine);\n\n        closeButtonElement.addClass('close-button');\n        closeButtonElement.html('&times;');\n\n        tipElement.addClass('_hidden');\n\n        tipTipElement.append(closeButtonElement);\n        tipTipElement.append($attrs.tooltipTemplate);\n\n        tipElement.append(tipTipElement);\n        tipElement.append(tipArrowElement);\n\n        tipContElement.append(element);\n\n        tooltipElement.attr(attributes);\n        tooltipElement.addClass('tooltips');\n\n        tooltipElement.append(tipContElement);\n        tooltipElement.append(tipElement);\n        $element.after(tooltipElement);\n\n        if ($attrs.tooltipAppendToBody) {\n\n          resizeObserver.add(function onResize() {\n\n            registerOnScrollFrom(tooltipElement);\n          });\n          registerOnScrollFrom(tooltipElement);\n        }\n\n        resizeObserver.add(function registerResize() {\n\n          calculateIfMultiLine();\n          onTooltipShow();\n        });\n\n        $timeout(function doLater() {\n\n          onTooltipShow();\n          tipElement.removeClass('_hidden');\n          tooltipElement.addClass('_ready');\n        });\n\n        scope.$on('$destroy', function unregisterListeners() {\n\n          unregisterOnTooltipTemplateChange();\n          unregisterOnTooltipTemplateUrlChange();\n          unregisterOnTooltipTemplateUrlCacheChange();\n          unregisterOnTooltipSideChangeObserver();\n          unregisterOnTooltipShowTrigger();\n          unregisterOnTooltipHideTrigger();\n          unregisterOnTooltipClassChange();\n          unregisterOnTooltipSmartChange();\n          unregisterOnTooltipCloseButtonChange();\n          unregisterOnTooltipSizeChange();\n          unregisterOnTooltipSpeedChange();\n          unregisterTipContentChangeWatcher();\n          resizeObserver.remove();\n          element.off($attrs.tooltipShowTrigger + ' ' + $attrs.tooltipHideTrigger);\n        });\n      });\n    };\n\n    return {\n      'restrict': 'A',\n      'transclude': 'element',\n      'priority': 1,\n      'terminal': true,\n      'link': linkingFunction\n    };\n  }];\n\n  angular.module('720kb.tooltips', [])\n  .provider(directiveName + 'Conf', tooltipConfigurationProvider)\n  .directive(directiveName, tooltipDirective);\n}(angular, window));\n","/*!\n * ui-select\n * http://github.com/angular-ui/ui-select\n * Version: 0.19.3 - 2016-08-17T06:16:41.345Z\n * License: MIT\n */\n\n\n(function () {\n\"use strict\";\nvar KEY = {\n    TAB: 9,\n    ENTER: 13,\n    ESC: 27,\n    SPACE: 32,\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n    SHIFT: 16,\n    CTRL: 17,\n    ALT: 18,\n    PAGE_UP: 33,\n    PAGE_DOWN: 34,\n    HOME: 36,\n    END: 35,\n    BACKSPACE: 8,\n    DELETE: 46,\n    COMMAND: 91,\n\n    MAP: { 91 : \"COMMAND\", 8 : \"BACKSPACE\" , 9 : \"TAB\" , 13 : \"ENTER\" , 16 : \"SHIFT\" , 17 : \"CTRL\" , 18 : \"ALT\" , 19 : \"PAUSEBREAK\" , 20 : \"CAPSLOCK\" , 27 : \"ESC\" , 32 : \"SPACE\" , 33 : \"PAGE_UP\", 34 : \"PAGE_DOWN\" , 35 : \"END\" , 36 : \"HOME\" , 37 : \"LEFT\" , 38 : \"UP\" , 39 : \"RIGHT\" , 40 : \"DOWN\" , 43 : \"+\" , 44 : \"PRINTSCREEN\" , 45 : \"INSERT\" , 46 : \"DELETE\", 48 : \"0\" , 49 : \"1\" , 50 : \"2\" , 51 : \"3\" , 52 : \"4\" , 53 : \"5\" , 54 : \"6\" , 55 : \"7\" , 56 : \"8\" , 57 : \"9\" , 59 : \";\", 61 : \"=\" , 65 : \"A\" , 66 : \"B\" , 67 : \"C\" , 68 : \"D\" , 69 : \"E\" , 70 : \"F\" , 71 : \"G\" , 72 : \"H\" , 73 : \"I\" , 74 : \"J\" , 75 : \"K\" , 76 : \"L\", 77 : \"M\" , 78 : \"N\" , 79 : \"O\" , 80 : \"P\" , 81 : \"Q\" , 82 : \"R\" , 83 : \"S\" , 84 : \"T\" , 85 : \"U\" , 86 : \"V\" , 87 : \"W\" , 88 : \"X\" , 89 : \"Y\" , 90 : \"Z\", 96 : \"0\" , 97 : \"1\" , 98 : \"2\" , 99 : \"3\" , 100 : \"4\" , 101 : \"5\" , 102 : \"6\" , 103 : \"7\" , 104 : \"8\" , 105 : \"9\", 106 : \"*\" , 107 : \"+\" , 109 : \"-\" , 110 : \".\" , 111 : \"/\", 112 : \"F1\" , 113 : \"F2\" , 114 : \"F3\" , 115 : \"F4\" , 116 : \"F5\" , 117 : \"F6\" , 118 : \"F7\" , 119 : \"F8\" , 120 : \"F9\" , 121 : \"F10\" , 122 : \"F11\" , 123 : \"F12\", 144 : \"NUMLOCK\" , 145 : \"SCROLLLOCK\" , 186 : \";\" , 187 : \"=\" , 188 : \",\" , 189 : \"-\" , 190 : \".\" , 191 : \"/\" , 192 : \"`\" , 219 : \"[\" , 220 : \"\\\\\" , 221 : \"]\" , 222 : \"'\"\n    },\n\n    isControl: function (e) {\n        var k = e.which;\n        switch (k) {\n        case KEY.COMMAND:\n        case KEY.SHIFT:\n        case KEY.CTRL:\n        case KEY.ALT:\n            return true;\n        }\n\n        if (e.metaKey || e.ctrlKey || e.altKey) return true;\n\n        return false;\n    },\n    isFunctionKey: function (k) {\n        k = k.which ? k.which : k;\n        return k >= 112 && k <= 123;\n    },\n    isVerticalMovement: function (k){\n      return ~[KEY.UP, KEY.DOWN].indexOf(k);\n    },\n    isHorizontalMovement: function (k){\n      return ~[KEY.LEFT,KEY.RIGHT,KEY.BACKSPACE,KEY.DELETE].indexOf(k);\n    },\n    toSeparator: function (k) {\n      var sep = {ENTER:\"\\n\",TAB:\"\\t\",SPACE:\" \"}[k];\n      if (sep) return sep;\n      // return undefined for special keys other than enter, tab or space.\n      // no way to use them to cut strings.\n      return KEY[k] ? undefined : k;\n    }\n  };\n\n/**\n * Add querySelectorAll() to jqLite.\n *\n * jqLite find() is limited to lookups by tag name.\n * TODO This will change with future versions of AngularJS, to be removed when this happens\n *\n * See jqLite.find - why not use querySelectorAll? https://github.com/angular/angular.js/issues/3586\n * See feat(jqLite): use querySelectorAll instead of getElementsByTagName in jqLite.find https://github.com/angular/angular.js/pull/3598\n */\nif (angular.element.prototype.querySelectorAll === undefined) {\n  angular.element.prototype.querySelectorAll = function(selector) {\n    return angular.element(this[0].querySelectorAll(selector));\n  };\n}\n\n/**\n * Add closest() to jqLite.\n */\nif (angular.element.prototype.closest === undefined) {\n  angular.element.prototype.closest = function( selector) {\n    var elem = this[0];\n    var matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector;\n\n    while (elem) {\n      if (matchesSelector.bind(elem)(selector)) {\n        return elem;\n      } else {\n        elem = elem.parentElement;\n      }\n    }\n    return false;\n  };\n}\n\nvar latestId = 0;\n\nvar uis = angular.module('ui.select', [])\n\n.constant('uiSelectConfig', {\n  theme: 'bootstrap',\n  searchEnabled: true,\n  sortable: false,\n  placeholder: '', // Empty by default, like HTML tag <select>\n  refreshDelay: 1000, // In milliseconds\n  closeOnSelect: true,\n  skipFocusser: false,\n  dropdownPosition: 'auto',\n  removeSelected: true,\n  resetSearchInput: true,\n  generateId: function() {\n    return latestId++;\n  },\n  appendToBody: false\n})\n\n// See Rename minErr and make it accessible from outside https://github.com/angular/angular.js/issues/6913\n.service('uiSelectMinErr', function() {\n  var minErr = angular.$$minErr('ui.select');\n  return function() {\n    var error = minErr.apply(this, arguments);\n    var message = error.message.replace(new RegExp('\\nhttp://errors.angularjs.org/.*'), '');\n    return new Error(message);\n  };\n})\n\n// Recreates old behavior of ng-transclude. Used internally.\n.directive('uisTranscludeAppend', function () {\n  return {\n    link: function (scope, element, attrs, ctrl, transclude) {\n        transclude(scope, function (clone) {\n          element.append(clone);\n        });\n      }\n    };\n})\n\n/**\n * Highlights text that matches $select.search.\n *\n * Taken from AngularUI Bootstrap Typeahead\n * See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L340\n */\n.filter('highlight', function() {\n  function escapeRegexp(queryToEscape) {\n    return ('' + queryToEscape).replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n  }\n\n  return function(matchItem, query) {\n    return query && matchItem ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<span class=\"ui-select-highlight\">$&</span>') : matchItem;\n  };\n})\n\n/**\n * A read-only equivalent of jQuery's offset function: http://api.jquery.com/offset/\n *\n * Taken from AngularUI Bootstrap Position:\n * See https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js#L70\n */\n.factory('uisOffset',\n  ['$document', '$window',\n  function ($document, $window) {\n\n  return function(element) {\n    var boundingClientRect = element[0].getBoundingClientRect();\n    return {\n      width: boundingClientRect.width || element.prop('offsetWidth'),\n      height: boundingClientRect.height || element.prop('offsetHeight'),\n      top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n      left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n    };\n  };\n}]);\n\nuis.directive('uiSelectChoices',\n  ['uiSelectConfig', 'uisRepeatParser', 'uiSelectMinErr', '$compile', '$window',\n  function(uiSelectConfig, RepeatParser, uiSelectMinErr, $compile, $window) {\n\n  return {\n    restrict: 'EA',\n    require: '^uiSelect',\n    replace: true,\n    transclude: true,\n    templateUrl: function(tElement) {\n      // Needed so the uiSelect can detect the transcluded content\n      tElement.addClass('ui-select-choices');\n\n      // Gets theme attribute from parent (ui-select)\n      var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;\n      return theme + '/choices.tpl.html';\n    },\n\n    compile: function(tElement, tAttrs) {\n\n      if (!tAttrs.repeat) throw uiSelectMinErr('repeat', \"Expected 'repeat' expression.\");\n\n      // var repeat = RepeatParser.parse(attrs.repeat);\n      var groupByExp = tAttrs.groupBy;\n      var groupFilterExp = tAttrs.groupFilter;\n\n      if (groupByExp) {\n        var groups = tElement.querySelectorAll('.ui-select-choices-group');\n        if (groups.length !== 1) throw uiSelectMinErr('rows', \"Expected 1 .ui-select-choices-group but got '{0}'.\", groups.length);\n        groups.attr('ng-repeat', RepeatParser.getGroupNgRepeatExpression());\n      }\n\n      var parserResult = RepeatParser.parse(tAttrs.repeat);\n\n      var choices = tElement.querySelectorAll('.ui-select-choices-row');\n      if (choices.length !== 1) {\n        throw uiSelectMinErr('rows', \"Expected 1 .ui-select-choices-row but got '{0}'.\", choices.length);\n      }\n\n      choices.attr('ng-repeat', parserResult.repeatExpression(groupByExp))\n             .attr('ng-if', '$select.open'); //Prevent unnecessary watches when dropdown is closed\n\n\n      var rowsInner = tElement.querySelectorAll('.ui-select-choices-row-inner');\n      if (rowsInner.length !== 1) {\n        throw uiSelectMinErr('rows', \"Expected 1 .ui-select-choices-row-inner but got '{0}'.\", rowsInner.length);\n      }\n      rowsInner.attr('uis-transclude-append', ''); //Adding uisTranscludeAppend directive to row element after choices element has ngRepeat\n\n      // If IE8 then need to target rowsInner to apply the ng-click attr as choices will not capture the event.\n      var clickTarget = $window.document.addEventListener ? choices : rowsInner;\n      clickTarget.attr('ng-click', '$select.select(' + parserResult.itemName + ',$select.skipFocusser,$event)');\n\n      return function link(scope, element, attrs, $select) {\n\n\n        $select.parseRepeatAttr(attrs.repeat, groupByExp, groupFilterExp); //Result ready at $select.parserResult\n\n        $select.disableChoiceExpression = attrs.uiDisableChoice;\n        $select.onHighlightCallback = attrs.onHighlight;\n\n        $select.dropdownPosition = attrs.position ? attrs.position.toLowerCase() : uiSelectConfig.dropdownPosition;\n\n        scope.$on('$destroy', function() {\n          choices.remove();\n        });\n\n        scope.$watch('$select.search', function(newValue) {\n          if(newValue && !$select.open && $select.multiple) $select.activate(false, true);\n          $select.activeIndex = $select.tagging.isActivated ? -1 : 0;\n          if (!attrs.minimumInputLength || $select.search.length >= attrs.minimumInputLength) {\n            $select.refresh(attrs.refresh);\n          } else {\n            $select.items = [];\n          }\n        });\n\n        attrs.$observe('refreshDelay', function() {\n          // $eval() is needed otherwise we get a string instead of a number\n          var refreshDelay = scope.$eval(attrs.refreshDelay);\n          $select.refreshDelay = refreshDelay !== undefined ? refreshDelay : uiSelectConfig.refreshDelay;\n        });\n      };\n    }\n  };\n}]);\n\n/**\n * Contains ui-select \"intelligence\".\n *\n * The goal is to limit dependency on the DOM whenever possible and\n * put as much logic in the controller (instead of the link functions) as possible so it can be easily tested.\n */\nuis.controller('uiSelectCtrl',\n  ['$scope', '$element', '$timeout', '$filter', '$$uisDebounce', 'uisRepeatParser', 'uiSelectMinErr', 'uiSelectConfig', '$parse', '$injector', '$window',\n  function($scope, $element, $timeout, $filter, $$uisDebounce, RepeatParser, uiSelectMinErr, uiSelectConfig, $parse, $injector, $window) {\n\n  var ctrl = this;\n\n  var EMPTY_SEARCH = '';\n\n  ctrl.placeholder = uiSelectConfig.placeholder;\n  ctrl.searchEnabled = uiSelectConfig.searchEnabled;\n  ctrl.sortable = uiSelectConfig.sortable;\n  ctrl.refreshDelay = uiSelectConfig.refreshDelay;\n  ctrl.paste = uiSelectConfig.paste;\n  ctrl.resetSearchInput = uiSelectConfig.resetSearchInput;\n\n  ctrl.removeSelected = uiSelectConfig.removeSelected; //If selected item(s) should be removed from dropdown list\n  ctrl.closeOnSelect = true; //Initialized inside uiSelect directive link function\n  ctrl.skipFocusser = false; //Set to true to avoid returning focus to ctrl when item is selected\n  ctrl.search = EMPTY_SEARCH;\n\n  ctrl.activeIndex = 0; //Dropdown of choices\n  ctrl.items = []; //All available choices\n\n  ctrl.open = false;\n  ctrl.focus = false;\n  ctrl.disabled = false;\n  ctrl.selected = undefined;\n\n  ctrl.dropdownPosition = 'auto';\n\n  ctrl.focusser = undefined; //Reference to input element used to handle focus events\n  ctrl.multiple = undefined; // Initialized inside uiSelect directive link function\n  ctrl.disableChoiceExpression = undefined; // Initialized inside uiSelectChoices directive link function\n  ctrl.tagging = {isActivated: false, fct: undefined};\n  ctrl.taggingTokens = {isActivated: false, tokens: undefined};\n  ctrl.lockChoiceExpression = undefined; // Initialized inside uiSelectMatch directive link function\n  ctrl.clickTriggeredSelect = false;\n  ctrl.$filter = $filter;\n  ctrl.$element = $element;\n\n  // Use $injector to check for $animate and store a reference to it\n  ctrl.$animate = (function () {\n    try {\n      return $injector.get('$animate');\n    } catch (err) {\n      // $animate does not exist\n      return null;\n    }\n  })();\n\n  ctrl.searchInput = $element.querySelectorAll('input.ui-select-search');\n  if (ctrl.searchInput.length !== 1) {\n    throw uiSelectMinErr('searchInput', \"Expected 1 input.ui-select-search but got '{0}'.\", ctrl.searchInput.length);\n  }\n\n  ctrl.isEmpty = function() {\n    return angular.isUndefined(ctrl.selected) || ctrl.selected === null || ctrl.selected === '' || (ctrl.multiple && ctrl.selected.length === 0);\n  };\n\n  function _findIndex(collection, predicate, thisArg){\n    if (collection.findIndex){\n      return collection.findIndex(predicate, thisArg);\n    } else {\n      var list = Object(collection);\n      var length = list.length >>> 0;\n      var value;\n\n      for (var i = 0; i < length; i++) {\n        value = list[i];\n        if (predicate.call(thisArg, value, i, list)) {\n          return i;\n        }\n      }\n      return -1;\n    }\n  }\n\n  // Most of the time the user does not want to empty the search input when in typeahead mode\n  function _resetSearchInput() {\n    if (ctrl.resetSearchInput) {\n      ctrl.search = EMPTY_SEARCH;\n      //reset activeIndex\n      if (ctrl.selected && ctrl.items.length && !ctrl.multiple) {\n        ctrl.activeIndex = _findIndex(ctrl.items, function(item){\n          return angular.equals(this, item);\n        }, ctrl.selected);\n      }\n    }\n  }\n\n    function _groupsFilter(groups, groupNames) {\n      var i, j, result = [];\n      for(i = 0; i < groupNames.length ;i++){\n        for(j = 0; j < groups.length ;j++){\n          if(groups[j].name == [groupNames[i]]){\n            result.push(groups[j]);\n          }\n        }\n      }\n      return result;\n    }\n\n  // When the user clicks on ui-select, displays the dropdown list\n  ctrl.activate = function(initSearchValue, avoidReset) {\n    if (!ctrl.disabled  && !ctrl.open) {\n      if(!avoidReset) _resetSearchInput();\n\n      $scope.$broadcast('uis:activate');\n\n      ctrl.open = true;\n\n      ctrl.activeIndex = ctrl.activeIndex >= ctrl.items.length ? 0 : ctrl.activeIndex;\n\n      // ensure that the index is set to zero for tagging variants\n      // that where first option is auto-selected\n      if ( ctrl.activeIndex === -1 && ctrl.taggingLabel !== false ) {\n        ctrl.activeIndex = 0;\n      }\n\n      var container = $element.querySelectorAll('.ui-select-choices-content');\n      var searchInput = $element.querySelectorAll('.ui-select-search');\n      if (ctrl.$animate && ctrl.$animate.on && ctrl.$animate.enabled(container[0])) {\n        var animateHandler = function(elem, phase) {\n          if (phase === 'start' && ctrl.items.length === 0) {\n            // Only focus input after the animation has finished\n            ctrl.$animate.off('removeClass', searchInput[0], animateHandler);\n            $timeout(function () {\n              ctrl.focusSearchInput(initSearchValue);\n            });\n          } else if (phase === 'close') {\n            // Only focus input after the animation has finished\n            ctrl.$animate.off('enter', container[0], animateHandler);\n            $timeout(function () {\n              ctrl.focusSearchInput(initSearchValue);\n            });\n          }\n        };\n\n        if (ctrl.items.length > 0) {\n          ctrl.$animate.on('enter', container[0], animateHandler);\n        } else {\n          ctrl.$animate.on('removeClass', searchInput[0], animateHandler);\n        }\n      } else {\n        $timeout(function () {\n          ctrl.focusSearchInput(initSearchValue);\n          if(!ctrl.tagging.isActivated && ctrl.items.length > 1) {\n            _ensureHighlightVisible();\n          }\n        });\n      }\n    }\n    else if (ctrl.open && !ctrl.searchEnabled) {\n      // Close the selection if we don't have search enabled, and we click on the select again\n      ctrl.close();\n    }\n  };\n\n  ctrl.focusSearchInput = function (initSearchValue) {\n    ctrl.search = initSearchValue || ctrl.search;\n    ctrl.searchInput[0].focus();\n  };\n\n  ctrl.findGroupByName = function(name) {\n    return ctrl.groups && ctrl.groups.filter(function(group) {\n      return group.name === name;\n    })[0];\n  };\n\n  ctrl.parseRepeatAttr = function(repeatAttr, groupByExp, groupFilterExp) {\n    function updateGroups(items) {\n      var groupFn = $scope.$eval(groupByExp);\n      ctrl.groups = [];\n      angular.forEach(items, function(item) {\n        var groupName = angular.isFunction(groupFn) ? groupFn(item) : item[groupFn];\n        var group = ctrl.findGroupByName(groupName);\n        if(group) {\n          group.items.push(item);\n        }\n        else {\n          ctrl.groups.push({name: groupName, items: [item]});\n        }\n      });\n      if(groupFilterExp){\n        var groupFilterFn = $scope.$eval(groupFilterExp);\n        if( angular.isFunction(groupFilterFn)){\n          ctrl.groups = groupFilterFn(ctrl.groups);\n        } else if(angular.isArray(groupFilterFn)){\n          ctrl.groups = _groupsFilter(ctrl.groups, groupFilterFn);\n        }\n      }\n      ctrl.items = [];\n      ctrl.groups.forEach(function(group) {\n        ctrl.items = ctrl.items.concat(group.items);\n      });\n    }\n\n    function setPlainItems(items) {\n      ctrl.items = items;\n    }\n\n    ctrl.setItemsFn = groupByExp ? updateGroups : setPlainItems;\n\n    ctrl.parserResult = RepeatParser.parse(repeatAttr);\n\n    ctrl.isGrouped = !!groupByExp;\n    ctrl.itemProperty = ctrl.parserResult.itemName;\n\n    //If collection is an Object, convert it to Array\n\n    var originalSource = ctrl.parserResult.source;\n\n    //When an object is used as source, we better create an array and use it as 'source'\n    var createArrayFromObject = function(){\n      var origSrc = originalSource($scope);\n      $scope.$uisSource = Object.keys(origSrc).map(function(v){\n        var result = {};\n        result[ctrl.parserResult.keyName] = v;\n        result.value = origSrc[v];\n        return result;\n      });\n    };\n\n    if (ctrl.parserResult.keyName){ // Check for (key,value) syntax\n      createArrayFromObject();\n      ctrl.parserResult.source = $parse('$uisSource' + ctrl.parserResult.filters);\n      $scope.$watch(originalSource, function(newVal, oldVal){\n        if (newVal !== oldVal) createArrayFromObject();\n      }, true);\n    }\n\n    ctrl.refreshItems = function (data){\n      data = data || ctrl.parserResult.source($scope);\n      var selectedItems = ctrl.selected;\n      //TODO should implement for single mode removeSelected\n      if (ctrl.isEmpty() || (angular.isArray(selectedItems) && !selectedItems.length) || !ctrl.multiple || !ctrl.removeSelected) {\n        ctrl.setItemsFn(data);\n      }else{\n        if ( data !== undefined && data !== null ) {\n          var filteredItems = data.filter(function(i) {\n            return angular.isArray(selectedItems) ? selectedItems.every(function(selectedItem) {\n              return !angular.equals(i, selectedItem);\n            }) : !angular.equals(i, selectedItems);\n          });\n          ctrl.setItemsFn(filteredItems);\n        }\n      }\n      if (ctrl.dropdownPosition === 'auto' || ctrl.dropdownPosition === 'up'){\n        $scope.calculateDropdownPos();\n      }\n\n      $scope.$broadcast('uis:refresh');\n    };\n\n    // See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L259\n    $scope.$watchCollection(ctrl.parserResult.source, function(items) {\n      if (items === undefined || items === null) {\n        // If the user specifies undefined or null => reset the collection\n        // Special case: items can be undefined if the user did not initialized the collection on the scope\n        // i.e $scope.addresses = [] is missing\n        ctrl.items = [];\n      } else {\n        if (!angular.isArray(items)) {\n          throw uiSelectMinErr('items', \"Expected an array but got '{0}'.\", items);\n        } else {\n          //Remove already selected items (ex: while searching)\n          //TODO Should add a test\n          ctrl.refreshItems(items);\n\n          //update the view value with fresh data from items, if there is a valid model value\n          if(angular.isDefined(ctrl.ngModel.$modelValue)) {\n            ctrl.ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters\n          }\n        }\n      }\n    });\n\n  };\n\n  var _refreshDelayPromise;\n\n  /**\n   * Typeahead mode: lets the user refresh the collection using his own function.\n   *\n   * See Expose $select.search for external / remote filtering https://github.com/angular-ui/ui-select/pull/31\n   */\n  ctrl.refresh = function(refreshAttr) {\n    if (refreshAttr !== undefined) {\n\n      // Debounce\n      // See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L155\n      // FYI AngularStrap typeahead does not have debouncing: https://github.com/mgcrea/angular-strap/blob/v2.0.0-rc.4/src/typeahead/typeahead.js#L177\n      if (_refreshDelayPromise) {\n        $timeout.cancel(_refreshDelayPromise);\n      }\n      _refreshDelayPromise = $timeout(function() {\n        $scope.$eval(refreshAttr);\n      }, ctrl.refreshDelay);\n    }\n  };\n\n  ctrl.isActive = function(itemScope) {\n    if ( !ctrl.open ) {\n      return false;\n    }\n    var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);\n    var isActive =  itemIndex == ctrl.activeIndex;\n\n    if ( !isActive || itemIndex < 0 ) {\n      return false;\n    }\n\n    if (isActive && !angular.isUndefined(ctrl.onHighlightCallback)) {\n      itemScope.$eval(ctrl.onHighlightCallback);\n    }\n\n    return isActive;\n  };\n\n  var _isItemSelected = function (item) {\n    return (ctrl.selected && angular.isArray(ctrl.selected) &&\n        ctrl.selected.filter(function (selection) { return angular.equals(selection, item); }).length > 0);\n  };\n\n  var disabledItems = [];\n\n  function _updateItemDisabled(item, isDisabled) {\n    var disabledItemIndex = disabledItems.indexOf(item);\n    if (isDisabled && disabledItemIndex === -1) {\n      disabledItems.push(item);\n    }\n\n    if (!isDisabled && disabledItemIndex > -1) {\n      disabledItems.splice(disabledItemIndex, 1);\n    }\n  }\n\n  function _isItemDisabled(item) {\n    return disabledItems.indexOf(item) > -1;\n  }\n\n  ctrl.isDisabled = function(itemScope) {\n\n    if (!ctrl.open) return;\n\n    var item = itemScope[ctrl.itemProperty];\n    var itemIndex = ctrl.items.indexOf(item);\n    var isDisabled = false;\n\n    if (itemIndex >= 0 && (angular.isDefined(ctrl.disableChoiceExpression) || ctrl.multiple)) {\n\n      if (item.isTag) return false;\n\n      if (ctrl.multiple) {\n        isDisabled = _isItemSelected(item);\n      }\n\n      if (!isDisabled && angular.isDefined(ctrl.disableChoiceExpression)) {\n        isDisabled = !!(itemScope.$eval(ctrl.disableChoiceExpression));\n      }\n\n      _updateItemDisabled(item, isDisabled);\n    }\n\n    return isDisabled;\n  };\n\n\n  // When the user selects an item with ENTER or clicks the dropdown\n  ctrl.select = function(item, skipFocusser, $event) {\n    if (item === undefined || !_isItemDisabled(item)) {\n\n      if ( ! ctrl.items && ! ctrl.search && ! ctrl.tagging.isActivated) return;\n\n      if (!item || !_isItemDisabled(item)) {\n        // if click is made on existing item, prevent from tagging, ctrl.search does not matter\n        ctrl.clickTriggeredSelect = false;\n        if($event && $event.type === 'click' && item)\n          ctrl.clickTriggeredSelect = true;\n\n        if(ctrl.tagging.isActivated && ctrl.clickTriggeredSelect === false) {\n          // if taggingLabel is disabled and item is undefined we pull from ctrl.search\n          if ( ctrl.taggingLabel === false ) {\n            if ( ctrl.activeIndex < 0 ) {\n              if (item === undefined) {\n                item = ctrl.tagging.fct !== undefined ? ctrl.tagging.fct(ctrl.search) : ctrl.search;\n              }\n              if (!item || angular.equals( ctrl.items[0], item ) ) {\n                return;\n              }\n            } else {\n              // keyboard nav happened first, user selected from dropdown\n              item = ctrl.items[ctrl.activeIndex];\n            }\n          } else {\n            // tagging always operates at index zero, taggingLabel === false pushes\n            // the ctrl.search value without having it injected\n            if ( ctrl.activeIndex === 0 ) {\n              // ctrl.tagging pushes items to ctrl.items, so we only have empty val\n              // for `item` if it is a detected duplicate\n              if ( item === undefined ) return;\n\n              // create new item on the fly if we don't already have one;\n              // use tagging function if we have one\n              if ( ctrl.tagging.fct !== undefined && typeof item === 'string' ) {\n                item = ctrl.tagging.fct(item);\n                if (!item) return;\n              // if item type is 'string', apply the tagging label\n              } else if ( typeof item === 'string' ) {\n                // trim the trailing space\n                item = item.replace(ctrl.taggingLabel,'').trim();\n              }\n            }\n          }\n          // search ctrl.selected for dupes potentially caused by tagging and return early if found\n          if (_isItemSelected(item)) {\n            ctrl.close(skipFocusser);\n            return;\n          }\n        }\n        _resetSearchInput();\n        $scope.$broadcast('uis:select', item);\n\n        var locals = {};\n        locals[ctrl.parserResult.itemName] = item;\n\n        $timeout(function(){\n          ctrl.onSelectCallback($scope, {\n            $item: item,\n            $model: ctrl.parserResult.modelMapper($scope, locals)\n          });\n        });\n\n        if (ctrl.closeOnSelect) {\n          ctrl.close(skipFocusser);\n        }\n      }\n    }\n  };\n\n  // Closes the dropdown\n  ctrl.close = function(skipFocusser) {\n    if (!ctrl.open) return;\n    if (ctrl.ngModel && ctrl.ngModel.$setTouched) ctrl.ngModel.$setTouched();\n    ctrl.open = false;\n    _resetSearchInput();\n    $scope.$broadcast('uis:close', skipFocusser);\n\n  };\n\n  ctrl.setFocus = function(){\n    if (!ctrl.focus) ctrl.focusInput[0].focus();\n  };\n\n  ctrl.clear = function($event) {\n    ctrl.select(undefined);\n    $event.stopPropagation();\n    $timeout(function() {\n      ctrl.focusser[0].focus();\n    }, 0, false);\n  };\n\n  // Toggle dropdown\n  ctrl.toggle = function(e) {\n    if (ctrl.open) {\n      ctrl.close();\n      e.preventDefault();\n      e.stopPropagation();\n    } else {\n      ctrl.activate();\n    }\n  };\n\n  // Set default function for locked choices - avoids unnecessary\n  // logic if functionality is not being used\n  ctrl.isLocked = function () {\n    return false;\n  };\n\n  $scope.$watch(function () {\n    return angular.isDefined(ctrl.lockChoiceExpression) && ctrl.lockChoiceExpression !== \"\";\n  }, _initaliseLockedChoices);\n\n  function _initaliseLockedChoices(doInitalise) {\n    if(!doInitalise) return;\n\n    var lockedItems = [];\n\n    function _updateItemLocked(item, isLocked) {\n      var lockedItemIndex = lockedItems.indexOf(item);\n      if (isLocked && lockedItemIndex === -1) {\n        lockedItems.push(item);\n        }\n\n      if (!isLocked && lockedItemIndex > -1) {\n        lockedItems.splice(lockedItemIndex, 0);\n      }\n    }\n\n    function _isItemlocked(item) {\n      return lockedItems.indexOf(item) > -1;\n    }\n\n    ctrl.isLocked = function (itemScope, itemIndex) {\n      var isLocked = false,\n          item = ctrl.selected[itemIndex];\n\n      if(item) {\n        if (itemScope) {\n          isLocked = !!(itemScope.$eval(ctrl.lockChoiceExpression));\n          _updateItemLocked(item, isLocked);\n        } else {\n          isLocked = _isItemlocked(item);\n        }\n      }\n\n      return isLocked;\n    };\n  }\n\n\n  var sizeWatch = null;\n  var updaterScheduled = false;\n  ctrl.sizeSearchInput = function() {\n\n    var input = ctrl.searchInput[0],\n        container = ctrl.searchInput.parent().parent()[0],\n        calculateContainerWidth = function() {\n          // Return the container width only if the search input is visible\n          return container.clientWidth * !!input.offsetParent;\n        },\n        updateIfVisible = function(containerWidth) {\n          if (containerWidth === 0) {\n            return false;\n          }\n          var inputWidth = containerWidth - input.offsetLeft - 10;\n          if (inputWidth < 50) inputWidth = containerWidth;\n          ctrl.searchInput.css('width', inputWidth+'px');\n          return true;\n        };\n\n    ctrl.searchInput.css('width', '10px');\n    $timeout(function() { //Give tags time to render correctly\n      if (sizeWatch === null && !updateIfVisible(calculateContainerWidth())) {\n        sizeWatch = $scope.$watch(function() {\n          if (!updaterScheduled) {\n            updaterScheduled = true;\n            $scope.$$postDigest(function() {\n              updaterScheduled = false;\n              if (updateIfVisible(calculateContainerWidth())) {\n                sizeWatch();\n                sizeWatch = null;\n              }\n            });\n          }\n        }, angular.noop);\n      }\n    });\n  };\n\n  function _handleDropDownSelection(key) {\n    var processed = true;\n    switch (key) {\n      case KEY.DOWN:\n        if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode\n        else if (ctrl.activeIndex < ctrl.items.length - 1) { ctrl.activeIndex++; }\n        break;\n      case KEY.UP:\n        if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode\n        else if (ctrl.activeIndex > 0 || (ctrl.search.length === 0 && ctrl.tagging.isActivated && ctrl.activeIndex > -1)) { ctrl.activeIndex--; }\n        break;\n      case KEY.TAB:\n        if (!ctrl.multiple || ctrl.open) ctrl.select(ctrl.items[ctrl.activeIndex], true);\n        break;\n      case KEY.ENTER:\n        if(ctrl.open && (ctrl.tagging.isActivated || ctrl.activeIndex >= 0)){\n          ctrl.select(ctrl.items[ctrl.activeIndex], ctrl.skipFocusser); // Make sure at least one dropdown item is highlighted before adding if not in tagging mode\n        } else {\n          ctrl.activate(false, true); //In case its the search input in 'multiple' mode\n        }\n        break;\n      case KEY.ESC:\n        ctrl.close();\n        break;\n      default:\n        processed = false;\n    }\n    return processed;\n  }\n\n  // Bind to keyboard shortcuts\n  ctrl.searchInput.on('keydown', function(e) {\n\n    var key = e.which;\n\n    if (~[KEY.ENTER,KEY.ESC].indexOf(key)){\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    // if(~[KEY.ESC,KEY.TAB].indexOf(key)){\n    //   //TODO: SEGURO?\n    //   ctrl.close();\n    // }\n\n    $scope.$apply(function() {\n\n      var tagged = false;\n\n      if (ctrl.items.length > 0 || ctrl.tagging.isActivated) {\n        if(!_handleDropDownSelection(key) && !ctrl.searchEnabled) {\n          e.preventDefault();\n          e.stopPropagation();\n        }\n        if ( ctrl.taggingTokens.isActivated ) {\n          for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {\n            if ( ctrl.taggingTokens.tokens[i] === KEY.MAP[e.keyCode] ) {\n              // make sure there is a new value to push via tagging\n              if ( ctrl.search.length > 0 ) {\n                tagged = true;\n              }\n            }\n          }\n          if ( tagged ) {\n            $timeout(function() {\n              ctrl.searchInput.triggerHandler('tagged');\n              var newItem = ctrl.search.replace(KEY.MAP[e.keyCode],'').trim();\n              if ( ctrl.tagging.fct ) {\n                newItem = ctrl.tagging.fct( newItem );\n              }\n              if (newItem) ctrl.select(newItem, true);\n            });\n          }\n        }\n      }\n\n    });\n\n    if(KEY.isVerticalMovement(key) && ctrl.items.length > 0){\n      _ensureHighlightVisible();\n    }\n\n    if (key === KEY.ENTER || key === KEY.ESC) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n  });\n\n  ctrl.searchInput.on('paste', function (e) {\n    var data;\n\n    if (window.clipboardData && window.clipboardData.getData) { // IE\n      data = window.clipboardData.getData('Text');\n    } else {\n      data = (e.originalEvent || e).clipboardData.getData('text/plain');\n    }\n\n    // Prepend the current input field text to the paste buffer.\n    data = ctrl.search + data;\n\n    if (data && data.length > 0) {\n      // If tagging try to split by tokens and add items\n      if (ctrl.taggingTokens.isActivated) {\n        var items = [];\n        for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {  // split by first token that is contained in data\n          var separator = KEY.toSeparator(ctrl.taggingTokens.tokens[i]) || ctrl.taggingTokens.tokens[i];\n          if (data.indexOf(separator) > -1) {\n            items = data.split(separator);\n            break;  // only split by one token\n          }\n        }\n        if (items.length === 0) {\n          items = [data];\n        }\n        var oldsearch = ctrl.search;\n        angular.forEach(items, function (item) {\n          var newItem = ctrl.tagging.fct ? ctrl.tagging.fct(item) : item;\n          if (newItem) {\n            ctrl.select(newItem, true);\n          }\n        });\n        ctrl.search = oldsearch || EMPTY_SEARCH;\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (ctrl.paste) {\n        ctrl.paste(data);\n        ctrl.search = EMPTY_SEARCH;\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  });\n\n  ctrl.searchInput.on('tagged', function() {\n    $timeout(function() {\n      _resetSearchInput();\n    });\n  });\n\n  // See https://github.com/ivaynberg/select2/blob/3.4.6/select2.js#L1431\n  function _ensureHighlightVisible() {\n    var container = $element.querySelectorAll('.ui-select-choices-content');\n    var choices = container.querySelectorAll('.ui-select-choices-row');\n    if (choices.length < 1) {\n      throw uiSelectMinErr('choices', \"Expected multiple .ui-select-choices-row but got '{0}'.\", choices.length);\n    }\n\n    if (ctrl.activeIndex < 0) {\n      return;\n    }\n\n    var highlighted = choices[ctrl.activeIndex];\n    var posY = highlighted.offsetTop + highlighted.clientHeight - container[0].scrollTop;\n    var height = container[0].offsetHeight;\n\n    if (posY > height) {\n      container[0].scrollTop += posY - height;\n    } else if (posY < highlighted.clientHeight) {\n      if (ctrl.isGrouped && ctrl.activeIndex === 0)\n        container[0].scrollTop = 0; //To make group header visible when going all the way up\n      else\n        container[0].scrollTop -= highlighted.clientHeight - posY;\n    }\n  }\n\n  var onResize = $$uisDebounce(function() {\n    ctrl.sizeSearchInput();\n  }, 50);\n\n  angular.element($window).bind('resize', onResize);\n\n  $scope.$on('$destroy', function() {\n    ctrl.searchInput.off('keyup keydown tagged blur paste');\n    angular.element($window).off('resize', onResize);\n  });\n}]);\n\nuis.directive('uiSelect',\n  ['$document', 'uiSelectConfig', 'uiSelectMinErr', 'uisOffset', '$compile', '$parse', '$timeout',\n  function($document, uiSelectConfig, uiSelectMinErr, uisOffset, $compile, $parse, $timeout) {\n\n  return {\n    restrict: 'EA',\n    templateUrl: function(tElement, tAttrs) {\n      var theme = tAttrs.theme || uiSelectConfig.theme;\n      return theme + (angular.isDefined(tAttrs.multiple) ? '/select-multiple.tpl.html' : '/select.tpl.html');\n    },\n    replace: true,\n    transclude: true,\n    require: ['uiSelect', '^ngModel'],\n    scope: true,\n\n    controller: 'uiSelectCtrl',\n    controllerAs: '$select',\n    compile: function(tElement, tAttrs) {\n\n      // Allow setting ngClass on uiSelect\n      var match = /{(.*)}\\s*{(.*)}/.exec(tAttrs.ngClass);\n      if(match) {\n        var combined = '{'+ match[1] +', '+ match[2] +'}';\n        tAttrs.ngClass = combined;\n        tElement.attr('ng-class', combined);\n      }\n\n      //Multiple or Single depending if multiple attribute presence\n      if (angular.isDefined(tAttrs.multiple))\n        tElement.append('<ui-select-multiple/>').removeAttr('multiple');\n      else\n        tElement.append('<ui-select-single/>');\n\n      if (tAttrs.inputId)\n        tElement.querySelectorAll('input.ui-select-search')[0].id = tAttrs.inputId;\n\n      return function(scope, element, attrs, ctrls, transcludeFn) {\n\n        var $select = ctrls[0];\n        var ngModel = ctrls[1];\n\n        $select.generatedId = uiSelectConfig.generateId();\n        $select.baseTitle = attrs.title || 'Select box';\n        $select.focusserTitle = $select.baseTitle + ' focus';\n        $select.focusserId = 'focusser-' + $select.generatedId;\n\n        $select.closeOnSelect = function() {\n          if (angular.isDefined(attrs.closeOnSelect)) {\n            return $parse(attrs.closeOnSelect)();\n          } else {\n            return uiSelectConfig.closeOnSelect;\n          }\n        }();\n\n        scope.$watch('skipFocusser', function() {\n            var skipFocusser = scope.$eval(attrs.skipFocusser);\n            $select.skipFocusser = skipFocusser !== undefined ? skipFocusser : uiSelectConfig.skipFocusser;\n        });\n\n        $select.onSelectCallback = $parse(attrs.onSelect);\n        $select.onRemoveCallback = $parse(attrs.onRemove);\n\n        //Set reference to ngModel from uiSelectCtrl\n        $select.ngModel = ngModel;\n\n        $select.choiceGrouped = function(group){\n          return $select.isGrouped && group && group.name;\n        };\n\n        if(attrs.tabindex){\n          attrs.$observe('tabindex', function(value) {\n            $select.focusInput.attr('tabindex', value);\n            element.removeAttr('tabindex');\n          });\n        }\n\n        scope.$watch(function () { return scope.$eval(attrs.searchEnabled); }, function(newVal) {\n          $select.searchEnabled = newVal !== undefined ? newVal : uiSelectConfig.searchEnabled;\n        });\n\n        scope.$watch('sortable', function() {\n            var sortable = scope.$eval(attrs.sortable);\n            $select.sortable = sortable !== undefined ? sortable : uiSelectConfig.sortable;\n        });\n\n        attrs.$observe('limit', function() {\n          //Limit the number of selections allowed\n          $select.limit = (angular.isDefined(attrs.limit)) ? parseInt(attrs.limit, 10) : undefined;\n        });\n\n        scope.$watch('removeSelected', function() {\n            var removeSelected = scope.$eval(attrs.removeSelected);\n            $select.removeSelected = removeSelected !== undefined ? removeSelected : uiSelectConfig.removeSelected;\n        });\n\n        attrs.$observe('disabled', function() {\n          // No need to use $eval() (thanks to ng-disabled) since we already get a boolean instead of a string\n          $select.disabled = attrs.disabled !== undefined ? attrs.disabled : false;\n        });\n\n        attrs.$observe('resetSearchInput', function() {\n          // $eval() is needed otherwise we get a string instead of a boolean\n          var resetSearchInput = scope.$eval(attrs.resetSearchInput);\n          $select.resetSearchInput = resetSearchInput !== undefined ? resetSearchInput : true;\n        });\n\n        attrs.$observe('paste', function() {\n          $select.paste = scope.$eval(attrs.paste);\n        });\n\n        attrs.$observe('tagging', function() {\n          if(attrs.tagging !== undefined)\n          {\n            // $eval() is needed otherwise we get a string instead of a boolean\n            var taggingEval = scope.$eval(attrs.tagging);\n            $select.tagging = {isActivated: true, fct: taggingEval !== true ? taggingEval : undefined};\n          }\n          else\n          {\n            $select.tagging = {isActivated: false, fct: undefined};\n          }\n        });\n\n        attrs.$observe('taggingLabel', function() {\n          if(attrs.tagging !== undefined )\n          {\n            // check eval for FALSE, in this case, we disable the labels\n            // associated with tagging\n            if ( attrs.taggingLabel === 'false' ) {\n              $select.taggingLabel = false;\n            }\n            else\n            {\n              $select.taggingLabel = attrs.taggingLabel !== undefined ? attrs.taggingLabel : '(new)';\n            }\n          }\n        });\n\n        attrs.$observe('taggingTokens', function() {\n          if (attrs.tagging !== undefined) {\n            var tokens = attrs.taggingTokens !== undefined ? attrs.taggingTokens.split('|') : [',','ENTER'];\n            $select.taggingTokens = {isActivated: true, tokens: tokens };\n          }\n        });\n\n        //Automatically gets focus when loaded\n        if (angular.isDefined(attrs.autofocus)){\n          $timeout(function(){\n            $select.setFocus();\n          });\n        }\n\n        //Gets focus based on scope event name (e.g. focus-on='SomeEventName')\n        if (angular.isDefined(attrs.focusOn)){\n          scope.$on(attrs.focusOn, function() {\n              $timeout(function(){\n                $select.setFocus();\n              });\n          });\n        }\n\n        function onDocumentClick(e) {\n          if (!$select.open) return; //Skip it if dropdown is close\n\n          var contains = false;\n\n          if (window.jQuery) {\n            // Firefox 3.6 does not support element.contains()\n            // See Node.contains https://developer.mozilla.org/en-US/docs/Web/API/Node.contains\n            contains = window.jQuery.contains(element[0], e.target);\n          } else {\n            contains = element[0].contains(e.target);\n          }\n\n          if (!contains && !$select.clickTriggeredSelect) {\n            var skipFocusser;\n            if (!$select.skipFocusser) {\n              //Will lose focus only with certain targets\n              var focusableControls = ['input','button','textarea','select'];\n              var targetController = angular.element(e.target).controller('uiSelect'); //To check if target is other ui-select\n              skipFocusser = targetController && targetController !== $select; //To check if target is other ui-select\n              if (!skipFocusser) skipFocusser =  ~focusableControls.indexOf(e.target.tagName.toLowerCase()); //Check if target is input, button or textarea\n            } else {\n              skipFocusser = true;\n            }\n            $select.close(skipFocusser);\n            scope.$digest();\n          }\n          $select.clickTriggeredSelect = false;\n        }\n\n        // See Click everywhere but here event http://stackoverflow.com/questions/12931369\n        $document.on('click', onDocumentClick);\n\n        scope.$on('$destroy', function() {\n          $document.off('click', onDocumentClick);\n        });\n\n        // Move transcluded elements to their correct position in main template\n        transcludeFn(scope, function(clone) {\n          // See Transclude in AngularJS http://blog.omkarpatil.com/2012/11/transclude-in-angularjs.html\n\n          // One day jqLite will be replaced by jQuery and we will be able to write:\n          // var transcludedElement = clone.filter('.my-class')\n          // instead of creating a hackish DOM element:\n          var transcluded = angular.element('<div>').append(clone);\n\n          var transcludedMatch = transcluded.querySelectorAll('.ui-select-match');\n          transcludedMatch.removeAttr('ui-select-match'); //To avoid loop in case directive as attr\n          transcludedMatch.removeAttr('data-ui-select-match'); // Properly handle HTML5 data-attributes\n          if (transcludedMatch.length !== 1) {\n            throw uiSelectMinErr('transcluded', \"Expected 1 .ui-select-match but got '{0}'.\", transcludedMatch.length);\n          }\n          element.querySelectorAll('.ui-select-match').replaceWith(transcludedMatch);\n\n          var transcludedChoices = transcluded.querySelectorAll('.ui-select-choices');\n          transcludedChoices.removeAttr('ui-select-choices'); //To avoid loop in case directive as attr\n          transcludedChoices.removeAttr('data-ui-select-choices'); // Properly handle HTML5 data-attributes\n          if (transcludedChoices.length !== 1) {\n            throw uiSelectMinErr('transcluded', \"Expected 1 .ui-select-choices but got '{0}'.\", transcludedChoices.length);\n          }\n          element.querySelectorAll('.ui-select-choices').replaceWith(transcludedChoices);\n\n          var transcludedNoChoice = transcluded.querySelectorAll('.ui-select-no-choice');\n          transcludedNoChoice.removeAttr('ui-select-no-choice'); //To avoid loop in case directive as attr\n          transcludedNoChoice.removeAttr('data-ui-select-no-choice'); // Properly handle HTML5 data-attributes\n          if (transcludedNoChoice.length == 1) {\n            element.querySelectorAll('.ui-select-no-choice').replaceWith(transcludedNoChoice);\n          }\n        });\n\n        // Support for appending the select field to the body when its open\n        var appendToBody = scope.$eval(attrs.appendToBody);\n        if (appendToBody !== undefined ? appendToBody : uiSelectConfig.appendToBody) {\n          scope.$watch('$select.open', function(isOpen) {\n            if (isOpen) {\n              positionDropdown();\n            } else {\n              resetDropdown();\n            }\n          });\n\n          // Move the dropdown back to its original location when the scope is destroyed. Otherwise\n          // it might stick around when the user routes away or the select field is otherwise removed\n          scope.$on('$destroy', function() {\n            resetDropdown();\n          });\n        }\n\n        // Hold on to a reference to the .ui-select-container element for appendToBody support\n        var placeholder = null,\n            originalWidth = '';\n\n        function positionDropdown() {\n          // Remember the absolute position of the element\n          var offset = uisOffset(element);\n\n          // Clone the element into a placeholder element to take its original place in the DOM\n          placeholder = angular.element('<div class=\"ui-select-placeholder\"></div>');\n          placeholder[0].style.width = offset.width + 'px';\n          placeholder[0].style.height = offset.height + 'px';\n          element.after(placeholder);\n\n          // Remember the original value of the element width inline style, so it can be restored\n          // when the dropdown is closed\n          originalWidth = element[0].style.width;\n\n          // Now move the actual dropdown element to the end of the body\n          $document.find('body').append(element);\n\n          element[0].style.position = 'absolute';\n          element[0].style.left = offset.left + 'px';\n          element[0].style.top = offset.top + 'px';\n          element[0].style.width = offset.width + 'px';\n        }\n\n        function resetDropdown() {\n          if (placeholder === null) {\n            // The dropdown has not actually been display yet, so there's nothing to reset\n            return;\n          }\n\n          // Move the dropdown element back to its original location in the DOM\n          placeholder.replaceWith(element);\n          placeholder = null;\n\n          element[0].style.position = '';\n          element[0].style.left = '';\n          element[0].style.top = '';\n          element[0].style.width = originalWidth;\n\n          // Set focus back on to the moved element\n          $select.setFocus();\n        }\n\n        // Hold on to a reference to the .ui-select-dropdown element for direction support.\n        var dropdown = null,\n            directionUpClassName = 'direction-up';\n\n        // Support changing the direction of the dropdown if there isn't enough space to render it.\n        scope.$watch('$select.open', function() {\n\n          if ($select.dropdownPosition === 'auto' || $select.dropdownPosition === 'up'){\n            scope.calculateDropdownPos();\n          }\n\n        });\n\n        var setDropdownPosUp = function(offset, offsetDropdown){\n\n          offset = offset || uisOffset(element);\n          offsetDropdown = offsetDropdown || uisOffset(dropdown);\n\n          dropdown[0].style.position = 'absolute';\n          dropdown[0].style.top = (offsetDropdown.height * -1) + 'px';\n          element.addClass(directionUpClassName);\n\n        };\n\n        var setDropdownPosDown = function(offset, offsetDropdown){\n\n          element.removeClass(directionUpClassName);\n\n          offset = offset || uisOffset(element);\n          offsetDropdown = offsetDropdown || uisOffset(dropdown);\n\n          dropdown[0].style.position = '';\n          dropdown[0].style.top = '';\n\n        };\n\n        var calculateDropdownPosAfterAnimation = function() {\n          // Delay positioning the dropdown until all choices have been added so its height is correct.\n          $timeout(function() {\n            if ($select.dropdownPosition === 'up') {\n              //Go UP\n              setDropdownPosUp();\n            } else {\n              //AUTO\n              element.removeClass(directionUpClassName);\n\n              var offset = uisOffset(element);\n              var offsetDropdown = uisOffset(dropdown);\n\n              //https://code.google.com/p/chromium/issues/detail?id=342307#c4\n              var scrollTop = $document[0].documentElement.scrollTop || $document[0].body.scrollTop; //To make it cross browser (blink, webkit, IE, Firefox).\n\n              // Determine if the direction of the dropdown needs to be changed.\n              if (offset.top + offset.height + offsetDropdown.height > scrollTop + $document[0].documentElement.clientHeight) {\n                //Go UP\n                setDropdownPosUp(offset, offsetDropdown);\n              }else{\n                //Go DOWN\n                setDropdownPosDown(offset, offsetDropdown);\n              }\n            }\n\n            // Display the dropdown once it has been positioned.\n            dropdown[0].style.opacity = 1;\n          });\n        };\n\n        var opened = false;\n\n        scope.calculateDropdownPos = function() {\n          if ($select.open) {\n            dropdown = angular.element(element).querySelectorAll('.ui-select-dropdown');\n\n            if (dropdown.length === 0) {\n              return;\n            }\n\n           // Hide the dropdown so there is no flicker until $timeout is done executing.\n           if ($select.search === '' && !opened) {\n              dropdown[0].style.opacity = 0;\n              opened = true;\n           }\n\n            if (!uisOffset(dropdown).height && $select.$animate && $select.$animate.on && $select.$animate.enabled(dropdown)) {\n              var needsCalculated = true;\n\n              $select.$animate.on('enter', dropdown, function (elem, phase) {\n                if (phase === 'close' && needsCalculated) {\n                  calculateDropdownPosAfterAnimation();\n                  needsCalculated = false;\n                }\n              });\n            } else {\n              calculateDropdownPosAfterAnimation();\n            }\n          } else {\n            if (dropdown === null || dropdown.length === 0) {\n              return;\n            }\n\n            // Reset the position of the dropdown.\n            dropdown[0].style.opacity = 0;\n            dropdown[0].style.position = '';\n            dropdown[0].style.top = '';\n            element.removeClass(directionUpClassName);\n          }\n        };\n      };\n    }\n  };\n}]);\n\nuis.directive('uiSelectMatch', ['uiSelectConfig', function(uiSelectConfig) {\n  return {\n    restrict: 'EA',\n    require: '^uiSelect',\n    replace: true,\n    transclude: true,\n    templateUrl: function(tElement) {\n      // Needed so the uiSelect can detect the transcluded content\n      tElement.addClass('ui-select-match');\n\n      var parent = tElement.parent();\n      // Gets theme attribute from parent (ui-select)\n      var theme = getAttribute(parent, 'theme') || uiSelectConfig.theme;\n      var multi = angular.isDefined(getAttribute(parent, 'multiple'));\n\n      return theme + (multi ? '/match-multiple.tpl.html' : '/match.tpl.html');\n    },\n    link: function(scope, element, attrs, $select) {\n      $select.lockChoiceExpression = attrs.uiLockChoice;\n      attrs.$observe('placeholder', function(placeholder) {\n        $select.placeholder = placeholder !== undefined ? placeholder : uiSelectConfig.placeholder;\n      });\n\n      function setAllowClear(allow) {\n        $select.allowClear = (angular.isDefined(allow)) ? (allow === '') ? true : (allow.toLowerCase() === 'true') : false;\n      }\n\n      attrs.$observe('allowClear', setAllowClear);\n      setAllowClear(attrs.allowClear);\n\n      if($select.multiple){\n        $select.sizeSearchInput();\n      }\n\n    }\n  };\n\n  function getAttribute(elem, attribute) {\n    if (elem[0].hasAttribute(attribute))\n      return elem.attr(attribute);\n\n    if (elem[0].hasAttribute('data-' + attribute))\n      return elem.attr('data-' + attribute);\n\n    if (elem[0].hasAttribute('x-' + attribute))\n      return elem.attr('x-' + attribute);\n  }\n}]);\n\nuis.directive('uiSelectMultiple', ['uiSelectMinErr','$timeout', function(uiSelectMinErr, $timeout) {\n  return {\n    restrict: 'EA',\n    require: ['^uiSelect', '^ngModel'],\n\n    controller: ['$scope','$timeout', function($scope, $timeout){\n\n      var ctrl = this,\n          $select = $scope.$select,\n          ngModel;\n\n      if (angular.isUndefined($select.selected))\n        $select.selected = [];\n\n      //Wait for link fn to inject it\n      $scope.$evalAsync(function(){ ngModel = $scope.ngModel; });\n\n      ctrl.activeMatchIndex = -1;\n\n      ctrl.updateModel = function(){\n        ngModel.$setViewValue(Date.now()); //Set timestamp as a unique string to force changes\n        ctrl.refreshComponent();\n      };\n\n      ctrl.refreshComponent = function(){\n        //Remove already selected items\n        //e.g. When user clicks on a selection, the selected array changes and\n        //the dropdown should remove that item\n        if($select.refreshItems){\n          $select.refreshItems();\n        }\n        if($select.sizeSearchInput){\n          $select.sizeSearchInput();\n        }\n      };\n\n      // Remove item from multiple select\n      ctrl.removeChoice = function(index){\n\n        // if the choice is locked, don't remove it\n        if($select.isLocked(null, index)) return false;\n\n        var removedChoice = $select.selected[index];\n\n        var locals = {};\n        locals[$select.parserResult.itemName] = removedChoice;\n\n        $select.selected.splice(index, 1);\n        ctrl.activeMatchIndex = -1;\n        $select.sizeSearchInput();\n\n        // Give some time for scope propagation.\n        $timeout(function(){\n          $select.onRemoveCallback($scope, {\n            $item: removedChoice,\n            $model: $select.parserResult.modelMapper($scope, locals)\n          });\n        });\n\n        ctrl.updateModel();\n\n        return true;\n      };\n\n      ctrl.getPlaceholder = function(){\n        //Refactor single?\n        if($select.selected && $select.selected.length) return;\n        return $select.placeholder;\n      };\n\n\n    }],\n    controllerAs: '$selectMultiple',\n\n    link: function(scope, element, attrs, ctrls) {\n\n      var $select = ctrls[0];\n      var ngModel = scope.ngModel = ctrls[1];\n      var $selectMultiple = scope.$selectMultiple;\n\n      //$select.selected = raw selected objects (ignoring any property binding)\n\n      $select.multiple = true;\n\n      //Input that will handle focus\n      $select.focusInput = $select.searchInput;\n\n      //Properly check for empty if set to multiple\n      ngModel.$isEmpty = function(value) {\n        return !value || value.length === 0;\n      };\n\n      //From view --> model\n      ngModel.$parsers.unshift(function () {\n        var locals = {},\n            result,\n            resultMultiple = [];\n        for (var j = $select.selected.length - 1; j >= 0; j--) {\n          locals = {};\n          locals[$select.parserResult.itemName] = $select.selected[j];\n          result = $select.parserResult.modelMapper(scope, locals);\n          resultMultiple.unshift(result);\n        }\n        return resultMultiple;\n      });\n\n      // From model --> view\n      ngModel.$formatters.unshift(function (inputValue) {\n        var data = $select.parserResult && $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search\n            locals = {},\n            result;\n        if (!data) return inputValue;\n        var resultMultiple = [];\n        var checkFnMultiple = function(list, value){\n          if (!list || !list.length) return;\n          for (var p = list.length - 1; p >= 0; p--) {\n            locals[$select.parserResult.itemName] = list[p];\n            result = $select.parserResult.modelMapper(scope, locals);\n            if($select.parserResult.trackByExp){\n                var propsItemNameMatches = /(\\w*)\\./.exec($select.parserResult.trackByExp);\n                var matches = /\\.([^\\s]+)/.exec($select.parserResult.trackByExp);\n                if(propsItemNameMatches && propsItemNameMatches.length > 0 && propsItemNameMatches[1] == $select.parserResult.itemName){\n                  if(matches && matches.length>0 && result[matches[1]] == value[matches[1]]){\n                      resultMultiple.unshift(list[p]);\n                      return true;\n                  }\n                }\n            }\n            if (angular.equals(result,value)){\n              resultMultiple.unshift(list[p]);\n              return true;\n            }\n          }\n          return false;\n        };\n        if (!inputValue) return resultMultiple; //If ngModel was undefined\n        for (var k = inputValue.length - 1; k >= 0; k--) {\n          //Check model array of currently selected items\n          if (!checkFnMultiple($select.selected, inputValue[k])){\n            //Check model array of all items available\n            if (!checkFnMultiple(data, inputValue[k])){\n              //If not found on previous lists, just add it directly to resultMultiple\n              resultMultiple.unshift(inputValue[k]);\n            }\n          }\n        }\n        return resultMultiple;\n      });\n\n      //Watch for external model changes\n      scope.$watchCollection(function(){ return ngModel.$modelValue; }, function(newValue, oldValue) {\n        if (oldValue != newValue){\n          //update the view value with fresh data from items, if there is a valid model value\n          if(angular.isDefined(ngModel.$modelValue)) {\n            ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters\n          }\n          $selectMultiple.refreshComponent();\n        }\n      });\n\n      ngModel.$render = function() {\n        // Make sure that model value is array\n        if(!angular.isArray(ngModel.$viewValue)){\n          // Have tolerance for null or undefined values\n          if(angular.isUndefined(ngModel.$viewValue) || ngModel.$viewValue === null){\n            ngModel.$viewValue = [];\n          } else {\n            throw uiSelectMinErr('multiarr', \"Expected model value to be array but got '{0}'\", ngModel.$viewValue);\n          }\n        }\n        $select.selected = ngModel.$viewValue;\n        $selectMultiple.refreshComponent();\n        scope.$evalAsync(); //To force $digest\n      };\n\n      scope.$on('uis:select', function (event, item) {\n        if($select.selected.length >= $select.limit) {\n          return;\n        }\n        $select.selected.push(item);\n        $selectMultiple.updateModel();\n      });\n\n      scope.$on('uis:activate', function () {\n        $selectMultiple.activeMatchIndex = -1;\n      });\n\n      scope.$watch('$select.disabled', function(newValue, oldValue) {\n        // As the search input field may now become visible, it may be necessary to recompute its size\n        if (oldValue && !newValue) $select.sizeSearchInput();\n      });\n\n      $select.searchInput.on('keydown', function(e) {\n        var key = e.which;\n        scope.$apply(function() {\n          var processed = false;\n          // var tagged = false; //Checkme\n          if(KEY.isHorizontalMovement(key)){\n            processed = _handleMatchSelection(key);\n          }\n          if (processed  && key != KEY.TAB) {\n            //TODO Check si el tab selecciona aun correctamente\n            //Crear test\n            e.preventDefault();\n            e.stopPropagation();\n          }\n        });\n      });\n      function _getCaretPosition(el) {\n        if(angular.isNumber(el.selectionStart)) return el.selectionStart;\n        // selectionStart is not supported in IE8 and we don't want hacky workarounds so we compromise\n        else return el.value.length;\n      }\n      // Handles selected options in \"multiple\" mode\n      function _handleMatchSelection(key){\n        var caretPosition = _getCaretPosition($select.searchInput[0]),\n            length = $select.selected.length,\n            // none  = -1,\n            first = 0,\n            last  = length-1,\n            curr  = $selectMultiple.activeMatchIndex,\n            next  = $selectMultiple.activeMatchIndex+1,\n            prev  = $selectMultiple.activeMatchIndex-1,\n            newIndex = curr;\n\n        if(caretPosition > 0 || ($select.search.length && key == KEY.RIGHT)) return false;\n\n        $select.close();\n\n        function getNewActiveMatchIndex(){\n          switch(key){\n            case KEY.LEFT:\n              // Select previous/first item\n              if(~$selectMultiple.activeMatchIndex) return prev;\n              // Select last item\n              else return last;\n              break;\n            case KEY.RIGHT:\n              // Open drop-down\n              if(!~$selectMultiple.activeMatchIndex || curr === last){\n                $select.activate();\n                return false;\n              }\n              // Select next/last item\n              else return next;\n              break;\n            case KEY.BACKSPACE:\n              // Remove selected item and select previous/first\n              if(~$selectMultiple.activeMatchIndex){\n                if($selectMultiple.removeChoice(curr)) {\n                  return prev;\n                } else {\n                  return curr;\n                }\n\n              } else {\n                // If nothing yet selected, select last item\n                return last;\n              }\n              break;\n            case KEY.DELETE:\n              // Remove selected item and select next item\n              if(~$selectMultiple.activeMatchIndex){\n                $selectMultiple.removeChoice($selectMultiple.activeMatchIndex);\n                return curr;\n              }\n              else return false;\n          }\n        }\n\n        newIndex = getNewActiveMatchIndex();\n\n        if(!$select.selected.length || newIndex === false) $selectMultiple.activeMatchIndex = -1;\n        else $selectMultiple.activeMatchIndex = Math.min(last,Math.max(first,newIndex));\n\n        return true;\n      }\n\n      $select.searchInput.on('keyup', function(e) {\n\n        if ( ! KEY.isVerticalMovement(e.which) ) {\n          scope.$evalAsync( function () {\n            $select.activeIndex = $select.taggingLabel === false ? -1 : 0;\n          });\n        }\n        // Push a \"create new\" item into array if there is a search string\n        if ( $select.tagging.isActivated && $select.search.length > 0 ) {\n\n          // return early with these keys\n          if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || KEY.isVerticalMovement(e.which) ) {\n            return;\n          }\n          // always reset the activeIndex to the first item when tagging\n          $select.activeIndex = $select.taggingLabel === false ? -1 : 0;\n          // taggingLabel === false bypasses all of this\n          if ($select.taggingLabel === false) return;\n\n          var items = angular.copy( $select.items );\n          var stashArr = angular.copy( $select.items );\n          var newItem;\n          var item;\n          var hasTag = false;\n          var dupeIndex = -1;\n          var tagItems;\n          var tagItem;\n\n          // case for object tagging via transform `$select.tagging.fct` function\n          if ( $select.tagging.fct !== undefined) {\n            tagItems = $select.$filter('filter')(items,{'isTag': true});\n            if ( tagItems.length > 0 ) {\n              tagItem = tagItems[0];\n            }\n            // remove the first element, if it has the `isTag` prop we generate a new one with each keyup, shaving the previous\n            if ( items.length > 0 && tagItem ) {\n              hasTag = true;\n              items = items.slice(1,items.length);\n              stashArr = stashArr.slice(1,stashArr.length);\n            }\n            newItem = $select.tagging.fct($select.search);\n            // verify the new tag doesn't match the value of a possible selection choice or an already selected item.\n            if (\n              stashArr.some(function (origItem) {\n                 return angular.equals(origItem, newItem);\n              }) ||\n              $select.selected.some(function (origItem) {\n                return angular.equals(origItem, newItem);\n              })\n            ) {\n              scope.$evalAsync(function () {\n                $select.activeIndex = 0;\n                $select.items = items;\n              });\n              return;\n            }\n            if (newItem) newItem.isTag = true;\n          // handle newItem string and stripping dupes in tagging string context\n          } else {\n            // find any tagging items already in the $select.items array and store them\n            tagItems = $select.$filter('filter')(items,function (item) {\n              return item.match($select.taggingLabel);\n            });\n            if ( tagItems.length > 0 ) {\n              tagItem = tagItems[0];\n            }\n            item = items[0];\n            // remove existing tag item if found (should only ever be one tag item)\n            if ( item !== undefined && items.length > 0 && tagItem ) {\n              hasTag = true;\n              items = items.slice(1,items.length);\n              stashArr = stashArr.slice(1,stashArr.length);\n            }\n            newItem = $select.search+' '+$select.taggingLabel;\n            if ( _findApproxDupe($select.selected, $select.search) > -1 ) {\n              return;\n            }\n            // verify the the tag doesn't match the value of an existing item from\n            // the searched data set or the items already selected\n            if ( _findCaseInsensitiveDupe(stashArr.concat($select.selected)) ) {\n              // if there is a tag from prev iteration, strip it / queue the change\n              // and return early\n              if ( hasTag ) {\n                items = stashArr;\n                scope.$evalAsync( function () {\n                  $select.activeIndex = 0;\n                  $select.items = items;\n                });\n              }\n              return;\n            }\n            if ( _findCaseInsensitiveDupe(stashArr) ) {\n              // if there is a tag from prev iteration, strip it\n              if ( hasTag ) {\n                $select.items = stashArr.slice(1,stashArr.length);\n              }\n              return;\n            }\n          }\n          if ( hasTag ) dupeIndex = _findApproxDupe($select.selected, newItem);\n          // dupe found, shave the first item\n          if ( dupeIndex > -1 ) {\n            items = items.slice(dupeIndex+1,items.length-1);\n          } else {\n            items = [];\n            if (newItem) items.push(newItem);\n            items = items.concat(stashArr);\n          }\n          scope.$evalAsync( function () {\n            $select.activeIndex = 0;\n            $select.items = items;\n\n            if ($select.isGrouped) {\n              // update item references in groups, so that indexOf will work after angular.copy\n              var itemsWithoutTag = newItem ? items.slice(1) : items;\n              $select.setItemsFn(itemsWithoutTag);\n              if (newItem) {\n                // add tag item as a new group\n                $select.items.unshift(newItem);\n                $select.groups.unshift({name: '', items: [newItem], tagging: true});\n              }\n            }\n          });\n        }\n      });\n      function _findCaseInsensitiveDupe(arr) {\n        if ( arr === undefined || $select.search === undefined ) {\n          return false;\n        }\n        var hasDupe = arr.filter( function (origItem) {\n          if ( $select.search.toUpperCase() === undefined || origItem === undefined ) {\n            return false;\n          }\n          return origItem.toUpperCase() === $select.search.toUpperCase();\n        }).length > 0;\n\n        return hasDupe;\n      }\n      function _findApproxDupe(haystack, needle) {\n        var dupeIndex = -1;\n        if(angular.isArray(haystack)) {\n          var tempArr = angular.copy(haystack);\n          for (var i = 0; i <tempArr.length; i++) {\n            // handle the simple string version of tagging\n            if ( $select.tagging.fct === undefined ) {\n              // search the array for the match\n              if ( tempArr[i]+' '+$select.taggingLabel === needle ) {\n              dupeIndex = i;\n              }\n            // handle the object tagging implementation\n            } else {\n              var mockObj = tempArr[i];\n              if (angular.isObject(mockObj)) {\n                mockObj.isTag = true;\n              }\n              if ( angular.equals(mockObj, needle) ) {\n                dupeIndex = i;\n              }\n            }\n          }\n        }\n        return dupeIndex;\n      }\n\n      $select.searchInput.on('blur', function() {\n        $timeout(function() {\n          $selectMultiple.activeMatchIndex = -1;\n        });\n      });\n\n    }\n  };\n}]);\n\nuis.directive('uiSelectNoChoice',\n    ['uiSelectConfig', function (uiSelectConfig) {\n        return {\n            restrict: 'EA',\n            require: '^uiSelect',\n            replace: true,\n            transclude: true,\n            templateUrl: function (tElement) {\n                // Needed so the uiSelect can detect the transcluded content\n                tElement.addClass('ui-select-no-choice');\n\n                // Gets theme attribute from parent (ui-select)\n                var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;\n                return theme + '/no-choice.tpl.html';\n            }\n        };\n    }]);\n\nuis.directive('uiSelectSingle', ['$timeout','$compile', function($timeout, $compile) {\n  return {\n    restrict: 'EA',\n    require: ['^uiSelect', '^ngModel'],\n    link: function(scope, element, attrs, ctrls) {\n\n      var $select = ctrls[0];\n      var ngModel = ctrls[1];\n\n      //From view --> model\n      ngModel.$parsers.unshift(function (inputValue) {\n        var locals = {},\n            result;\n        locals[$select.parserResult.itemName] = inputValue;\n        result = $select.parserResult.modelMapper(scope, locals);\n        return result;\n      });\n\n      //From model --> view\n      ngModel.$formatters.unshift(function (inputValue) {\n        var data = $select.parserResult && $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search\n            locals = {},\n            result;\n        if (data){\n          var checkFnSingle = function(d){\n            locals[$select.parserResult.itemName] = d;\n            result = $select.parserResult.modelMapper(scope, locals);\n            return result === inputValue;\n          };\n          //If possible pass same object stored in $select.selected\n          if ($select.selected && checkFnSingle($select.selected)) {\n            return $select.selected;\n          }\n          for (var i = data.length - 1; i >= 0; i--) {\n            if (checkFnSingle(data[i])) return data[i];\n          }\n        }\n        return inputValue;\n      });\n\n      //Update viewValue if model change\n      scope.$watch('$select.selected', function(newValue) {\n        if (ngModel.$viewValue !== newValue) {\n          ngModel.$setViewValue(newValue);\n        }\n      });\n\n      ngModel.$render = function() {\n        $select.selected = ngModel.$viewValue;\n      };\n\n      scope.$on('uis:select', function (event, item) {\n        $select.selected = item;\n      });\n\n      scope.$on('uis:close', function (event, skipFocusser) {\n        $timeout(function(){\n          $select.focusser.prop('disabled', false);\n          if (!skipFocusser) $select.focusser[0].focus();\n        },0,false);\n      });\n\n      scope.$on('uis:activate', function () {\n        focusser.prop('disabled', true); //Will reactivate it on .close()\n      });\n\n      //Idea from: https://github.com/ivaynberg/select2/blob/79b5bf6db918d7560bdd959109b7bcfb47edaf43/select2.js#L1954\n      var focusser = angular.element(\"<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' id='{{ $select.focusserId }}' aria-label='{{ $select.focusserTitle }}' aria-haspopup='true' role='button' />\");\n      $compile(focusser)(scope);\n      $select.focusser = focusser;\n\n      //Input that will handle focus\n      $select.focusInput = focusser;\n\n      element.parent().append(focusser);\n      focusser.bind(\"focus\", function(){\n        scope.$evalAsync(function(){\n          $select.focus = true;\n        });\n      });\n      focusser.bind(\"blur\", function(){\n        scope.$evalAsync(function(){\n          $select.focus = false;\n        });\n      });\n      focusser.bind(\"keydown\", function(e){\n\n        if (e.which === KEY.BACKSPACE) {\n          e.preventDefault();\n          e.stopPropagation();\n          $select.select(undefined);\n          scope.$apply();\n          return;\n        }\n\n        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {\n          return;\n        }\n\n        if (e.which == KEY.DOWN  || e.which == KEY.UP || e.which == KEY.ENTER || e.which == KEY.SPACE){\n          e.preventDefault();\n          e.stopPropagation();\n          $select.activate();\n        }\n\n        scope.$digest();\n      });\n\n      focusser.bind(\"keyup input\", function(e){\n\n        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || e.which == KEY.ENTER || e.which === KEY.BACKSPACE) {\n          return;\n        }\n\n        $select.activate(focusser.val()); //User pressed some regular key, so we pass it to the search input\n        focusser.val('');\n        scope.$digest();\n\n      });\n\n\n    }\n  };\n}]);\n\n// Make multiple matches sortable\nuis.directive('uiSelectSort', ['$timeout', 'uiSelectConfig', 'uiSelectMinErr', function($timeout, uiSelectConfig, uiSelectMinErr) {\n  return {\n    require: ['^^uiSelect', '^ngModel'],\n    link: function(scope, element, attrs, ctrls) {\n      if (scope[attrs.uiSelectSort] === null) {\n        throw uiSelectMinErr('sort', 'Expected a list to sort');\n      }\n\n      var $select = ctrls[0];\n      var $ngModel = ctrls[1];\n\n      var options = angular.extend({\n          axis: 'horizontal'\n        },\n        scope.$eval(attrs.uiSelectSortOptions));\n\n      var axis = options.axis;\n      var draggingClassName = 'dragging';\n      var droppingClassName = 'dropping';\n      var droppingBeforeClassName = 'dropping-before';\n      var droppingAfterClassName = 'dropping-after';\n\n      scope.$watch(function(){\n        return $select.sortable;\n      }, function(newValue){\n        if (newValue) {\n          element.attr('draggable', true);\n        } else {\n          element.removeAttr('draggable');\n        }\n      });\n\n      element.on('dragstart', function(event) {\n        element.addClass(draggingClassName);\n\n        (event.dataTransfer || event.originalEvent.dataTransfer).setData('text', scope.$index.toString());\n      });\n\n      element.on('dragend', function() {\n        removeClass(draggingClassName);\n      });\n\n      var move = function(from, to) {\n        /*jshint validthis: true */\n        this.splice(to, 0, this.splice(from, 1)[0]);\n      };\n\n      var removeClass = function(className) {\n        angular.forEach($select.$element.querySelectorAll('.' + className), function(el){\n          angular.element(el).removeClass(className);\n        });\n      };\n\n      var dragOverHandler = function(event) {\n        event.preventDefault();\n\n        var offset = axis === 'vertical' ? event.offsetY || event.layerY || (event.originalEvent ? event.originalEvent.offsetY : 0) : event.offsetX || event.layerX || (event.originalEvent ? event.originalEvent.offsetX : 0);\n\n        if (offset < (this[axis === 'vertical' ? 'offsetHeight' : 'offsetWidth'] / 2)) {\n          removeClass(droppingAfterClassName);\n          element.addClass(droppingBeforeClassName);\n\n        } else {\n          removeClass(droppingBeforeClassName);\n          element.addClass(droppingAfterClassName);\n        }\n      };\n\n      var dropTimeout;\n\n      var dropHandler = function(event) {\n        event.preventDefault();\n\n        var droppedItemIndex = parseInt((event.dataTransfer || event.originalEvent.dataTransfer).getData('text'), 10);\n\n        // prevent event firing multiple times in firefox\n        $timeout.cancel(dropTimeout);\n        dropTimeout = $timeout(function() {\n          _dropHandler(droppedItemIndex);\n        }, 20);\n      };\n\n      var _dropHandler = function(droppedItemIndex) {\n        var theList = scope.$eval(attrs.uiSelectSort);\n        var itemToMove = theList[droppedItemIndex];\n        var newIndex = null;\n\n        if (element.hasClass(droppingBeforeClassName)) {\n          if (droppedItemIndex < scope.$index) {\n            newIndex = scope.$index - 1;\n          } else {\n            newIndex = scope.$index;\n          }\n        } else {\n          if (droppedItemIndex < scope.$index) {\n            newIndex = scope.$index;\n          } else {\n            newIndex = scope.$index + 1;\n          }\n        }\n\n        move.apply(theList, [droppedItemIndex, newIndex]);\n\n        $ngModel.$setViewValue(Date.now());\n\n        scope.$apply(function() {\n          scope.$emit('uiSelectSort:change', {\n            array: theList,\n            item: itemToMove,\n            from: droppedItemIndex,\n            to: newIndex\n          });\n        });\n\n        removeClass(droppingClassName);\n        removeClass(droppingBeforeClassName);\n        removeClass(droppingAfterClassName);\n\n        element.off('drop', dropHandler);\n      };\n\n      element.on('dragenter', function() {\n        if (element.hasClass(draggingClassName)) {\n          return;\n        }\n\n        element.addClass(droppingClassName);\n\n        element.on('dragover', dragOverHandler);\n        element.on('drop', dropHandler);\n      });\n\n      element.on('dragleave', function(event) {\n        if (event.target != element) {\n          return;\n        }\n\n        removeClass(droppingClassName);\n        removeClass(droppingBeforeClassName);\n        removeClass(droppingAfterClassName);\n\n        element.off('dragover', dragOverHandler);\n        element.off('drop', dropHandler);\n      });\n    }\n  };\n}]);\n\n/**\n * Debounces functions\n *\n * Taken from UI Bootstrap $$debounce source code\n * See https://github.com/angular-ui/bootstrap/blob/master/src/debounce/debounce.js\n *\n */\nuis.factory('$$uisDebounce', ['$timeout', function($timeout) {\n  return function(callback, debounceTime) {\n    var timeoutPromise;\n\n    return function() {\n      var self = this;\n      var args = Array.prototype.slice.call(arguments);\n      if (timeoutPromise) {\n        $timeout.cancel(timeoutPromise);\n      }\n\n      timeoutPromise = $timeout(function() {\n        callback.apply(self, args);\n      }, debounceTime);\n    };\n  };\n}]);\n\nuis.directive('uisOpenClose', ['$parse', '$timeout', function ($parse, $timeout) {\n  return {\n    restrict: 'A',\n    require: 'uiSelect',\n    link: function (scope, element, attrs, $select) {\n      $select.onOpenCloseCallback = $parse(attrs.uisOpenClose);\n\n      scope.$watch('$select.open', function (isOpen, previousState) {\n        if (isOpen !== previousState) {\n          $timeout(function () {\n            $select.onOpenCloseCallback(scope, {\n              isOpen: isOpen\n            });\n          });\n        }\n      });\n    }\n  };\n}]);\n\n/**\n * Parses \"repeat\" attribute.\n *\n * Taken from AngularJS ngRepeat source code\n * See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L211\n *\n * Original discussion about parsing \"repeat\" attribute instead of fully relying on ng-repeat:\n * https://github.com/angular-ui/ui-select/commit/5dd63ad#commitcomment-5504697\n */\n\nuis.service('uisRepeatParser', ['uiSelectMinErr','$parse', function(uiSelectMinErr, $parse) {\n  var self = this;\n\n  /**\n   * Example:\n   * expression = \"address in addresses | filter: {street: $select.search} track by $index\"\n   * itemName = \"address\",\n   * source = \"addresses | filter: {street: $select.search}\",\n   * trackByExp = \"$index\",\n   */\n  self.parse = function(expression) {\n\n\n    var match;\n    //var isObjectCollection = /\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)/.test(expression);\n    // If an array is used as collection\n\n    // if (isObjectCollection){\n    // 000000000000000000000000000000111111111000000000000000222222222222220033333333333333333333330000444444444444444444000000000000000055555555555000000000000000000000066666666600000000\n    match = expression.match(/^\\s*(?:([\\s\\S]+?)\\s+as\\s+)?(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(\\s*[\\s\\S]+?)?(?:\\s+track\\s+by\\s+([\\s\\S]+?))?\\s*$/);\n\n    // 1 Alias\n    // 2 Item\n    // 3 Key on (key,value)\n    // 4 Value on (key,value)\n    // 5 Source expression (including filters)\n    // 6 Track by\n\n    if (!match) {\n      throw uiSelectMinErr('iexp', \"Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.\",\n              expression);\n    }\n\n    var source = match[5],\n        filters = '';\n\n    // When using (key,value) ui-select requires filters to be extracted, since the object\n    // is converted to an array for $select.items\n    // (in which case the filters need to be reapplied)\n    if (match[3]) {\n      // Remove any enclosing parenthesis\n      source = match[5].replace(/(^\\()|(\\)$)/g, '');\n      // match all after | but not after ||\n      var filterMatch = match[5].match(/^\\s*(?:[\\s\\S]+?)(?:[^\\|]|\\|\\|)+([\\s\\S]*)\\s*$/);\n      if(filterMatch && filterMatch[1].trim()) {\n        filters = filterMatch[1];\n        source = source.replace(filters, '');\n      }\n    }\n\n    return {\n      itemName: match[4] || match[2], // (lhs) Left-hand side,\n      keyName: match[3], //for (key, value) syntax\n      source: $parse(source),\n      filters: filters,\n      trackByExp: match[6],\n      modelMapper: $parse(match[1] || match[4] || match[2]),\n      repeatExpression: function (grouped) {\n        var expression = this.itemName + ' in ' + (grouped ? '$group.items' : '$select.items');\n        if (this.trackByExp) {\n          expression += ' track by ' + this.trackByExp;\n        }\n        return expression;\n      }\n    };\n\n  };\n\n  self.getGroupNgRepeatExpression = function() {\n    return '$group in $select.groups track by $group.name';\n  };\n\n}]);\n\n}());\nangular.module(\"ui.select\").run([\"$templateCache\", function($templateCache) {$templateCache.put(\"bootstrap/choices.tpl.html\",\"<ul class=\\\"ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu\\\" role=\\\"listbox\\\" ng-show=\\\"$select.open && $select.items.length > 0\\\"><li class=\\\"ui-select-choices-group\\\" id=\\\"ui-select-choices-{{ $select.generatedId }}\\\"><div class=\\\"divider\\\" ng-show=\\\"$select.isGrouped && $index > 0\\\"></div><div ng-show=\\\"$select.isGrouped\\\" class=\\\"ui-select-choices-group-label dropdown-header\\\" ng-bind=\\\"$group.name\\\"></div><div ng-attr-id=\\\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\\\" class=\\\"ui-select-choices-row\\\" ng-class=\\\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\\\" role=\\\"option\\\"><span class=\\\"ui-select-choices-row-inner\\\"></span></div></li></ul>\");\n$templateCache.put(\"bootstrap/match-multiple.tpl.html\",\"<span class=\\\"ui-select-match\\\"><span ng-repeat=\\\"$item in $select.selected track by $index\\\"><span class=\\\"ui-select-match-item btn btn-default btn-xs\\\" tabindex=\\\"-1\\\" type=\\\"button\\\" ng-disabled=\\\"$select.disabled\\\" ng-click=\\\"$selectMultiple.activeMatchIndex = $index;\\\" ng-class=\\\"{\\'btn-primary\\':$selectMultiple.activeMatchIndex === $index, \\'select-locked\\':$select.isLocked(this, $index)}\\\" ui-select-sort=\\\"$select.selected\\\"><span class=\\\"close ui-select-match-close\\\" ng-hide=\\\"$select.disabled\\\" ng-click=\\\"$selectMultiple.removeChoice($index)\\\">&nbsp;&times;</span> <span uis-transclude-append=\\\"\\\"></span></span></span></span>\");\n$templateCache.put(\"bootstrap/match.tpl.html\",\"<div class=\\\"ui-select-match\\\" ng-hide=\\\"$select.open && $select.searchEnabled\\\" ng-disabled=\\\"$select.disabled\\\" ng-class=\\\"{\\'btn-default-focus\\':$select.focus}\\\"><span tabindex=\\\"-1\\\" class=\\\"btn btn-default form-control ui-select-toggle\\\" aria-label=\\\"{{ $select.baseTitle }} activate\\\" ng-disabled=\\\"$select.disabled\\\" ng-click=\\\"$select.activate()\\\" style=\\\"outline: 0;\\\"><span ng-show=\\\"$select.isEmpty()\\\" class=\\\"ui-select-placeholder text-muted\\\">{{$select.placeholder}}</span> <span ng-hide=\\\"$select.isEmpty()\\\" class=\\\"ui-select-match-text pull-left\\\" ng-class=\\\"{\\'ui-select-allow-clear\\': $select.allowClear && !$select.isEmpty()}\\\" ng-transclude=\\\"\\\"></span> <i class=\\\"caret pull-right\\\" ng-click=\\\"$select.toggle($event)\\\"></i> <a ng-show=\\\"$select.allowClear && !$select.isEmpty() && ($select.disabled !== true)\\\" aria-label=\\\"{{ $select.baseTitle }} clear\\\" style=\\\"margin-right: 10px\\\" ng-click=\\\"$select.clear($event)\\\" class=\\\"btn btn-xs btn-link pull-right\\\"><i class=\\\"glyphicon glyphicon-remove\\\" aria-hidden=\\\"true\\\"></i></a></span></div>\");\n$templateCache.put(\"bootstrap/no-choice.tpl.html\",\"<ul class=\\\"ui-select-no-choice dropdown-menu\\\" ng-show=\\\"$select.items.length == 0\\\"><li ng-transclude=\\\"\\\"></li></ul>\");\n$templateCache.put(\"bootstrap/select-multiple.tpl.html\",\"<div class=\\\"ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control\\\" ng-class=\\\"{open: $select.open}\\\"><div><div class=\\\"ui-select-match\\\"></div><input type=\\\"search\\\" autocomplete=\\\"off\\\" autocorrect=\\\"off\\\" autocapitalize=\\\"off\\\" spellcheck=\\\"false\\\" class=\\\"ui-select-search input-xs\\\" placeholder=\\\"{{$selectMultiple.getPlaceholder()}}\\\" ng-disabled=\\\"$select.disabled\\\" ng-click=\\\"$select.activate()\\\" ng-model=\\\"$select.search\\\" role=\\\"combobox\\\" aria-label=\\\"{{ $select.baseTitle }}\\\" ondrop=\\\"return false;\\\"></div><div class=\\\"ui-select-choices\\\"></div><div class=\\\"ui-select-no-choice\\\"></div></div>\");\n$templateCache.put(\"bootstrap/select.tpl.html\",\"<div class=\\\"ui-select-container ui-select-bootstrap dropdown\\\" ng-class=\\\"{open: $select.open}\\\"><div class=\\\"ui-select-match\\\"></div><input type=\\\"search\\\" autocomplete=\\\"off\\\" tabindex=\\\"-1\\\" aria-expanded=\\\"true\\\" aria-label=\\\"{{ $select.baseTitle }}\\\" aria-owns=\\\"ui-select-choices-{{ $select.generatedId }}\\\" aria-activedescendant=\\\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\\\" class=\\\"form-control ui-select-search\\\" ng-class=\\\"{ \\'ui-select-search-hidden\\' : !$select.searchEnabled }\\\" placeholder=\\\"{{$select.placeholder}}\\\" ng-model=\\\"$select.search\\\" ng-show=\\\"$select.open\\\"><div class=\\\"ui-select-choices\\\"></div><div class=\\\"ui-select-no-choice\\\"></div></div>\");\n$templateCache.put(\"select2/choices.tpl.html\",\"<ul tabindex=\\\"-1\\\" class=\\\"ui-select-choices ui-select-choices-content select2-results\\\"><li class=\\\"ui-select-choices-group\\\" ng-class=\\\"{\\'select2-result-with-children\\': $select.choiceGrouped($group) }\\\"><div ng-show=\\\"$select.choiceGrouped($group)\\\" class=\\\"ui-select-choices-group-label select2-result-label\\\" ng-bind=\\\"$group.name\\\"></div><ul role=\\\"listbox\\\" id=\\\"ui-select-choices-{{ $select.generatedId }}\\\" ng-class=\\\"{\\'select2-result-sub\\': $select.choiceGrouped($group), \\'select2-result-single\\': !$select.choiceGrouped($group) }\\\"><li role=\\\"option\\\" ng-attr-id=\\\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\\\" class=\\\"ui-select-choices-row\\\" ng-class=\\\"{\\'select2-highlighted\\': $select.isActive(this), \\'select2-disabled\\': $select.isDisabled(this)}\\\"><div class=\\\"select2-result-label ui-select-choices-row-inner\\\"></div></li></ul></li></ul>\");\n$templateCache.put(\"select2/match-multiple.tpl.html\",\"<span class=\\\"ui-select-match\\\"><li class=\\\"ui-select-match-item select2-search-choice\\\" ng-repeat=\\\"$item in $select.selected track by $index\\\" ng-class=\\\"{\\'select2-search-choice-focus\\':$selectMultiple.activeMatchIndex === $index, \\'select2-locked\\':$select.isLocked(this, $index)}\\\" ui-select-sort=\\\"$select.selected\\\"><span uis-transclude-append=\\\"\\\"></span> <a href=\\\"javascript:;\\\" class=\\\"ui-select-match-close select2-search-choice-close\\\" ng-click=\\\"$selectMultiple.removeChoice($index)\\\" tabindex=\\\"-1\\\"></a></li></span>\");\n$templateCache.put(\"select2/match.tpl.html\",\"<a class=\\\"select2-choice ui-select-match\\\" ng-class=\\\"{\\'select2-default\\': $select.isEmpty()}\\\" ng-click=\\\"$select.toggle($event)\\\" aria-label=\\\"{{ $select.baseTitle }} select\\\"><span ng-show=\\\"$select.isEmpty()\\\" class=\\\"select2-chosen\\\">{{$select.placeholder}}</span> <span ng-hide=\\\"$select.isEmpty()\\\" class=\\\"select2-chosen\\\" ng-transclude=\\\"\\\"></span> <abbr ng-if=\\\"$select.allowClear && !$select.isEmpty()\\\" class=\\\"select2-search-choice-close\\\" ng-click=\\\"$select.clear($event)\\\"></abbr> <span class=\\\"select2-arrow ui-select-toggle\\\"><b></b></span></a>\");\n$templateCache.put(\"select2/no-choice.tpl.html\",\"<div class=\\\"ui-select-no-choice dropdown\\\" ng-show=\\\"$select.items.length == 0\\\"><div class=\\\"dropdown-content\\\"><div data-selectable=\\\"\\\" ng-transclude=\\\"\\\"></div></div></div>\");\n$templateCache.put(\"select2/select-multiple.tpl.html\",\"<div class=\\\"ui-select-container ui-select-multiple select2 select2-container select2-container-multi\\\" ng-class=\\\"{\\'select2-container-active select2-dropdown-open open\\': $select.open, \\'select2-container-disabled\\': $select.disabled}\\\"><ul class=\\\"select2-choices\\\"><span class=\\\"ui-select-match\\\"></span><li class=\\\"select2-search-field\\\"><input type=\\\"search\\\" autocomplete=\\\"off\\\" autocorrect=\\\"off\\\" autocapitalize=\\\"off\\\" spellcheck=\\\"false\\\" role=\\\"combobox\\\" aria-expanded=\\\"true\\\" aria-owns=\\\"ui-select-choices-{{ $select.generatedId }}\\\" aria-label=\\\"{{ $select.baseTitle }}\\\" aria-activedescendant=\\\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\\\" class=\\\"select2-input ui-select-search\\\" placeholder=\\\"{{$selectMultiple.getPlaceholder()}}\\\" ng-disabled=\\\"$select.disabled\\\" ng-hide=\\\"$select.disabled\\\" ng-model=\\\"$select.search\\\" ng-click=\\\"$select.activate()\\\" style=\\\"width: 34px;\\\" ondrop=\\\"return false;\\\"></li></ul><div class=\\\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\\\" ng-class=\\\"{\\'select2-display-none\\': !$select.open || $select.items.length === 0}\\\"><div class=\\\"ui-select-choices\\\"></div></div></div>\");\n$templateCache.put(\"select2/select.tpl.html\",\"<div class=\\\"ui-select-container select2 select2-container\\\" ng-class=\\\"{\\'select2-container-active select2-dropdown-open open\\': $select.open, \\'select2-container-disabled\\': $select.disabled, \\'select2-container-active\\': $select.focus, \\'select2-allowclear\\': $select.allowClear && !$select.isEmpty()}\\\"><div class=\\\"ui-select-match\\\"></div><div class=\\\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\\\" ng-class=\\\"{\\'select2-display-none\\': !$select.open}\\\"><div class=\\\"search-container\\\" ng-class=\\\"{\\'ui-select-search-hidden\\':!$select.searchEnabled, \\'select2-search\\':$select.searchEnabled}\\\"><input type=\\\"search\\\" autocomplete=\\\"off\\\" autocorrect=\\\"off\\\" autocapitalize=\\\"off\\\" spellcheck=\\\"false\\\" role=\\\"combobox\\\" aria-expanded=\\\"true\\\" aria-owns=\\\"ui-select-choices-{{ $select.generatedId }}\\\" aria-label=\\\"{{ $select.baseTitle }}\\\" aria-activedescendant=\\\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\\\" class=\\\"ui-select-search select2-input\\\" ng-model=\\\"$select.search\\\"></div><div class=\\\"ui-select-choices\\\"></div><div class=\\\"ui-select-no-choice\\\"></div></div></div>\");\n$templateCache.put(\"selectize/choices.tpl.html\",\"<div ng-show=\\\"$select.open\\\" class=\\\"ui-select-choices ui-select-dropdown selectize-dropdown single\\\"><div class=\\\"ui-select-choices-content selectize-dropdown-content\\\"><div class=\\\"ui-select-choices-group optgroup\\\" role=\\\"listbox\\\"><div ng-show=\\\"$select.isGrouped\\\" class=\\\"ui-select-choices-group-label optgroup-header\\\" ng-bind=\\\"$group.name\\\"></div><div role=\\\"option\\\" class=\\\"ui-select-choices-row\\\" ng-class=\\\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\\\"><div class=\\\"option ui-select-choices-row-inner\\\" data-selectable=\\\"\\\"></div></div></div></div></div>\");\n$templateCache.put(\"selectize/match.tpl.html\",\"<div ng-hide=\\\"$select.searchEnabled && ($select.open || $select.isEmpty())\\\" class=\\\"ui-select-match\\\"><span ng-show=\\\"!$select.searchEnabled && ($select.isEmpty() || $select.open)\\\" class=\\\"ui-select-placeholder text-muted\\\">{{$select.placeholder}}</span> <span ng-hide=\\\"$select.isEmpty() || $select.open\\\" ng-transclude=\\\"\\\"></span></div>\");\n$templateCache.put(\"selectize/no-choice.tpl.html\",\"<div class=\\\"ui-select-no-choice selectize-dropdown\\\" ng-show=\\\"$select.items.length == 0\\\"><div class=\\\"selectize-dropdown-content\\\"><div data-selectable=\\\"\\\" ng-transclude=\\\"\\\"></div></div></div>\");\n$templateCache.put(\"selectize/select.tpl.html\",\"<div class=\\\"ui-select-container selectize-control single\\\" ng-class=\\\"{\\'open\\': $select.open}\\\"><div class=\\\"selectize-input\\\" ng-class=\\\"{\\'focus\\': $select.open, \\'disabled\\': $select.disabled, \\'selectize-focus\\' : $select.focus}\\\" ng-click=\\\"$select.open && !$select.searchEnabled ? $select.toggle($event) : $select.activate()\\\"><div class=\\\"ui-select-match\\\"></div><input type=\\\"search\\\" autocomplete=\\\"off\\\" tabindex=\\\"-1\\\" class=\\\"ui-select-search ui-select-toggle\\\" ng-class=\\\"{\\'ui-select-search-hidden\\':!$select.searchEnabled}\\\" ng-click=\\\"$select.toggle($event)\\\" placeholder=\\\"{{$select.placeholder}}\\\" ng-model=\\\"$select.search\\\" ng-hide=\\\"!$select.isEmpty() && !$select.open\\\" ng-disabled=\\\"$select.disabled\\\" aria-label=\\\"{{ $select.baseTitle }}\\\"></div><div class=\\\"ui-select-choices\\\"></div><div class=\\\"ui-select-no-choice\\\"></div></div>\");}]);\n","(function() {\n  angular\n    .module('validation.rule', ['validation'])\n    .config(['$validationProvider', function($validationProvider) {\n      var expression = {\n        required: function(value) {\n          return !!value;\n        },\n        url: /((([A-Za-z]{3,9}:(?:\\/\\/)?)(?:[-;:&=\\+\\$,\\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=\\+\\$,\\w]+@)[A-Za-z0-9.-]+)((?:\\/[\\+~%\\/.\\w-_]*)?\\??(?:[-\\+=&;%@.\\w_]*)#?(?:[\\w]*))?)/,\n        email: /^([\\w-\\.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([\\w-]+\\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\\]?)$/,\n        number: /^\\d+$/,\n        minlength: function(value, scope, element, attrs, param) {\n          return value && value.length >= param;\n        },\n        maxlength: function(value, scope, element, attrs, param) {\n          return !value || value.length <= param;\n        }\n      };\n\n      var defaultMsg = {\n        required: {\n          error: 'Dit veld is verplicht',\n          success: ''\n        },\n        url: {\n          error: 'Dit is geen geldige URL',\n          success: ''\n        },\n        email: {\n          error: 'Dit is geen geldig e-mailadres',\n          success: ''\n        },\n        number: {\n          error: 'Dit veld moet een nummer zijn',\n          success: ''\n        },\n        minlength: {\n          error: 'Dit is niet lang genoeg',\n          success: ''\n        },\n        maxlength: {\n          error: 'Dit moet korter',\n          success: ''\n        }\n      };\n      $validationProvider.setExpression(expression).setDefaultMsg(defaultMsg);\n    }]);\n}).call(this);\n","angular.module('validation', ['validation.provider', 'validation.directive']);\nangular.module('validation.provider', []);\nangular.module('validation.directive', ['validation.provider']);\n\n(function() {\n  angular\n    .module('validation.provider')\n    .provider('$validation', Provider);\n\n  function Provider() {\n    var $injector;\n    var $scope;\n    var $http;\n    var $q;\n    var $timeout;\n    var _this = this;\n\n    /**\n     * Setup the provider\n     * @param injector\n     */\n    var setup = function(injector) {\n      $injector = injector;\n      $scope = $injector.get('$rootScope');\n      $http = $injector.get('$http');\n      $q = $injector.get('$q');\n      $timeout = $injector.get('$timeout');\n    };\n\n    /**\n     * Define validation type RegExp\n     * @type {{}}\n     */\n    var expression = {};\n\n    /**\n     * default valid method\n     * @type {{}}\n     */\n    var validMethod = null;\n\n    /**\n     * default error, success message\n     * @type {{}}\n     */\n    var defaultMsg = {};\n\n    /**\n     * Allow user to set a custom Expression, do remember set the default message using setDefaultMsg\n     * @param obj\n     * @returns {*}\n     */\n    this.setExpression = function(obj) {\n      angular.extend(expression, obj);\n      return _this;\n    };\n\n    /**\n     * Get the Expression\n     * @param exprs\n     * @returns {*}\n     */\n    this.getExpression = function(exprs) {\n      return expression[exprs];\n    };\n\n    /**\n     * Allow user to set default message\n     * @param obj\n     * @returns {*}\n     */\n    this.setDefaultMsg = function(obj) {\n      angular.extend(defaultMsg, obj);\n      return _this;\n    };\n\n    /**\n     * Get the Default Message\n     * @param msg\n     * @returns {*}\n     */\n    this.getDefaultMsg = function(msg) {\n      return defaultMsg[msg];\n    };\n\n    /**\n     * allow user to set the global valid method\n     * @param v\n     * @returns {*}\n     */\n    this.setValidMethod = function(v) {\n      validMethod = v;\n    };\n\n    /**\n     * Get the valid method     \n     * @returns {*}\n     */\n    this.getValidMethod = function() {\n      return validMethod;\n    };\n\n    /**\n     * Override the errorHTML function\n     * @param func\n     * @returns {*}\n     */\n    this.setErrorHTML = function(func) {\n      if (func.constructor !== Function) {\n        return;\n      }\n      _this.getErrorHTML = func;\n      return _this;\n    };\n\n    /**\n     * Invalid message HTML, here's the default\n     * @param message\n     * @returns {string}\n     */\n    this.getErrorHTML = function(message) {\n      return '<p class=\"validation-invalid\">' + message + '</p>';\n    };\n\n    /**\n     * Override the successHTML function\n     * @param func\n     * @returns {*}\n     */\n    this.setSuccessHTML = function(func) {\n      if (func.constructor !== Function) {\n        return;\n      }\n      _this.getSuccessHTML = func;\n      return _this;\n    };\n\n    /**\n     * Valid message HTML, here's the default\n     * @param message\n     * @returns {string}\n     */\n    this.getSuccessHTML = function(message) {\n      return '<p class=\"validation-valid\">' + message + '</p>';\n    };\n\n    /**\n     * Whether show the validation success message\n     * You can easily change this to false in your config\n     * example: $validationProvider.showSuccessMessage = false;\n     * @type {boolean}\n     */\n    this.showSuccessMessage = true;\n\n    /**\n     * Whether show the validation error message\n     * You can easily change this to false in your config\n     * example: $validationProvider.showErrorMessage = false;\n     * @type {boolean}\n     */\n    this.showErrorMessage = true;\n\n    /**\n     * Check form valid, return true\n     * checkValid(Form): Check the specific form(Form) valid from angular `$valid`\n     * @param form\n     * @returns {boolean}\n     */\n    this.checkValid = function(form) {\n      return !!(form && form.$valid);\n    };\n\n    /**\n     * Validate the form when click submit, when `validMethod = submit`\n     * @param form\n     * @returns {promise|*}\n     */\n    this.validate = function(form) {\n      var deferred = $q.defer();\n      var idx = 0;\n\n      if (form === undefined) {\n        console.error('This is not a regular Form name scope');\n        deferred.reject('This is not a regular Form name scope');\n        return deferred.promise;\n      }\n\n      if (form.validationId) { // single\n        $scope.$broadcast(form.$name + 'submit-' + form.validationId, idx++);\n      } else if (form.constructor === Array) { // multiple\n        for (var k in form) {\n          $scope.$broadcast(form[k].$name + 'submit-' + form[k].validationId, idx++);\n        }\n      } else {\n        for (var i in form) { // whole scope\n          if (i[0] !== '$' && form[i].hasOwnProperty('$dirty')) {\n            $scope.$broadcast(i + 'submit-' + form[i].validationId, idx++);\n          }\n        }\n      }\n\n      deferred.promise.success = function(fn) {\n        deferred.promise.then(function(value) {\n          fn(value);\n        });\n        return deferred.promise;\n      };\n\n      deferred.promise.error = function(fn) {\n        deferred.promise.then(null, function(value) {\n          fn(value);\n        });\n        return deferred.promise;\n      };\n\n      $timeout(function() {\n        if (_this.checkValid(form)) {\n          deferred.resolve('success');\n        } else {\n          deferred.reject('error');\n        }\n      });\n\n      return deferred.promise;\n    };\n\n    /**\n     * Do this function if validation valid\n     * @param element\n     */\n    this.validCallback = null;\n\n    /**\n     * Do this function if validation invalid\n     * @param element\n     */\n    this.invalidCallback = null;\n\n    /**\n     * Do this function when reset is performed\n     * @param element\n     */\n    this.resetCallback = null;\n\n    /**\n     * reset the specific form\n     * @param form\n     */\n    this.reset = function(form) {\n      if (form === undefined) {\n        console.error('This is not a regular Form name scope');\n        return;\n      }\n\n      if (form.validationId) {\n        $scope.$broadcast(form.$name + 'reset-' + form.validationId);\n      } else if (form.constructor === Array) {\n        for (var k in form) {\n          $scope.$broadcast(form[k].$name + 'reset-' + form[k].validationId);\n        }\n      } else {\n        for (var i in form) {\n          if (i[0] !== '$' && form[i].hasOwnProperty('$dirty')) {\n            $scope.$broadcast(i + 'reset-' + form[i].validationId);\n          }\n        }\n      }\n    };\n\n    /**\n     * Add Message Element in config phase\n     * When you need custom your messageElement \n     * NODE: this funtion & and `message-id` attribute, have similar purpose.\n     * This function will help you add your `messageElement` automatically instead of pre-defined.\n     * @param element\n     */\n    this.addMsgElement = function(element) {\n      return element.after('<span></span>');\n    };\n\n    /**\n     * Add Message Element in config phase\n     * When you need custom your messageElement \n     * NODE: this funtion & and `message-id` attribute, have similar purpose.\n     * This function will help you add your `messageElement` automatically instead of pre-defined.\n     * @param element\n     */\n    this.getMsgElement = function(element) {\n      return element.next();\n    };\n\n    /**\n     * $get\n     * @returns {{setErrorHTML: *, getErrorHTML: Function, setSuccessHTML: *, getSuccessHTML: Function, setExpression: *, getExpression: Function, setDefaultMsg: *, getDefaultMsg: Function, checkValid: Function, validate: Function, reset: Function}}\n     */\n    this.$get = ['$injector', function($injector) {\n      setup($injector);\n      return {\n        setValidMethod: this.setValidMethod,\n        getValidMethod: this.getValidMethod,\n        setErrorHTML: this.setErrorHTML,\n        getErrorHTML: this.getErrorHTML,\n        setSuccessHTML: this.setSuccessHTML,\n        getSuccessHTML: this.getSuccessHTML,\n        setExpression: this.setExpression,\n        getExpression: this.getExpression,\n        setDefaultMsg: this.setDefaultMsg,\n        getDefaultMsg: this.getDefaultMsg,\n        showSuccessMessage: this.showSuccessMessage,\n        showErrorMessage: this.showErrorMessage,\n        checkValid: this.checkValid,\n        validate: this.validate,\n        validCallback: this.validCallback,\n        invalidCallback: this.invalidCallback,\n        resetCallback: this.resetCallback,\n        reset: this.reset,\n        addMsgElement: this.addMsgElement,\n        getMsgElement: this.getMsgElement\n      };\n    }];\n  }\n}).call(this);\n\n(function() {\n  angular\n    .module('validation.directive')\n    .directive('validationReset', Reset);\n\n  function Reset($injector) {\n    var $validationProvider = $injector.get('$validation');\n    var $timeout = $injector.get('$timeout');\n    var $parse = $injector.get('$parse');\n    return {\n      link: function postLink(scope, element, attrs) {\n        var form = $parse(attrs.validationReset)(scope);\n        $timeout(function() {\n          element.on('click', function(e) {\n            e.preventDefault();\n            $validationProvider.reset(form);\n          });\n        });\n      }\n    };\n  }\n  Reset.$inject = ['$injector'];\n}).call(this);\n\n(function() {\n  angular\n    .module('validation.directive')\n    .directive('validationSubmit', Submit);\n\n  function Submit($injector) {\n    var $validationProvider = $injector.get('$validation');\n    var $timeout = $injector.get('$timeout');\n    var $parse = $injector.get('$parse');\n    return {\n      priority: 1, // execute before ng-click (0)\n      require: '?ngClick',\n      link: function postLink(scope, element, attrs) {\n        var form = $parse(attrs.validationSubmit)(scope);\n        $timeout(function() {\n          // Disable ng-click event propagation\n          element.off('click');\n          element.on('click', function(e) {\n            e.preventDefault();\n            $validationProvider.validate(form)\n              .success(function() {\n                $parse(attrs.ngClick)(scope);\n              });\n          });\n        });\n      }\n    };\n  }\n  Submit.$inject = ['$injector'];\n}).call(this);\n\n(function() {\n  angular\n    .module('validation.directive')\n    .directive('validator', Validator);\n\n  function Validator($injector) {\n    var $validationProvider = $injector.get('$validation');\n    var $q = $injector.get('$q');\n    var $timeout = $injector.get('$timeout');\n    var $compile = $injector.get('$compile');\n    var $parse = $injector.get('$parse');\n    var groups = {};\n\n    /**\n     * Do this function if validation valid\n     * @param element\n     * @param validMessage\n     * @param validation\n     * @param callback\n     * @param ctrl\n     * @returns {}\n     */\n    var validFunc = function(element, validMessage, validation, scope, ctrl, attrs) {\n      var messageToShow = validMessage || $validationProvider.getDefaultMsg(validation).success;\n      var validCallback = $parse(attrs.validCallback);\n      var messageId = attrs.messageId;\n      var validationGroup = attrs.validationGroup;\n      var messageElem;\n\n      if (messageId || validationGroup) messageElem = angular.element(document.querySelector('#' + (messageId || validationGroup)));\n      else messageElem = $validationProvider.getMsgElement(element);\n\n      if (element.attr('no-validation-message')) {\n        messageElem.css('display', 'none');\n      } else if ($validationProvider.showSuccessMessage && messageToShow) {\n        messageElem.html('').append($compile($validationProvider.getSuccessHTML(messageToShow, element, attrs))(scope));\n        messageElem.css('display', '');\n      } else {\n        messageElem.css('display', 'none');\n      }\n\n      ctrl.$setValidity(ctrl.$name, true);\n      validCallback(scope, {\n        message: messageToShow\n      });\n      if ($validationProvider.validCallback) $validationProvider.validCallback(element);\n\n      return true;\n    };\n\n\n    /**\n     * Do this function if validation invalid\n     * @param element\n     * @param validMessage\n     * @param validation\n     * @param callback\n     * @param ctrl\n     * @returns {}\n     */\n    var invalidFunc = function(element, validMessage, validation, scope, ctrl, attrs) {\n      var messageToShow = validMessage || $validationProvider.getDefaultMsg(validation).error;\n      var invalidCallback = $parse(attrs.invalidCallback);\n      var messageId = attrs.messageId;\n      var validationGroup = attrs.validationGroup;\n      var messageElem;\n\n      if (messageId || validationGroup) messageElem = angular.element(document.querySelector('#' + (messageId || validationGroup)));\n      else messageElem = $validationProvider.getMsgElement(element);\n\n      if (element.attr('no-validation-message')) {\n        messageElem.css('display', 'none');\n      } else if ($validationProvider.showErrorMessage && messageToShow) {\n        messageElem.html('').append($compile($validationProvider.getErrorHTML(messageToShow, element, attrs))(scope));\n        messageElem.css('display', '');\n      } else {\n        messageElem.css('display', 'none');\n      }\n\n      ctrl.$setValidity(ctrl.$name, false);\n      invalidCallback(scope, {\n        message: messageToShow\n      });\n      if ($validationProvider.invalidCallback) $validationProvider.invalidCallback(element);\n\n      return false;\n    };\n\n    /**\n     * Verify whether there is one of the elements inside the group valid.\n     * If so, it returns true, otherwise, it returns false\n     *\n     * @param validationGroup\n     * @return {boolean}\n     */\n    var checkValidationGroup = function(validationGroup) {\n      var group = groups[validationGroup];\n\n      return Object.keys(group).some(function(key) {\n        return group[key];\n      });\n    };\n\n    /**\n     * Set validity to all elements inside the given group\n     *\n     * @param scope\n     * @param groupName\n     * @param validity\n     */\n    function setValidationGroup(scope, validationGroup, validity) {\n      var validationGroupElems = document.querySelectorAll('*[validation-group=' + validationGroup + ']');\n\n      // Loop through all elements inside the group\n      for (var i = 0, len = validationGroupElems.length; i < len; i++) {\n        var elem = validationGroupElems[i];\n        var formName = elem.form.name;\n        var elemName = elem.name;\n        scope[formName][elemName].$setValidity(elemName, validity);\n      }\n    }\n\n    /**\n     * collect elements for focus\n     * @type {Object}\n     ***private variable\n     */\n    var focusElements = {};\n\n    /**\n     * Get Validation Result Object\n     * @param data\n     * @returns {\n     *    result: Boolean, // is success or error\n     *    message: String  // tips\n     * }\n     */\n    function getResultObj(data) {\n      var res = {};\n      if (data && data.length > 0) {\n        res = data[0];\n        if (!angular.isObject(res)) {\n          res = {\n            result: res,\n            message: ''\n          };\n        }\n      } else {\n        res = {\n          result: false,\n          message: ''\n        };\n      }\n      return res;\n    }\n\n    /**\n     * Check Validation with Function or RegExp\n     * @param scope\n     * @param element\n     * @param attrs\n     * @param ctrl\n     * @param validation\n     * @param value\n     * @returns {}\n     */\n    var checkValidation = function(scope, element, attrs, ctrl, validation, value) {\n      var validators = validation.slice(0);\n      var validatorExpr = validators[0].trim();\n      var paramIndex = validatorExpr.indexOf('=');\n      var validator = paramIndex === -1 ? validatorExpr : validatorExpr.substr(0, paramIndex);\n      var validatorParam = paramIndex === -1 ? null : validatorExpr.substr(paramIndex + 1);\n      var leftValidation = validators.slice(1);\n      var successMessage = validator + 'SuccessMessage';\n      var errorMessage = validator + 'ErrorMessage';\n      var expression = $validationProvider.getExpression(validator);\n      var validationGroup = attrs.validationGroup;\n      var valid = {\n        success: function(message) {\n          validFunc(element, message || attrs[successMessage], validator, scope, ctrl, attrs);\n          if (leftValidation.length) {\n            return checkValidation(scope, element, attrs, ctrl, leftValidation, value);\n          } else {\n            return true;\n          }\n        },\n        error: function(message) {\n          return invalidFunc(element, message || attrs[errorMessage], validator, scope, ctrl, attrs);\n        }\n      };\n\n      if (expression === undefined) {\n        console.error('You are using undefined validator \"%s\"', validator);\n        if (leftValidation.length) return checkValidation(scope, element, attrs, ctrl, leftValidation, value);\n        else return;\n      }\n      // Check with Function\n      if (expression.constructor === Function) {\n        return $q.all([$validationProvider.getExpression(validator)(value, scope, element, attrs, validatorParam)])\n          .then(function(data) {\n            var resultObj = getResultObj(data);\n            var message = resultObj.message;\n            if (resultObj.result) {\n              if (validationGroup) {\n                groups[validationGroup][ctrl.$name] = true;\n                setValidationGroup(scope, validationGroup, true);\n              }\n              return valid.success(message);\n            } else if (validationGroup) {\n              groups[validationGroup][ctrl.$name] = false;\n\n              // Whenever the element is invalid, we'll check whether one of the elements inside the its group valid or not.\n              // If there is a valid element, its invalid message won't be shown, Otherwise, shows its invalid message.\n              if (checkValidationGroup(validationGroup)) {\n                setValidationGroup(scope, validationGroup, true);\n              } else {\n                setValidationGroup(scope, validationGroup, false);\n                return valid.error(message);\n              }\n            } else return valid.error(message);\n          }, function() {\n            return valid.error();\n          });\n      }\n\n      // Check with RegExp\n      else if (expression.constructor === RegExp) {\n        // Only apply the test if the value is neither undefined or null\n        if (value !== undefined && value !== null) {\n          if ($validationProvider.getExpression(validator).test(value)) {\n            if (validationGroup) {\n              groups[validationGroup][ctrl.$name] = true;\n              setValidationGroup(scope, validationGroup, true);\n            }\n            return valid.success();\n          } else if (validationGroup) {\n            groups[validationGroup][ctrl.$name] = false;\n\n            // Whenever the element is invalid, we'll check whether one of the elements inside the its group valid or not.\n            // If there is a valid element, its invalid message won't be shown, Otherwise, shows its invalid message.\n            if (checkValidationGroup(validationGroup)) {\n              setValidationGroup(scope, validationGroup, true);\n            } else {\n              setValidationGroup(scope, validationGroup, false);\n              return valid.error();\n            }\n          } else return valid.error();\n        }\n      } else return valid.error();\n    };\n\n    /**\n     * generate unique guid\n     */\n    var s4 = function() {\n      return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n    };\n    var guid = function() {\n      return (s4() + s4() + s4() + s4());\n    };\n\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function(scope, element, attrs, ctrl) {\n        /**\n         * All attributes\n         */\n        var useViewValue = attrs.useViewValue !== 'false';\n        var validator = attrs.validator;\n        var messageId = attrs.messageId;\n        var validationGroup = attrs.validationGroup;\n        var validMethod = attrs.validMethod;\n        var ngModel = attrs.ngModel;\n\n        /**\n         * watch\n         * @type {watch}\n         *\n         * Use to collect scope.$watch method\n         *\n         * use watch() to destroy the $watch method\n         */\n        var watch = function() {};\n\n        /**\n         * validator\n         * @type {Array}\n         *\n         * Convert user input String to Array\n         */\n        var validation = validator.split(',');\n\n        /**\n         * guid use\n         */\n        var uid = ctrl.validationId = guid();\n\n        /**\n         * to have a value to rollback to\n         */\n        var originalViewValue = null;\n\n        /**\n         * Set initial validity to undefined if no boolean value is transmitted\n         */\n        var initialValidity = void 0;\n        if (typeof attrs.initialValidity === 'boolean') {\n          initialValidity = attrs.initialValidity;\n        }\n\n        /**\n         * Observe validator changes in order to allow dynamically change it\n         */\n        attrs.$observe('validator', function(value) {\n          validation = value.split(',');\n        });\n\n        /**\n         * Set up groups object in order to keep track validation of elements\n         */\n        if (validationGroup) {\n          if (!groups[validationGroup]) groups[validationGroup] = {};\n          groups[validationGroup][ctrl.$name] = false;\n        }\n\n        /**\n         * Default Valid/Invalid Message\n         */\n        if (!(messageId || validationGroup)) $validationProvider.addMsgElement(element);\n\n        /**\n         * Set custom initial validity\n         * Usage: <input initial-validity=\"true\" ... >\n         */\n        ctrl.$setValidity(ctrl.$name, initialValidity);\n\n        /**\n         * Reset the validation for specific form\n         */\n        scope.$on(ctrl.$name + 'reset-' + uid, function() {\n          /**\n           * clear scope.$watch here\n           * when reset status\n           * clear the $watch method to prevent\n           * $watch again while reset the form\n           */\n          watch();\n\n          $timeout(function() {\n            ctrl.$setViewValue(originalViewValue);\n            ctrl.$setPristine();\n            ctrl.$setValidity(ctrl.$name, undefined);\n            ctrl.$render();\n            if (messageId || validationGroup) angular.element(document.querySelector('#' + (messageId || validationGroup))).html('');\n            else $validationProvider.getMsgElement(element).html('');\n\n            if ($validationProvider.resetCallback) $validationProvider.resetCallback(element);\n          });\n        });\n\n        /**\n         * Check validator\n         */\n        validMethod = (angular.isUndefined(validMethod)) ? $validationProvider.getValidMethod() : validMethod;\n\n        /**\n         * Click submit form, check the validity when submit\n         */\n        scope.$on(ctrl.$name + 'submit-' + uid, function(event, index) {\n          var value = useViewValue ? ctrl.$viewValue : ctrl.$modelValue;\n          var isValid = false;\n\n          isValid = checkValidation(scope, element, attrs, ctrl, validation, value);\n\n          if (validMethod === 'submit') {\n            // clear previous scope.$watch\n            watch();\n            watch = scope.$watch(function() {\n              return scope.$eval(ngModel);\n            }, function(value, oldValue) {\n              // don't watch when init\n              if (value === oldValue) {\n                return;\n              }\n\n              // scope.$watch will translate '' to undefined\n              // undefined/null will pass the required submit /^.+/\n              // cause some error in this validation\n              if (value === undefined || value === null) {\n                value = '';\n              }\n\n              isValid = checkValidation(scope, element, attrs, ctrl, validation, value);\n            });\n          }\n\n          var setFocus = function(isValid) {\n            if (isValid) {\n              delete focusElements[index];\n            } else {\n              focusElements[index] = element[0];\n\n              $timeout(function() {\n                focusElements[Math.min.apply(null, Object.keys(focusElements))].focus();\n              }, 0);\n            }\n          };\n\n          if (isValid.constructor === Object) isValid.then(setFocus);\n          else setFocus(isValid);\n        });\n\n        /**\n         * Validate blur method\n         */\n        if (validMethod === 'blur') {\n          element.bind('blur', function() {\n            var value = scope.$eval(ngModel);\n            scope.$apply(function() {\n              checkValidation(scope, element, attrs, ctrl, validation, value);\n            });\n          });\n\n          return;\n        }\n\n        /**\n         * Validate submit & submit-only method\n         */\n        if (validMethod === 'submit' || validMethod === 'submit-only') {\n          return;\n        }\n\n        /**\n         * Validate watch method\n         * This is the default method\n         */\n        scope.$watch(function() {\n          return scope.$eval(ngModel);\n        }, function(value) {\n          /**\n           * dirty, pristine, viewValue control here\n           */\n          if (ctrl.$pristine && ctrl.$viewValue) {\n            // has value when initial\n            originalViewValue = ctrl.$viewValue || '';\n            ctrl.$setViewValue(ctrl.$viewValue);\n          } else if (ctrl.$pristine) {\n            // Don't validate form when the input is clean(pristine)\n            if (messageId || validationGroup) angular.element(document.querySelector('#' + (messageId || validationGroup))).html('');\n            else $validationProvider.getMsgElement(element).html('');\n            return;\n          }\n          checkValidation(scope, element, attrs, ctrl, validation, value);\n        });\n\n        $timeout(function() {\n          /**\n           * Don't showup the validation Message\n           */\n          attrs.$observe('noValidationMessage', function(value) {\n            var el;\n            if (messageId || validationGroup) el = angular.element(document.querySelector('#' + (messageId || validationGroup)));\n            else el = $validationProvider.getMsgElement(element);\n            if (value === 'true' || value === true) el.css('display', 'none');\n            else if (value === 'false' || value === false) el.css('display', 'block');\n          });\n        });\n      }\n    };\n  }\n  Validator.$inject = ['$injector'];\n}).call(this);\n","/*!\n * angular-vertilize 1.0.1\n * Christopher Collins\n * https://github.com/Sixthdim/angular-vertilize.git\n * License: MIT\n */\n(function () {\n  \"use strict\";\n\n  var module = angular.module('angular.vertilize', []);\n\n  // Vertilize Container\n  module.directive('vertilizeContainer', [\n    function(){\n      return {\n        restrict: 'EA',\n        controller: [\n          '$scope', '$window',\n          function($scope, $window){\n            // Alias this\n            var _this = this;\n\n            // Array of children heights\n            _this.childrenHeights = [];\n\n            // API: Allocate child, return index for tracking.\n            _this.allocateMe = function(){\n              _this.childrenHeights.push(0);\n              return (_this.childrenHeights.length - 1);\n            };\n\n            // API: Update a child's height\n            _this.updateMyHeight = function(index, height){\n              _this.childrenHeights[index] = height;\n            };\n\n            // API: Get tallest height\n            _this.getTallestHeight = function(){\n              var height = 0;\n              for (var i=0; i < _this.childrenHeights.length; i=i+1){\n                height = Math.max(height, _this.childrenHeights[i]);\n              }\n              return height;\n            };\n\n            // Add window resize to digest cycle\n            angular.element($window).bind('resize', function(){\n              return $scope.$apply();\n            });\n          }\n        ]\n      };\n    }\n  ]);\n\n  // Vertilize Item\n  module.directive('vertilize', [\n    function(){\n      return {\n        restrict: 'EA',\n        require: '^vertilizeContainer',\n        link: function(scope, element, attrs, parent){\n          // My index allocation\n          var myIndex = parent.allocateMe();\n\n          // Get my real height by cloning so my height is not affected.\n          var getMyRealHeight = function(){\n            var clone = element.clone()\n              .removeAttr('vertilize')\n              .css({\n                height: '',\n                width: element.outerWidth(),\n                position: 'fixed',\n                top: 0,\n                left: 0,\n                visibility: 'hidden'\n              });\n            element.after(clone);\n            var realHeight = clone.height();\n            clone['remove']();\n            return realHeight;\n          };\n\n          // Watch my height\n          scope.$watch(getMyRealHeight, function(myNewHeight){\n            if (myNewHeight){\n              parent.updateMyHeight(myIndex, myNewHeight);\n            }\n          });\n\n          // Watch for tallest height change\n          scope.$watch(parent.getTallestHeight, function(tallestHeight){\n            if (tallestHeight){\n              element.css('height', tallestHeight);\n            }\n          });\n        }\n      };\n    }\n  ]);\n\n}());\n","/**\n * Owl Carousel v2.2.1\n * Copyright 2013-2017 David Deutsch\n * Licensed under  ()\n */\n/**\n * Owl carousel\n * @version 2.1.6\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n * @todo Lazy Load Icon\n * @todo prevent animationend bubling\n * @todo itemsScaleUp\n * @todo Test Zepto\n * @todo stagePadding calculate wrong active classes\n */\n;(function($, window, document, undefined) {\n\n    /**\n     * Creates a carousel.\n     * @class The Owl Carousel.\n     * @public\n     * @param {HTMLElement|jQuery} element - The element to create the carousel for.\n     * @param {Object} [options] - The options\n     */\n    function Owl(element, options) {\n\n        /**\n         * Current settings for the carousel.\n         * @public\n         */\n        this.settings = null;\n\n        /**\n         * Current options set by the caller including defaults.\n         * @public\n         */\n        this.options = $.extend({}, Owl.Defaults, options);\n\n        /**\n         * Plugin element.\n         * @public\n         */\n        this.$element = $(element);\n\n        /**\n         * Proxied event handlers.\n         * @protected\n         */\n        this._handlers = {};\n\n        /**\n         * References to the running plugins of this carousel.\n         * @protected\n         */\n        this._plugins = {};\n\n        /**\n         * Currently suppressed events to prevent them from beeing retriggered.\n         * @protected\n         */\n        this._supress = {};\n\n        /**\n         * Absolute current position.\n         * @protected\n         */\n        this._current = null;\n\n        /**\n         * Animation speed in milliseconds.\n         * @protected\n         */\n        this._speed = null;\n\n        /**\n         * Coordinates of all items in pixel.\n         * @todo The name of this member is missleading.\n         * @protected\n         */\n        this._coordinates = [];\n\n        /**\n         * Current breakpoint.\n         * @todo Real media queries would be nice.\n         * @protected\n         */\n        this._breakpoint = null;\n\n        /**\n         * Current width of the plugin element.\n         */\n        this._width = null;\n\n        /**\n         * All real items.\n         * @protected\n         */\n        this._items = [];\n\n        /**\n         * All cloned items.\n         * @protected\n         */\n        this._clones = [];\n\n        /**\n         * Merge values of all items.\n         * @todo Maybe this could be part of a plugin.\n         * @protected\n         */\n        this._mergers = [];\n\n        /**\n         * Widths of all items.\n         */\n        this._widths = [];\n\n        /**\n         * Invalidated parts within the update process.\n         * @protected\n         */\n        this._invalidated = {};\n\n        /**\n         * Ordered list of workers for the update process.\n         * @protected\n         */\n        this._pipe = [];\n\n        /**\n         * Current state information for the drag operation.\n         * @todo #261\n         * @protected\n         */\n        this._drag = {\n            time: null,\n            target: null,\n            pointer: null,\n            stage: {\n                start: null,\n                current: null\n            },\n            direction: null\n        };\n\n        /**\n         * Current state information and their tags.\n         * @type {Object}\n         * @protected\n         */\n        this._states = {\n            current: {},\n            tags: {\n                'initializing': [ 'busy' ],\n                'animating': [ 'busy' ],\n                'dragging': [ 'interacting' ]\n            }\n        };\n\n        $.each([ 'onResize', 'onThrottledResize' ], $.proxy(function(i, handler) {\n            this._handlers[handler] = $.proxy(this[handler], this);\n        }, this));\n\n        $.each(Owl.Plugins, $.proxy(function(key, plugin) {\n            this._plugins[key.charAt(0).toLowerCase() + key.slice(1)]\n                = new plugin(this);\n        }, this));\n\n        $.each(Owl.Workers, $.proxy(function(priority, worker) {\n            this._pipe.push({\n                'filter': worker.filter,\n                'run': $.proxy(worker.run, this)\n            });\n        }, this));\n\n        this.setup();\n        this.initialize();\n    }\n\n    /**\n     * Default options for the carousel.\n     * @public\n     */\n    Owl.Defaults = {\n        items: 3,\n        loop: false,\n        center: false,\n        rewind: false,\n\n        mouseDrag: true,\n        touchDrag: true,\n        pullDrag: true,\n        freeDrag: false,\n\n        margin: 0,\n        stagePadding: 0,\n\n        merge: false,\n        mergeFit: true,\n        autoWidth: false,\n\n        startPosition: 0,\n        rtl: false,\n\n        smartSpeed: 250,\n        fluidSpeed: false,\n        dragEndSpeed: false,\n\n        responsive: {},\n        responsiveRefreshRate: 200,\n        responsiveBaseElement: window,\n\n        fallbackEasing: 'swing',\n\n        info: false,\n\n        nestedItemSelector: false,\n        itemElement: 'div',\n        stageElement: 'div',\n\n        refreshClass: 'owl-refresh',\n        loadedClass: 'owl-loaded',\n        loadingClass: 'owl-loading',\n        rtlClass: 'owl-rtl',\n        responsiveClass: 'owl-responsive',\n        dragClass: 'owl-drag',\n        itemClass: 'owl-item',\n        stageClass: 'owl-stage',\n        stageOuterClass: 'owl-stage-outer',\n        grabClass: 'owl-grab'\n    };\n\n    /**\n     * Enumeration for width.\n     * @public\n     * @readonly\n     * @enum {String}\n     */\n    Owl.Width = {\n        Default: 'default',\n        Inner: 'inner',\n        Outer: 'outer'\n    };\n\n    /**\n     * Enumeration for types.\n     * @public\n     * @readonly\n     * @enum {String}\n     */\n    Owl.Type = {\n        Event: 'event',\n        State: 'state'\n    };\n\n    /**\n     * Contains all registered plugins.\n     * @public\n     */\n    Owl.Plugins = {};\n\n    /**\n     * List of workers involved in the update process.\n     */\n    Owl.Workers = [ {\n        filter: [ 'width', 'settings' ],\n        run: function() {\n            this._width = this.$element.width();\n        }\n    }, {\n        filter: [ 'width', 'items', 'settings' ],\n        run: function(cache) {\n            cache.current = this._items && this._items[this.relative(this._current)];\n        }\n    }, {\n        filter: [ 'items', 'settings' ],\n        run: function() {\n            this.$stage.children('.cloned').remove();\n        }\n    }, {\n        filter: [ 'width', 'items', 'settings' ],\n        run: function(cache) {\n            var margin = this.settings.margin || '',\n                grid = !this.settings.autoWidth,\n                rtl = this.settings.rtl,\n                css = {\n                    'width': 'auto',\n                    'margin-left': rtl ? margin : '',\n                    'margin-right': rtl ? '' : margin\n                };\n\n            !grid && this.$stage.children().css(css);\n\n            cache.css = css;\n        }\n    }, {\n        filter: [ 'width', 'items', 'settings' ],\n        run: function(cache) {\n            var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,\n                merge = null,\n                iterator = this._items.length,\n                grid = !this.settings.autoWidth,\n                widths = [];\n\n            cache.items = {\n                merge: false,\n                width: width\n            };\n\n            while (iterator--) {\n                merge = this._mergers[iterator];\n                merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;\n\n                cache.items.merge = merge > 1 || cache.items.merge;\n\n                widths[iterator] = !grid ? this._items[iterator].width() : width * merge;\n            }\n\n            this._widths = widths;\n        }\n    }, {\n        filter: [ 'items', 'settings' ],\n        run: function() {\n            var clones = [],\n                items = this._items,\n                settings = this.settings,\n                // TODO: Should be computed from number of min width items in stage\n                view = Math.max(settings.items * 2, 4),\n                size = Math.ceil(items.length / 2) * 2,\n                repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,\n                append = '',\n                prepend = '';\n\n            repeat /= 2;\n\n            while (repeat--) {\n                // Switch to only using appended clones\n                clones.push(this.normalize(clones.length / 2, true));\n                append = append + items[clones[clones.length - 1]][0].outerHTML;\n                clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));\n                prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;\n            }\n\n            this._clones = clones;\n\n            $(append).addClass('cloned').appendTo(this.$stage);\n            $(prepend).addClass('cloned').prependTo(this.$stage);\n        }\n    }, {\n        filter: [ 'width', 'items', 'settings' ],\n        run: function() {\n            var rtl = this.settings.rtl ? 1 : -1,\n                size = this._clones.length + this._items.length,\n                iterator = -1,\n                previous = 0,\n                current = 0,\n                coordinates = [];\n\n            while (++iterator < size) {\n                previous = coordinates[iterator - 1] || 0;\n                current = this._widths[this.relative(iterator)] + this.settings.margin;\n                coordinates.push(previous + current * rtl);\n            }\n\n            this._coordinates = coordinates;\n        }\n    }, {\n        filter: [ 'width', 'items', 'settings' ],\n        run: function() {\n            var padding = this.settings.stagePadding,\n                coordinates = this._coordinates,\n                css = {\n                    'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,\n                    'padding-left': padding || '',\n                    'padding-right': padding || ''\n                };\n\n            this.$stage.css(css);\n        }\n    }, {\n        filter: [ 'width', 'items', 'settings' ],\n        run: function(cache) {\n            var iterator = this._coordinates.length,\n                grid = !this.settings.autoWidth,\n                items = this.$stage.children();\n\n            if (grid && cache.items.merge) {\n                while (iterator--) {\n                    cache.css.width = this._widths[this.relative(iterator)];\n                    items.eq(iterator).css(cache.css);\n                }\n            } else if (grid) {\n                cache.css.width = cache.items.width;\n                items.css(cache.css);\n            }\n        }\n    }, {\n        filter: [ 'items' ],\n        run: function() {\n            this._coordinates.length < 1 && this.$stage.removeAttr('style');\n        }\n    }, {\n        filter: [ 'width', 'items', 'settings' ],\n        run: function(cache) {\n            cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;\n            cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));\n            this.reset(cache.current);\n        }\n    }, {\n        filter: [ 'position' ],\n        run: function() {\n            this.animate(this.coordinates(this._current));\n        }\n    }, {\n        filter: [ 'width', 'position', 'items', 'settings' ],\n        run: function() {\n            var rtl = this.settings.rtl ? 1 : -1,\n                padding = this.settings.stagePadding * 2,\n                begin = this.coordinates(this.current()) + padding,\n                end = begin + this.width() * rtl,\n                inner, outer, matches = [], i, n;\n\n            for (i = 0, n = this._coordinates.length; i < n; i++) {\n                inner = this._coordinates[i - 1] || 0;\n                outer = Math.abs(this._coordinates[i]) + padding * rtl;\n\n                if ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))\n                    || (this.op(outer, '<', begin) && this.op(outer, '>', end))) {\n                    matches.push(i);\n                }\n            }\n\n            this.$stage.children('.active').removeClass('active');\n            this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');\n\n            if (this.settings.center) {\n                this.$stage.children('.center').removeClass('center');\n                this.$stage.children().eq(this.current()).addClass('center');\n            }\n        }\n    } ];\n\n    /**\n     * Initializes the carousel.\n     * @protected\n     */\n    Owl.prototype.initialize = function() {\n        this.enter('initializing');\n        this.trigger('initialize');\n\n        this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);\n\n        if (this.settings.autoWidth && !this.is('pre-loading')) {\n            var imgs, nestedSelector, width;\n            imgs = this.$element.find('img');\n            nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;\n            width = this.$element.children(nestedSelector).width();\n\n            if (imgs.length && width <= 0) {\n                this.preloadAutoWidthImages(imgs);\n            }\n        }\n\n        this.$element.addClass(this.options.loadingClass);\n\n        // create stage\n        this.$stage = $('<' + this.settings.stageElement + ' class=\"' + this.settings.stageClass + '\"/>')\n            .wrap('<div class=\"' + this.settings.stageOuterClass + '\"/>');\n\n        // append stage\n        this.$element.append(this.$stage.parent());\n\n        // append content\n        this.replace(this.$element.children().not(this.$stage.parent()));\n\n        // check visibility\n        if (this.$element.is(':visible')) {\n            // update view\n            this.refresh();\n        } else {\n            // invalidate width\n            this.invalidate('width');\n        }\n\n        this.$element\n            .removeClass(this.options.loadingClass)\n            .addClass(this.options.loadedClass);\n\n        // register event handlers\n        this.registerEventHandlers();\n\n        this.leave('initializing');\n        this.trigger('initialized');\n    };\n\n    /**\n     * Setups the current settings.\n     * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?\n     * @todo Support for media queries by using `matchMedia` would be nice.\n     * @public\n     */\n    Owl.prototype.setup = function() {\n        var viewport = this.viewport(),\n            overwrites = this.options.responsive,\n            match = -1,\n            settings = null;\n\n        if (!overwrites) {\n            settings = $.extend({}, this.options);\n        } else {\n            $.each(overwrites, function(breakpoint) {\n                if (breakpoint <= viewport && breakpoint > match) {\n                    match = Number(breakpoint);\n                }\n            });\n\n            settings = $.extend({}, this.options, overwrites[match]);\n            if (typeof settings.stagePadding === 'function') {\n                settings.stagePadding = settings.stagePadding();\n            }\n            delete settings.responsive;\n\n            // responsive class\n            if (settings.responsiveClass) {\n                this.$element.attr('class',\n                    this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\\\S+\\\\s', 'g'), '$1' + match)\n                );\n            }\n        }\n\n        this.trigger('change', { property: { name: 'settings', value: settings } });\n        this._breakpoint = match;\n        this.settings = settings;\n        this.invalidate('settings');\n        this.trigger('changed', { property: { name: 'settings', value: this.settings } });\n    };\n\n    /**\n     * Updates option logic if necessery.\n     * @protected\n     */\n    Owl.prototype.optionsLogic = function() {\n        if (this.settings.autoWidth) {\n            this.settings.stagePadding = false;\n            this.settings.merge = false;\n        }\n    };\n\n    /**\n     * Prepares an item before add.\n     * @todo Rename event parameter `content` to `item`.\n     * @protected\n     * @returns {jQuery|HTMLElement} - The item container.\n     */\n    Owl.prototype.prepare = function(item) {\n        var event = this.trigger('prepare', { content: item });\n\n        if (!event.data) {\n            event.data = $('<' + this.settings.itemElement + '/>')\n                .addClass(this.options.itemClass).append(item)\n        }\n\n        this.trigger('prepared', { content: event.data });\n\n        return event.data;\n    };\n\n    /**\n     * Updates the view.\n     * @public\n     */\n    Owl.prototype.update = function() {\n        var i = 0,\n            n = this._pipe.length,\n            filter = $.proxy(function(p) { return this[p] }, this._invalidated),\n            cache = {};\n\n        while (i < n) {\n            if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {\n                this._pipe[i].run(cache);\n            }\n            i++;\n        }\n\n        this._invalidated = {};\n\n        !this.is('valid') && this.enter('valid');\n    };\n\n    /**\n     * Gets the width of the view.\n     * @public\n     * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.\n     * @returns {Number} - The width of the view in pixel.\n     */\n    Owl.prototype.width = function(dimension) {\n        dimension = dimension || Owl.Width.Default;\n        switch (dimension) {\n            case Owl.Width.Inner:\n            case Owl.Width.Outer:\n                return this._width;\n            default:\n                return this._width - this.settings.stagePadding * 2 + this.settings.margin;\n        }\n    };\n\n    /**\n     * Refreshes the carousel primarily for adaptive purposes.\n     * @public\n     */\n    Owl.prototype.refresh = function() {\n        this.enter('refreshing');\n        this.trigger('refresh');\n\n        this.setup();\n\n        this.optionsLogic();\n\n        this.$element.addClass(this.options.refreshClass);\n\n        this.update();\n\n        this.$element.removeClass(this.options.refreshClass);\n\n        this.leave('refreshing');\n        this.trigger('refreshed');\n    };\n\n    /**\n     * Checks window `resize` event.\n     * @protected\n     */\n    Owl.prototype.onThrottledResize = function() {\n        window.clearTimeout(this.resizeTimer);\n        this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);\n    };\n\n    /**\n     * Checks window `resize` event.\n     * @protected\n     */\n    Owl.prototype.onResize = function() {\n        if (!this._items.length) {\n            return false;\n        }\n\n        if (this._width === this.$element.width()) {\n            return false;\n        }\n\n        if (!this.$element.is(':visible')) {\n            return false;\n        }\n\n        this.enter('resizing');\n\n        if (this.trigger('resize').isDefaultPrevented()) {\n            this.leave('resizing');\n            return false;\n        }\n\n        this.invalidate('width');\n\n        this.refresh();\n\n        this.leave('resizing');\n        this.trigger('resized');\n    };\n\n    /**\n     * Registers event handlers.\n     * @todo Check `msPointerEnabled`\n     * @todo #261\n     * @protected\n     */\n    Owl.prototype.registerEventHandlers = function() {\n        if ($.support.transition) {\n            this.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));\n        }\n\n        if (this.settings.responsive !== false) {\n            this.on(window, 'resize', this._handlers.onThrottledResize);\n        }\n\n        if (this.settings.mouseDrag) {\n            this.$element.addClass(this.options.dragClass);\n            this.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));\n            this.$stage.on('dragstart.owl.core selectstart.owl.core', function() { return false });\n        }\n\n        if (this.settings.touchDrag){\n            this.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));\n            this.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));\n        }\n    };\n\n    /**\n     * Handles `touchstart` and `mousedown` events.\n     * @todo Horizontal swipe threshold as option\n     * @todo #261\n     * @protected\n     * @param {Event} event - The event arguments.\n     */\n    Owl.prototype.onDragStart = function(event) {\n        var stage = null;\n\n        if (event.which === 3) {\n            return;\n        }\n\n        if ($.support.transform) {\n            stage = this.$stage.css('transform').replace(/.*\\(|\\)| /g, '').split(',');\n            stage = {\n                x: stage[stage.length === 16 ? 12 : 4],\n                y: stage[stage.length === 16 ? 13 : 5]\n            };\n        } else {\n            stage = this.$stage.position();\n            stage = {\n                x: this.settings.rtl ?\n                stage.left + this.$stage.width() - this.width() + this.settings.margin :\n                    stage.left,\n                y: stage.top\n            };\n        }\n\n        if (this.is('animating')) {\n            $.support.transform ? this.animate(stage.x) : this.$stage.stop()\n            this.invalidate('position');\n        }\n\n        this.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');\n\n        this.speed(0);\n\n        this._drag.time = new Date().getTime();\n        this._drag.target = $(event.target);\n        this._drag.stage.start = stage;\n        this._drag.stage.current = stage;\n        this._drag.pointer = this.pointer(event);\n\n        $(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));\n\n        $(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {\n            var delta = this.difference(this._drag.pointer, this.pointer(event));\n\n            $(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));\n\n            if (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {\n                return;\n            }\n\n            event.preventDefault();\n\n            this.enter('dragging');\n            this.trigger('drag');\n        }, this));\n    };\n\n    /**\n     * Handles the `touchmove` and `mousemove` events.\n     * @todo #261\n     * @protected\n     * @param {Event} event - The event arguments.\n     */\n    Owl.prototype.onDragMove = function(event) {\n        var minimum = null,\n            maximum = null,\n            pull = null,\n            delta = this.difference(this._drag.pointer, this.pointer(event)),\n            stage = this.difference(this._drag.stage.start, delta);\n\n        if (!this.is('dragging')) {\n            return;\n        }\n\n        event.preventDefault();\n\n        if (this.settings.loop) {\n            minimum = this.coordinates(this.minimum());\n            maximum = this.coordinates(this.maximum() + 1) - minimum;\n            stage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;\n        } else {\n            minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());\n            maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());\n            pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;\n            stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);\n        }\n\n        this._drag.stage.current = stage;\n\n        this.animate(stage.x);\n    };\n\n    /**\n     * Handles the `touchend` and `mouseup` events.\n     * @todo #261\n     * @todo Threshold for click event\n     * @protected\n     * @param {Event} event - The event arguments.\n     */\n    Owl.prototype.onDragEnd = function(event) {\n        var delta = this.difference(this._drag.pointer, this.pointer(event)),\n            stage = this._drag.stage.current,\n            direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';\n\n        $(document).off('.owl.core');\n\n        this.$element.removeClass(this.options.grabClass);\n\n        if (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {\n            this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);\n            this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));\n            this.invalidate('position');\n            this.update();\n\n            this._drag.direction = direction;\n\n            if (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {\n                this._drag.target.one('click.owl.core', function() { return false; });\n            }\n        }\n\n        if (!this.is('dragging')) {\n            return;\n        }\n\n        this.leave('dragging');\n        this.trigger('dragged');\n    };\n\n    /**\n     * Gets absolute position of the closest item for a coordinate.\n     * @todo Setting `freeDrag` makes `closest` not reusable. See #165.\n     * @protected\n     * @param {Number} coordinate - The coordinate in pixel.\n     * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.\n     * @return {Number} - The absolute position of the closest item.\n     */\n    Owl.prototype.closest = function(coordinate, direction) {\n        var position = -1,\n            pull = 30,\n            width = this.width(),\n            coordinates = this.coordinates();\n\n        if (!this.settings.freeDrag) {\n            // check closest item\n            $.each(coordinates, $.proxy(function(index, value) {\n                // on a left pull, check on current index\n                if (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {\n                    position = index;\n                    // on a right pull, check on previous index\n                    // to do so, subtract width from value and set position = index + 1\n                } else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {\n                    position = index + 1;\n                } else if (this.op(coordinate, '<', value)\n                    && this.op(coordinate, '>', coordinates[index + 1] || value - width)) {\n                    position = direction === 'left' ? index + 1 : index;\n                }\n                return position === -1;\n            }, this));\n        }\n\n        if (!this.settings.loop) {\n            // non loop boundries\n            if (this.op(coordinate, '>', coordinates[this.minimum()])) {\n                position = coordinate = this.minimum();\n            } else if (this.op(coordinate, '<', coordinates[this.maximum()])) {\n                position = coordinate = this.maximum();\n            }\n        }\n\n        return position;\n    };\n\n    /**\n     * Animates the stage.\n     * @todo #270\n     * @public\n     * @param {Number} coordinate - The coordinate in pixels.\n     */\n    Owl.prototype.animate = function(coordinate) {\n        var animate = this.speed() > 0;\n\n        this.is('animating') && this.onTransitionEnd();\n\n        if (animate) {\n            this.enter('animating');\n            this.trigger('translate');\n        }\n\n        if ($.support.transform3d && $.support.transition) {\n            this.$stage.css({\n                transform: 'translate3d(' + coordinate + 'px,0px,0px)',\n                transition: (this.speed() / 1000) + 's'\n            });\n        } else if (animate) {\n            this.$stage.animate({\n                left: coordinate + 'px'\n            }, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));\n        } else {\n            this.$stage.css({\n                left: coordinate + 'px'\n            });\n        }\n    };\n\n    /**\n     * Checks whether the carousel is in a specific state or not.\n     * @param {String} state - The state to check.\n     * @returns {Boolean} - The flag which indicates if the carousel is busy.\n     */\n    Owl.prototype.is = function(state) {\n        return this._states.current[state] && this._states.current[state] > 0;\n    };\n\n    /**\n     * Sets the absolute position of the current item.\n     * @public\n     * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.\n     * @returns {Number} - The absolute position of the current item.\n     */\n    Owl.prototype.current = function(position) {\n        if (position === undefined) {\n            return this._current;\n        }\n\n        if (this._items.length === 0) {\n            return undefined;\n        }\n\n        position = this.normalize(position);\n\n        if (this._current !== position) {\n            var event = this.trigger('change', { property: { name: 'position', value: position } });\n\n            if (event.data !== undefined) {\n                position = this.normalize(event.data);\n            }\n\n            this._current = position;\n\n            this.invalidate('position');\n\n            this.trigger('changed', { property: { name: 'position', value: this._current } });\n        }\n\n        return this._current;\n    };\n\n    /**\n     * Invalidates the given part of the update routine.\n     * @param {String} [part] - The part to invalidate.\n     * @returns {Array.<String>} - The invalidated parts.\n     */\n    Owl.prototype.invalidate = function(part) {\n        if ($.type(part) === 'string') {\n            this._invalidated[part] = true;\n            this.is('valid') && this.leave('valid');\n        }\n        return $.map(this._invalidated, function(v, i) { return i });\n    };\n\n    /**\n     * Resets the absolute position of the current item.\n     * @public\n     * @param {Number} position - The absolute position of the new item.\n     */\n    Owl.prototype.reset = function(position) {\n        position = this.normalize(position);\n\n        if (position === undefined) {\n            return;\n        }\n\n        this._speed = 0;\n        this._current = position;\n\n        this.suppress([ 'translate', 'translated' ]);\n\n        this.animate(this.coordinates(position));\n\n        this.release([ 'translate', 'translated' ]);\n    };\n\n    /**\n     * Normalizes an absolute or a relative position of an item.\n     * @public\n     * @param {Number} position - The absolute or relative position to normalize.\n     * @param {Boolean} [relative=false] - Whether the given position is relative or not.\n     * @returns {Number} - The normalized position.\n     */\n    Owl.prototype.normalize = function(position, relative) {\n        var n = this._items.length,\n            m = relative ? 0 : this._clones.length;\n\n        if (!this.isNumeric(position) || n < 1) {\n            position = undefined;\n        } else if (position < 0 || position >= n + m) {\n            position = ((position - m / 2) % n + n) % n + m / 2;\n        }\n\n        return position;\n    };\n\n    /**\n     * Converts an absolute position of an item into a relative one.\n     * @public\n     * @param {Number} position - The absolute position to convert.\n     * @returns {Number} - The converted position.\n     */\n    Owl.prototype.relative = function(position) {\n        position -= this._clones.length / 2;\n        return this.normalize(position, true);\n    };\n\n    /**\n     * Gets the maximum position for the current item.\n     * @public\n     * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n     * @returns {Number}\n     */\n    Owl.prototype.maximum = function(relative) {\n        var settings = this.settings,\n            maximum = this._coordinates.length,\n            iterator,\n            reciprocalItemsWidth,\n            elementWidth;\n\n        if (settings.loop) {\n            maximum = this._clones.length / 2 + this._items.length - 1;\n        } else if (settings.autoWidth || settings.merge) {\n            iterator = this._items.length;\n            reciprocalItemsWidth = this._items[--iterator].width();\n            elementWidth = this.$element.width();\n            while (iterator--) {\n                reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;\n                if (reciprocalItemsWidth > elementWidth) {\n                    break;\n                }\n            }\n            maximum = iterator + 1;\n        } else if (settings.center) {\n            maximum = this._items.length - 1;\n        } else {\n            maximum = this._items.length - settings.items;\n        }\n\n        if (relative) {\n            maximum -= this._clones.length / 2;\n        }\n\n        return Math.max(maximum, 0);\n    };\n\n    /**\n     * Gets the minimum position for the current item.\n     * @public\n     * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n     * @returns {Number}\n     */\n    Owl.prototype.minimum = function(relative) {\n        return relative ? 0 : this._clones.length / 2;\n    };\n\n    /**\n     * Gets an item at the specified relative position.\n     * @public\n     * @param {Number} [position] - The relative position of the item.\n     * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n     */\n    Owl.prototype.items = function(position) {\n        if (position === undefined) {\n            return this._items.slice();\n        }\n\n        position = this.normalize(position, true);\n        return this._items[position];\n    };\n\n    /**\n     * Gets an item at the specified relative position.\n     * @public\n     * @param {Number} [position] - The relative position of the item.\n     * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n     */\n    Owl.prototype.mergers = function(position) {\n        if (position === undefined) {\n            return this._mergers.slice();\n        }\n\n        position = this.normalize(position, true);\n        return this._mergers[position];\n    };\n\n    /**\n     * Gets the absolute positions of clones for an item.\n     * @public\n     * @param {Number} [position] - The relative position of the item.\n     * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.\n     */\n    Owl.prototype.clones = function(position) {\n        var odd = this._clones.length / 2,\n            even = odd + this._items.length,\n            map = function(index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };\n\n        if (position === undefined) {\n            return $.map(this._clones, function(v, i) { return map(i) });\n        }\n\n        return $.map(this._clones, function(v, i) { return v === position ? map(i) : null });\n    };\n\n    /**\n     * Sets the current animation speed.\n     * @public\n     * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.\n     * @returns {Number} - The current animation speed in milliseconds.\n     */\n    Owl.prototype.speed = function(speed) {\n        if (speed !== undefined) {\n            this._speed = speed;\n        }\n\n        return this._speed;\n    };\n\n    /**\n     * Gets the coordinate of an item.\n     * @todo The name of this method is missleanding.\n     * @public\n     * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.\n     * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.\n     */\n    Owl.prototype.coordinates = function(position) {\n        var multiplier = 1,\n            newPosition = position - 1,\n            coordinate;\n\n        if (position === undefined) {\n            return $.map(this._coordinates, $.proxy(function(coordinate, index) {\n                return this.coordinates(index);\n            }, this));\n        }\n\n        if (this.settings.center) {\n            if (this.settings.rtl) {\n                multiplier = -1;\n                newPosition = position + 1;\n            }\n\n            coordinate = this._coordinates[position];\n            coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;\n        } else {\n            coordinate = this._coordinates[newPosition] || 0;\n        }\n\n        coordinate = Math.ceil(coordinate);\n\n        return coordinate;\n    };\n\n    /**\n     * Calculates the speed for a translation.\n     * @protected\n     * @param {Number} from - The absolute position of the start item.\n     * @param {Number} to - The absolute position of the target item.\n     * @param {Number} [factor=undefined] - The time factor in milliseconds.\n     * @returns {Number} - The time in milliseconds for the translation.\n     */\n    Owl.prototype.duration = function(from, to, factor) {\n        if (factor === 0) {\n            return 0;\n        }\n\n        return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));\n    };\n\n    /**\n     * Slides to the specified item.\n     * @public\n     * @param {Number} position - The position of the item.\n     * @param {Number} [speed] - The time in milliseconds for the transition.\n     */\n    Owl.prototype.to = function(position, speed) {\n        var current = this.current(),\n            revert = null,\n            distance = position - this.relative(current),\n            direction = (distance > 0) - (distance < 0),\n            items = this._items.length,\n            minimum = this.minimum(),\n            maximum = this.maximum();\n\n        if (this.settings.loop) {\n            if (!this.settings.rewind && Math.abs(distance) > items / 2) {\n                distance += direction * -1 * items;\n            }\n\n            position = current + distance;\n            revert = ((position - minimum) % items + items) % items + minimum;\n\n            if (revert !== position && revert - distance <= maximum && revert - distance > 0) {\n                current = revert - distance;\n                position = revert;\n                this.reset(current);\n            }\n        } else if (this.settings.rewind) {\n            maximum += 1;\n            position = (position % maximum + maximum) % maximum;\n        } else {\n            position = Math.max(minimum, Math.min(maximum, position));\n        }\n\n        this.speed(this.duration(current, position, speed));\n        this.current(position);\n\n        if (this.$element.is(':visible')) {\n            this.update();\n        }\n    };\n\n    /**\n     * Slides to the next item.\n     * @public\n     * @param {Number} [speed] - The time in milliseconds for the transition.\n     */\n    Owl.prototype.next = function(speed) {\n        speed = speed || false;\n        this.to(this.relative(this.current()) + 1, speed);\n    };\n\n    /**\n     * Slides to the previous item.\n     * @public\n     * @param {Number} [speed] - The time in milliseconds for the transition.\n     */\n    Owl.prototype.prev = function(speed) {\n        speed = speed || false;\n        this.to(this.relative(this.current()) - 1, speed);\n    };\n\n    /**\n     * Handles the end of an animation.\n     * @protected\n     * @param {Event} event - The event arguments.\n     */\n    Owl.prototype.onTransitionEnd = function(event) {\n\n        // if css2 animation then event object is undefined\n        if (event !== undefined) {\n            event.stopPropagation();\n\n            // Catch only owl-stage transitionEnd event\n            if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {\n                return false;\n            }\n        }\n\n        this.leave('animating');\n        this.trigger('translated');\n    };\n\n    /**\n     * Gets viewport width.\n     * @protected\n     * @return {Number} - The width in pixel.\n     */\n    Owl.prototype.viewport = function() {\n        var width;\n        if (this.options.responsiveBaseElement !== window) {\n            width = $(this.options.responsiveBaseElement).width();\n        } else if (window.innerWidth) {\n            width = window.innerWidth;\n        } else if (document.documentElement && document.documentElement.clientWidth) {\n            width = document.documentElement.clientWidth;\n        } else {\n            console.warn('Can not detect viewport width.');\n        }\n        return width;\n    };\n\n    /**\n     * Replaces the current content.\n     * @public\n     * @param {HTMLElement|jQuery|String} content - The new content.\n     */\n    Owl.prototype.replace = function(content) {\n        this.$stage.empty();\n        this._items = [];\n\n        if (content) {\n            content = (content instanceof jQuery) ? content : $(content);\n        }\n\n        if (this.settings.nestedItemSelector) {\n            content = content.find('.' + this.settings.nestedItemSelector);\n        }\n\n        content.filter(function() {\n            return this.nodeType === 1;\n        }).each($.proxy(function(index, item) {\n            item = this.prepare(item);\n            this.$stage.append(item);\n            this._items.push(item);\n            this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n        }, this));\n\n        this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);\n\n        this.invalidate('items');\n    };\n\n    /**\n     * Adds an item.\n     * @todo Use `item` instead of `content` for the event arguments.\n     * @public\n     * @param {HTMLElement|jQuery|String} content - The item content to add.\n     * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.\n     */\n    Owl.prototype.add = function(content, position) {\n        var current = this.relative(this._current);\n\n        position = position === undefined ? this._items.length : this.normalize(position, true);\n        content = content instanceof jQuery ? content : $(content);\n\n        this.trigger('add', { content: content, position: position });\n\n        content = this.prepare(content);\n\n        if (this._items.length === 0 || position === this._items.length) {\n            this._items.length === 0 && this.$stage.append(content);\n            this._items.length !== 0 && this._items[position - 1].after(content);\n            this._items.push(content);\n            this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n        } else {\n            this._items[position].before(content);\n            this._items.splice(position, 0, content);\n            this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n        }\n\n        this._items[current] && this.reset(this._items[current].index());\n\n        this.invalidate('items');\n\n        this.trigger('added', { content: content, position: position });\n    };\n\n    /**\n     * Removes an item by its position.\n     * @todo Use `item` instead of `content` for the event arguments.\n     * @public\n     * @param {Number} position - The relative position of the item to remove.\n     */\n    Owl.prototype.remove = function(position) {\n        position = this.normalize(position, true);\n\n        if (position === undefined) {\n            return;\n        }\n\n        this.trigger('remove', { content: this._items[position], position: position });\n\n        this._items[position].remove();\n        this._items.splice(position, 1);\n        this._mergers.splice(position, 1);\n\n        this.invalidate('items');\n\n        this.trigger('removed', { content: null, position: position });\n    };\n\n    /**\n     * Preloads images with auto width.\n     * @todo Replace by a more generic approach\n     * @protected\n     */\n    Owl.prototype.preloadAutoWidthImages = function(images) {\n        images.each($.proxy(function(i, element) {\n            this.enter('pre-loading');\n            element = $(element);\n            $(new Image()).one('load', $.proxy(function(e) {\n                element.attr('src', e.target.src);\n                element.css('opacity', 1);\n                this.leave('pre-loading');\n                !this.is('pre-loading') && !this.is('initializing') && this.refresh();\n            }, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));\n        }, this));\n    };\n\n    /**\n     * Destroys the carousel.\n     * @public\n     */\n    Owl.prototype.destroy = function() {\n\n        this.$element.off('.owl.core');\n        this.$stage.off('.owl.core');\n        $(document).off('.owl.core');\n\n        if (this.settings.responsive !== false) {\n            window.clearTimeout(this.resizeTimer);\n            this.off(window, 'resize', this._handlers.onThrottledResize);\n        }\n\n        for (var i in this._plugins) {\n            this._plugins[i].destroy();\n        }\n\n        this.$stage.children('.cloned').remove();\n\n        this.$stage.unwrap();\n        this.$stage.children().contents().unwrap();\n        this.$stage.children().unwrap();\n\n        this.$element\n            .removeClass(this.options.refreshClass)\n            .removeClass(this.options.loadingClass)\n            .removeClass(this.options.loadedClass)\n            .removeClass(this.options.rtlClass)\n            .removeClass(this.options.dragClass)\n            .removeClass(this.options.grabClass)\n            .attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\\\S+\\\\s', 'g'), ''))\n            .removeData('owl.carousel');\n    };\n\n    /**\n     * Operators to calculate right-to-left and left-to-right.\n     * @protected\n     * @param {Number} [a] - The left side operand.\n     * @param {String} [o] - The operator.\n     * @param {Number} [b] - The right side operand.\n     */\n    Owl.prototype.op = function(a, o, b) {\n        var rtl = this.settings.rtl;\n        switch (o) {\n            case '<':\n                return rtl ? a > b : a < b;\n            case '>':\n                return rtl ? a < b : a > b;\n            case '>=':\n                return rtl ? a <= b : a >= b;\n            case '<=':\n                return rtl ? a >= b : a <= b;\n            default:\n                break;\n        }\n    };\n\n    /**\n     * Attaches to an internal event.\n     * @protected\n     * @param {HTMLElement} element - The event source.\n     * @param {String} event - The event name.\n     * @param {Function} listener - The event handler to attach.\n     * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.\n     */\n    Owl.prototype.on = function(element, event, listener, capture) {\n        if (element.addEventListener) {\n            element.addEventListener(event, listener, capture);\n        } else if (element.attachEvent) {\n            element.attachEvent('on' + event, listener);\n        }\n    };\n\n    /**\n     * Detaches from an internal event.\n     * @protected\n     * @param {HTMLElement} element - The event source.\n     * @param {String} event - The event name.\n     * @param {Function} listener - The attached event handler to detach.\n     * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.\n     */\n    Owl.prototype.off = function(element, event, listener, capture) {\n        if (element.removeEventListener) {\n            element.removeEventListener(event, listener, capture);\n        } else if (element.detachEvent) {\n            element.detachEvent('on' + event, listener);\n        }\n    };\n\n    /**\n     * Triggers a public event.\n     * @todo Remove `status`, `relatedTarget` should be used instead.\n     * @protected\n     * @param {String} name - The event name.\n     * @param {*} [data=null] - The event data.\n     * @param {String} [namespace=carousel] - The event namespace.\n     * @param {String} [state] - The state which is associated with the event.\n     * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.\n     * @returns {Event} - The event arguments.\n     */\n    Owl.prototype.trigger = function(name, data, namespace, state, enter) {\n        var status = {\n            item: { count: this._items.length, index: this.current() }\n        }, handler = $.camelCase(\n            $.grep([ 'on', name, namespace ], function(v) { return v })\n                .join('-').toLowerCase()\n        ), event = $.Event(\n            [ name, 'owl', namespace || 'carousel' ].join('.').toLowerCase(),\n            $.extend({ relatedTarget: this }, status, data)\n        );\n\n        if (!this._supress[name]) {\n            $.each(this._plugins, function(name, plugin) {\n                if (plugin.onTrigger) {\n                    plugin.onTrigger(event);\n                }\n            });\n\n            this.register({ type: Owl.Type.Event, name: name });\n            this.$element.trigger(event);\n\n            if (this.settings && typeof this.settings[handler] === 'function') {\n                this.settings[handler].call(this, event);\n            }\n        }\n\n        return event;\n    };\n\n    /**\n     * Enters a state.\n     * @param name - The state name.\n     */\n    Owl.prototype.enter = function(name) {\n        $.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\n            if (this._states.current[name] === undefined) {\n                this._states.current[name] = 0;\n            }\n\n            this._states.current[name]++;\n        }, this));\n    };\n\n    /**\n     * Leaves a state.\n     * @param name - The state name.\n     */\n    Owl.prototype.leave = function(name) {\n        $.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\n            this._states.current[name]--;\n        }, this));\n    };\n\n    /**\n     * Registers an event or state.\n     * @public\n     * @param {Object} object - The event or state to register.\n     */\n    Owl.prototype.register = function(object) {\n        if (object.type === Owl.Type.Event) {\n            if (!$.event.special[object.name]) {\n                $.event.special[object.name] = {};\n            }\n\n            if (!$.event.special[object.name].owl) {\n                var _default = $.event.special[object.name]._default;\n                $.event.special[object.name]._default = function(e) {\n                    if (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {\n                        return _default.apply(this, arguments);\n                    }\n                    return e.namespace && e.namespace.indexOf('owl') > -1;\n                };\n                $.event.special[object.name].owl = true;\n            }\n        } else if (object.type === Owl.Type.State) {\n            if (!this._states.tags[object.name]) {\n                this._states.tags[object.name] = object.tags;\n            } else {\n                this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);\n            }\n\n            this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {\n                return $.inArray(tag, this._states.tags[object.name]) === i;\n            }, this));\n        }\n    };\n\n    /**\n     * Suppresses events.\n     * @protected\n     * @param {Array.<String>} events - The events to suppress.\n     */\n    Owl.prototype.suppress = function(events) {\n        $.each(events, $.proxy(function(index, event) {\n            this._supress[event] = true;\n        }, this));\n    };\n\n    /**\n     * Releases suppressed events.\n     * @protected\n     * @param {Array.<String>} events - The events to release.\n     */\n    Owl.prototype.release = function(events) {\n        $.each(events, $.proxy(function(index, event) {\n            delete this._supress[event];\n        }, this));\n    };\n\n    /**\n     * Gets unified pointer coordinates from event.\n     * @todo #261\n     * @protected\n     * @param {Event} - The `mousedown` or `touchstart` event.\n     * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.\n     */\n    Owl.prototype.pointer = function(event) {\n        var result = { x: null, y: null };\n\n        event = event.originalEvent || event || window.event;\n\n        event = event.touches && event.touches.length ?\n            event.touches[0] : event.changedTouches && event.changedTouches.length ?\n            event.changedTouches[0] : event;\n\n        if (event.pageX) {\n            result.x = event.pageX;\n            result.y = event.pageY;\n        } else {\n            result.x = event.clientX;\n            result.y = event.clientY;\n        }\n\n        return result;\n    };\n\n    /**\n     * Determines if the input is a Number or something that can be coerced to a Number\n     * @protected\n     * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested\n     * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number\n     */\n    Owl.prototype.isNumeric = function(number) {\n        return !isNaN(parseFloat(number));\n    };\n\n    /**\n     * Gets the difference of two vectors.\n     * @todo #261\n     * @protected\n     * @param {Object} - The first vector.\n     * @param {Object} - The second vector.\n     * @returns {Object} - The difference.\n     */\n    Owl.prototype.difference = function(first, second) {\n        return {\n            x: first.x - second.x,\n            y: first.y - second.y\n        };\n    };\n\n    /**\n     * The jQuery Plugin for the Owl Carousel\n     * @todo Navigation plugin `next` and `prev`\n     * @public\n     */\n    $.fn.owlCarousel = function(option) {\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        return this.each(function() {\n            var $this = $(this),\n                data = $this.data('owl.carousel');\n\n            if (!data) {\n                data = new Owl(this, typeof option == 'object' && option);\n                $this.data('owl.carousel', data);\n\n                $.each([\n                    'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'\n                ], function(i, event) {\n                    data.register({ type: Owl.Type.Event, name: event });\n                    data.$element.on(event + '.owl.carousel.core', $.proxy(function(e) {\n                        if (e.namespace && e.relatedTarget !== this) {\n                            this.suppress([ event ]);\n                            data[event].apply(this, [].slice.call(arguments, 1));\n                            this.release([ event ]);\n                        }\n                    }, data));\n                });\n            }\n\n            if (typeof option == 'string' && option.charAt(0) !== '_') {\n                data[option].apply(data, args);\n            }\n        });\n    };\n\n    /**\n     * The constructor for the jQuery Plugin\n     * @public\n     */\n    $.fn.owlCarousel.Constructor = Owl;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * AutoRefresh Plugin\n * @version 2.1.0\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n    /**\n     * Creates the auto refresh plugin.\n     * @class The Auto Refresh Plugin\n     * @param {Owl} carousel - The Owl Carousel\n     */\n    var AutoRefresh = function(carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * Refresh interval.\n         * @protected\n         * @type {number}\n         */\n        this._interval = null;\n\n        /**\n         * Whether the element is currently visible or not.\n         * @protected\n         * @type {Boolean}\n         */\n        this._visible = null;\n\n        /**\n         * All event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'initialized.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.autoRefresh) {\n                    this.watch();\n                }\n            }, this)\n        };\n\n        // set default options\n        this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);\n\n        // register event handlers\n        this._core.$element.on(this._handlers);\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    AutoRefresh.Defaults = {\n        autoRefresh: true,\n        autoRefreshInterval: 500\n    };\n\n    /**\n     * Watches the element.\n     */\n    AutoRefresh.prototype.watch = function() {\n        if (this._interval) {\n            return;\n        }\n\n        this._visible = this._core.$element.is(':visible');\n        this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);\n    };\n\n    /**\n     * Refreshes the element.\n     */\n    AutoRefresh.prototype.refresh = function() {\n        if (this._core.$element.is(':visible') === this._visible) {\n            return;\n        }\n\n        this._visible = !this._visible;\n\n        this._core.$element.toggleClass('owl-hidden', !this._visible);\n\n        this._visible && (this._core.invalidate('width') && this._core.refresh());\n    };\n\n    /**\n     * Destroys the plugin.\n     */\n    AutoRefresh.prototype.destroy = function() {\n        var handler, property;\n\n        window.clearInterval(this._interval);\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Lazy Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n    /**\n     * Creates the lazy plugin.\n     * @class The Lazy Plugin\n     * @param {Owl} carousel - The Owl Carousel\n     */\n    var Lazy = function(carousel) {\n\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * Already loaded items.\n         * @protected\n         * @type {Array.<jQuery>}\n         */\n        this._loaded = [];\n\n        /**\n         * Event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function(e) {\n                if (!e.namespace) {\n                    return;\n                }\n\n                if (!this._core.settings || !this._core.settings.lazyLoad) {\n                    return;\n                }\n\n                if ((e.property && e.property.name == 'position') || e.type == 'initialized') {\n                    var settings = this._core.settings,\n                        n = (settings.center && Math.ceil(settings.items / 2) || settings.items),\n                        i = ((settings.center && n * -1) || 0),\n                        position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,\n                        clones = this._core.clones().length,\n                        load = $.proxy(function(i, v) { this.load(v) }, this);\n\n                    while (i++ < n) {\n                        this.load(clones / 2 + this._core.relative(position));\n                        clones && $.each(this._core.clones(this._core.relative(position)), load);\n                        position++;\n                    }\n                }\n            }, this)\n        };\n\n        // set the default options\n        this._core.options = $.extend({}, Lazy.Defaults, this._core.options);\n\n        // register event handler\n        this._core.$element.on(this._handlers);\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    Lazy.Defaults = {\n        lazyLoad: false\n    };\n\n    /**\n     * Loads all resources of an item at the specified position.\n     * @param {Number} position - The absolute position of the item.\n     * @protected\n     */\n    Lazy.prototype.load = function(position) {\n        var $item = this._core.$stage.children().eq(position),\n            $elements = $item && $item.find('.owl-lazy');\n\n        if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {\n            return;\n        }\n\n        $elements.each($.proxy(function(index, element) {\n            var $element = $(element), image,\n                url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src');\n\n            this._core.trigger('load', { element: $element, url: url }, 'lazy');\n\n            if ($element.is('img')) {\n                $element.one('load.owl.lazy', $.proxy(function() {\n                    $element.css('opacity', 1);\n                    this._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n                }, this)).attr('src', url);\n            } else {\n                image = new Image();\n                image.onload = $.proxy(function() {\n                    $element.css({\n                        'background-image': 'url(\"' + url + '\")',\n                        'opacity': '1'\n                    });\n                    this._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n                }, this);\n                image.src = url;\n            }\n        }, this));\n\n        this._loaded.push($item.get(0));\n    };\n\n    /**\n     * Destroys the plugin.\n     * @public\n     */\n    Lazy.prototype.destroy = function() {\n        var handler, property;\n\n        for (handler in this.handlers) {\n            this._core.$element.off(handler, this.handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * AutoHeight Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n    /**\n     * Creates the auto height plugin.\n     * @class The Auto Height Plugin\n     * @param {Owl} carousel - The Owl Carousel\n     */\n    var AutoHeight = function(carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * All event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.autoHeight) {\n                    this.update();\n                }\n            }, this),\n            'changed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.autoHeight && e.property.name == 'position'){\n                    this.update();\n                }\n            }, this),\n            'loaded.owl.lazy': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.autoHeight\n                    && e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {\n                    this.update();\n                }\n            }, this)\n        };\n\n        // set default options\n        this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);\n\n        // register event handlers\n        this._core.$element.on(this._handlers);\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    AutoHeight.Defaults = {\n        autoHeight: false,\n        autoHeightClass: 'owl-height'\n    };\n\n    /**\n     * Updates the view.\n     */\n    AutoHeight.prototype.update = function() {\n        var start = this._core._current,\n            end = start + this._core.settings.items,\n            visible = this._core.$stage.children().toArray().slice(start, end),\n            heights = [],\n            maxheight = 0;\n\n        $.each(visible, function(index, item) {\n            heights.push($(item).height());\n        });\n\n        maxheight = Math.max.apply(null, heights);\n\n        this._core.$stage.parent()\n            .height(maxheight)\n            .addClass(this._core.settings.autoHeightClass);\n    };\n\n    AutoHeight.prototype.destroy = function() {\n        var handler, property;\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Video Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n    /**\n     * Creates the video plugin.\n     * @class The Video Plugin\n     * @param {Owl} carousel - The Owl Carousel\n     */\n    var Video = function(carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * Cache all video URLs.\n         * @protected\n         * @type {Object}\n         */\n        this._videos = {};\n\n        /**\n         * Current playing item.\n         * @protected\n         * @type {jQuery}\n         */\n        this._playing = null;\n\n        /**\n         * All event handlers.\n         * @todo The cloned content removale is too late\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'initialized.owl.carousel': $.proxy(function(e) {\n                if (e.namespace) {\n                    this._core.register({ type: 'state', name: 'playing', tags: [ 'interacting' ] });\n                }\n            }, this),\n            'resize.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.video && this.isInFullScreen()) {\n                    e.preventDefault();\n                }\n            }, this),\n            'refreshed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.is('resizing')) {\n                    this._core.$stage.find('.cloned .owl-video-frame').remove();\n                }\n            }, this),\n            'changed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && e.property.name === 'position' && this._playing) {\n                    this.stop();\n                }\n            }, this),\n            'prepared.owl.carousel': $.proxy(function(e) {\n                if (!e.namespace) {\n                    return;\n                }\n\n                var $element = $(e.content).find('.owl-video');\n\n                if ($element.length) {\n                    $element.css('display', 'none');\n                    this.fetch($element, $(e.content));\n                }\n            }, this)\n        };\n\n        // set default options\n        this._core.options = $.extend({}, Video.Defaults, this._core.options);\n\n        // register event handlers\n        this._core.$element.on(this._handlers);\n\n        this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {\n            this.play(e);\n        }, this));\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    Video.Defaults = {\n        video: false,\n        videoHeight: false,\n        videoWidth: false\n    };\n\n    /**\n     * Gets the video ID and the type (YouTube/Vimeo/vzaar only).\n     * @protected\n     * @param {jQuery} target - The target containing the video data.\n     * @param {jQuery} item - The item containing the video.\n     */\n    Video.prototype.fetch = function(target, item) {\n        var type = (function() {\n                if (target.attr('data-vimeo-id')) {\n                    return 'vimeo';\n                } else if (target.attr('data-vzaar-id')) {\n                    return 'vzaar'\n                } else {\n                    return 'youtube';\n                }\n            })(),\n            id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),\n            width = target.attr('data-width') || this._core.settings.videoWidth,\n            height = target.attr('data-height') || this._core.settings.videoHeight,\n            url = target.attr('href');\n\n        if (url) {\n\n            /*\n             Parses the id's out of the following urls (and probably more):\n             https://www.youtube.com/watch?v=:id\n             https://youtu.be/:id\n             https://vimeo.com/:id\n             https://vimeo.com/channels/:channel/:id\n             https://vimeo.com/groups/:group/videos/:id\n             https://app.vzaar.com/videos/:id\n\n             Visual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F\n             */\n\n            id = url.match(/(http:|https:|)\\/\\/(player.|www.|app.)?(vimeo\\.com|youtu(be\\.com|\\.be|be\\.googleapis\\.com)|vzaar\\.com)\\/(video\\/|videos\\/|embed\\/|channels\\/.+\\/|groups\\/.+\\/|watch\\?v=|v\\/)?([A-Za-z0-9._%-]*)(\\&\\S+)?/);\n\n            if (id[3].indexOf('youtu') > -1) {\n                type = 'youtube';\n            } else if (id[3].indexOf('vimeo') > -1) {\n                type = 'vimeo';\n            } else if (id[3].indexOf('vzaar') > -1) {\n                type = 'vzaar';\n            } else {\n                throw new Error('Video URL not supported.');\n            }\n            id = id[6];\n        } else {\n            throw new Error('Missing video URL.');\n        }\n\n        this._videos[url] = {\n            type: type,\n            id: id,\n            width: width,\n            height: height\n        };\n\n        item.attr('data-video', url);\n\n        this.thumbnail(target, this._videos[url]);\n    };\n\n    /**\n     * Creates video thumbnail.\n     * @protected\n     * @param {jQuery} target - The target containing the video data.\n     * @param {Object} info - The video info object.\n     * @see `fetch`\n     */\n    Video.prototype.thumbnail = function(target, video) {\n        var tnLink,\n            icon,\n            path,\n            dimensions = video.width && video.height ? 'style=\"width:' + video.width + 'px;height:' + video.height + 'px;\"' : '',\n            customTn = target.find('img'),\n            srcType = 'src',\n            lazyClass = '',\n            settings = this._core.settings,\n            create = function(path) {\n                icon = '<div class=\"owl-video-play-icon\"></div>';\n\n                if (settings.lazyLoad) {\n                    tnLink = '<div class=\"owl-video-tn ' + lazyClass + '\" ' + srcType + '=\"' + path + '\"></div>';\n                } else {\n                    tnLink = '<div class=\"owl-video-tn\" style=\"opacity:1;background-image:url(' + path + ')\"></div>';\n                }\n                target.after(tnLink);\n                target.after(icon);\n            };\n\n        // wrap video content into owl-video-wrapper div\n        target.wrap('<div class=\"owl-video-wrapper\"' + dimensions + '></div>');\n\n        if (this._core.settings.lazyLoad) {\n            srcType = 'data-src';\n            lazyClass = 'owl-lazy';\n        }\n\n        // custom thumbnail\n        if (customTn.length) {\n            create(customTn.attr(srcType));\n            customTn.remove();\n            return false;\n        }\n\n        if (video.type === 'youtube') {\n            path = \"//img.youtube.com/vi/\" + video.id + \"/hqdefault.jpg\";\n            create(path);\n        } else if (video.type === 'vimeo') {\n            $.ajax({\n                type: 'GET',\n                url: '//vimeo.com/api/v2/video/' + video.id + '.json',\n                jsonp: 'callback',\n                dataType: 'jsonp',\n                success: function(data) {\n                    path = data[0].thumbnail_large;\n                    create(path);\n                }\n            });\n        } else if (video.type === 'vzaar') {\n            $.ajax({\n                type: 'GET',\n                url: '//vzaar.com/api/videos/' + video.id + '.json',\n                jsonp: 'callback',\n                dataType: 'jsonp',\n                success: function(data) {\n                    path = data.framegrab_url;\n                    create(path);\n                }\n            });\n        }\n    };\n\n    /**\n     * Stops the current video.\n     * @public\n     */\n    Video.prototype.stop = function() {\n        this._core.trigger('stop', null, 'video');\n        this._playing.find('.owl-video-frame').remove();\n        this._playing.removeClass('owl-video-playing');\n        this._playing = null;\n        this._core.leave('playing');\n        this._core.trigger('stopped', null, 'video');\n    };\n\n    /**\n     * Starts the current video.\n     * @public\n     * @param {Event} event - The event arguments.\n     */\n    Video.prototype.play = function(event) {\n        var target = $(event.target),\n            item = target.closest('.' + this._core.settings.itemClass),\n            video = this._videos[item.attr('data-video')],\n            width = video.width || '100%',\n            height = video.height || this._core.$stage.height(),\n            html;\n\n        if (this._playing) {\n            return;\n        }\n\n        this._core.enter('playing');\n        this._core.trigger('play', null, 'video');\n\n        item = this._core.items(this._core.relative(item.index()));\n\n        this._core.reset(item.index());\n\n        if (video.type === 'youtube') {\n            html = '<iframe width=\"' + width + '\" height=\"' + height + '\" src=\"//www.youtube.com/embed/' +\n                video.id + '?autoplay=1&rel=0&v=' + video.id + '\" frameborder=\"0\" allowfullscreen></iframe>';\n        } else if (video.type === 'vimeo') {\n            html = '<iframe src=\"//player.vimeo.com/video/' + video.id +\n                '?autoplay=1\" width=\"' + width + '\" height=\"' + height +\n                '\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';\n        } else if (video.type === 'vzaar') {\n            html = '<iframe frameborder=\"0\"' + 'height=\"' + height + '\"' + 'width=\"' + width +\n                '\" allowfullscreen mozallowfullscreen webkitAllowFullScreen ' +\n                'src=\"//view.vzaar.com/' + video.id + '/player?autoplay=true\"></iframe>';\n        }\n\n        $('<div class=\"owl-video-frame\">' + html + '</div>').insertAfter(item.find('.owl-video'));\n\n        this._playing = item.addClass('owl-video-playing');\n    };\n\n    /**\n     * Checks whether an video is currently in full screen mode or not.\n     * @todo Bad style because looks like a readonly method but changes members.\n     * @protected\n     * @returns {Boolean}\n     */\n    Video.prototype.isInFullScreen = function() {\n        var element = document.fullscreenElement || document.mozFullScreenElement ||\n            document.webkitFullscreenElement;\n\n        return element && $(element).parent().hasClass('owl-video-frame');\n    };\n\n    /**\n     * Destroys the plugin.\n     */\n    Video.prototype.destroy = function() {\n        var handler, property;\n\n        this._core.$element.off('click.owl.video');\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Video = Video;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Animate Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n    /**\n     * Creates the animate plugin.\n     * @class The Navigation Plugin\n     * @param {Owl} scope - The Owl Carousel\n     */\n    var Animate = function(scope) {\n        this.core = scope;\n        this.core.options = $.extend({}, Animate.Defaults, this.core.options);\n        this.swapping = true;\n        this.previous = undefined;\n        this.next = undefined;\n\n        this.handlers = {\n            'change.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && e.property.name == 'position') {\n                    this.previous = this.core.current();\n                    this.next = e.property.value;\n                }\n            }, this),\n            'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {\n                if (e.namespace) {\n                    this.swapping = e.type == 'translated';\n                }\n            }, this),\n            'translate.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {\n                    this.swap();\n                }\n            }, this)\n        };\n\n        this.core.$element.on(this.handlers);\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    Animate.Defaults = {\n        animateOut: false,\n        animateIn: false\n    };\n\n    /**\n     * Toggles the animation classes whenever an translations starts.\n     * @protected\n     * @returns {Boolean|undefined}\n     */\n    Animate.prototype.swap = function() {\n\n        if (this.core.settings.items !== 1) {\n            return;\n        }\n\n        if (!$.support.animation || !$.support.transition) {\n            return;\n        }\n\n        this.core.speed(0);\n\n        var left,\n            clear = $.proxy(this.clear, this),\n            previous = this.core.$stage.children().eq(this.previous),\n            next = this.core.$stage.children().eq(this.next),\n            incoming = this.core.settings.animateIn,\n            outgoing = this.core.settings.animateOut;\n\n        if (this.core.current() === this.previous) {\n            return;\n        }\n\n        if (outgoing) {\n            left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);\n            previous.one($.support.animation.end, clear)\n                .css( { 'left': left + 'px' } )\n                .addClass('animated owl-animated-out')\n                .addClass(outgoing);\n        }\n\n        if (incoming) {\n            next.one($.support.animation.end, clear)\n                .addClass('animated owl-animated-in')\n                .addClass(incoming);\n        }\n    };\n\n    Animate.prototype.clear = function(e) {\n        $(e.target).css( { 'left': '' } )\n            .removeClass('animated owl-animated-out owl-animated-in')\n            .removeClass(this.core.settings.animateIn)\n            .removeClass(this.core.settings.animateOut);\n        this.core.onTransitionEnd();\n    };\n\n    /**\n     * Destroys the plugin.\n     * @public\n     */\n    Animate.prototype.destroy = function() {\n        var handler, property;\n\n        for (handler in this.handlers) {\n            this.core.$element.off(handler, this.handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Animate = Animate;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Autoplay Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n    /**\n     * Creates the autoplay plugin.\n     * @class The Autoplay Plugin\n     * @param {Owl} scope - The Owl Carousel\n     */\n    var Autoplay = function(carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * The autoplay timeout.\n         * @type {Timeout}\n         */\n        this._timeout = null;\n\n        /**\n         * Indicates whenever the autoplay is paused.\n         * @type {Boolean}\n         */\n        this._paused = false;\n\n        /**\n         * All event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'changed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && e.property.name === 'settings') {\n                    if (this._core.settings.autoplay) {\n                        this.play();\n                    } else {\n                        this.stop();\n                    }\n                } else if (e.namespace && e.property.name === 'position') {\n                    //console.log('play?', e);\n                    if (this._core.settings.autoplay) {\n                        this._setAutoPlayInterval();\n                    }\n                }\n            }, this),\n            'initialized.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.autoplay) {\n                    this.play();\n                }\n            }, this),\n            'play.owl.autoplay': $.proxy(function(e, t, s) {\n                if (e.namespace) {\n                    this.play(t, s);\n                }\n            }, this),\n            'stop.owl.autoplay': $.proxy(function(e) {\n                if (e.namespace) {\n                    this.stop();\n                }\n            }, this),\n            'mouseover.owl.autoplay': $.proxy(function() {\n                if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n                    this.pause();\n                }\n            }, this),\n            'mouseleave.owl.autoplay': $.proxy(function() {\n                if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n                    this.play();\n                }\n            }, this),\n            'touchstart.owl.core': $.proxy(function() {\n                if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n                    this.pause();\n                }\n            }, this),\n            'touchend.owl.core': $.proxy(function() {\n                if (this._core.settings.autoplayHoverPause) {\n                    this.play();\n                }\n            }, this)\n        };\n\n        // register event handlers\n        this._core.$element.on(this._handlers);\n\n        // set default options\n        this._core.options = $.extend({}, Autoplay.Defaults, this._core.options);\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    Autoplay.Defaults = {\n        autoplay: false,\n        autoplayTimeout: 5000,\n        autoplayHoverPause: false,\n        autoplaySpeed: false\n    };\n\n    /**\n     * Starts the autoplay.\n     * @public\n     * @param {Number} [timeout] - The interval before the next animation starts.\n     * @param {Number} [speed] - The animation speed for the animations.\n     */\n    Autoplay.prototype.play = function(timeout, speed) {\n        this._paused = false;\n\n        if (this._core.is('rotating')) {\n            return;\n        }\n\n        this._core.enter('rotating');\n\n        this._setAutoPlayInterval();\n    };\n\n    /**\n     * Gets a new timeout\n     * @private\n     * @param {Number} [timeout] - The interval before the next animation starts.\n     * @param {Number} [speed] - The animation speed for the animations.\n     * @return {Timeout}\n     */\n    Autoplay.prototype._getNextTimeout = function(timeout, speed) {\n        if ( this._timeout ) {\n            window.clearTimeout(this._timeout);\n        }\n        return window.setTimeout($.proxy(function() {\n            if (this._paused || this._core.is('busy') || this._core.is('interacting') || document.hidden) {\n                return;\n            }\n            this._core.next(speed || this._core.settings.autoplaySpeed);\n        }, this), timeout || this._core.settings.autoplayTimeout);\n    };\n\n    /**\n     * Sets autoplay in motion.\n     * @private\n     */\n    Autoplay.prototype._setAutoPlayInterval = function() {\n        this._timeout = this._getNextTimeout();\n    };\n\n    /**\n     * Stops the autoplay.\n     * @public\n     */\n    Autoplay.prototype.stop = function() {\n        if (!this._core.is('rotating')) {\n            return;\n        }\n\n        window.clearTimeout(this._timeout);\n        this._core.leave('rotating');\n    };\n\n    /**\n     * Stops the autoplay.\n     * @public\n     */\n    Autoplay.prototype.pause = function() {\n        if (!this._core.is('rotating')) {\n            return;\n        }\n\n        this._paused = true;\n    };\n\n    /**\n     * Destroys the plugin.\n     */\n    Autoplay.prototype.destroy = function() {\n        var handler, property;\n\n        this.stop();\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Navigation Plugin\n * @version 2.1.0\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n    'use strict';\n\n    /**\n     * Creates the navigation plugin.\n     * @class The Navigation Plugin\n     * @param {Owl} carousel - The Owl Carousel.\n     */\n    var Navigation = function(carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * Indicates whether the plugin is initialized or not.\n         * @protected\n         * @type {Boolean}\n         */\n        this._initialized = false;\n\n        /**\n         * The current paging indexes.\n         * @protected\n         * @type {Array}\n         */\n        this._pages = [];\n\n        /**\n         * All DOM elements of the user interface.\n         * @protected\n         * @type {Object}\n         */\n        this._controls = {};\n\n        /**\n         * Markup for an indicator.\n         * @protected\n         * @type {Array.<String>}\n         */\n        this._templates = [];\n\n        /**\n         * The carousel element.\n         * @type {jQuery}\n         */\n        this.$element = this._core.$element;\n\n        /**\n         * Overridden methods of the carousel.\n         * @protected\n         * @type {Object}\n         */\n        this._overrides = {\n            next: this._core.next,\n            prev: this._core.prev,\n            to: this._core.to\n        };\n\n        /**\n         * All event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'prepared.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.dotsData) {\n                    this._templates.push('<div class=\"' + this._core.settings.dotClass + '\">' +\n                        $(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');\n                }\n            }, this),\n            'added.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.dotsData) {\n                    this._templates.splice(e.position, 0, this._templates.pop());\n                }\n            }, this),\n            'remove.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.dotsData) {\n                    this._templates.splice(e.position, 1);\n                }\n            }, this),\n            'changed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && e.property.name == 'position') {\n                    this.draw();\n                }\n            }, this),\n            'initialized.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && !this._initialized) {\n                    this._core.trigger('initialize', null, 'navigation');\n                    this.initialize();\n                    this.update();\n                    this.draw();\n                    this._initialized = true;\n                    this._core.trigger('initialized', null, 'navigation');\n                }\n            }, this),\n            'refreshed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._initialized) {\n                    this._core.trigger('refresh', null, 'navigation');\n                    this.update();\n                    this.draw();\n                    this._core.trigger('refreshed', null, 'navigation');\n                }\n            }, this)\n        };\n\n        // set default options\n        this._core.options = $.extend({}, Navigation.Defaults, this._core.options);\n\n        // register event handlers\n        this.$element.on(this._handlers);\n    };\n\n    /**\n     * Default options.\n     * @public\n     * @todo Rename `slideBy` to `navBy`\n     */\n    Navigation.Defaults = {\n        nav: false,\n        navText: [ 'prev', 'next' ],\n        navSpeed: false,\n        navElement: 'div',\n        navContainer: false,\n        navContainerClass: 'owl-nav',\n        navClass: [ 'owl-prev', 'owl-next' ],\n        slideBy: 1,\n        dotClass: 'owl-dot',\n        dotsClass: 'owl-dots',\n        dots: true,\n        dotsEach: false,\n        dotsData: false,\n        dotsSpeed: false,\n        dotsContainer: false\n    };\n\n    /**\n     * Initializes the layout of the plugin and extends the carousel.\n     * @protected\n     */\n    Navigation.prototype.initialize = function() {\n        var override,\n            settings = this._core.settings;\n\n        // create DOM structure for relative navigation\n        this._controls.$relative = (settings.navContainer ? $(settings.navContainer)\n            : $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');\n\n        this._controls.$previous = $('<' + settings.navElement + '>')\n            .addClass(settings.navClass[0])\n            .html(settings.navText[0])\n            .prependTo(this._controls.$relative)\n            .on('click', $.proxy(function(e) {\n                this.prev(settings.navSpeed);\n            }, this));\n        this._controls.$next = $('<' + settings.navElement + '>')\n            .addClass(settings.navClass[1])\n            .html(settings.navText[1])\n            .appendTo(this._controls.$relative)\n            .on('click', $.proxy(function(e) {\n                this.next(settings.navSpeed);\n            }, this));\n\n        // create DOM structure for absolute navigation\n        if (!settings.dotsData) {\n            this._templates = [ $('<div>')\n                .addClass(settings.dotClass)\n                .append($('<span>'))\n                .prop('outerHTML') ];\n        }\n\n        this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)\n            : $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');\n\n        this._controls.$absolute.on('click', 'div', $.proxy(function(e) {\n            var index = $(e.target).parent().is(this._controls.$absolute)\n                ? $(e.target).index() : $(e.target).parent().index();\n\n            e.preventDefault();\n\n            this.to(index, settings.dotsSpeed);\n        }, this));\n\n        // override public methods of the carousel\n        for (override in this._overrides) {\n            this._core[override] = $.proxy(this[override], this);\n        }\n    };\n\n    /**\n     * Destroys the plugin.\n     * @protected\n     */\n    Navigation.prototype.destroy = function() {\n        var handler, control, property, override;\n\n        for (handler in this._handlers) {\n            this.$element.off(handler, this._handlers[handler]);\n        }\n        for (control in this._controls) {\n            this._controls[control].remove();\n        }\n        for (override in this.overides) {\n            this._core[override] = this._overrides[override];\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    /**\n     * Updates the internal state.\n     * @protected\n     */\n    Navigation.prototype.update = function() {\n        var i, j, k,\n            lower = this._core.clones().length / 2,\n            upper = lower + this._core.items().length,\n            maximum = this._core.maximum(true),\n            settings = this._core.settings,\n            size = settings.center || settings.autoWidth || settings.dotsData\n                ? 1 : settings.dotsEach || settings.items;\n\n        if (settings.slideBy !== 'page') {\n            settings.slideBy = Math.min(settings.slideBy, settings.items);\n        }\n\n        if (settings.dots || settings.slideBy == 'page') {\n            this._pages = [];\n\n            for (i = lower, j = 0, k = 0; i < upper; i++) {\n                if (j >= size || j === 0) {\n                    this._pages.push({\n                        start: Math.min(maximum, i - lower),\n                        end: i - lower + size - 1\n                    });\n                    if (Math.min(maximum, i - lower) === maximum) {\n                        break;\n                    }\n                    j = 0, ++k;\n                }\n                j += this._core.mergers(this._core.relative(i));\n            }\n        }\n    };\n\n    /**\n     * Draws the user interface.\n     * @todo The option `dotsData` wont work.\n     * @protected\n     */\n    Navigation.prototype.draw = function() {\n        var difference,\n            settings = this._core.settings,\n            disabled = this._core.items().length <= settings.items,\n            index = this._core.relative(this._core.current()),\n            loop = settings.loop || settings.rewind;\n\n        this._controls.$relative.toggleClass('disabled', !settings.nav || disabled);\n\n        if (settings.nav) {\n            this._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));\n            this._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));\n        }\n\n        this._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);\n\n        if (settings.dots) {\n            difference = this._pages.length - this._controls.$absolute.children().length;\n\n            if (settings.dotsData && difference !== 0) {\n                this._controls.$absolute.html(this._templates.join(''));\n            } else if (difference > 0) {\n                this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));\n            } else if (difference < 0) {\n                this._controls.$absolute.children().slice(difference).remove();\n            }\n\n            this._controls.$absolute.find('.active').removeClass('active');\n            this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');\n        }\n    };\n\n    /**\n     * Extends event data.\n     * @protected\n     * @param {Event} event - The event object which gets thrown.\n     */\n    Navigation.prototype.onTrigger = function(event) {\n        var settings = this._core.settings;\n\n        event.page = {\n            index: $.inArray(this.current(), this._pages),\n            count: this._pages.length,\n            size: settings && (settings.center || settings.autoWidth || settings.dotsData\n                ? 1 : settings.dotsEach || settings.items)\n        };\n    };\n\n    /**\n     * Gets the current page position of the carousel.\n     * @protected\n     * @returns {Number}\n     */\n    Navigation.prototype.current = function() {\n        var current = this._core.relative(this._core.current());\n        return $.grep(this._pages, $.proxy(function(page, index) {\n            return page.start <= current && page.end >= current;\n        }, this)).pop();\n    };\n\n    /**\n     * Gets the current succesor/predecessor position.\n     * @protected\n     * @returns {Number}\n     */\n    Navigation.prototype.getPosition = function(successor) {\n        var position, length,\n            settings = this._core.settings;\n\n        if (settings.slideBy == 'page') {\n            position = $.inArray(this.current(), this._pages);\n            length = this._pages.length;\n            successor ? ++position : --position;\n            position = this._pages[((position % length) + length) % length].start;\n        } else {\n            position = this._core.relative(this._core.current());\n            length = this._core.items().length;\n            successor ? position += settings.slideBy : position -= settings.slideBy;\n        }\n\n        return position;\n    };\n\n    /**\n     * Slides to the next item or page.\n     * @public\n     * @param {Number} [speed=false] - The time in milliseconds for the transition.\n     */\n    Navigation.prototype.next = function(speed) {\n        $.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);\n    };\n\n    /**\n     * Slides to the previous item or page.\n     * @public\n     * @param {Number} [speed=false] - The time in milliseconds for the transition.\n     */\n    Navigation.prototype.prev = function(speed) {\n        $.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);\n    };\n\n    /**\n     * Slides to the specified item or page.\n     * @public\n     * @param {Number} position - The position of the item or page.\n     * @param {Number} [speed] - The time in milliseconds for the transition.\n     * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.\n     */\n    Navigation.prototype.to = function(position, speed, standard) {\n        var length;\n\n        if (!standard && this._pages.length) {\n            length = this._pages.length;\n            $.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);\n        } else {\n            $.proxy(this._overrides.to, this._core)(position, speed);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Hash Plugin\n * @version 2.1.0\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n    'use strict';\n\n    /**\n     * Creates the hash plugin.\n     * @class The Hash Plugin\n     * @param {Owl} carousel - The Owl Carousel\n     */\n    var Hash = function(carousel) {\n        /**\n         * Reference to the core.\n         * @protected\n         * @type {Owl}\n         */\n        this._core = carousel;\n\n        /**\n         * Hash index for the items.\n         * @protected\n         * @type {Object}\n         */\n        this._hashes = {};\n\n        /**\n         * The carousel element.\n         * @type {jQuery}\n         */\n        this.$element = this._core.$element;\n\n        /**\n         * All event handlers.\n         * @protected\n         * @type {Object}\n         */\n        this._handlers = {\n            'initialized.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this._core.settings.startPosition === 'URLHash') {\n                    $(window).trigger('hashchange.owl.navigation');\n                }\n            }, this),\n            'prepared.owl.carousel': $.proxy(function(e) {\n                if (e.namespace) {\n                    var hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');\n\n                    if (!hash) {\n                        return;\n                    }\n\n                    this._hashes[hash] = e.content;\n                }\n            }, this),\n            'changed.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && e.property.name === 'position') {\n                    var current = this._core.items(this._core.relative(this._core.current())),\n                        hash = $.map(this._hashes, function(item, hash) {\n                            return item === current ? hash : null;\n                        }).join();\n\n                    if (!hash || window.location.hash.slice(1) === hash) {\n                        return;\n                    }\n\n                    window.location.hash = hash;\n                }\n            }, this)\n        };\n\n        // set default options\n        this._core.options = $.extend({}, Hash.Defaults, this._core.options);\n\n        // register the event handlers\n        this.$element.on(this._handlers);\n\n        // register event listener for hash navigation\n        $(window).on('hashchange.owl.navigation', $.proxy(function(e) {\n            var hash = window.location.hash.substring(1),\n                items = this._core.$stage.children(),\n                position = this._hashes[hash] && items.index(this._hashes[hash]);\n\n            if (position === undefined || position === this._core.current()) {\n                return;\n            }\n\n            this._core.to(this._core.relative(position), false, true);\n        }, this));\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    Hash.Defaults = {\n        URLhashListener: false\n    };\n\n    /**\n     * Destroys the plugin.\n     * @public\n     */\n    Hash.prototype.destroy = function() {\n        var handler, property;\n\n        $(window).off('hashchange.owl.navigation');\n\n        for (handler in this._handlers) {\n            this._core.$element.off(handler, this._handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Hash = Hash;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Support Plugin\n *\n * @version 2.1.0\n * @author Vivid Planet Software GmbH\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n    var style = $('<support>').get(0).style,\n        prefixes = 'Webkit Moz O ms'.split(' '),\n        events = {\n            transition: {\n                end: {\n                    WebkitTransition: 'webkitTransitionEnd',\n                    MozTransition: 'transitionend',\n                    OTransition: 'oTransitionEnd',\n                    transition: 'transitionend'\n                }\n            },\n            animation: {\n                end: {\n                    WebkitAnimation: 'webkitAnimationEnd',\n                    MozAnimation: 'animationend',\n                    OAnimation: 'oAnimationEnd',\n                    animation: 'animationend'\n                }\n            }\n        },\n        tests = {\n            csstransforms: function() {\n                return !!test('transform');\n            },\n            csstransforms3d: function() {\n                return !!test('perspective');\n            },\n            csstransitions: function() {\n                return !!test('transition');\n            },\n            cssanimations: function() {\n                return !!test('animation');\n            }\n        };\n\n    function test(property, prefixed) {\n        var result = false,\n            upper = property.charAt(0).toUpperCase() + property.slice(1);\n\n        $.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function(i, property) {\n            if (style[property] !== undefined) {\n                result = prefixed ? property : true;\n                return false;\n            }\n        });\n\n        return result;\n    }\n\n    function prefixed(property) {\n        return test(property, true);\n    }\n\n    if (tests.csstransitions()) {\n        /* jshint -W053 */\n        $.support.transition = new String(prefixed('transition'))\n        $.support.transition.end = events.transition.end[ $.support.transition ];\n    }\n\n    if (tests.cssanimations()) {\n        /* jshint -W053 */\n        $.support.animation = new String(prefixed('animation'))\n        $.support.animation.end = events.animation.end[ $.support.animation ];\n    }\n\n    if (tests.csstransforms()) {\n        /* jshint -W053 */\n        $.support.transform = new String(prefixed('transform'));\n        $.support.transform3d = tests.csstransforms3d();\n    }\n\n})(window.Zepto || window.jQuery, window, document);","/**\n * Rangy, a cross-browser JavaScript range and selection library\n * https://github.com/timdown/rangy\n *\n * Copyright 2015, Tim Down\n * Licensed under the MIT license.\n * Version: 1.3.1-dev\n * Build date: 20 May 2015\n */\n\n(function(factory, root) {\n    if (typeof define == \"function\" && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(factory);\n    } else if (typeof module != \"undefined\" && typeof exports == \"object\") {\n        // Node/CommonJS style\n        module.exports = factory();\n    } else {\n        // No AMD or CommonJS support so we place Rangy in (probably) the global variable\n        root.rangy = factory();\n    }\n})(function() {\n\n    var OBJECT = \"object\", FUNCTION = \"function\", UNDEFINED = \"undefined\";\n\n    // Minimal set of properties required for DOM Level 2 Range compliance. Comparison constants such as START_TO_START\n    // are omitted because ranges in KHTML do not have them but otherwise work perfectly well. See issue 113.\n    var domRangeProperties = [\"startContainer\", \"startOffset\", \"endContainer\", \"endOffset\", \"collapsed\",\n        \"commonAncestorContainer\"];\n\n    // Minimal set of methods required for DOM Level 2 Range compliance\n    var domRangeMethods = [\"setStart\", \"setStartBefore\", \"setStartAfter\", \"setEnd\", \"setEndBefore\",\n        \"setEndAfter\", \"collapse\", \"selectNode\", \"selectNodeContents\", \"compareBoundaryPoints\", \"deleteContents\",\n        \"extractContents\", \"cloneContents\", \"insertNode\", \"surroundContents\", \"cloneRange\", \"toString\", \"detach\"];\n\n    var textRangeProperties = [\"boundingHeight\", \"boundingLeft\", \"boundingTop\", \"boundingWidth\", \"htmlText\", \"text\"];\n\n    // Subset of TextRange's full set of methods that we're interested in\n    var textRangeMethods = [\"collapse\", \"compareEndPoints\", \"duplicate\", \"moveToElementText\", \"parentElement\", \"select\",\n        \"setEndPoint\", \"getBoundingClientRect\"];\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Trio of functions taken from Peter Michaux's article:\n    // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting\n    function isHostMethod(o, p) {\n        var t = typeof o[p];\n        return t == FUNCTION || (!!(t == OBJECT && o[p])) || t == \"unknown\";\n    }\n\n    function isHostObject(o, p) {\n        return !!(typeof o[p] == OBJECT && o[p]);\n    }\n\n    function isHostProperty(o, p) {\n        return typeof o[p] != UNDEFINED;\n    }\n\n    // Creates a convenience function to save verbose repeated calls to tests functions\n    function createMultiplePropertyTest(testFunc) {\n        return function(o, props) {\n            var i = props.length;\n            while (i--) {\n                if (!testFunc(o, props[i])) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    }\n\n    // Next trio of functions are a convenience to save verbose repeated calls to previous two functions\n    var areHostMethods = createMultiplePropertyTest(isHostMethod);\n    var areHostObjects = createMultiplePropertyTest(isHostObject);\n    var areHostProperties = createMultiplePropertyTest(isHostProperty);\n\n    function isTextRange(range) {\n        return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);\n    }\n\n    function getBody(doc) {\n        return isHostObject(doc, \"body\") ? doc.body : doc.getElementsByTagName(\"body\")[0];\n    }\n\n    var forEach = [].forEach ?\n        function(arr, func) {\n            arr.forEach(func);\n        } :\n        function(arr, func) {\n            for (var i = 0, len = arr.length; i < len; ++i) {\n                func(arr[i], i);\n            }\n        };\n\n    var modules = {};\n\n    var isBrowser = (typeof window != UNDEFINED && typeof document != UNDEFINED);\n\n    var util = {\n        isHostMethod: isHostMethod,\n        isHostObject: isHostObject,\n        isHostProperty: isHostProperty,\n        areHostMethods: areHostMethods,\n        areHostObjects: areHostObjects,\n        areHostProperties: areHostProperties,\n        isTextRange: isTextRange,\n        getBody: getBody,\n        forEach: forEach\n    };\n\n    var api = {\n        version: \"1.3.1-dev\",\n        initialized: false,\n        isBrowser: isBrowser,\n        supported: true,\n        util: util,\n        features: {},\n        modules: modules,\n        config: {\n            alertOnFail: false,\n            alertOnWarn: false,\n            preferTextRange: false,\n            autoInitialize: (typeof rangyAutoInitialize == UNDEFINED) ? true : rangyAutoInitialize\n        }\n    };\n\n    function consoleLog(msg) {\n        if (typeof console != UNDEFINED && isHostMethod(console, \"log\")) {\n            console.log(msg);\n        }\n    }\n\n    function alertOrLog(msg, shouldAlert) {\n        if (isBrowser && shouldAlert) {\n            alert(msg);\n        } else  {\n            consoleLog(msg);\n        }\n    }\n\n    function fail(reason) {\n        api.initialized = true;\n        api.supported = false;\n        alertOrLog(\"Rangy is not supported in this environment. Reason: \" + reason, api.config.alertOnFail);\n    }\n\n    api.fail = fail;\n\n    function warn(msg) {\n        alertOrLog(\"Rangy warning: \" + msg, api.config.alertOnWarn);\n    }\n\n    api.warn = warn;\n\n    // Add utility extend() method\n    var extend;\n    if ({}.hasOwnProperty) {\n        util.extend = extend = function(obj, props, deep) {\n            var o, p;\n            for (var i in props) {\n                if (props.hasOwnProperty(i)) {\n                    o = obj[i];\n                    p = props[i];\n                    if (deep && o !== null && typeof o == \"object\" && p !== null && typeof p == \"object\") {\n                        extend(o, p, true);\n                    }\n                    obj[i] = p;\n                }\n            }\n            // Special case for toString, which does not show up in for...in loops in IE <= 8\n            if (props.hasOwnProperty(\"toString\")) {\n                obj.toString = props.toString;\n            }\n            return obj;\n        };\n\n        util.createOptions = function(optionsParam, defaults) {\n            var options = {};\n            extend(options, defaults);\n            if (optionsParam) {\n                extend(options, optionsParam);\n            }\n            return options;\n        };\n    } else {\n        fail(\"hasOwnProperty not supported\");\n    }\n\n    // Test whether we're in a browser and bail out if not\n    if (!isBrowser) {\n        fail(\"Rangy can only run in a browser\");\n    }\n\n    // Test whether Array.prototype.slice can be relied on for NodeLists and use an alternative toArray() if not\n    (function() {\n        var toArray;\n\n        if (isBrowser) {\n            var el = document.createElement(\"div\");\n            el.appendChild(document.createElement(\"span\"));\n            var slice = [].slice;\n            try {\n                if (slice.call(el.childNodes, 0)[0].nodeType == 1) {\n                    toArray = function(arrayLike) {\n                        return slice.call(arrayLike, 0);\n                    };\n                }\n            } catch (e) {}\n        }\n\n        if (!toArray) {\n            toArray = function(arrayLike) {\n                var arr = [];\n                for (var i = 0, len = arrayLike.length; i < len; ++i) {\n                    arr[i] = arrayLike[i];\n                }\n                return arr;\n            };\n        }\n\n        util.toArray = toArray;\n    })();\n\n    // Very simple event handler wrapper function that doesn't attempt to solve issues such as \"this\" handling or\n    // normalization of event properties\n    var addListener;\n    if (isBrowser) {\n        if (isHostMethod(document, \"addEventListener\")) {\n            addListener = function(obj, eventType, listener) {\n                obj.addEventListener(eventType, listener, false);\n            };\n        } else if (isHostMethod(document, \"attachEvent\")) {\n            addListener = function(obj, eventType, listener) {\n                obj.attachEvent(\"on\" + eventType, listener);\n            };\n        } else {\n            fail(\"Document does not have required addEventListener or attachEvent method\");\n        }\n\n        util.addListener = addListener;\n    }\n\n    var initListeners = [];\n\n    function getErrorDesc(ex) {\n        return ex.message || ex.description || String(ex);\n    }\n\n    // Initialization\n    function init() {\n        if (!isBrowser || api.initialized) {\n            return;\n        }\n        var testRange;\n        var implementsDomRange = false, implementsTextRange = false;\n\n        // First, perform basic feature tests\n\n        if (isHostMethod(document, \"createRange\")) {\n            testRange = document.createRange();\n            if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {\n                implementsDomRange = true;\n            }\n        }\n\n        var body = getBody(document);\n        if (!body || body.nodeName.toLowerCase() != \"body\") {\n            fail(\"No body element found\");\n            return;\n        }\n\n        if (body && isHostMethod(body, \"createTextRange\")) {\n            testRange = body.createTextRange();\n            if (isTextRange(testRange)) {\n                implementsTextRange = true;\n            }\n        }\n\n        if (!implementsDomRange && !implementsTextRange) {\n            fail(\"Neither Range nor TextRange are available\");\n            return;\n        }\n\n        api.initialized = true;\n        api.features = {\n            implementsDomRange: implementsDomRange,\n            implementsTextRange: implementsTextRange\n        };\n\n        // Initialize modules\n        var module, errorMessage;\n        for (var moduleName in modules) {\n            if ( (module = modules[moduleName]) instanceof Module ) {\n                module.init(module, api);\n            }\n        }\n\n        // Call init listeners\n        for (var i = 0, len = initListeners.length; i < len; ++i) {\n            try {\n                initListeners[i](api);\n            } catch (ex) {\n                errorMessage = \"Rangy init listener threw an exception. Continuing. Detail: \" + getErrorDesc(ex);\n                consoleLog(errorMessage);\n            }\n        }\n    }\n\n    function deprecationNotice(deprecated, replacement, module) {\n        if (module) {\n            deprecated += \" in module \" + module.name;\n        }\n        api.warn(\"DEPRECATED: \" + deprecated + \" is deprecated. Please use \" +\n            replacement + \" instead.\");\n    }\n\n    function createAliasForDeprecatedMethod(owner, deprecated, replacement, module) {\n        owner[deprecated] = function() {\n            deprecationNotice(deprecated, replacement, module);\n            return owner[replacement].apply(owner, util.toArray(arguments));\n        };\n    }\n\n    util.deprecationNotice = deprecationNotice;\n    util.createAliasForDeprecatedMethod = createAliasForDeprecatedMethod;\n\n    // Allow external scripts to initialize this library in case it's loaded after the document has loaded\n    api.init = init;\n\n    // Execute listener immediately if already initialized\n    api.addInitListener = function(listener) {\n        if (api.initialized) {\n            listener(api);\n        } else {\n            initListeners.push(listener);\n        }\n    };\n\n    var shimListeners = [];\n\n    api.addShimListener = function(listener) {\n        shimListeners.push(listener);\n    };\n\n    function shim(win) {\n        win = win || window;\n        init();\n\n        // Notify listeners\n        for (var i = 0, len = shimListeners.length; i < len; ++i) {\n            shimListeners[i](win);\n        }\n    }\n\n    if (isBrowser) {\n        api.shim = api.createMissingNativeApi = shim;\n        createAliasForDeprecatedMethod(api, \"createMissingNativeApi\", \"shim\");\n    }\n\n    function Module(name, dependencies, initializer) {\n        this.name = name;\n        this.dependencies = dependencies;\n        this.initialized = false;\n        this.supported = false;\n        this.initializer = initializer;\n    }\n\n    Module.prototype = {\n        init: function() {\n            var requiredModuleNames = this.dependencies || [];\n            for (var i = 0, len = requiredModuleNames.length, requiredModule, moduleName; i < len; ++i) {\n                moduleName = requiredModuleNames[i];\n\n                requiredModule = modules[moduleName];\n                if (!requiredModule || !(requiredModule instanceof Module)) {\n                    throw new Error(\"required module '\" + moduleName + \"' not found\");\n                }\n\n                requiredModule.init();\n\n                if (!requiredModule.supported) {\n                    throw new Error(\"required module '\" + moduleName + \"' not supported\");\n                }\n            }\n\n            // Now run initializer\n            this.initializer(this);\n        },\n\n        fail: function(reason) {\n            this.initialized = true;\n            this.supported = false;\n            throw new Error(reason);\n        },\n\n        warn: function(msg) {\n            api.warn(\"Module \" + this.name + \": \" + msg);\n        },\n\n        deprecationNotice: function(deprecated, replacement) {\n            api.warn(\"DEPRECATED: \" + deprecated + \" in module \" + this.name + \" is deprecated. Please use \" +\n                replacement + \" instead\");\n        },\n\n        createError: function(msg) {\n            return new Error(\"Error in Rangy \" + this.name + \" module: \" + msg);\n        }\n    };\n\n    function createModule(name, dependencies, initFunc) {\n        var newModule = new Module(name, dependencies, function(module) {\n            if (!module.initialized) {\n                module.initialized = true;\n                try {\n                    initFunc(api, module);\n                    module.supported = true;\n                } catch (ex) {\n                    var errorMessage = \"Module '\" + name + \"' failed to load: \" + getErrorDesc(ex);\n                    consoleLog(errorMessage);\n                    if (ex.stack) {\n                        consoleLog(ex.stack);\n                    }\n                }\n            }\n        });\n        modules[name] = newModule;\n        return newModule;\n    }\n\n    api.createModule = function(name) {\n        // Allow 2 or 3 arguments (second argument is an optional array of dependencies)\n        var initFunc, dependencies;\n        if (arguments.length == 2) {\n            initFunc = arguments[1];\n            dependencies = [];\n        } else {\n            initFunc = arguments[2];\n            dependencies = arguments[1];\n        }\n\n        var module = createModule(name, dependencies, initFunc);\n\n        // Initialize the module immediately if the core is already initialized\n        if (api.initialized && api.supported) {\n            module.init();\n        }\n    };\n\n    api.createCoreModule = function(name, dependencies, initFunc) {\n        createModule(name, dependencies, initFunc);\n    };\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Ensure rangy.rangePrototype and rangy.selectionPrototype are available immediately\n\n    function RangePrototype() {}\n    api.RangePrototype = RangePrototype;\n    api.rangePrototype = new RangePrototype();\n\n    function SelectionPrototype() {}\n    api.selectionPrototype = new SelectionPrototype();\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // DOM utility methods used by Rangy\n    api.createCoreModule(\"DomUtil\", [], function(api, module) {\n        var UNDEF = \"undefined\";\n        var util = api.util;\n        var getBody = util.getBody;\n\n        // Perform feature tests\n        if (!util.areHostMethods(document, [\"createDocumentFragment\", \"createElement\", \"createTextNode\"])) {\n            module.fail(\"document missing a Node creation method\");\n        }\n\n        if (!util.isHostMethod(document, \"getElementsByTagName\")) {\n            module.fail(\"document missing getElementsByTagName method\");\n        }\n\n        var el = document.createElement(\"div\");\n        if (!util.areHostMethods(el, [\"insertBefore\", \"appendChild\", \"cloneNode\"] ||\n                !util.areHostObjects(el, [\"previousSibling\", \"nextSibling\", \"childNodes\", \"parentNode\"]))) {\n            module.fail(\"Incomplete Element implementation\");\n        }\n\n        // innerHTML is required for Range's createContextualFragment method\n        if (!util.isHostProperty(el, \"innerHTML\")) {\n            module.fail(\"Element is missing innerHTML property\");\n        }\n\n        var textNode = document.createTextNode(\"test\");\n        if (!util.areHostMethods(textNode, [\"splitText\", \"deleteData\", \"insertData\", \"appendData\", \"cloneNode\"] ||\n                !util.areHostObjects(el, [\"previousSibling\", \"nextSibling\", \"childNodes\", \"parentNode\"]) ||\n                !util.areHostProperties(textNode, [\"data\"]))) {\n            module.fail(\"Incomplete Text Node implementation\");\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven't been\n        // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that\n        // contains just the document as a single element and the value searched for is the document.\n        var arrayContains = /*Array.prototype.indexOf ?\n         function(arr, val) {\n         return arr.indexOf(val) > -1;\n         }:*/\n\n            function(arr, val) {\n                var i = arr.length;\n                while (i--) {\n                    if (arr[i] === val) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n\n        // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI\n        function isHtmlNamespace(node) {\n            var ns;\n            return typeof node.namespaceURI == UNDEF || ((ns = node.namespaceURI) === null || ns == \"http://www.w3.org/1999/xhtml\");\n        }\n\n        function parentElement(node) {\n            var parent = node.parentNode;\n            return (parent.nodeType == 1) ? parent : null;\n        }\n\n        function getNodeIndex(node) {\n            var i = 0;\n            while( (node = node.previousSibling) ) {\n                ++i;\n            }\n            return i;\n        }\n\n        function getNodeLength(node) {\n            switch (node.nodeType) {\n                case 7:\n                case 10:\n                    return 0;\n                case 3:\n                case 8:\n                    return node.length;\n                default:\n                    return node.childNodes.length;\n            }\n        }\n\n        function getCommonAncestor(node1, node2) {\n            var ancestors = [], n;\n            for (n = node1; n; n = n.parentNode) {\n                ancestors.push(n);\n            }\n\n            for (n = node2; n; n = n.parentNode) {\n                if (arrayContains(ancestors, n)) {\n                    return n;\n                }\n            }\n\n            return null;\n        }\n\n        function isAncestorOf(ancestor, descendant, selfIsAncestor) {\n            var n = selfIsAncestor ? descendant : descendant.parentNode;\n            while (n) {\n                if (n === ancestor) {\n                    return true;\n                } else {\n                    n = n.parentNode;\n                }\n            }\n            return false;\n        }\n\n        function isOrIsAncestorOf(ancestor, descendant) {\n            return isAncestorOf(ancestor, descendant, true);\n        }\n\n        function getClosestAncestorIn(node, ancestor, selfIsAncestor) {\n            var p, n = selfIsAncestor ? node : node.parentNode;\n            while (n) {\n                p = n.parentNode;\n                if (p === ancestor) {\n                    return n;\n                }\n                n = p;\n            }\n            return null;\n        }\n\n        function isCharacterDataNode(node) {\n            var t = node.nodeType;\n            return t == 3 || t == 4 || t == 8 ; // Text, CDataSection or Comment\n        }\n\n        function isTextOrCommentNode(node) {\n            if (!node) {\n                return false;\n            }\n            var t = node.nodeType;\n            return t == 3 || t == 8 ; // Text or Comment\n        }\n\n        function insertAfter(node, precedingNode) {\n            var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;\n            if (nextNode) {\n                parent.insertBefore(node, nextNode);\n            } else {\n                parent.appendChild(node);\n            }\n            return node;\n        }\n\n        // Note that we cannot use splitText() because it is bugridden in IE 9.\n        function splitDataNode(node, index, positionsToPreserve) {\n            var newNode = node.cloneNode(false);\n            newNode.deleteData(0, index);\n            node.deleteData(index, node.length - index);\n            insertAfter(newNode, node);\n\n            // Preserve positions\n            if (positionsToPreserve) {\n                for (var i = 0, position; position = positionsToPreserve[i++]; ) {\n                    // Handle case where position was inside the portion of node after the split point\n                    if (position.node == node && position.offset > index) {\n                        position.node = newNode;\n                        position.offset -= index;\n                    }\n                    // Handle the case where the position is a node offset within node's parent\n                    else if (position.node == node.parentNode && position.offset > getNodeIndex(node)) {\n                        ++position.offset;\n                    }\n                }\n            }\n            return newNode;\n        }\n\n        function getDocument(node) {\n            if (node.nodeType == 9) {\n                return node;\n            } else if (typeof node.ownerDocument != UNDEF) {\n                return node.ownerDocument;\n            } else if (typeof node.document != UNDEF) {\n                return node.document;\n            } else if (node.parentNode) {\n                return getDocument(node.parentNode);\n            } else {\n                throw module.createError(\"getDocument: no document found for node\");\n            }\n        }\n\n        function getWindow(node) {\n            var doc = getDocument(node);\n            if (typeof doc.defaultView != UNDEF) {\n                return doc.defaultView;\n            } else if (typeof doc.parentWindow != UNDEF) {\n                return doc.parentWindow;\n            } else {\n                throw module.createError(\"Cannot get a window object for node\");\n            }\n        }\n\n        function getIframeDocument(iframeEl) {\n            if (typeof iframeEl.contentDocument != UNDEF) {\n                return iframeEl.contentDocument;\n            } else if (typeof iframeEl.contentWindow != UNDEF) {\n                return iframeEl.contentWindow.document;\n            } else {\n                throw module.createError(\"getIframeDocument: No Document object found for iframe element\");\n            }\n        }\n\n        function getIframeWindow(iframeEl) {\n            if (typeof iframeEl.contentWindow != UNDEF) {\n                return iframeEl.contentWindow;\n            } else if (typeof iframeEl.contentDocument != UNDEF) {\n                return iframeEl.contentDocument.defaultView;\n            } else {\n                throw module.createError(\"getIframeWindow: No Window object found for iframe element\");\n            }\n        }\n\n        // This looks bad. Is it worth it?\n        function isWindow(obj) {\n            return obj && util.isHostMethod(obj, \"setTimeout\") && util.isHostObject(obj, \"document\");\n        }\n\n        function getContentDocument(obj, module, methodName) {\n            var doc;\n\n            if (!obj) {\n                doc = document;\n            }\n\n            // Test if a DOM node has been passed and obtain a document object for it if so\n            else if (util.isHostProperty(obj, \"nodeType\")) {\n                doc = (obj.nodeType == 1 && obj.tagName.toLowerCase() == \"iframe\") ?\n                    getIframeDocument(obj) : getDocument(obj);\n            }\n\n            // Test if the doc parameter appears to be a Window object\n            else if (isWindow(obj)) {\n                doc = obj.document;\n            }\n\n            if (!doc) {\n                throw module.createError(methodName + \"(): Parameter must be a Window object or DOM node\");\n            }\n\n            return doc;\n        }\n\n        function getRootContainer(node) {\n            var parent;\n            while ( (parent = node.parentNode) ) {\n                node = parent;\n            }\n            return node;\n        }\n\n        function comparePoints(nodeA, offsetA, nodeB, offsetB) {\n            // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing\n            var nodeC, root, childA, childB, n;\n            if (nodeA == nodeB) {\n                // Case 1: nodes are the same\n                return offsetA === offsetB ? 0 : (offsetA < offsetB) ? -1 : 1;\n            } else if ( (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) ) {\n                // Case 2: node C (container B or an ancestor) is a child node of A\n                return offsetA <= getNodeIndex(nodeC) ? -1 : 1;\n            } else if ( (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) ) {\n                // Case 3: node C (container A or an ancestor) is a child node of B\n                return getNodeIndex(nodeC) < offsetB  ? -1 : 1;\n            } else {\n                root = getCommonAncestor(nodeA, nodeB);\n                if (!root) {\n                    throw new Error(\"comparePoints error: nodes have no common ancestor\");\n                }\n\n                // Case 4: containers are siblings or descendants of siblings\n                childA = (nodeA === root) ? root : getClosestAncestorIn(nodeA, root, true);\n                childB = (nodeB === root) ? root : getClosestAncestorIn(nodeB, root, true);\n\n                if (childA === childB) {\n                    // This shouldn't be possible\n                    throw module.createError(\"comparePoints got to case 4 and childA and childB are the same!\");\n                } else {\n                    n = root.firstChild;\n                    while (n) {\n                        if (n === childA) {\n                            return -1;\n                        } else if (n === childB) {\n                            return 1;\n                        }\n                        n = n.nextSibling;\n                    }\n                }\n            }\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Test for IE's crash (IE 6/7) or exception (IE >= 8) when a reference to garbage-collected text node is queried\n        var crashyTextNodes = false;\n\n        function isBrokenNode(node) {\n            var n;\n            try {\n                n = node.parentNode;\n                return false;\n            } catch (e) {\n                return true;\n            }\n        }\n\n        (function() {\n            var el = document.createElement(\"b\");\n            el.innerHTML = \"1\";\n            var textNode = el.firstChild;\n            el.innerHTML = \"<br />\";\n            crashyTextNodes = isBrokenNode(textNode);\n\n            api.features.crashyTextNodes = crashyTextNodes;\n        })();\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        function inspectNode(node) {\n            if (!node) {\n                return \"[No node]\";\n            }\n            if (crashyTextNodes && isBrokenNode(node)) {\n                return \"[Broken node]\";\n            }\n            if (isCharacterDataNode(node)) {\n                return '\"' + node.data + '\"';\n            }\n            if (node.nodeType == 1) {\n                var idAttr = node.id ? ' id=\"' + node.id + '\"' : \"\";\n                return \"<\" + node.nodeName + idAttr + \">[index:\" + getNodeIndex(node) + \",length:\" + node.childNodes.length + \"][\" + (node.innerHTML || \"[innerHTML not supported]\").slice(0, 25) + \"]\";\n            }\n            return node.nodeName;\n        }\n\n        function fragmentFromNodeChildren(node) {\n            var fragment = getDocument(node).createDocumentFragment(), child;\n            while ( (child = node.firstChild) ) {\n                fragment.appendChild(child);\n            }\n            return fragment;\n        }\n\n        var getComputedStyleProperty;\n        if (typeof window.getComputedStyle != UNDEF) {\n            getComputedStyleProperty = function(el, propName) {\n                return getWindow(el).getComputedStyle(el, null)[propName];\n            };\n        } else if (typeof document.documentElement.currentStyle != UNDEF) {\n            getComputedStyleProperty = function(el, propName) {\n                return el.currentStyle ? el.currentStyle[propName] : \"\";\n            };\n        } else {\n            module.fail(\"No means of obtaining computed style properties found\");\n        }\n\n        function createTestElement(doc, html, contentEditable) {\n            var body = getBody(doc);\n            var el = doc.createElement(\"div\");\n            el.contentEditable = \"\" + !!contentEditable;\n            if (html) {\n                el.innerHTML = html;\n            }\n\n            // Insert the test element at the start of the body to prevent scrolling to the bottom in iOS (issue #292)\n            var bodyFirstChild = body.firstChild;\n            if (bodyFirstChild) {\n                body.insertBefore(el, bodyFirstChild);\n            } else {\n                body.appendChild(el);\n            }\n\n            return el;\n        }\n\n        function removeNode(node) {\n            return node.parentNode.removeChild(node);\n        }\n\n        function NodeIterator(root) {\n            this.root = root;\n            this._next = root;\n        }\n\n        NodeIterator.prototype = {\n            _current: null,\n\n            hasNext: function() {\n                return !!this._next;\n            },\n\n            next: function() {\n                var n = this._current = this._next;\n                var child, next;\n                if (this._current) {\n                    child = n.firstChild;\n                    if (child) {\n                        this._next = child;\n                    } else {\n                        next = null;\n                        while ((n !== this.root) && !(next = n.nextSibling)) {\n                            n = n.parentNode;\n                        }\n                        this._next = next;\n                    }\n                }\n                return this._current;\n            },\n\n            detach: function() {\n                this._current = this._next = this.root = null;\n            }\n        };\n\n        function createIterator(root) {\n            return new NodeIterator(root);\n        }\n\n        function DomPosition(node, offset) {\n            this.node = node;\n            this.offset = offset;\n        }\n\n        DomPosition.prototype = {\n            equals: function(pos) {\n                return !!pos && this.node === pos.node && this.offset == pos.offset;\n            },\n\n            inspect: function() {\n                return \"[DomPosition(\" + inspectNode(this.node) + \":\" + this.offset + \")]\";\n            },\n\n            toString: function() {\n                return this.inspect();\n            }\n        };\n\n        function DOMException(codeName) {\n            this.code = this[codeName];\n            this.codeName = codeName;\n            this.message = \"DOMException: \" + this.codeName;\n        }\n\n        DOMException.prototype = {\n            INDEX_SIZE_ERR: 1,\n            HIERARCHY_REQUEST_ERR: 3,\n            WRONG_DOCUMENT_ERR: 4,\n            NO_MODIFICATION_ALLOWED_ERR: 7,\n            NOT_FOUND_ERR: 8,\n            NOT_SUPPORTED_ERR: 9,\n            INVALID_STATE_ERR: 11,\n            INVALID_NODE_TYPE_ERR: 24\n        };\n\n        DOMException.prototype.toString = function() {\n            return this.message;\n        };\n\n        api.dom = {\n            arrayContains: arrayContains,\n            isHtmlNamespace: isHtmlNamespace,\n            parentElement: parentElement,\n            getNodeIndex: getNodeIndex,\n            getNodeLength: getNodeLength,\n            getCommonAncestor: getCommonAncestor,\n            isAncestorOf: isAncestorOf,\n            isOrIsAncestorOf: isOrIsAncestorOf,\n            getClosestAncestorIn: getClosestAncestorIn,\n            isCharacterDataNode: isCharacterDataNode,\n            isTextOrCommentNode: isTextOrCommentNode,\n            insertAfter: insertAfter,\n            splitDataNode: splitDataNode,\n            getDocument: getDocument,\n            getWindow: getWindow,\n            getIframeWindow: getIframeWindow,\n            getIframeDocument: getIframeDocument,\n            getBody: getBody,\n            isWindow: isWindow,\n            getContentDocument: getContentDocument,\n            getRootContainer: getRootContainer,\n            comparePoints: comparePoints,\n            isBrokenNode: isBrokenNode,\n            inspectNode: inspectNode,\n            getComputedStyleProperty: getComputedStyleProperty,\n            createTestElement: createTestElement,\n            removeNode: removeNode,\n            fragmentFromNodeChildren: fragmentFromNodeChildren,\n            createIterator: createIterator,\n            DomPosition: DomPosition\n        };\n\n        api.DOMException = DOMException;\n    });\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Pure JavaScript implementation of DOM Range\n    api.createCoreModule(\"DomRange\", [\"DomUtil\"], function(api, module) {\n        var dom = api.dom;\n        var util = api.util;\n        var DomPosition = dom.DomPosition;\n        var DOMException = api.DOMException;\n\n        var isCharacterDataNode = dom.isCharacterDataNode;\n        var getNodeIndex = dom.getNodeIndex;\n        var isOrIsAncestorOf = dom.isOrIsAncestorOf;\n        var getDocument = dom.getDocument;\n        var comparePoints = dom.comparePoints;\n        var splitDataNode = dom.splitDataNode;\n        var getClosestAncestorIn = dom.getClosestAncestorIn;\n        var getNodeLength = dom.getNodeLength;\n        var arrayContains = dom.arrayContains;\n        var getRootContainer = dom.getRootContainer;\n        var crashyTextNodes = api.features.crashyTextNodes;\n\n        var removeNode = dom.removeNode;\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Utility functions\n\n        function isNonTextPartiallySelected(node, range) {\n            return (node.nodeType != 3) &&\n                (isOrIsAncestorOf(node, range.startContainer) || isOrIsAncestorOf(node, range.endContainer));\n        }\n\n        function getRangeDocument(range) {\n            return range.document || getDocument(range.startContainer);\n        }\n\n        function getRangeRoot(range) {\n            return getRootContainer(range.startContainer);\n        }\n\n        function getBoundaryBeforeNode(node) {\n            return new DomPosition(node.parentNode, getNodeIndex(node));\n        }\n\n        function getBoundaryAfterNode(node) {\n            return new DomPosition(node.parentNode, getNodeIndex(node) + 1);\n        }\n\n        function insertNodeAtPosition(node, n, o) {\n            var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;\n            if (isCharacterDataNode(n)) {\n                if (o == n.length) {\n                    dom.insertAfter(node, n);\n                } else {\n                    n.parentNode.insertBefore(node, o == 0 ? n : splitDataNode(n, o));\n                }\n            } else if (o >= n.childNodes.length) {\n                n.appendChild(node);\n            } else {\n                n.insertBefore(node, n.childNodes[o]);\n            }\n            return firstNodeInserted;\n        }\n\n        function rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {\n            assertRangeValid(rangeA);\n            assertRangeValid(rangeB);\n\n            if (getRangeDocument(rangeB) != getRangeDocument(rangeA)) {\n                throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n            }\n\n            var startComparison = comparePoints(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset),\n                endComparison = comparePoints(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);\n\n            return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n        }\n\n        function cloneSubtree(iterator) {\n            var partiallySelected;\n            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {\n                partiallySelected = iterator.isPartiallySelectedSubtree();\n                node = node.cloneNode(!partiallySelected);\n                if (partiallySelected) {\n                    subIterator = iterator.getSubtreeIterator();\n                    node.appendChild(cloneSubtree(subIterator));\n                    subIterator.detach();\n                }\n\n                if (node.nodeType == 10) { // DocumentType\n                    throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n                }\n                frag.appendChild(node);\n            }\n            return frag;\n        }\n\n        function iterateSubtree(rangeIterator, func, iteratorState) {\n            var it, n;\n            iteratorState = iteratorState || { stop: false };\n            for (var node, subRangeIterator; node = rangeIterator.next(); ) {\n                if (rangeIterator.isPartiallySelectedSubtree()) {\n                    if (func(node) === false) {\n                        iteratorState.stop = true;\n                        return;\n                    } else {\n                        // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of\n                        // the node selected by the Range.\n                        subRangeIterator = rangeIterator.getSubtreeIterator();\n                        iterateSubtree(subRangeIterator, func, iteratorState);\n                        subRangeIterator.detach();\n                        if (iteratorState.stop) {\n                            return;\n                        }\n                    }\n                } else {\n                    // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its\n                    // descendants\n                    it = dom.createIterator(node);\n                    while ( (n = it.next()) ) {\n                        if (func(n) === false) {\n                            iteratorState.stop = true;\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n\n        function deleteSubtree(iterator) {\n            var subIterator;\n            while (iterator.next()) {\n                if (iterator.isPartiallySelectedSubtree()) {\n                    subIterator = iterator.getSubtreeIterator();\n                    deleteSubtree(subIterator);\n                    subIterator.detach();\n                } else {\n                    iterator.remove();\n                }\n            }\n        }\n\n        function extractSubtree(iterator) {\n            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {\n\n                if (iterator.isPartiallySelectedSubtree()) {\n                    node = node.cloneNode(false);\n                    subIterator = iterator.getSubtreeIterator();\n                    node.appendChild(extractSubtree(subIterator));\n                    subIterator.detach();\n                } else {\n                    iterator.remove();\n                }\n                if (node.nodeType == 10) { // DocumentType\n                    throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n                }\n                frag.appendChild(node);\n            }\n            return frag;\n        }\n\n        function getNodesInRange(range, nodeTypes, filter) {\n            var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;\n            var filterExists = !!filter;\n            if (filterNodeTypes) {\n                regex = new RegExp(\"^(\" + nodeTypes.join(\"|\") + \")$\");\n            }\n\n            var nodes = [];\n            iterateSubtree(new RangeIterator(range, false), function(node) {\n                if (filterNodeTypes && !regex.test(node.nodeType)) {\n                    return;\n                }\n                if (filterExists && !filter(node)) {\n                    return;\n                }\n                // Don't include a boundary container if it is a character data node and the range does not contain any\n                // of its character data. See issue 190.\n                var sc = range.startContainer;\n                if (node == sc && isCharacterDataNode(sc) && range.startOffset == sc.length) {\n                    return;\n                }\n\n                var ec = range.endContainer;\n                if (node == ec && isCharacterDataNode(ec) && range.endOffset == 0) {\n                    return;\n                }\n\n                nodes.push(node);\n            });\n            return nodes;\n        }\n\n        function inspect(range) {\n            var name = (typeof range.getName == \"undefined\") ? \"Range\" : range.getName();\n            return \"[\" + name + \"(\" + dom.inspectNode(range.startContainer) + \":\" + range.startOffset + \", \" +\n                dom.inspectNode(range.endContainer) + \":\" + range.endOffset + \")]\";\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)\n\n        function RangeIterator(range, clonePartiallySelectedTextNodes) {\n            this.range = range;\n            this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n\n\n            if (!range.collapsed) {\n                this.sc = range.startContainer;\n                this.so = range.startOffset;\n                this.ec = range.endContainer;\n                this.eo = range.endOffset;\n                var root = range.commonAncestorContainer;\n\n                if (this.sc === this.ec && isCharacterDataNode(this.sc)) {\n                    this.isSingleCharacterDataNode = true;\n                    this._first = this._last = this._next = this.sc;\n                } else {\n                    this._first = this._next = (this.sc === root && !isCharacterDataNode(this.sc)) ?\n                        this.sc.childNodes[this.so] : getClosestAncestorIn(this.sc, root, true);\n                    this._last = (this.ec === root && !isCharacterDataNode(this.ec)) ?\n                        this.ec.childNodes[this.eo - 1] : getClosestAncestorIn(this.ec, root, true);\n                }\n            }\n        }\n\n        RangeIterator.prototype = {\n            _current: null,\n            _next: null,\n            _first: null,\n            _last: null,\n            isSingleCharacterDataNode: false,\n\n            reset: function() {\n                this._current = null;\n                this._next = this._first;\n            },\n\n            hasNext: function() {\n                return !!this._next;\n            },\n\n            next: function() {\n                // Move to next node\n                var current = this._current = this._next;\n                if (current) {\n                    this._next = (current !== this._last) ? current.nextSibling : null;\n\n                    // Check for partially selected text nodes\n                    if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n                        if (current === this.ec) {\n                            (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);\n                        }\n                        if (this._current === this.sc) {\n                            (current = current.cloneNode(true)).deleteData(0, this.so);\n                        }\n                    }\n                }\n\n                return current;\n            },\n\n            remove: function() {\n                var current = this._current, start, end;\n\n                if (isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {\n                    start = (current === this.sc) ? this.so : 0;\n                    end = (current === this.ec) ? this.eo : current.length;\n                    if (start != end) {\n                        current.deleteData(start, end - start);\n                    }\n                } else {\n                    if (current.parentNode) {\n                        removeNode(current);\n                    } else {\n                    }\n                }\n            },\n\n            // Checks if the current node is partially selected\n            isPartiallySelectedSubtree: function() {\n                var current = this._current;\n                return isNonTextPartiallySelected(current, this.range);\n            },\n\n            getSubtreeIterator: function() {\n                var subRange;\n                if (this.isSingleCharacterDataNode) {\n                    subRange = this.range.cloneRange();\n                    subRange.collapse(false);\n                } else {\n                    subRange = new Range(getRangeDocument(this.range));\n                    var current = this._current;\n                    var startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);\n\n                    if (isOrIsAncestorOf(current, this.sc)) {\n                        startContainer = this.sc;\n                        startOffset = this.so;\n                    }\n                    if (isOrIsAncestorOf(current, this.ec)) {\n                        endContainer = this.ec;\n                        endOffset = this.eo;\n                    }\n\n                    updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);\n                }\n                return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);\n            },\n\n            detach: function() {\n                this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;\n            }\n        };\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];\n        var rootContainerNodeTypes = [2, 9, 11];\n        var readonlyNodeTypes = [5, 6, 10, 12];\n        var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];\n        var surroundNodeTypes = [1, 3, 4, 5, 7, 8];\n\n        function createAncestorFinder(nodeTypes) {\n            return function(node, selfIsAncestor) {\n                var t, n = selfIsAncestor ? node : node.parentNode;\n                while (n) {\n                    t = n.nodeType;\n                    if (arrayContains(nodeTypes, t)) {\n                        return n;\n                    }\n                    n = n.parentNode;\n                }\n                return null;\n            };\n        }\n\n        var getDocumentOrFragmentContainer = createAncestorFinder( [9, 11] );\n        var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);\n        var getDocTypeNotationEntityAncestor = createAncestorFinder( [6, 10, 12] );\n\n        function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {\n            if (getDocTypeNotationEntityAncestor(node, allowSelf)) {\n                throw new DOMException(\"INVALID_NODE_TYPE_ERR\");\n            }\n        }\n\n        function assertValidNodeType(node, invalidTypes) {\n            if (!arrayContains(invalidTypes, node.nodeType)) {\n                throw new DOMException(\"INVALID_NODE_TYPE_ERR\");\n            }\n        }\n\n        function assertValidOffset(node, offset) {\n            if (offset < 0 || offset > (isCharacterDataNode(node) ? node.length : node.childNodes.length)) {\n                throw new DOMException(\"INDEX_SIZE_ERR\");\n            }\n        }\n\n        function assertSameDocumentOrFragment(node1, node2) {\n            if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {\n                throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n            }\n        }\n\n        function assertNodeNotReadOnly(node) {\n            if (getReadonlyAncestor(node, true)) {\n                throw new DOMException(\"NO_MODIFICATION_ALLOWED_ERR\");\n            }\n        }\n\n        function assertNode(node, codeName) {\n            if (!node) {\n                throw new DOMException(codeName);\n            }\n        }\n\n        function isValidOffset(node, offset) {\n            return offset <= (isCharacterDataNode(node) ? node.length : node.childNodes.length);\n        }\n\n        function isRangeValid(range) {\n            return (!!range.startContainer && !!range.endContainer &&\n            !(crashyTextNodes && (dom.isBrokenNode(range.startContainer) || dom.isBrokenNode(range.endContainer))) &&\n            getRootContainer(range.startContainer) == getRootContainer(range.endContainer) &&\n            isValidOffset(range.startContainer, range.startOffset) &&\n            isValidOffset(range.endContainer, range.endOffset));\n        }\n\n        function assertRangeValid(range) {\n            if (!isRangeValid(range)) {\n                throw new Error(\"Range error: Range is not valid. This usually happens after DOM mutation. Range: (\" + range.inspect() + \")\");\n            }\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Test the browser's innerHTML support to decide how to implement createContextualFragment\n        var styleEl = document.createElement(\"style\");\n        var htmlParsingConforms = false;\n        try {\n            styleEl.innerHTML = \"<b>x</b>\";\n            htmlParsingConforms = (styleEl.firstChild.nodeType == 3); // Opera incorrectly creates an element node\n        } catch (e) {\n            // IE 6 and 7 throw\n        }\n\n        api.features.htmlParsingConforms = htmlParsingConforms;\n\n        var createContextualFragment = htmlParsingConforms ?\n\n            // Implementation as per HTML parsing spec, trusting in the browser's implementation of innerHTML. See\n            // discussion and base code for this implementation at issue 67.\n            // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface\n            // Thanks to Aleks Williams.\n            function(fragmentStr) {\n                // \"Let node the context object's start's node.\"\n                var node = this.startContainer;\n                var doc = getDocument(node);\n\n                // \"If the context object's start's node is null, raise an INVALID_STATE_ERR\n                // exception and abort these steps.\"\n                if (!node) {\n                    throw new DOMException(\"INVALID_STATE_ERR\");\n                }\n\n                // \"Let element be as follows, depending on node's interface:\"\n                // Document, Document Fragment: null\n                var el = null;\n\n                // \"Element: node\"\n                if (node.nodeType == 1) {\n                    el = node;\n\n                    // \"Text, Comment: node's parentElement\"\n                } else if (isCharacterDataNode(node)) {\n                    el = dom.parentElement(node);\n                }\n\n                // \"If either element is null or element's ownerDocument is an HTML document\n                // and element's local name is \"html\" and element's namespace is the HTML\n                // namespace\"\n                if (el === null || (\n                        el.nodeName == \"HTML\" &&\n                        dom.isHtmlNamespace(getDocument(el).documentElement) &&\n                        dom.isHtmlNamespace(el)\n                    )) {\n\n                    // \"let element be a new Element with \"body\" as its local name and the HTML\n                    // namespace as its namespace.\"\"\n                    el = doc.createElement(\"body\");\n                } else {\n                    el = el.cloneNode(false);\n                }\n\n                // \"If the node's document is an HTML document: Invoke the HTML fragment parsing algorithm.\"\n                // \"If the node's document is an XML document: Invoke the XML fragment parsing algorithm.\"\n                // \"In either case, the algorithm must be invoked with fragment as the input\n                // and element as the context element.\"\n                el.innerHTML = fragmentStr;\n\n                // \"If this raises an exception, then abort these steps. Otherwise, let new\n                // children be the nodes returned.\"\n\n                // \"Let fragment be a new DocumentFragment.\"\n                // \"Append all new children to fragment.\"\n                // \"Return fragment.\"\n                return dom.fragmentFromNodeChildren(el);\n            } :\n\n            // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that\n            // previous versions of Rangy used (with the exception of using a body element rather than a div)\n            function(fragmentStr) {\n                var doc = getRangeDocument(this);\n                var el = doc.createElement(\"body\");\n                el.innerHTML = fragmentStr;\n\n                return dom.fragmentFromNodeChildren(el);\n            };\n\n        function splitRangeBoundaries(range, positionsToPreserve) {\n            assertRangeValid(range);\n\n            var sc = range.startContainer, so = range.startOffset, ec = range.endContainer, eo = range.endOffset;\n            var startEndSame = (sc === ec);\n\n            if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n                splitDataNode(ec, eo, positionsToPreserve);\n            }\n\n            if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n                sc = splitDataNode(sc, so, positionsToPreserve);\n                if (startEndSame) {\n                    eo -= so;\n                    ec = sc;\n                } else if (ec == sc.parentNode && eo >= getNodeIndex(sc)) {\n                    eo++;\n                }\n                so = 0;\n            }\n            range.setStartAndEnd(sc, so, ec, eo);\n        }\n\n        function rangeToHtml(range) {\n            assertRangeValid(range);\n            var container = range.commonAncestorContainer.parentNode.cloneNode(false);\n            container.appendChild( range.cloneContents() );\n            return container.innerHTML;\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        var rangeProperties = [\"startContainer\", \"startOffset\", \"endContainer\", \"endOffset\", \"collapsed\",\n            \"commonAncestorContainer\"];\n\n        var s2s = 0, s2e = 1, e2e = 2, e2s = 3;\n        var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;\n\n        util.extend(api.rangePrototype, {\n            compareBoundaryPoints: function(how, range) {\n                assertRangeValid(this);\n                assertSameDocumentOrFragment(this.startContainer, range.startContainer);\n\n                var nodeA, offsetA, nodeB, offsetB;\n                var prefixA = (how == e2s || how == s2s) ? \"start\" : \"end\";\n                var prefixB = (how == s2e || how == s2s) ? \"start\" : \"end\";\n                nodeA = this[prefixA + \"Container\"];\n                offsetA = this[prefixA + \"Offset\"];\n                nodeB = range[prefixB + \"Container\"];\n                offsetB = range[prefixB + \"Offset\"];\n                return comparePoints(nodeA, offsetA, nodeB, offsetB);\n            },\n\n            insertNode: function(node) {\n                assertRangeValid(this);\n                assertValidNodeType(node, insertableNodeTypes);\n                assertNodeNotReadOnly(this.startContainer);\n\n                if (isOrIsAncestorOf(node, this.startContainer)) {\n                    throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n                }\n\n                // No check for whether the container of the start of the Range is of a type that does not allow\n                // children of the type of node: the browser's DOM implementation should do this for us when we attempt\n                // to add the node\n\n                var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);\n                this.setStartBefore(firstNodeInserted);\n            },\n\n            cloneContents: function() {\n                assertRangeValid(this);\n\n                var clone, frag;\n                if (this.collapsed) {\n                    return getRangeDocument(this).createDocumentFragment();\n                } else {\n                    if (this.startContainer === this.endContainer && isCharacterDataNode(this.startContainer)) {\n                        clone = this.startContainer.cloneNode(true);\n                        clone.data = clone.data.slice(this.startOffset, this.endOffset);\n                        frag = getRangeDocument(this).createDocumentFragment();\n                        frag.appendChild(clone);\n                        return frag;\n                    } else {\n                        var iterator = new RangeIterator(this, true);\n                        clone = cloneSubtree(iterator);\n                        iterator.detach();\n                    }\n                    return clone;\n                }\n            },\n\n            canSurroundContents: function() {\n                assertRangeValid(this);\n                assertNodeNotReadOnly(this.startContainer);\n                assertNodeNotReadOnly(this.endContainer);\n\n                // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n                // no non-text nodes.\n                var iterator = new RangeIterator(this, true);\n                var boundariesInvalid = (iterator._first && (isNonTextPartiallySelected(iterator._first, this)) ||\n                (iterator._last && isNonTextPartiallySelected(iterator._last, this)));\n                iterator.detach();\n                return !boundariesInvalid;\n            },\n\n            surroundContents: function(node) {\n                assertValidNodeType(node, surroundNodeTypes);\n\n                if (!this.canSurroundContents()) {\n                    throw new DOMException(\"INVALID_STATE_ERR\");\n                }\n\n                // Extract the contents\n                var content = this.extractContents();\n\n                // Clear the children of the node\n                if (node.hasChildNodes()) {\n                    while (node.lastChild) {\n                        node.removeChild(node.lastChild);\n                    }\n                }\n\n                // Insert the new node and add the extracted contents\n                insertNodeAtPosition(node, this.startContainer, this.startOffset);\n                node.appendChild(content);\n\n                this.selectNode(node);\n            },\n\n            cloneRange: function() {\n                assertRangeValid(this);\n                var range = new Range(getRangeDocument(this));\n                var i = rangeProperties.length, prop;\n                while (i--) {\n                    prop = rangeProperties[i];\n                    range[prop] = this[prop];\n                }\n                return range;\n            },\n\n            toString: function() {\n                assertRangeValid(this);\n                var sc = this.startContainer;\n                if (sc === this.endContainer && isCharacterDataNode(sc)) {\n                    return (sc.nodeType == 3 || sc.nodeType == 4) ? sc.data.slice(this.startOffset, this.endOffset) : \"\";\n                } else {\n                    var textParts = [], iterator = new RangeIterator(this, true);\n                    iterateSubtree(iterator, function(node) {\n                        // Accept only text or CDATA nodes, not comments\n                        if (node.nodeType == 3 || node.nodeType == 4) {\n                            textParts.push(node.data);\n                        }\n                    });\n                    iterator.detach();\n                    return textParts.join(\"\");\n                }\n            },\n\n            // The methods below are all non-standard. The following batch were introduced by Mozilla but have since\n            // been removed from Mozilla.\n\n            compareNode: function(node) {\n                assertRangeValid(this);\n\n                var parent = node.parentNode;\n                var nodeIndex = getNodeIndex(node);\n\n                if (!parent) {\n                    throw new DOMException(\"NOT_FOUND_ERR\");\n                }\n\n                var startComparison = this.comparePoint(parent, nodeIndex),\n                    endComparison = this.comparePoint(parent, nodeIndex + 1);\n\n                if (startComparison < 0) { // Node starts before\n                    return (endComparison > 0) ? n_b_a : n_b;\n                } else {\n                    return (endComparison > 0) ? n_a : n_i;\n                }\n            },\n\n            comparePoint: function(node, offset) {\n                assertRangeValid(this);\n                assertNode(node, \"HIERARCHY_REQUEST_ERR\");\n                assertSameDocumentOrFragment(node, this.startContainer);\n\n                if (comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {\n                    return -1;\n                } else if (comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {\n                    return 1;\n                }\n                return 0;\n            },\n\n            createContextualFragment: createContextualFragment,\n\n            toHtml: function() {\n                return rangeToHtml(this);\n            },\n\n            // touchingIsIntersecting determines whether this method considers a node that borders a range intersects\n            // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)\n            intersectsNode: function(node, touchingIsIntersecting) {\n                assertRangeValid(this);\n                if (getRootContainer(node) != getRangeRoot(this)) {\n                    return false;\n                }\n\n                var parent = node.parentNode, offset = getNodeIndex(node);\n                if (!parent) {\n                    return true;\n                }\n\n                var startComparison = comparePoints(parent, offset, this.endContainer, this.endOffset),\n                    endComparison = comparePoints(parent, offset + 1, this.startContainer, this.startOffset);\n\n                return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n            },\n\n            isPointInRange: function(node, offset) {\n                assertRangeValid(this);\n                assertNode(node, \"HIERARCHY_REQUEST_ERR\");\n                assertSameDocumentOrFragment(node, this.startContainer);\n\n                return (comparePoints(node, offset, this.startContainer, this.startOffset) >= 0) &&\n                    (comparePoints(node, offset, this.endContainer, this.endOffset) <= 0);\n            },\n\n            // The methods below are non-standard and invented by me.\n\n            // Sharing a boundary start-to-end or end-to-start does not count as intersection.\n            intersectsRange: function(range) {\n                return rangesIntersect(this, range, false);\n            },\n\n            // Sharing a boundary start-to-end or end-to-start does count as intersection.\n            intersectsOrTouchesRange: function(range) {\n                return rangesIntersect(this, range, true);\n            },\n\n            intersection: function(range) {\n                if (this.intersectsRange(range)) {\n                    var startComparison = comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),\n                        endComparison = comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);\n\n                    var intersectionRange = this.cloneRange();\n                    if (startComparison == -1) {\n                        intersectionRange.setStart(range.startContainer, range.startOffset);\n                    }\n                    if (endComparison == 1) {\n                        intersectionRange.setEnd(range.endContainer, range.endOffset);\n                    }\n                    return intersectionRange;\n                }\n                return null;\n            },\n\n            union: function(range) {\n                if (this.intersectsOrTouchesRange(range)) {\n                    var unionRange = this.cloneRange();\n                    if (comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {\n                        unionRange.setStart(range.startContainer, range.startOffset);\n                    }\n                    if (comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {\n                        unionRange.setEnd(range.endContainer, range.endOffset);\n                    }\n                    return unionRange;\n                } else {\n                    throw new DOMException(\"Ranges do not intersect\");\n                }\n            },\n\n            containsNode: function(node, allowPartial) {\n                if (allowPartial) {\n                    return this.intersectsNode(node, false);\n                } else {\n                    return this.compareNode(node) == n_i;\n                }\n            },\n\n            containsNodeContents: function(node) {\n                return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, getNodeLength(node)) <= 0;\n            },\n\n            containsRange: function(range) {\n                var intersection = this.intersection(range);\n                return intersection !== null && range.equals(intersection);\n            },\n\n            containsNodeText: function(node) {\n                var nodeRange = this.cloneRange();\n                nodeRange.selectNode(node);\n                var textNodes = nodeRange.getNodes([3]);\n                if (textNodes.length > 0) {\n                    nodeRange.setStart(textNodes[0], 0);\n                    var lastTextNode = textNodes.pop();\n                    nodeRange.setEnd(lastTextNode, lastTextNode.length);\n                    return this.containsRange(nodeRange);\n                } else {\n                    return this.containsNodeContents(node);\n                }\n            },\n\n            getNodes: function(nodeTypes, filter) {\n                assertRangeValid(this);\n                return getNodesInRange(this, nodeTypes, filter);\n            },\n\n            getDocument: function() {\n                return getRangeDocument(this);\n            },\n\n            collapseBefore: function(node) {\n                this.setEndBefore(node);\n                this.collapse(false);\n            },\n\n            collapseAfter: function(node) {\n                this.setStartAfter(node);\n                this.collapse(true);\n            },\n\n            getBookmark: function(containerNode) {\n                var doc = getRangeDocument(this);\n                var preSelectionRange = api.createRange(doc);\n                containerNode = containerNode || dom.getBody(doc);\n                preSelectionRange.selectNodeContents(containerNode);\n                var range = this.intersection(preSelectionRange);\n                var start = 0, end = 0;\n                if (range) {\n                    preSelectionRange.setEnd(range.startContainer, range.startOffset);\n                    start = preSelectionRange.toString().length;\n                    end = start + range.toString().length;\n                }\n\n                return {\n                    start: start,\n                    end: end,\n                    containerNode: containerNode\n                };\n            },\n\n            moveToBookmark: function(bookmark) {\n                var containerNode = bookmark.containerNode;\n                var charIndex = 0;\n                this.setStart(containerNode, 0);\n                this.collapse(true);\n                var nodeStack = [containerNode], node, foundStart = false, stop = false;\n                var nextCharIndex, i, childNodes;\n\n                while (!stop && (node = nodeStack.pop())) {\n                    if (node.nodeType == 3) {\n                        nextCharIndex = charIndex + node.length;\n                        if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {\n                            this.setStart(node, bookmark.start - charIndex);\n                            foundStart = true;\n                        }\n                        if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {\n                            this.setEnd(node, bookmark.end - charIndex);\n                            stop = true;\n                        }\n                        charIndex = nextCharIndex;\n                    } else {\n                        childNodes = node.childNodes;\n                        i = childNodes.length;\n                        while (i--) {\n                            nodeStack.push(childNodes[i]);\n                        }\n                    }\n                }\n            },\n\n            getName: function() {\n                return \"DomRange\";\n            },\n\n            equals: function(range) {\n                return Range.rangesEqual(this, range);\n            },\n\n            isValid: function() {\n                return isRangeValid(this);\n            },\n\n            inspect: function() {\n                return inspect(this);\n            },\n\n            detach: function() {\n                // In DOM4, detach() is now a no-op.\n            }\n        });\n\n        function copyComparisonConstantsToObject(obj) {\n            obj.START_TO_START = s2s;\n            obj.START_TO_END = s2e;\n            obj.END_TO_END = e2e;\n            obj.END_TO_START = e2s;\n\n            obj.NODE_BEFORE = n_b;\n            obj.NODE_AFTER = n_a;\n            obj.NODE_BEFORE_AND_AFTER = n_b_a;\n            obj.NODE_INSIDE = n_i;\n        }\n\n        function copyComparisonConstants(constructor) {\n            copyComparisonConstantsToObject(constructor);\n            copyComparisonConstantsToObject(constructor.prototype);\n        }\n\n        function createRangeContentRemover(remover, boundaryUpdater) {\n            return function() {\n                assertRangeValid(this);\n\n                var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;\n\n                var iterator = new RangeIterator(this, true);\n\n                // Work out where to position the range after content removal\n                var node, boundary;\n                if (sc !== root) {\n                    node = getClosestAncestorIn(sc, root, true);\n                    boundary = getBoundaryAfterNode(node);\n                    sc = boundary.node;\n                    so = boundary.offset;\n                }\n\n                // Check none of the range is read-only\n                iterateSubtree(iterator, assertNodeNotReadOnly);\n\n                iterator.reset();\n\n                // Remove the content\n                var returnValue = remover(iterator);\n                iterator.detach();\n\n                // Move to the new position\n                boundaryUpdater(this, sc, so, sc, so);\n\n                return returnValue;\n            };\n        }\n\n        function createPrototypeRange(constructor, boundaryUpdater) {\n            function createBeforeAfterNodeSetter(isBefore, isStart) {\n                return function(node) {\n                    assertValidNodeType(node, beforeAfterNodeTypes);\n                    assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);\n\n                    var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);\n                    (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);\n                };\n            }\n\n            function setRangeStart(range, node, offset) {\n                var ec = range.endContainer, eo = range.endOffset;\n                if (node !== range.startContainer || offset !== range.startOffset) {\n                    // Check the root containers of the range and the new boundary, and also check whether the new boundary\n                    // is after the current end. In either case, collapse the range to the new position\n                    if (getRootContainer(node) != getRootContainer(ec) || comparePoints(node, offset, ec, eo) == 1) {\n                        ec = node;\n                        eo = offset;\n                    }\n                    boundaryUpdater(range, node, offset, ec, eo);\n                }\n            }\n\n            function setRangeEnd(range, node, offset) {\n                var sc = range.startContainer, so = range.startOffset;\n                if (node !== range.endContainer || offset !== range.endOffset) {\n                    // Check the root containers of the range and the new boundary, and also check whether the new boundary\n                    // is after the current end. In either case, collapse the range to the new position\n                    if (getRootContainer(node) != getRootContainer(sc) || comparePoints(node, offset, sc, so) == -1) {\n                        sc = node;\n                        so = offset;\n                    }\n                    boundaryUpdater(range, sc, so, node, offset);\n                }\n            }\n\n            // Set up inheritance\n            var F = function() {};\n            F.prototype = api.rangePrototype;\n            constructor.prototype = new F();\n\n            util.extend(constructor.prototype, {\n                setStart: function(node, offset) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n                    assertValidOffset(node, offset);\n\n                    setRangeStart(this, node, offset);\n                },\n\n                setEnd: function(node, offset) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n                    assertValidOffset(node, offset);\n\n                    setRangeEnd(this, node, offset);\n                },\n\n                /**\n                 * Convenience method to set a range's start and end boundaries. Overloaded as follows:\n                 * - Two parameters (node, offset) creates a collapsed range at that position\n                 * - Three parameters (node, startOffset, endOffset) creates a range contained with node starting at\n                 *   startOffset and ending at endOffset\n                 * - Four parameters (startNode, startOffset, endNode, endOffset) creates a range starting at startOffset in\n                 *   startNode and ending at endOffset in endNode\n                 */\n                setStartAndEnd: function() {\n                    var args = arguments;\n                    var sc = args[0], so = args[1], ec = sc, eo = so;\n\n                    switch (args.length) {\n                        case 3:\n                            eo = args[2];\n                            break;\n                        case 4:\n                            ec = args[2];\n                            eo = args[3];\n                            break;\n                    }\n\n                    boundaryUpdater(this, sc, so, ec, eo);\n                },\n\n                setBoundary: function(node, offset, isStart) {\n                    this[\"set\" + (isStart ? \"Start\" : \"End\")](node, offset);\n                },\n\n                setStartBefore: createBeforeAfterNodeSetter(true, true),\n                setStartAfter: createBeforeAfterNodeSetter(false, true),\n                setEndBefore: createBeforeAfterNodeSetter(true, false),\n                setEndAfter: createBeforeAfterNodeSetter(false, false),\n\n                collapse: function(isStart) {\n                    assertRangeValid(this);\n                    if (isStart) {\n                        boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);\n                    } else {\n                        boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);\n                    }\n                },\n\n                selectNodeContents: function(node) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n\n                    boundaryUpdater(this, node, 0, node, getNodeLength(node));\n                },\n\n                selectNode: function(node) {\n                    assertNoDocTypeNotationEntityAncestor(node, false);\n                    assertValidNodeType(node, beforeAfterNodeTypes);\n\n                    var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);\n                    boundaryUpdater(this, start.node, start.offset, end.node, end.offset);\n                },\n\n                extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),\n\n                deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),\n\n                canSurroundContents: function() {\n                    assertRangeValid(this);\n                    assertNodeNotReadOnly(this.startContainer);\n                    assertNodeNotReadOnly(this.endContainer);\n\n                    // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n                    // no non-text nodes.\n                    var iterator = new RangeIterator(this, true);\n                    var boundariesInvalid = (iterator._first && isNonTextPartiallySelected(iterator._first, this) ||\n                    (iterator._last && isNonTextPartiallySelected(iterator._last, this)));\n                    iterator.detach();\n                    return !boundariesInvalid;\n                },\n\n                splitBoundaries: function() {\n                    splitRangeBoundaries(this);\n                },\n\n                splitBoundariesPreservingPositions: function(positionsToPreserve) {\n                    splitRangeBoundaries(this, positionsToPreserve);\n                },\n\n                normalizeBoundaries: function() {\n                    assertRangeValid(this);\n\n                    var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;\n\n                    var mergeForward = function(node) {\n                        var sibling = node.nextSibling;\n                        if (sibling && sibling.nodeType == node.nodeType) {\n                            ec = node;\n                            eo = node.length;\n                            node.appendData(sibling.data);\n                            removeNode(sibling);\n                        }\n                    };\n\n                    var mergeBackward = function(node) {\n                        var sibling = node.previousSibling;\n                        if (sibling && sibling.nodeType == node.nodeType) {\n                            sc = node;\n                            var nodeLength = node.length;\n                            so = sibling.length;\n                            node.insertData(0, sibling.data);\n                            removeNode(sibling);\n                            if (sc == ec) {\n                                eo += so;\n                                ec = sc;\n                            } else if (ec == node.parentNode) {\n                                var nodeIndex = getNodeIndex(node);\n                                if (eo == nodeIndex) {\n                                    ec = node;\n                                    eo = nodeLength;\n                                } else if (eo > nodeIndex) {\n                                    eo--;\n                                }\n                            }\n                        }\n                    };\n\n                    var normalizeStart = true;\n                    var sibling;\n\n                    if (isCharacterDataNode(ec)) {\n                        if (eo == ec.length) {\n                            mergeForward(ec);\n                        } else if (eo == 0) {\n                            sibling = ec.previousSibling;\n                            if (sibling && sibling.nodeType == ec.nodeType) {\n                                eo = sibling.length;\n                                if (sc == ec) {\n                                    normalizeStart = false;\n                                }\n                                sibling.appendData(ec.data);\n                                removeNode(ec);\n                                ec = sibling;\n                            }\n                        }\n                    } else {\n                        if (eo > 0) {\n                            var endNode = ec.childNodes[eo - 1];\n                            if (endNode && isCharacterDataNode(endNode)) {\n                                mergeForward(endNode);\n                            }\n                        }\n                        normalizeStart = !this.collapsed;\n                    }\n\n                    if (normalizeStart) {\n                        if (isCharacterDataNode(sc)) {\n                            if (so == 0) {\n                                mergeBackward(sc);\n                            } else if (so == sc.length) {\n                                sibling = sc.nextSibling;\n                                if (sibling && sibling.nodeType == sc.nodeType) {\n                                    if (ec == sibling) {\n                                        ec = sc;\n                                        eo += sc.length;\n                                    }\n                                    sc.appendData(sibling.data);\n                                    removeNode(sibling);\n                                }\n                            }\n                        } else {\n                            if (so < sc.childNodes.length) {\n                                var startNode = sc.childNodes[so];\n                                if (startNode && isCharacterDataNode(startNode)) {\n                                    mergeBackward(startNode);\n                                }\n                            }\n                        }\n                    } else {\n                        sc = ec;\n                        so = eo;\n                    }\n\n                    boundaryUpdater(this, sc, so, ec, eo);\n                },\n\n                collapseToPoint: function(node, offset) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n                    assertValidOffset(node, offset);\n                    this.setStartAndEnd(node, offset);\n                }\n            });\n\n            copyComparisonConstants(constructor);\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Updates commonAncestorContainer and collapsed after boundary change\n        function updateCollapsedAndCommonAncestor(range) {\n            range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);\n            range.commonAncestorContainer = range.collapsed ?\n                range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);\n        }\n\n        function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {\n            range.startContainer = startContainer;\n            range.startOffset = startOffset;\n            range.endContainer = endContainer;\n            range.endOffset = endOffset;\n            range.document = dom.getDocument(startContainer);\n\n            updateCollapsedAndCommonAncestor(range);\n        }\n\n        function Range(doc) {\n            this.startContainer = doc;\n            this.startOffset = 0;\n            this.endContainer = doc;\n            this.endOffset = 0;\n            this.document = doc;\n            updateCollapsedAndCommonAncestor(this);\n        }\n\n        createPrototypeRange(Range, updateBoundaries);\n\n        util.extend(Range, {\n            rangeProperties: rangeProperties,\n            RangeIterator: RangeIterator,\n            copyComparisonConstants: copyComparisonConstants,\n            createPrototypeRange: createPrototypeRange,\n            inspect: inspect,\n            toHtml: rangeToHtml,\n            getRangeDocument: getRangeDocument,\n            rangesEqual: function(r1, r2) {\n                return r1.startContainer === r2.startContainer &&\n                    r1.startOffset === r2.startOffset &&\n                    r1.endContainer === r2.endContainer &&\n                    r1.endOffset === r2.endOffset;\n            }\n        });\n\n        api.DomRange = Range;\n    });\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Wrappers for the browser's native DOM Range and/or TextRange implementation\n    api.createCoreModule(\"WrappedRange\", [\"DomRange\"], function(api, module) {\n        var WrappedRange, WrappedTextRange;\n        var dom = api.dom;\n        var util = api.util;\n        var DomPosition = dom.DomPosition;\n        var DomRange = api.DomRange;\n        var getBody = dom.getBody;\n        var getContentDocument = dom.getContentDocument;\n        var isCharacterDataNode = dom.isCharacterDataNode;\n\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        if (api.features.implementsDomRange) {\n            // This is a wrapper around the browser's native DOM Range. It has two aims:\n            // - Provide workarounds for specific browser bugs\n            // - provide convenient extensions, which are inherited from Rangy's DomRange\n\n            (function() {\n                var rangeProto;\n                var rangeProperties = DomRange.rangeProperties;\n\n                function updateRangeProperties(range) {\n                    var i = rangeProperties.length, prop;\n                    while (i--) {\n                        prop = rangeProperties[i];\n                        range[prop] = range.nativeRange[prop];\n                    }\n                    // Fix for broken collapsed property in IE 9.\n                    range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);\n                }\n\n                function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {\n                    var startMoved = (range.startContainer !== startContainer || range.startOffset != startOffset);\n                    var endMoved = (range.endContainer !== endContainer || range.endOffset != endOffset);\n                    var nativeRangeDifferent = !range.equals(range.nativeRange);\n\n                    // Always set both boundaries for the benefit of IE9 (see issue 35)\n                    if (startMoved || endMoved || nativeRangeDifferent) {\n                        range.setEnd(endContainer, endOffset);\n                        range.setStart(startContainer, startOffset);\n                    }\n                }\n\n                var createBeforeAfterNodeSetter;\n\n                WrappedRange = function(range) {\n                    if (!range) {\n                        throw module.createError(\"WrappedRange: Range must be specified\");\n                    }\n                    this.nativeRange = range;\n                    updateRangeProperties(this);\n                };\n\n                DomRange.createPrototypeRange(WrappedRange, updateNativeRange);\n\n                rangeProto = WrappedRange.prototype;\n\n                rangeProto.selectNode = function(node) {\n                    this.nativeRange.selectNode(node);\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.cloneContents = function() {\n                    return this.nativeRange.cloneContents();\n                };\n\n                // Due to a long-standing Firefox bug that I have not been able to find a reliable way to detect,\n                // insertNode() is never delegated to the native range.\n\n                rangeProto.surroundContents = function(node) {\n                    this.nativeRange.surroundContents(node);\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.collapse = function(isStart) {\n                    this.nativeRange.collapse(isStart);\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.cloneRange = function() {\n                    return new WrappedRange(this.nativeRange.cloneRange());\n                };\n\n                rangeProto.refresh = function() {\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.toString = function() {\n                    return this.nativeRange.toString();\n                };\n\n                // Create test range and node for feature detection\n\n                var testTextNode = document.createTextNode(\"test\");\n                getBody(document).appendChild(testTextNode);\n                var range = document.createRange();\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and\n                // correct for it\n\n                range.setStart(testTextNode, 0);\n                range.setEnd(testTextNode, 0);\n\n                try {\n                    range.setStart(testTextNode, 1);\n\n                    rangeProto.setStart = function(node, offset) {\n                        this.nativeRange.setStart(node, offset);\n                        updateRangeProperties(this);\n                    };\n\n                    rangeProto.setEnd = function(node, offset) {\n                        this.nativeRange.setEnd(node, offset);\n                        updateRangeProperties(this);\n                    };\n\n                    createBeforeAfterNodeSetter = function(name) {\n                        return function(node) {\n                            this.nativeRange[name](node);\n                            updateRangeProperties(this);\n                        };\n                    };\n\n                } catch(ex) {\n\n                    rangeProto.setStart = function(node, offset) {\n                        try {\n                            this.nativeRange.setStart(node, offset);\n                        } catch (ex) {\n                            this.nativeRange.setEnd(node, offset);\n                            this.nativeRange.setStart(node, offset);\n                        }\n                        updateRangeProperties(this);\n                    };\n\n                    rangeProto.setEnd = function(node, offset) {\n                        try {\n                            this.nativeRange.setEnd(node, offset);\n                        } catch (ex) {\n                            this.nativeRange.setStart(node, offset);\n                            this.nativeRange.setEnd(node, offset);\n                        }\n                        updateRangeProperties(this);\n                    };\n\n                    createBeforeAfterNodeSetter = function(name, oppositeName) {\n                        return function(node) {\n                            try {\n                                this.nativeRange[name](node);\n                            } catch (ex) {\n                                this.nativeRange[oppositeName](node);\n                                this.nativeRange[name](node);\n                            }\n                            updateRangeProperties(this);\n                        };\n                    };\n                }\n\n                rangeProto.setStartBefore = createBeforeAfterNodeSetter(\"setStartBefore\", \"setEndBefore\");\n                rangeProto.setStartAfter = createBeforeAfterNodeSetter(\"setStartAfter\", \"setEndAfter\");\n                rangeProto.setEndBefore = createBeforeAfterNodeSetter(\"setEndBefore\", \"setStartBefore\");\n                rangeProto.setEndAfter = createBeforeAfterNodeSetter(\"setEndAfter\", \"setStartAfter\");\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Always use DOM4-compliant selectNodeContents implementation: it's simpler and less code than testing\n                // whether the native implementation can be trusted\n                rangeProto.selectNodeContents = function(node) {\n                    this.setStartAndEnd(node, 0, dom.getNodeLength(node));\n                };\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for and correct WebKit bug that has the behaviour of compareBoundaryPoints round the wrong way for\n                // constants START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738\n\n                range.selectNodeContents(testTextNode);\n                range.setEnd(testTextNode, 3);\n\n                var range2 = document.createRange();\n                range2.selectNodeContents(testTextNode);\n                range2.setEnd(testTextNode, 4);\n                range2.setStart(testTextNode, 2);\n\n                if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 &&\n                    range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {\n                    // This is the wrong way round, so correct for it\n\n                    rangeProto.compareBoundaryPoints = function(type, range) {\n                        range = range.nativeRange || range;\n                        if (type == range.START_TO_END) {\n                            type = range.END_TO_START;\n                        } else if (type == range.END_TO_START) {\n                            type = range.START_TO_END;\n                        }\n                        return this.nativeRange.compareBoundaryPoints(type, range);\n                    };\n                } else {\n                    rangeProto.compareBoundaryPoints = function(type, range) {\n                        return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);\n                    };\n                }\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for IE deleteContents() and extractContents() bug and correct it. See issue 107.\n\n                var el = document.createElement(\"div\");\n                el.innerHTML = \"123\";\n                var textNode = el.firstChild;\n                var body = getBody(document);\n                body.appendChild(el);\n\n                range.setStart(textNode, 1);\n                range.setEnd(textNode, 2);\n                range.deleteContents();\n\n                if (textNode.data == \"13\") {\n                    // Behaviour is correct per DOM4 Range so wrap the browser's implementation of deleteContents() and\n                    // extractContents()\n                    rangeProto.deleteContents = function() {\n                        this.nativeRange.deleteContents();\n                        updateRangeProperties(this);\n                    };\n\n                    rangeProto.extractContents = function() {\n                        var frag = this.nativeRange.extractContents();\n                        updateRangeProperties(this);\n                        return frag;\n                    };\n                } else {\n                }\n\n                body.removeChild(el);\n                body = null;\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for existence of createContextualFragment and delegate to it if it exists\n                if (util.isHostMethod(range, \"createContextualFragment\")) {\n                    rangeProto.createContextualFragment = function(fragmentStr) {\n                        return this.nativeRange.createContextualFragment(fragmentStr);\n                    };\n                }\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Clean up\n                getBody(document).removeChild(testTextNode);\n\n                rangeProto.getName = function() {\n                    return \"WrappedRange\";\n                };\n\n                api.WrappedRange = WrappedRange;\n\n                api.createNativeRange = function(doc) {\n                    doc = getContentDocument(doc, module, \"createNativeRange\");\n                    return doc.createRange();\n                };\n            })();\n        }\n\n        if (api.features.implementsTextRange) {\n            /*\n             This is a workaround for a bug where IE returns the wrong container element from the TextRange's parentElement()\n             method. For example, in the following (where pipes denote the selection boundaries):\n\n             <ul id=\"ul\"><li id=\"a\">| a </li><li id=\"b\"> b |</li></ul>\n\n             var range = document.selection.createRange();\n             alert(range.parentElement().id); // Should alert \"ul\" but alerts \"b\"\n\n             This method returns the common ancestor node of the following:\n             - the parentElement() of the textRange\n             - the parentElement() of the textRange after calling collapse(true)\n             - the parentElement() of the textRange after calling collapse(false)\n             */\n            var getTextRangeContainerElement = function(textRange) {\n                var parentEl = textRange.parentElement();\n                var range = textRange.duplicate();\n                range.collapse(true);\n                var startEl = range.parentElement();\n                range = textRange.duplicate();\n                range.collapse(false);\n                var endEl = range.parentElement();\n                var startEndContainer = (startEl == endEl) ? startEl : dom.getCommonAncestor(startEl, endEl);\n\n                return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);\n            };\n\n            var textRangeIsCollapsed = function(textRange) {\n                return textRange.compareEndPoints(\"StartToEnd\", textRange) == 0;\n            };\n\n            // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started\n            // out as an improved version of code found in Tim Cameron Ryan's IERange (http://code.google.com/p/ierange/)\n            // but has grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange\n            // bugs, handling for inputs and images, plus optimizations.\n            var getTextRangeBoundaryPosition = function(textRange, wholeRangeContainerElement, isStart, isCollapsed, startInfo) {\n                var workingRange = textRange.duplicate();\n                workingRange.collapse(isStart);\n                var containerElement = workingRange.parentElement();\n\n                // Sometimes collapsing a TextRange that's at the start of a text node can move it into the previous node, so\n                // check for that\n                if (!dom.isOrIsAncestorOf(wholeRangeContainerElement, containerElement)) {\n                    containerElement = wholeRangeContainerElement;\n                }\n\n\n                // Deal with nodes that cannot \"contain rich HTML markup\". In practice, this means form inputs, images and\n                // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx\n                if (!containerElement.canHaveHTML) {\n                    var pos = new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));\n                    return {\n                        boundaryPosition: pos,\n                        nodeInfo: {\n                            nodeIndex: pos.offset,\n                            containerElement: pos.node\n                        }\n                    };\n                }\n\n                var workingNode = dom.getDocument(containerElement).createElement(\"span\");\n\n                // Workaround for HTML5 Shiv's insane violation of document.createElement(). See Rangy issue 104 and HTML5\n                // Shiv issue 64: https://github.com/aFarkas/html5shiv/issues/64\n                if (workingNode.parentNode) {\n                    dom.removeNode(workingNode);\n                }\n\n                var comparison, workingComparisonType = isStart ? \"StartToStart\" : \"StartToEnd\";\n                var previousNode, nextNode, boundaryPosition, boundaryNode;\n                var start = (startInfo && startInfo.containerElement == containerElement) ? startInfo.nodeIndex : 0;\n                var childNodeCount = containerElement.childNodes.length;\n                var end = childNodeCount;\n\n                // Check end first. Code within the loop assumes that the endth child node of the container is definitely\n                // after the range boundary.\n                var nodeIndex = end;\n\n                while (true) {\n                    if (nodeIndex == childNodeCount) {\n                        containerElement.appendChild(workingNode);\n                    } else {\n                        containerElement.insertBefore(workingNode, containerElement.childNodes[nodeIndex]);\n                    }\n                    workingRange.moveToElementText(workingNode);\n                    comparison = workingRange.compareEndPoints(workingComparisonType, textRange);\n                    if (comparison == 0 || start == end) {\n                        break;\n                    } else if (comparison == -1) {\n                        if (end == start + 1) {\n                            // We know the endth child node is after the range boundary, so we must be done.\n                            break;\n                        } else {\n                            start = nodeIndex;\n                        }\n                    } else {\n                        end = (end == start + 1) ? start : nodeIndex;\n                    }\n                    nodeIndex = Math.floor((start + end) / 2);\n                    containerElement.removeChild(workingNode);\n                }\n\n\n                // We've now reached or gone past the boundary of the text range we're interested in\n                // so have identified the node we want\n                boundaryNode = workingNode.nextSibling;\n\n                if (comparison == -1 && boundaryNode && isCharacterDataNode(boundaryNode)) {\n                    // This is a character data node (text, comment, cdata). The working range is collapsed at the start of\n                    // the node containing the text range's boundary, so we move the end of the working range to the\n                    // boundary point and measure the length of its text to get the boundary's offset within the node.\n                    workingRange.setEndPoint(isStart ? \"EndToStart\" : \"EndToEnd\", textRange);\n\n                    var offset;\n\n                    if (/[\\r\\n]/.test(boundaryNode.data)) {\n                        /*\n                         For the particular case of a boundary within a text node containing rendered line breaks (within a\n                         <pre> element, for example), we need a slightly complicated approach to get the boundary's offset in\n                         IE. The facts:\n\n                         - Each line break is represented as \\r in the text node's data/nodeValue properties\n                         - Each line break is represented as \\r\\n in the TextRange's 'text' property\n                         - The 'text' property of the TextRange does not contain trailing line breaks\n\n                         To get round the problem presented by the final fact above, we can use the fact that TextRange's\n                         moveStart() and moveEnd() methods return the actual number of characters moved, which is not\n                         necessarily the same as the number of characters it was instructed to move. The simplest approach is\n                         to use this to store the characters moved when moving both the start and end of the range to the\n                         start of the document body and subtracting the start offset from the end offset (the\n                         \"move-negative-gazillion\" method). However, this is extremely slow when the document is large and\n                         the range is near the end of it. Clearly doing the mirror image (i.e. moving the range boundaries to\n                         the end of the document) has the same problem.\n\n                         Another approach that works is to use moveStart() to move the start boundary of the range up to the\n                         end boundary one character at a time and incrementing a counter with the value returned by the\n                         moveStart() call. However, the check for whether the start boundary has reached the end boundary is\n                         expensive, so this method is slow (although unlike \"move-negative-gazillion\" is largely unaffected\n                         by the location of the range within the document).\n\n                         The approach used below is a hybrid of the two methods above. It uses the fact that a string\n                         containing the TextRange's 'text' property with each \\r\\n converted to a single \\r character cannot\n                         be longer than the text of the TextRange, so the start of the range is moved that length initially\n                         and then a character at a time to make up for any trailing line breaks not contained in the 'text'\n                         property. This has good performance in most situations compared to the previous two methods.\n                         */\n                        var tempRange = workingRange.duplicate();\n                        var rangeLength = tempRange.text.replace(/\\r\\n/g, \"\\r\").length;\n\n                        offset = tempRange.moveStart(\"character\", rangeLength);\n                        while ( (comparison = tempRange.compareEndPoints(\"StartToEnd\", tempRange)) == -1) {\n                            offset++;\n                            tempRange.moveStart(\"character\", 1);\n                        }\n                    } else {\n                        offset = workingRange.text.length;\n                    }\n                    boundaryPosition = new DomPosition(boundaryNode, offset);\n                } else {\n\n                    // If the boundary immediately follows a character data node and this is the end boundary, we should favour\n                    // a position within that, and likewise for a start boundary preceding a character data node\n                    previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;\n                    nextNode = (isCollapsed || isStart) && workingNode.nextSibling;\n                    if (nextNode && isCharacterDataNode(nextNode)) {\n                        boundaryPosition = new DomPosition(nextNode, 0);\n                    } else if (previousNode && isCharacterDataNode(previousNode)) {\n                        boundaryPosition = new DomPosition(previousNode, previousNode.data.length);\n                    } else {\n                        boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));\n                    }\n                }\n\n                // Clean up\n                dom.removeNode(workingNode);\n\n                return {\n                    boundaryPosition: boundaryPosition,\n                    nodeInfo: {\n                        nodeIndex: nodeIndex,\n                        containerElement: containerElement\n                    }\n                };\n            };\n\n            // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that\n            // node. This function started out as an optimized version of code found in Tim Cameron Ryan's IERange\n            // (http://code.google.com/p/ierange/)\n            var createBoundaryTextRange = function(boundaryPosition, isStart) {\n                var boundaryNode, boundaryParent, boundaryOffset = boundaryPosition.offset;\n                var doc = dom.getDocument(boundaryPosition.node);\n                var workingNode, childNodes, workingRange = getBody(doc).createTextRange();\n                var nodeIsDataNode = isCharacterDataNode(boundaryPosition.node);\n\n                if (nodeIsDataNode) {\n                    boundaryNode = boundaryPosition.node;\n                    boundaryParent = boundaryNode.parentNode;\n                } else {\n                    childNodes = boundaryPosition.node.childNodes;\n                    boundaryNode = (boundaryOffset < childNodes.length) ? childNodes[boundaryOffset] : null;\n                    boundaryParent = boundaryPosition.node;\n                }\n\n                // Position the range immediately before the node containing the boundary\n                workingNode = doc.createElement(\"span\");\n\n                // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within\n                // the element rather than immediately before or after it\n                workingNode.innerHTML = \"&#feff;\";\n\n                // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report\n                // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12\n                if (boundaryNode) {\n                    boundaryParent.insertBefore(workingNode, boundaryNode);\n                } else {\n                    boundaryParent.appendChild(workingNode);\n                }\n\n                workingRange.moveToElementText(workingNode);\n                workingRange.collapse(!isStart);\n\n                // Clean up\n                boundaryParent.removeChild(workingNode);\n\n                // Move the working range to the text offset, if required\n                if (nodeIsDataNode) {\n                    workingRange[isStart ? \"moveStart\" : \"moveEnd\"](\"character\", boundaryOffset);\n                }\n\n                return workingRange;\n            };\n\n            /*------------------------------------------------------------------------------------------------------------*/\n\n            // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy's DomRange as a\n            // prototype\n\n            WrappedTextRange = function(textRange) {\n                this.textRange = textRange;\n                this.refresh();\n            };\n\n            WrappedTextRange.prototype = new DomRange(document);\n\n            WrappedTextRange.prototype.refresh = function() {\n                var start, end, startBoundary;\n\n                // TextRange's parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.\n                var rangeContainerElement = getTextRangeContainerElement(this.textRange);\n\n                if (textRangeIsCollapsed(this.textRange)) {\n                    end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true,\n                        true).boundaryPosition;\n                } else {\n                    startBoundary = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);\n                    start = startBoundary.boundaryPosition;\n\n                    // An optimization used here is that if the start and end boundaries have the same parent element, the\n                    // search scope for the end boundary can be limited to exclude the portion of the element that precedes\n                    // the start boundary\n                    end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false,\n                        startBoundary.nodeInfo).boundaryPosition;\n                }\n\n                this.setStart(start.node, start.offset);\n                this.setEnd(end.node, end.offset);\n            };\n\n            WrappedTextRange.prototype.getName = function() {\n                return \"WrappedTextRange\";\n            };\n\n            DomRange.copyComparisonConstants(WrappedTextRange);\n\n            var rangeToTextRange = function(range) {\n                if (range.collapsed) {\n                    return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n                } else {\n                    var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n                    var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);\n                    var textRange = getBody( DomRange.getRangeDocument(range) ).createTextRange();\n                    textRange.setEndPoint(\"StartToStart\", startRange);\n                    textRange.setEndPoint(\"EndToEnd\", endRange);\n                    return textRange;\n                }\n            };\n\n            WrappedTextRange.rangeToTextRange = rangeToTextRange;\n\n            WrappedTextRange.prototype.toTextRange = function() {\n                return rangeToTextRange(this);\n            };\n\n            api.WrappedTextRange = WrappedTextRange;\n\n            // IE 9 and above have both implementations and Rangy makes both available. The next few lines sets which\n            // implementation to use by default.\n            if (!api.features.implementsDomRange || api.config.preferTextRange) {\n                // Add WrappedTextRange as the Range property of the global object to allow expression like Range.END_TO_END to work\n                var globalObj = (function(f) { return f(\"return this;\")(); })(Function);\n                if (typeof globalObj.Range == \"undefined\") {\n                    globalObj.Range = WrappedTextRange;\n                }\n\n                api.createNativeRange = function(doc) {\n                    doc = getContentDocument(doc, module, \"createNativeRange\");\n                    return getBody(doc).createTextRange();\n                };\n\n                api.WrappedRange = WrappedTextRange;\n            }\n        }\n\n        api.createRange = function(doc) {\n            doc = getContentDocument(doc, module, \"createRange\");\n            return new api.WrappedRange(api.createNativeRange(doc));\n        };\n\n        api.createRangyRange = function(doc) {\n            doc = getContentDocument(doc, module, \"createRangyRange\");\n            return new DomRange(doc);\n        };\n\n        util.createAliasForDeprecatedMethod(api, \"createIframeRange\", \"createRange\");\n        util.createAliasForDeprecatedMethod(api, \"createIframeRangyRange\", \"createRangyRange\");\n\n        api.addShimListener(function(win) {\n            var doc = win.document;\n            if (typeof doc.createRange == \"undefined\") {\n                doc.createRange = function() {\n                    return api.createRange(doc);\n                };\n            }\n            doc = win = null;\n        });\n    });\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // This module creates a selection object wrapper that conforms as closely as possible to the Selection specification\n    // in the HTML Editing spec (http://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections)\n    api.createCoreModule(\"WrappedSelection\", [\"DomRange\", \"WrappedRange\"], function(api, module) {\n        api.config.checkSelectionRanges = true;\n\n        var BOOLEAN = \"boolean\";\n        var NUMBER = \"number\";\n        var dom = api.dom;\n        var util = api.util;\n        var isHostMethod = util.isHostMethod;\n        var DomRange = api.DomRange;\n        var WrappedRange = api.WrappedRange;\n        var DOMException = api.DOMException;\n        var DomPosition = dom.DomPosition;\n        var getNativeSelection;\n        var selectionIsCollapsed;\n        var features = api.features;\n        var CONTROL = \"Control\";\n        var getDocument = dom.getDocument;\n        var getBody = dom.getBody;\n        var rangesEqual = DomRange.rangesEqual;\n\n\n        // Utility function to support direction parameters in the API that may be a string (\"backward\", \"backwards\",\n        // \"forward\" or \"forwards\") or a Boolean (true for backwards).\n        function isDirectionBackward(dir) {\n            return (typeof dir == \"string\") ? /^backward(s)?$/i.test(dir) : !!dir;\n        }\n\n        function getWindow(win, methodName) {\n            if (!win) {\n                return window;\n            } else if (dom.isWindow(win)) {\n                return win;\n            } else if (win instanceof WrappedSelection) {\n                return win.win;\n            } else {\n                var doc = dom.getContentDocument(win, module, methodName);\n                return dom.getWindow(doc);\n            }\n        }\n\n        function getWinSelection(winParam) {\n            return getWindow(winParam, \"getWinSelection\").getSelection();\n        }\n\n        function getDocSelection(winParam) {\n            return getWindow(winParam, \"getDocSelection\").document.selection;\n        }\n\n        function winSelectionIsBackward(sel) {\n            var backward = false;\n            if (sel.anchorNode) {\n                backward = (dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1);\n            }\n            return backward;\n        }\n\n        // Test for the Range/TextRange and Selection features required\n        // Test for ability to retrieve selection\n        var implementsWinGetSelection = isHostMethod(window, \"getSelection\"),\n            implementsDocSelection = util.isHostObject(document, \"selection\");\n\n        features.implementsWinGetSelection = implementsWinGetSelection;\n        features.implementsDocSelection = implementsDocSelection;\n\n        var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);\n\n        if (useDocumentSelection) {\n            getNativeSelection = getDocSelection;\n            api.isSelectionValid = function(winParam) {\n                var doc = getWindow(winParam, \"isSelectionValid\").document, nativeSel = doc.selection;\n\n                // Check whether the selection TextRange is actually contained within the correct document\n                return (nativeSel.type != \"None\" || getDocument(nativeSel.createRange().parentElement()) == doc);\n            };\n        } else if (implementsWinGetSelection) {\n            getNativeSelection = getWinSelection;\n            api.isSelectionValid = function() {\n                return true;\n            };\n        } else {\n            module.fail(\"Neither document.selection or window.getSelection() detected.\");\n            return false;\n        }\n\n        api.getNativeSelection = getNativeSelection;\n\n        var testSelection = getNativeSelection();\n\n        // In Firefox, the selection is null in an iframe with display: none. See issue #138.\n        if (!testSelection) {\n            module.fail(\"Native selection was null (possibly issue 138?)\");\n            return false;\n        }\n\n        var testRange = api.createNativeRange(document);\n        var body = getBody(document);\n\n        // Obtaining a range from a selection\n        var selectionHasAnchorAndFocus = util.areHostProperties(testSelection,\n            [\"anchorNode\", \"focusNode\", \"anchorOffset\", \"focusOffset\"]);\n\n        features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;\n\n        // Test for existence of native selection extend() method\n        var selectionHasExtend = isHostMethod(testSelection, \"extend\");\n        features.selectionHasExtend = selectionHasExtend;\n\n        // Test if rangeCount exists\n        var selectionHasRangeCount = (typeof testSelection.rangeCount == NUMBER);\n        features.selectionHasRangeCount = selectionHasRangeCount;\n\n        var selectionSupportsMultipleRanges = false;\n        var collapsedNonEditableSelectionsSupported = true;\n\n        var addRangeBackwardToNative = selectionHasExtend ?\n            function(nativeSelection, range) {\n                var doc = DomRange.getRangeDocument(range);\n                var endRange = api.createRange(doc);\n                endRange.collapseToPoint(range.endContainer, range.endOffset);\n                nativeSelection.addRange(getNativeRange(endRange));\n                nativeSelection.extend(range.startContainer, range.startOffset);\n            } : null;\n\n        if (util.areHostMethods(testSelection, [\"addRange\", \"getRangeAt\", \"removeAllRanges\"]) &&\n            typeof testSelection.rangeCount == NUMBER && features.implementsDomRange) {\n\n            (function() {\n                // Previously an iframe was used but this caused problems in some circumstances in IE, so tests are\n                // performed on the current document's selection. See issue 109.\n\n                // Note also that if a selection previously existed, it is wiped and later restored by these tests. This\n                // will result in the selection direction begin reversed if the original selection was backwards and the\n                // browser does not support setting backwards selections (Internet Explorer, I'm looking at you).\n                var sel = window.getSelection();\n                if (sel) {\n                    // Store the current selection\n                    var originalSelectionRangeCount = sel.rangeCount;\n                    var selectionHasMultipleRanges = (originalSelectionRangeCount > 1);\n                    var originalSelectionRanges = [];\n                    var originalSelectionBackward = winSelectionIsBackward(sel);\n                    for (var i = 0; i < originalSelectionRangeCount; ++i) {\n                        originalSelectionRanges[i] = sel.getRangeAt(i);\n                    }\n\n                    // Create some test elements\n                    var testEl = dom.createTestElement(document, \"\", false);\n                    var textNode = testEl.appendChild( document.createTextNode(\"\\u00a0\\u00a0\\u00a0\") );\n\n                    // Test whether the native selection will allow a collapsed selection within a non-editable element\n                    var r1 = document.createRange();\n\n                    r1.setStart(textNode, 1);\n                    r1.collapse(true);\n                    sel.removeAllRanges();\n                    sel.addRange(r1);\n                    collapsedNonEditableSelectionsSupported = (sel.rangeCount == 1);\n                    sel.removeAllRanges();\n\n                    // Test whether the native selection is capable of supporting multiple ranges.\n                    if (!selectionHasMultipleRanges) {\n                        // Doing the original feature test here in Chrome 36 (and presumably later versions) prints a\n                        // console error of \"Discontiguous selection is not supported.\" that cannot be suppressed. There's\n                        // nothing we can do about this while retaining the feature test so we have to resort to a browser\n                        // sniff. I'm not happy about it. See\n                        // https://code.google.com/p/chromium/issues/detail?id=399791\n                        var chromeMatch = window.navigator.appVersion.match(/Chrome\\/(.*?) /);\n                        if (chromeMatch && parseInt(chromeMatch[1]) >= 36) {\n                            selectionSupportsMultipleRanges = false;\n                        } else {\n                            var r2 = r1.cloneRange();\n                            r1.setStart(textNode, 0);\n                            r2.setEnd(textNode, 3);\n                            r2.setStart(textNode, 2);\n                            sel.addRange(r1);\n                            sel.addRange(r2);\n                            selectionSupportsMultipleRanges = (sel.rangeCount == 2);\n                        }\n                    }\n\n                    // Clean up\n                    dom.removeNode(testEl);\n                    sel.removeAllRanges();\n\n                    for (i = 0; i < originalSelectionRangeCount; ++i) {\n                        if (i == 0 && originalSelectionBackward) {\n                            if (addRangeBackwardToNative) {\n                                addRangeBackwardToNative(sel, originalSelectionRanges[i]);\n                            } else {\n                                api.warn(\"Rangy initialization: original selection was backwards but selection has been restored forwards because the browser does not support Selection.extend\");\n                                sel.addRange(originalSelectionRanges[i]);\n                            }\n                        } else {\n                            sel.addRange(originalSelectionRanges[i]);\n                        }\n                    }\n                }\n            })();\n        }\n\n        features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;\n        features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;\n\n        // ControlRanges\n        var implementsControlRange = false, testControlRange;\n\n        if (body && isHostMethod(body, \"createControlRange\")) {\n            testControlRange = body.createControlRange();\n            if (util.areHostProperties(testControlRange, [\"item\", \"add\"])) {\n                implementsControlRange = true;\n            }\n        }\n        features.implementsControlRange = implementsControlRange;\n\n        // Selection collapsedness\n        if (selectionHasAnchorAndFocus) {\n            selectionIsCollapsed = function(sel) {\n                return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;\n            };\n        } else {\n            selectionIsCollapsed = function(sel) {\n                return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;\n            };\n        }\n\n        function updateAnchorAndFocusFromRange(sel, range, backward) {\n            var anchorPrefix = backward ? \"end\" : \"start\", focusPrefix = backward ? \"start\" : \"end\";\n            sel.anchorNode = range[anchorPrefix + \"Container\"];\n            sel.anchorOffset = range[anchorPrefix + \"Offset\"];\n            sel.focusNode = range[focusPrefix + \"Container\"];\n            sel.focusOffset = range[focusPrefix + \"Offset\"];\n        }\n\n        function updateAnchorAndFocusFromNativeSelection(sel) {\n            var nativeSel = sel.nativeSelection;\n            sel.anchorNode = nativeSel.anchorNode;\n            sel.anchorOffset = nativeSel.anchorOffset;\n            sel.focusNode = nativeSel.focusNode;\n            sel.focusOffset = nativeSel.focusOffset;\n        }\n\n        function updateEmptySelection(sel) {\n            sel.anchorNode = sel.focusNode = null;\n            sel.anchorOffset = sel.focusOffset = 0;\n            sel.rangeCount = 0;\n            sel.isCollapsed = true;\n            sel._ranges.length = 0;\n        }\n\n        function getNativeRange(range) {\n            var nativeRange;\n            if (range instanceof DomRange) {\n                nativeRange = api.createNativeRange(range.getDocument());\n                nativeRange.setEnd(range.endContainer, range.endOffset);\n                nativeRange.setStart(range.startContainer, range.startOffset);\n            } else if (range instanceof WrappedRange) {\n                nativeRange = range.nativeRange;\n            } else if (features.implementsDomRange && (range instanceof dom.getWindow(range.startContainer).Range)) {\n                nativeRange = range;\n            }\n            return nativeRange;\n        }\n\n        function rangeContainsSingleElement(rangeNodes) {\n            if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {\n                return false;\n            }\n            for (var i = 1, len = rangeNodes.length; i < len; ++i) {\n                if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function getSingleElementFromRange(range) {\n            var nodes = range.getNodes();\n            if (!rangeContainsSingleElement(nodes)) {\n                throw module.createError(\"getSingleElementFromRange: range \" + range.inspect() + \" did not consist of a single element\");\n            }\n            return nodes[0];\n        }\n\n        // Simple, quick test which only needs to distinguish between a TextRange and a ControlRange\n        function isTextRange(range) {\n            return !!range && typeof range.text != \"undefined\";\n        }\n\n        function updateFromTextRange(sel, range) {\n            // Create a Range from the selected TextRange\n            var wrappedRange = new WrappedRange(range);\n            sel._ranges = [wrappedRange];\n\n            updateAnchorAndFocusFromRange(sel, wrappedRange, false);\n            sel.rangeCount = 1;\n            sel.isCollapsed = wrappedRange.collapsed;\n        }\n\n        function updateControlSelection(sel) {\n            // Update the wrapped selection based on what's now in the native selection\n            sel._ranges.length = 0;\n            if (sel.docSelection.type == \"None\") {\n                updateEmptySelection(sel);\n            } else {\n                var controlRange = sel.docSelection.createRange();\n                if (isTextRange(controlRange)) {\n                    // This case (where the selection type is \"Control\" and calling createRange() on the selection returns\n                    // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected\n                    // ControlRange have been removed from the ControlRange and removed from the document.\n                    updateFromTextRange(sel, controlRange);\n                } else {\n                    sel.rangeCount = controlRange.length;\n                    var range, doc = getDocument(controlRange.item(0));\n                    for (var i = 0; i < sel.rangeCount; ++i) {\n                        range = api.createRange(doc);\n                        range.selectNode(controlRange.item(i));\n                        sel._ranges.push(range);\n                    }\n                    sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;\n                    updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);\n                }\n            }\n        }\n\n        function addRangeToControlSelection(sel, range) {\n            var controlRange = sel.docSelection.createRange();\n            var rangeElement = getSingleElementFromRange(range);\n\n            // Create a new ControlRange containing all the elements in the selected ControlRange plus the element\n            // contained by the supplied range\n            var doc = getDocument(controlRange.item(0));\n            var newControlRange = getBody(doc).createControlRange();\n            for (var i = 0, len = controlRange.length; i < len; ++i) {\n                newControlRange.add(controlRange.item(i));\n            }\n            try {\n                newControlRange.add(rangeElement);\n            } catch (ex) {\n                throw module.createError(\"addRange(): Element within the specified Range could not be added to control selection (does it have layout?)\");\n            }\n            newControlRange.select();\n\n            // Update the wrapped selection based on what's now in the native selection\n            updateControlSelection(sel);\n        }\n\n        var getSelectionRangeAt;\n\n        if (isHostMethod(testSelection, \"getRangeAt\")) {\n            // try/catch is present because getRangeAt() must have thrown an error in some browser and some situation.\n            // Unfortunately, I didn't write a comment about the specifics and am now scared to take it out. Let that be a\n            // lesson to us all, especially me.\n            getSelectionRangeAt = function(sel, index) {\n                try {\n                    return sel.getRangeAt(index);\n                } catch (ex) {\n                    return null;\n                }\n            };\n        } else if (selectionHasAnchorAndFocus) {\n            getSelectionRangeAt = function(sel) {\n                var doc = getDocument(sel.anchorNode);\n                var range = api.createRange(doc);\n                range.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);\n\n                // Handle the case when the selection was selected backwards (from the end to the start in the\n                // document)\n                if (range.collapsed !== this.isCollapsed) {\n                    range.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);\n                }\n\n                return range;\n            };\n        }\n\n        function WrappedSelection(selection, docSelection, win) {\n            this.nativeSelection = selection;\n            this.docSelection = docSelection;\n            this._ranges = [];\n            this.win = win;\n            this.refresh();\n        }\n\n        WrappedSelection.prototype = api.selectionPrototype;\n\n        function deleteProperties(sel) {\n            sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;\n            sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;\n            sel.detached = true;\n        }\n\n        var cachedRangySelections = [];\n\n        function actOnCachedSelection(win, action) {\n            var i = cachedRangySelections.length, cached, sel;\n            while (i--) {\n                cached = cachedRangySelections[i];\n                sel = cached.selection;\n                if (action == \"deleteAll\") {\n                    deleteProperties(sel);\n                } else if (cached.win == win) {\n                    if (action == \"delete\") {\n                        cachedRangySelections.splice(i, 1);\n                        return true;\n                    } else {\n                        return sel;\n                    }\n                }\n            }\n            if (action == \"deleteAll\") {\n                cachedRangySelections.length = 0;\n            }\n            return null;\n        }\n\n        var getSelection = function(win) {\n            // Check if the parameter is a Rangy Selection object\n            if (win && win instanceof WrappedSelection) {\n                win.refresh();\n                return win;\n            }\n\n            win = getWindow(win, \"getNativeSelection\");\n\n            var sel = actOnCachedSelection(win);\n            var nativeSel = getNativeSelection(win), docSel = implementsDocSelection ? getDocSelection(win) : null;\n            if (sel) {\n                sel.nativeSelection = nativeSel;\n                sel.docSelection = docSel;\n                sel.refresh();\n            } else {\n                sel = new WrappedSelection(nativeSel, docSel, win);\n                cachedRangySelections.push( { win: win, selection: sel } );\n            }\n            return sel;\n        };\n\n        api.getSelection = getSelection;\n\n        util.createAliasForDeprecatedMethod(api, \"getIframeSelection\", \"getSelection\");\n\n        var selProto = WrappedSelection.prototype;\n\n        function createControlSelection(sel, ranges) {\n            // Ensure that the selection becomes of type \"Control\"\n            var doc = getDocument(ranges[0].startContainer);\n            var controlRange = getBody(doc).createControlRange();\n            for (var i = 0, el, len = ranges.length; i < len; ++i) {\n                el = getSingleElementFromRange(ranges[i]);\n                try {\n                    controlRange.add(el);\n                } catch (ex) {\n                    throw module.createError(\"setRanges(): Element within one of the specified Ranges could not be added to control selection (does it have layout?)\");\n                }\n            }\n            controlRange.select();\n\n            // Update the wrapped selection based on what's now in the native selection\n            updateControlSelection(sel);\n        }\n\n        // Selecting a range\n        if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, [\"removeAllRanges\", \"addRange\"])) {\n            selProto.removeAllRanges = function() {\n                this.nativeSelection.removeAllRanges();\n                updateEmptySelection(this);\n            };\n\n            var addRangeBackward = function(sel, range) {\n                addRangeBackwardToNative(sel.nativeSelection, range);\n                sel.refresh();\n            };\n\n            if (selectionHasRangeCount) {\n                selProto.addRange = function(range, direction) {\n                    if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n                        addRangeToControlSelection(this, range);\n                    } else {\n                        if (isDirectionBackward(direction) && selectionHasExtend) {\n                            addRangeBackward(this, range);\n                        } else {\n                            var previousRangeCount;\n                            if (selectionSupportsMultipleRanges) {\n                                previousRangeCount = this.rangeCount;\n                            } else {\n                                this.removeAllRanges();\n                                previousRangeCount = 0;\n                            }\n                            // Clone the native range so that changing the selected range does not affect the selection.\n                            // This is contrary to the spec but is the only way to achieve consistency between browsers. See\n                            // issue 80.\n                            var clonedNativeRange = getNativeRange(range).cloneRange();\n                            try {\n                                this.nativeSelection.addRange(clonedNativeRange);\n                            } catch (ex) {\n                            }\n\n                            // Check whether adding the range was successful\n                            this.rangeCount = this.nativeSelection.rangeCount;\n\n                            if (this.rangeCount == previousRangeCount + 1) {\n                                // The range was added successfully\n\n                                // Check whether the range that we added to the selection is reflected in the last range extracted from\n                                // the selection\n                                if (api.config.checkSelectionRanges) {\n                                    var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);\n                                    if (nativeRange && !rangesEqual(nativeRange, range)) {\n                                        // Happens in WebKit with, for example, a selection placed at the start of a text node\n                                        range = new WrappedRange(nativeRange);\n                                    }\n                                }\n                                this._ranges[this.rangeCount - 1] = range;\n                                updateAnchorAndFocusFromRange(this, range, selectionIsBackward(this.nativeSelection));\n                                this.isCollapsed = selectionIsCollapsed(this);\n                            } else {\n                                // The range was not added successfully. The simplest thing is to refresh\n                                this.refresh();\n                            }\n                        }\n                    }\n                };\n            } else {\n                selProto.addRange = function(range, direction) {\n                    if (isDirectionBackward(direction) && selectionHasExtend) {\n                        addRangeBackward(this, range);\n                    } else {\n                        this.nativeSelection.addRange(getNativeRange(range));\n                        this.refresh();\n                    }\n                };\n            }\n\n            selProto.setRanges = function(ranges) {\n                if (implementsControlRange && implementsDocSelection && ranges.length > 1) {\n                    createControlSelection(this, ranges);\n                } else {\n                    this.removeAllRanges();\n                    for (var i = 0, len = ranges.length; i < len; ++i) {\n                        this.addRange(ranges[i]);\n                    }\n                }\n            };\n        } else if (isHostMethod(testSelection, \"empty\") && isHostMethod(testRange, \"select\") &&\n            implementsControlRange && useDocumentSelection) {\n\n            selProto.removeAllRanges = function() {\n                // Added try/catch as fix for issue #21\n                try {\n                    this.docSelection.empty();\n\n                    // Check for empty() not working (issue #24)\n                    if (this.docSelection.type != \"None\") {\n                        // Work around failure to empty a control selection by instead selecting a TextRange and then\n                        // calling empty()\n                        var doc;\n                        if (this.anchorNode) {\n                            doc = getDocument(this.anchorNode);\n                        } else if (this.docSelection.type == CONTROL) {\n                            var controlRange = this.docSelection.createRange();\n                            if (controlRange.length) {\n                                doc = getDocument( controlRange.item(0) );\n                            }\n                        }\n                        if (doc) {\n                            var textRange = getBody(doc).createTextRange();\n                            textRange.select();\n                            this.docSelection.empty();\n                        }\n                    }\n                } catch(ex) {}\n                updateEmptySelection(this);\n            };\n\n            selProto.addRange = function(range) {\n                if (this.docSelection.type == CONTROL) {\n                    addRangeToControlSelection(this, range);\n                } else {\n                    api.WrappedTextRange.rangeToTextRange(range).select();\n                    this._ranges[0] = range;\n                    this.rangeCount = 1;\n                    this.isCollapsed = this._ranges[0].collapsed;\n                    updateAnchorAndFocusFromRange(this, range, false);\n                }\n            };\n\n            selProto.setRanges = function(ranges) {\n                this.removeAllRanges();\n                var rangeCount = ranges.length;\n                if (rangeCount > 1) {\n                    createControlSelection(this, ranges);\n                } else if (rangeCount) {\n                    this.addRange(ranges[0]);\n                }\n            };\n        } else {\n            module.fail(\"No means of selecting a Range or TextRange was found\");\n            return false;\n        }\n\n        selProto.getRangeAt = function(index) {\n            if (index < 0 || index >= this.rangeCount) {\n                throw new DOMException(\"INDEX_SIZE_ERR\");\n            } else {\n                // Clone the range to preserve selection-range independence. See issue 80.\n                return this._ranges[index].cloneRange();\n            }\n        };\n\n        var refreshSelection;\n\n        if (useDocumentSelection) {\n            refreshSelection = function(sel) {\n                var range;\n                if (api.isSelectionValid(sel.win)) {\n                    range = sel.docSelection.createRange();\n                } else {\n                    range = getBody(sel.win.document).createTextRange();\n                    range.collapse(true);\n                }\n\n                if (sel.docSelection.type == CONTROL) {\n                    updateControlSelection(sel);\n                } else if (isTextRange(range)) {\n                    updateFromTextRange(sel, range);\n                } else {\n                    updateEmptySelection(sel);\n                }\n            };\n        } else if (isHostMethod(testSelection, \"getRangeAt\") && typeof testSelection.rangeCount == NUMBER) {\n            refreshSelection = function(sel) {\n                if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {\n                    updateControlSelection(sel);\n                } else {\n                    sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;\n                    if (sel.rangeCount) {\n                        for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n                            sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));\n                        }\n                        updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));\n                        sel.isCollapsed = selectionIsCollapsed(sel);\n                    } else {\n                        updateEmptySelection(sel);\n                    }\n                }\n            };\n        } else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && features.implementsDomRange) {\n            refreshSelection = function(sel) {\n                var range, nativeSel = sel.nativeSelection;\n                if (nativeSel.anchorNode) {\n                    range = getSelectionRangeAt(nativeSel, 0);\n                    sel._ranges = [range];\n                    sel.rangeCount = 1;\n                    updateAnchorAndFocusFromNativeSelection(sel);\n                    sel.isCollapsed = selectionIsCollapsed(sel);\n                } else {\n                    updateEmptySelection(sel);\n                }\n            };\n        } else {\n            module.fail(\"No means of obtaining a Range or TextRange from the user's selection was found\");\n            return false;\n        }\n\n        selProto.refresh = function(checkForChanges) {\n            var oldRanges = checkForChanges ? this._ranges.slice(0) : null;\n            var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;\n\n            refreshSelection(this);\n            if (checkForChanges) {\n                // Check the range count first\n                var i = oldRanges.length;\n                if (i != this._ranges.length) {\n                    return true;\n                }\n\n                // Now check the direction. Checking the anchor position is the same is enough since we're checking all the\n                // ranges after this\n                if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {\n                    return true;\n                }\n\n                // Finally, compare each range in turn\n                while (i--) {\n                    if (!rangesEqual(oldRanges[i], this._ranges[i])) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        };\n\n        // Removal of a single range\n        var removeRangeManually = function(sel, range) {\n            var ranges = sel.getAllRanges();\n            sel.removeAllRanges();\n            for (var i = 0, len = ranges.length; i < len; ++i) {\n                if (!rangesEqual(range, ranges[i])) {\n                    sel.addRange(ranges[i]);\n                }\n            }\n            if (!sel.rangeCount) {\n                updateEmptySelection(sel);\n            }\n        };\n\n        if (implementsControlRange && implementsDocSelection) {\n            selProto.removeRange = function(range) {\n                if (this.docSelection.type == CONTROL) {\n                    var controlRange = this.docSelection.createRange();\n                    var rangeElement = getSingleElementFromRange(range);\n\n                    // Create a new ControlRange containing all the elements in the selected ControlRange minus the\n                    // element contained by the supplied range\n                    var doc = getDocument(controlRange.item(0));\n                    var newControlRange = getBody(doc).createControlRange();\n                    var el, removed = false;\n                    for (var i = 0, len = controlRange.length; i < len; ++i) {\n                        el = controlRange.item(i);\n                        if (el !== rangeElement || removed) {\n                            newControlRange.add(controlRange.item(i));\n                        } else {\n                            removed = true;\n                        }\n                    }\n                    newControlRange.select();\n\n                    // Update the wrapped selection based on what's now in the native selection\n                    updateControlSelection(this);\n                } else {\n                    removeRangeManually(this, range);\n                }\n            };\n        } else {\n            selProto.removeRange = function(range) {\n                removeRangeManually(this, range);\n            };\n        }\n\n        // Detecting if a selection is backward\n        var selectionIsBackward;\n        if (!useDocumentSelection && selectionHasAnchorAndFocus && features.implementsDomRange) {\n            selectionIsBackward = winSelectionIsBackward;\n\n            selProto.isBackward = function() {\n                return selectionIsBackward(this);\n            };\n        } else {\n            selectionIsBackward = selProto.isBackward = function() {\n                return false;\n            };\n        }\n\n        // Create an alias for backwards compatibility. From 1.3, everything is \"backward\" rather than \"backwards\"\n        selProto.isBackwards = selProto.isBackward;\n\n        // Selection stringifier\n        // This is conformant to the old HTML5 selections draft spec but differs from WebKit and Mozilla's implementation.\n        // The current spec does not yet define this method.\n        selProto.toString = function() {\n            var rangeTexts = [];\n            for (var i = 0, len = this.rangeCount; i < len; ++i) {\n                rangeTexts[i] = \"\" + this._ranges[i];\n            }\n            return rangeTexts.join(\"\");\n        };\n\n        function assertNodeInSameDocument(sel, node) {\n            if (sel.win.document != getDocument(node)) {\n                throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n            }\n        }\n\n        // No current browser conforms fully to the spec for this method, so Rangy's own method is always used\n        selProto.collapse = function(node, offset) {\n            assertNodeInSameDocument(this, node);\n            var range = api.createRange(node);\n            range.collapseToPoint(node, offset);\n            this.setSingleRange(range);\n            this.isCollapsed = true;\n        };\n\n        selProto.collapseToStart = function() {\n            if (this.rangeCount) {\n                var range = this._ranges[0];\n                this.collapse(range.startContainer, range.startOffset);\n            } else {\n                throw new DOMException(\"INVALID_STATE_ERR\");\n            }\n        };\n\n        selProto.collapseToEnd = function() {\n            if (this.rangeCount) {\n                var range = this._ranges[this.rangeCount - 1];\n                this.collapse(range.endContainer, range.endOffset);\n            } else {\n                throw new DOMException(\"INVALID_STATE_ERR\");\n            }\n        };\n\n        // The spec is very specific on how selectAllChildren should be implemented and not all browsers implement it as\n        // specified so the native implementation is never used by Rangy.\n        selProto.selectAllChildren = function(node) {\n            assertNodeInSameDocument(this, node);\n            var range = api.createRange(node);\n            range.selectNodeContents(node);\n            this.setSingleRange(range);\n        };\n\n        selProto.deleteFromDocument = function() {\n            // Sepcial behaviour required for IE's control selections\n            if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n                var controlRange = this.docSelection.createRange();\n                var element;\n                while (controlRange.length) {\n                    element = controlRange.item(0);\n                    controlRange.remove(element);\n                    dom.removeNode(element);\n                }\n                this.refresh();\n            } else if (this.rangeCount) {\n                var ranges = this.getAllRanges();\n                if (ranges.length) {\n                    this.removeAllRanges();\n                    for (var i = 0, len = ranges.length; i < len; ++i) {\n                        ranges[i].deleteContents();\n                    }\n                    // The spec says nothing about what the selection should contain after calling deleteContents on each\n                    // range. Firefox moves the selection to where the final selected range was, so we emulate that\n                    this.addRange(ranges[len - 1]);\n                }\n            }\n        };\n\n        // The following are non-standard extensions\n        selProto.eachRange = function(func, returnValue) {\n            for (var i = 0, len = this._ranges.length; i < len; ++i) {\n                if ( func( this.getRangeAt(i) ) ) {\n                    return returnValue;\n                }\n            }\n        };\n\n        selProto.getAllRanges = function() {\n            var ranges = [];\n            this.eachRange(function(range) {\n                ranges.push(range);\n            });\n            return ranges;\n        };\n\n        selProto.setSingleRange = function(range, direction) {\n            this.removeAllRanges();\n            this.addRange(range, direction);\n        };\n\n        selProto.callMethodOnEachRange = function(methodName, params) {\n            var results = [];\n            this.eachRange( function(range) {\n                results.push( range[methodName].apply(range, params || []) );\n            } );\n            return results;\n        };\n\n        function createStartOrEndSetter(isStart) {\n            return function(node, offset) {\n                var range;\n                if (this.rangeCount) {\n                    range = this.getRangeAt(0);\n                    range[\"set\" + (isStart ? \"Start\" : \"End\")](node, offset);\n                } else {\n                    range = api.createRange(this.win.document);\n                    range.setStartAndEnd(node, offset);\n                }\n                this.setSingleRange(range, this.isBackward());\n            };\n        }\n\n        selProto.setStart = createStartOrEndSetter(true);\n        selProto.setEnd = createStartOrEndSetter(false);\n\n        // Add select() method to Range prototype. Any existing selection will be removed.\n        api.rangePrototype.select = function(direction) {\n            getSelection( this.getDocument() ).setSingleRange(this, direction);\n        };\n\n        selProto.changeEachRange = function(func) {\n            var ranges = [];\n            var backward = this.isBackward();\n\n            this.eachRange(function(range) {\n                func(range);\n                ranges.push(range);\n            });\n\n            this.removeAllRanges();\n            if (backward && ranges.length == 1) {\n                this.addRange(ranges[0], \"backward\");\n            } else {\n                this.setRanges(ranges);\n            }\n        };\n\n        selProto.containsNode = function(node, allowPartial) {\n            return this.eachRange( function(range) {\n                    return range.containsNode(node, allowPartial);\n                }, true ) || false;\n        };\n\n        selProto.getBookmark = function(containerNode) {\n            return {\n                backward: this.isBackward(),\n                rangeBookmarks: this.callMethodOnEachRange(\"getBookmark\", [containerNode])\n            };\n        };\n\n        selProto.moveToBookmark = function(bookmark) {\n            var selRanges = [];\n            for (var i = 0, rangeBookmark, range; rangeBookmark = bookmark.rangeBookmarks[i++]; ) {\n                range = api.createRange(this.win);\n                range.moveToBookmark(rangeBookmark);\n                selRanges.push(range);\n            }\n            if (bookmark.backward) {\n                this.setSingleRange(selRanges[0], \"backward\");\n            } else {\n                this.setRanges(selRanges);\n            }\n        };\n\n        selProto.saveRanges = function() {\n            return {\n                backward: this.isBackward(),\n                ranges: this.callMethodOnEachRange(\"cloneRange\")\n            };\n        };\n\n        selProto.restoreRanges = function(selRanges) {\n            this.removeAllRanges();\n            for (var i = 0, range; range = selRanges.ranges[i]; ++i) {\n                this.addRange(range, (selRanges.backward && i == 0));\n            }\n        };\n\n        selProto.toHtml = function() {\n            var rangeHtmls = [];\n            this.eachRange(function(range) {\n                rangeHtmls.push( DomRange.toHtml(range) );\n            });\n            return rangeHtmls.join(\"\");\n        };\n\n        if (features.implementsTextRange) {\n            selProto.getNativeTextRange = function() {\n                var sel, textRange;\n                if ( (sel = this.docSelection) ) {\n                    var range = sel.createRange();\n                    if (isTextRange(range)) {\n                        return range;\n                    } else {\n                        throw module.createError(\"getNativeTextRange: selection is a control selection\");\n                    }\n                } else if (this.rangeCount > 0) {\n                    return api.WrappedTextRange.rangeToTextRange( this.getRangeAt(0) );\n                } else {\n                    throw module.createError(\"getNativeTextRange: selection contains no range\");\n                }\n            };\n        }\n\n        function inspect(sel) {\n            var rangeInspects = [];\n            var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);\n            var focus = new DomPosition(sel.focusNode, sel.focusOffset);\n            var name = (typeof sel.getName == \"function\") ? sel.getName() : \"Selection\";\n\n            if (typeof sel.rangeCount != \"undefined\") {\n                for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n                    rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));\n                }\n            }\n            return \"[\" + name + \"(Ranges: \" + rangeInspects.join(\", \") +\n                \")(anchor: \" + anchor.inspect() + \", focus: \" + focus.inspect() + \"]\";\n        }\n\n        selProto.getName = function() {\n            return \"WrappedSelection\";\n        };\n\n        selProto.inspect = function() {\n            return inspect(this);\n        };\n\n        selProto.detach = function() {\n            actOnCachedSelection(this.win, \"delete\");\n            deleteProperties(this);\n        };\n\n        WrappedSelection.detachAll = function() {\n            actOnCachedSelection(null, \"deleteAll\");\n        };\n\n        WrappedSelection.inspect = inspect;\n        WrappedSelection.isDirectionBackward = isDirectionBackward;\n\n        api.Selection = WrappedSelection;\n\n        api.selectionPrototype = selProto;\n\n        api.addShimListener(function(win) {\n            if (typeof win.getSelection == \"undefined\") {\n                win.getSelection = function() {\n                    return getSelection(win);\n                };\n            }\n            win = null;\n        });\n    });\n\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Wait for document to load before initializing\n    var docReady = false;\n\n    var loadHandler = function(e) {\n        if (!docReady) {\n            docReady = true;\n            if (!api.initialized && api.config.autoInitialize) {\n                init();\n            }\n        }\n    };\n\n    if (isBrowser) {\n        // Test whether the document has already been loaded and initialize immediately if so\n        if (document.readyState == \"complete\") {\n            loadHandler();\n        } else {\n            if (isHostMethod(document, \"addEventListener\")) {\n                document.addEventListener(\"DOMContentLoaded\", loadHandler, false);\n            }\n\n            // Add a fallback in case the DOMContentLoaded event isn't supported\n            addListener(window, \"load\", loadHandler);\n        }\n    }\n\n    return api;\n}, this);\n\n/**\n * Selection save and restore module for Rangy.\n * Saves and restores user selections using marker invisible elements in the DOM.\n *\n * Part of Rangy, a cross-browser JavaScript range and selection library\n * https://github.com/timdown/rangy\n *\n * Depends on Rangy core.\n *\n * Copyright 2015, Tim Down\n * Licensed under the MIT license.\n * Version: 1.3.1-dev\n * Build date: 20 May 2015\n */\n(function(factory, root) {\n    if (typeof define == \"function\" && define.amd) {\n        // AMD. Register as an anonymous module with a dependency on Rangy.\n        define([\"./rangy-core\"], factory);\n    } else if (typeof module != \"undefined\" && typeof exports == \"object\") {\n        // Node/CommonJS style\n        module.exports = factory( require(\"rangy\") );\n    } else {\n        // No AMD or CommonJS support so we use the rangy property of root (probably the global variable)\n        factory(root.rangy);\n    }\n})(function(rangy) {\n    rangy.createModule(\"SaveRestore\", [\"WrappedRange\"], function(api, module) {\n        var dom = api.dom;\n        var removeNode = dom.removeNode;\n        var isDirectionBackward = api.Selection.isDirectionBackward;\n        var markerTextChar = \"\\ufeff\";\n\n        function gEBI(id, doc) {\n            return (doc || document).getElementById(id);\n        }\n\n        function insertRangeBoundaryMarker(range, atStart) {\n            var markerId = \"selectionBoundary_\" + (+new Date()) + \"_\" + (\"\" + Math.random()).slice(2);\n            var markerEl;\n            var doc = dom.getDocument(range.startContainer);\n\n            // Clone the Range and collapse to the appropriate boundary point\n            var boundaryRange = range.cloneRange();\n            boundaryRange.collapse(atStart);\n\n            // Create the marker element containing a single invisible character using DOM methods and insert it\n            markerEl = doc.createElement(\"span\");\n            markerEl.id = markerId;\n            markerEl.style.lineHeight = \"0\";\n            markerEl.style.display = \"none\";\n            markerEl.className = \"rangySelectionBoundary\";\n            markerEl.appendChild(doc.createTextNode(markerTextChar));\n\n            boundaryRange.insertNode(markerEl);\n            return markerEl;\n        }\n\n        function setRangeBoundary(doc, range, markerId, atStart) {\n            var markerEl = gEBI(markerId, doc);\n            if (markerEl) {\n                range[atStart ? \"setStartBefore\" : \"setEndBefore\"](markerEl);\n                removeNode(markerEl);\n            } else {\n                module.warn(\"Marker element has been removed. Cannot restore selection.\");\n            }\n        }\n\n        function compareRanges(r1, r2) {\n            return r2.compareBoundaryPoints(r1.START_TO_START, r1);\n        }\n\n        function saveRange(range, direction) {\n            var startEl, endEl, doc = api.DomRange.getRangeDocument(range), text = range.toString();\n            var backward = isDirectionBackward(direction);\n\n            if (range.collapsed) {\n                endEl = insertRangeBoundaryMarker(range, false);\n                return {\n                    document: doc,\n                    markerId: endEl.id,\n                    collapsed: true\n                };\n            } else {\n                endEl = insertRangeBoundaryMarker(range, false);\n                startEl = insertRangeBoundaryMarker(range, true);\n\n                return {\n                    document: doc,\n                    startMarkerId: startEl.id,\n                    endMarkerId: endEl.id,\n                    collapsed: false,\n                    backward: backward,\n                    toString: function() {\n                        return \"original text: '\" + text + \"', new text: '\" + range.toString() + \"'\";\n                    }\n                };\n            }\n        }\n\n        function restoreRange(rangeInfo, normalize) {\n            var doc = rangeInfo.document;\n            if (typeof normalize == \"undefined\") {\n                normalize = true;\n            }\n            var range = api.createRange(doc);\n            if (rangeInfo.collapsed) {\n                var markerEl = gEBI(rangeInfo.markerId, doc);\n                if (markerEl) {\n                    markerEl.style.display = \"inline\";\n                    var previousNode = markerEl.previousSibling;\n\n                    // Workaround for issue 17\n                    if (previousNode && previousNode.nodeType == 3) {\n                        removeNode(markerEl);\n                        range.collapseToPoint(previousNode, previousNode.length);\n                    } else {\n                        range.collapseBefore(markerEl);\n                        removeNode(markerEl);\n                    }\n                } else {\n                    module.warn(\"Marker element has been removed. Cannot restore selection.\");\n                }\n            } else {\n                setRangeBoundary(doc, range, rangeInfo.startMarkerId, true);\n                setRangeBoundary(doc, range, rangeInfo.endMarkerId, false);\n            }\n\n            if (normalize) {\n                range.normalizeBoundaries();\n            }\n\n            return range;\n        }\n\n        function saveRanges(ranges, direction) {\n            var rangeInfos = [], range, doc;\n            var backward = isDirectionBackward(direction);\n\n            // Order the ranges by position within the DOM, latest first, cloning the array to leave the original untouched\n            ranges = ranges.slice(0);\n            ranges.sort(compareRanges);\n\n            for (var i = 0, len = ranges.length; i < len; ++i) {\n                rangeInfos[i] = saveRange(ranges[i], backward);\n            }\n\n            // Now that all the markers are in place and DOM manipulation over, adjust each range's boundaries to lie\n            // between its markers\n            for (i = len - 1; i >= 0; --i) {\n                range = ranges[i];\n                doc = api.DomRange.getRangeDocument(range);\n                if (range.collapsed) {\n                    range.collapseAfter(gEBI(rangeInfos[i].markerId, doc));\n                } else {\n                    range.setEndBefore(gEBI(rangeInfos[i].endMarkerId, doc));\n                    range.setStartAfter(gEBI(rangeInfos[i].startMarkerId, doc));\n                }\n            }\n\n            return rangeInfos;\n        }\n\n        function saveSelection(win) {\n            if (!api.isSelectionValid(win)) {\n                module.warn(\"Cannot save selection. This usually happens when the selection is collapsed and the selection document has lost focus.\");\n                return null;\n            }\n            var sel = api.getSelection(win);\n            var ranges = sel.getAllRanges();\n            var backward = (ranges.length == 1 && sel.isBackward());\n\n            var rangeInfos = saveRanges(ranges, backward);\n\n            // Ensure current selection is unaffected\n            if (backward) {\n                sel.setSingleRange(ranges[0], backward);\n            } else {\n                sel.setRanges(ranges);\n            }\n\n            return {\n                win: win,\n                rangeInfos: rangeInfos,\n                restored: false\n            };\n        }\n\n        function restoreRanges(rangeInfos) {\n            var ranges = [];\n\n            // Ranges are in reverse order of appearance in the DOM. We want to restore earliest first to avoid\n            // normalization affecting previously restored ranges.\n            var rangeCount = rangeInfos.length;\n\n            for (var i = rangeCount - 1; i >= 0; i--) {\n                ranges[i] = restoreRange(rangeInfos[i], true);\n            }\n\n            return ranges;\n        }\n\n        function restoreSelection(savedSelection, preserveDirection) {\n            if (!savedSelection.restored) {\n                var rangeInfos = savedSelection.rangeInfos;\n                var sel = api.getSelection(savedSelection.win);\n                var ranges = restoreRanges(rangeInfos), rangeCount = rangeInfos.length;\n\n                if (rangeCount == 1 && preserveDirection && api.features.selectionHasExtend && rangeInfos[0].backward) {\n                    sel.removeAllRanges();\n                    sel.addRange(ranges[0], true);\n                } else {\n                    sel.setRanges(ranges);\n                }\n\n                savedSelection.restored = true;\n            }\n        }\n\n        function removeMarkerElement(doc, markerId) {\n            var markerEl = gEBI(markerId, doc);\n            if (markerEl) {\n                removeNode(markerEl);\n            }\n        }\n\n        function removeMarkers(savedSelection) {\n            var rangeInfos = savedSelection.rangeInfos;\n            for (var i = 0, len = rangeInfos.length, rangeInfo; i < len; ++i) {\n                rangeInfo = rangeInfos[i];\n                if (rangeInfo.collapsed) {\n                    removeMarkerElement(savedSelection.doc, rangeInfo.markerId);\n                } else {\n                    removeMarkerElement(savedSelection.doc, rangeInfo.startMarkerId);\n                    removeMarkerElement(savedSelection.doc, rangeInfo.endMarkerId);\n                }\n            }\n        }\n\n        api.util.extend(api, {\n            saveRange: saveRange,\n            restoreRange: restoreRange,\n            saveRanges: saveRanges,\n            restoreRanges: restoreRanges,\n            saveSelection: saveSelection,\n            restoreSelection: restoreSelection,\n            removeMarkerElement: removeMarkerElement,\n            removeMarkers: removeMarkers\n        });\n    });\n\n    return rangy;\n}, this);","$(document).ready(function(){\n\n    // Carousel on home page settings\n    $('#owl-carousel-home').owlCarousel({\n        loop:true,\n        margin:40,\n        dots: false,\n        autoplay: true,\n        autoplayTimeout: 5000,\n        autoplayHoverPause: true,\n        responsive:{\n            0:{\n                items:1\n            },\n            600:{\n                items:2\n            },\n            900:{\n                items:3\n            },\n            1440:{\n                items:4\n            }\n        }\n    });\n    // End of carousel home page settings\n\n});"]}